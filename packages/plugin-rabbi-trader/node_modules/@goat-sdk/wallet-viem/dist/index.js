"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/index.ts
var _viem = require('viem');
var _ens = require('viem/ens');
function viem(client) {
  const publicClient = client.extend(_viem.publicActions);
  return {
    getAddress: () => _nullishCoalesce(_optionalChain([client, 'access', _ => _.account, 'optionalAccess', _2 => _2.address]), () => ( "")),
    getChain() {
      return {
        type: "evm",
        id: _nullishCoalesce(_optionalChain([client, 'access', _3 => _3.chain, 'optionalAccess', _4 => _4.id]), () => ( 0))
      };
    },
    async resolveAddress(address) {
      if (/^0x[a-fA-F0-9]{40}$/.test(address)) {
        return address;
      }
      try {
        const resolvedAddress = await publicClient.getEnsAddress({
          name: _ens.normalize.call(void 0, address)
        });
        if (!resolvedAddress) {
          throw new Error("ENS name could not be resolved.");
        }
        return resolvedAddress;
      } catch (error) {
        throw new Error(`Failed to resolve ENS name: ${error}`);
      }
    },
    async signMessage(message) {
      if (!client.account) throw new Error("No account connected");
      const signature = await client.signMessage({
        message,
        account: client.account
      });
      return {
        signature
      };
    },
    async signTypedData(data) {
      if (!client.account) throw new Error("No account connected");
      const signature = await client.signTypedData({
        domain: data.domain,
        types: data.types,
        primaryType: data.primaryType,
        message: data.message,
        account: client.account
      });
      return {
        signature
      };
    },
    async sendTransaction(transaction) {
      const { to, abi, functionName, args, value } = transaction;
      const toAddress = await this.resolveAddress(to);
      if (!client.account) throw new Error("No account connected");
      if (!abi) {
        const tx = await client.sendTransaction({
          account: client.account,
          to: toAddress,
          chain: client.chain,
          value
        });
        const transaction2 = await publicClient.waitForTransactionReceipt({
          hash: tx
        });
        return {
          hash: transaction2.transactionHash,
          status: transaction2.status
        };
      }
      if (!functionName) {
        throw new Error("Function name is required");
      }
      await publicClient.simulateContract({
        account: client.account,
        address: toAddress,
        abi,
        functionName,
        args,
        chain: client.chain
      });
      const hash = await client.writeContract({
        account: client.account,
        address: toAddress,
        abi,
        functionName,
        args,
        chain: client.chain,
        value
      });
      const t = await publicClient.waitForTransactionReceipt({
        hash
      });
      return {
        hash: t.transactionHash,
        status: t.status
      };
    },
    async read(request) {
      const { address, abi, functionName, args } = request;
      if (!abi) throw new Error("Read request must include ABI for EVM");
      const result = await publicClient.readContract({
        address: await this.resolveAddress(address),
        abi,
        functionName,
        args
      });
      return {
        value: result
      };
    },
    async balanceOf(address) {
      const resolvedAddress = await this.resolveAddress(address);
      const balance = await publicClient.getBalance({
        address: resolvedAddress
      });
      return {
        value: balance,
        decimals: 18,
        symbol: "ETH",
        name: "Ether"
      };
    }
  };
}


exports.viem = viem;
//# sourceMappingURL=index.js.map