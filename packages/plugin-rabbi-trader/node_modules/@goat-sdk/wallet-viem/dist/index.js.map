{"version":3,"sources":["/Users/0xaguspunk/github.com/crossmint/goat/typescript/packages/wallets/viem/dist/index.js","../src/index.ts"],"names":[],"mappings":"AAAA;ACOA,4BAA8B;AAC9B,+BAA0B;AAGnB,SAAS,IAAA,CAAK,MAAA,EAA2C;AAC5D,EAAA,MAAM,aAAA,EAAe,MAAA,CAAO,MAAA,CAAO,mBAAa,CAAA;AAEhD,EAAA,OAAO;AAAA,IACH,UAAA,EAAY,CAAA,EAAA,oCAAM,MAAA,mBAAO,OAAA,6BAAS,SAAA,UAAW,IAAA;AAAA,IAC7C,QAAA,CAAA,EAAW;AACP,MAAA,OAAO;AAAA,QACH,IAAA,EAAM,KAAA;AAAA,QACN,EAAA,mCAAI,MAAA,qBAAO,KAAA,6BAAO,IAAA,UAAM;AAAA,MAC5B,CAAA;AAAA,IACJ,CAAA;AAAA,IACA,MAAM,cAAA,CAAe,OAAA,EAAiB;AAClC,MAAA,GAAA,CAAI,qBAAA,CAAsB,IAAA,CAAK,OAAO,CAAA,EAAG;AACrC,QAAA,OAAO,OAAA;AAAA,MACX;AAEA,MAAA,IAAI;AACA,QAAA,MAAM,gBAAA,EAAmB,MAAM,YAAA,CAAa,aAAA,CAAc;AAAA,UACtD,IAAA,EAAM,4BAAA,OAAiB;AAAA,QAC3B,CAAC,CAAA;AACD,QAAA,GAAA,CAAI,CAAC,eAAA,EAAiB;AAClB,UAAA,MAAM,IAAI,KAAA,CAAM,iCAAiC,CAAA;AAAA,QACrD;AACA,QAAA,OAAO,eAAA;AAAA,MACX,EAAA,MAAA,CAAS,KAAA,EAAO;AACZ,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4BAAA,EAA+B,KAAK,CAAA,CAAA;AACxD,MAAA;AACJ,IAAA;AACmC,IAAA;AACM,MAAA;AACM,MAAA;AACvC,QAAA;AACgB,QAAA;AACnB,MAAA;AAEM,MAAA;AACH,QAAA;AACJ,MAAA;AACJ,IAAA;AACwC,IAAA;AACC,MAAA;AAEQ,MAAA;AAC5B,QAAA;AACD,QAAA;AACM,QAAA;AACJ,QAAA;AACE,QAAA;AACnB,MAAA;AAEM,MAAA;AACH,QAAA;AACJ,MAAA;AACJ,IAAA;AACmD,IAAA;AACA,MAAA;AAED,MAAA;AACT,MAAA;AAE3B,MAAA;AACkC,QAAA;AACpB,UAAA;AACZ,UAAA;AACU,UAAA;AACd,UAAA;AACH,QAAA;AAGsB,QAAA;AACT,UAAA;AACT,QAAA;AAEE,QAAA;AACe,UAAA;AACE,UAAA;AACxB,QAAA;AACJ,MAAA;AAEmB,MAAA;AAC4B,QAAA;AAC/C,MAAA;AAEoC,MAAA;AAChB,QAAA;AACP,QAAA;AACT,QAAA;AACA,QAAA;AACA,QAAA;AACc,QAAA;AACjB,MAAA;AACuC,MAAA;AACpB,QAAA;AACP,QAAA;AACT,QAAA;AACA,QAAA;AACA,QAAA;AACc,QAAA;AACd,QAAA;AACH,MAAA;AAEsD,MAAA;AACnD,QAAA;AACH,MAAA;AAEM,MAAA;AACK,QAAA;AACE,QAAA;AACd,MAAA;AACJ,IAAA;AACoC,IAAA;AACa,MAAA;AAEnB,MAAA;AAEqB,MAAA;AACD,QAAA;AAC1C,QAAA;AACA,QAAA;AACA,QAAA;AACH,MAAA;AAEM,MAAA;AACI,QAAA;AACX,MAAA;AACJ,IAAA;AACiC,IAAA;AACqB,MAAA;AAEJ,MAAA;AACjC,QAAA;AACZ,MAAA;AAEM,MAAA;AACI,QAAA;AACG,QAAA;AACF,QAAA;AACF,QAAA;AACV,MAAA;AACJ,IAAA;AACJ,EAAA;AACJ;AD1B6D;AACA;AACA","file":"/Users/0xaguspunk/github.com/crossmint/goat/typescript/packages/wallets/viem/dist/index.js","sourcesContent":[null,"import type {\n    EVMReadRequest,\n    EVMTransaction,\n    EVMWalletClient,\n    EVMTypedData,\n} from \"@goat-sdk/core\";\n\nimport { publicActions } from \"viem\";\nimport { normalize } from \"viem/ens\";\nimport type { WalletClient as ViemWalletClient } from \"viem\";\n\nexport function viem(client: ViemWalletClient): EVMWalletClient {\n    const publicClient = client.extend(publicActions);\n\n    return {\n        getAddress: () => client.account?.address ?? \"\",\n        getChain() {\n            return {\n                type: \"evm\",\n                id: client.chain?.id ?? 0,\n            };\n        },\n        async resolveAddress(address: string) {\n            if (/^0x[a-fA-F0-9]{40}$/.test(address)) {\n                return address as `0x${string}`;\n            }\n\n            try {\n                const resolvedAddress = (await publicClient.getEnsAddress({\n                    name: normalize(address),\n                })) as `0x${string}`;\n                if (!resolvedAddress) {\n                    throw new Error(\"ENS name could not be resolved.\");\n                }\n                return resolvedAddress as `0x${string}`;\n            } catch (error) {\n                throw new Error(`Failed to resolve ENS name: ${error}`);\n            }\n        },\n        async signMessage(message: string) {\n            if (!client.account) throw new Error(\"No account connected\");\n            const signature = await client.signMessage({\n                message,\n                account: client.account,\n            });\n\n            return {\n                signature,\n            };\n        },\n        async signTypedData(data: EVMTypedData) {\n            if (!client.account) throw new Error(\"No account connected\");\n\n            const signature = await client.signTypedData({\n                domain: data.domain,\n                types: data.types,\n                primaryType: data.primaryType,\n                message: data.message,\n                account: client.account,\n            });\n\n            return {\n                signature,\n            };\n        },\n        async sendTransaction(transaction: EVMTransaction) {\n            const { to, abi, functionName, args, value } = transaction;\n\n            const toAddress = await this.resolveAddress(to);\n            if (!client.account) throw new Error(\"No account connected\");\n\n            if (!abi) {\n                const tx = await client.sendTransaction({\n                    account: client.account,\n                    to: toAddress,\n                    chain: client.chain,\n                    value,\n                });\n\n                const transaction =\n                    await publicClient.waitForTransactionReceipt({\n                        hash: tx,\n                    });\n\n                return {\n                    hash: transaction.transactionHash,\n                    status: transaction.status,\n                };\n            }\n\n            if (!functionName) {\n                throw new Error(\"Function name is required\");\n            }\n\n            await publicClient.simulateContract({\n                account: client.account,\n                address: toAddress,\n                abi,\n                functionName,\n                args,\n                chain: client.chain,\n            });\n            const hash = await client.writeContract({\n                account: client.account,\n                address: toAddress,\n                abi,\n                functionName,\n                args,\n                chain: client.chain,\n                value,\n            });\n\n            const t = await publicClient.waitForTransactionReceipt({\n                hash: hash,\n            });\n\n            return {\n                hash: t.transactionHash,\n                status: t.status,\n            };\n        },\n        async read(request: EVMReadRequest) {\n            const { address, abi, functionName, args } = request;\n\n            if (!abi) throw new Error(\"Read request must include ABI for EVM\");\n\n            const result = await publicClient.readContract({\n                address: await this.resolveAddress(address),\n                abi,\n                functionName,\n                args,\n            });\n\n            return {\n                value: result,\n            };\n        },\n        async balanceOf(address: string) {\n            const resolvedAddress = await this.resolveAddress(address);\n\n            const balance = await publicClient.getBalance({\n                address: resolvedAddress,\n            });\n\n            return {\n                value: balance,\n                decimals: 18,\n                symbol: \"ETH\",\n                name: \"Ether\",\n            };\n        },\n    };\n}\n"]}