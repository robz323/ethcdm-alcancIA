{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type {\n    EVMReadRequest,\n    EVMTransaction,\n    EVMWalletClient,\n    EVMTypedData,\n} from \"@goat-sdk/core\";\n\nimport { publicActions } from \"viem\";\nimport { normalize } from \"viem/ens\";\nimport type { WalletClient as ViemWalletClient } from \"viem\";\n\nexport function viem(client: ViemWalletClient): EVMWalletClient {\n    const publicClient = client.extend(publicActions);\n\n    return {\n        getAddress: () => client.account?.address ?? \"\",\n        getChain() {\n            return {\n                type: \"evm\",\n                id: client.chain?.id ?? 0,\n            };\n        },\n        async resolveAddress(address: string) {\n            if (/^0x[a-fA-F0-9]{40}$/.test(address)) {\n                return address as `0x${string}`;\n            }\n\n            try {\n                const resolvedAddress = (await publicClient.getEnsAddress({\n                    name: normalize(address),\n                })) as `0x${string}`;\n                if (!resolvedAddress) {\n                    throw new Error(\"ENS name could not be resolved.\");\n                }\n                return resolvedAddress as `0x${string}`;\n            } catch (error) {\n                throw new Error(`Failed to resolve ENS name: ${error}`);\n            }\n        },\n        async signMessage(message: string) {\n            if (!client.account) throw new Error(\"No account connected\");\n            const signature = await client.signMessage({\n                message,\n                account: client.account,\n            });\n\n            return {\n                signature,\n            };\n        },\n        async signTypedData(data: EVMTypedData) {\n            if (!client.account) throw new Error(\"No account connected\");\n\n            const signature = await client.signTypedData({\n                domain: data.domain,\n                types: data.types,\n                primaryType: data.primaryType,\n                message: data.message,\n                account: client.account,\n            });\n\n            return {\n                signature,\n            };\n        },\n        async sendTransaction(transaction: EVMTransaction) {\n            const { to, abi, functionName, args, value } = transaction;\n\n            const toAddress = await this.resolveAddress(to);\n            if (!client.account) throw new Error(\"No account connected\");\n\n            if (!abi) {\n                const tx = await client.sendTransaction({\n                    account: client.account,\n                    to: toAddress,\n                    chain: client.chain,\n                    value,\n                });\n\n                const transaction =\n                    await publicClient.waitForTransactionReceipt({\n                        hash: tx,\n                    });\n\n                return {\n                    hash: transaction.transactionHash,\n                    status: transaction.status,\n                };\n            }\n\n            if (!functionName) {\n                throw new Error(\"Function name is required\");\n            }\n\n            await publicClient.simulateContract({\n                account: client.account,\n                address: toAddress,\n                abi,\n                functionName,\n                args,\n                chain: client.chain,\n            });\n            const hash = await client.writeContract({\n                account: client.account,\n                address: toAddress,\n                abi,\n                functionName,\n                args,\n                chain: client.chain,\n                value,\n            });\n\n            const t = await publicClient.waitForTransactionReceipt({\n                hash: hash,\n            });\n\n            return {\n                hash: t.transactionHash,\n                status: t.status,\n            };\n        },\n        async read(request: EVMReadRequest) {\n            const { address, abi, functionName, args } = request;\n\n            if (!abi) throw new Error(\"Read request must include ABI for EVM\");\n\n            const result = await publicClient.readContract({\n                address: await this.resolveAddress(address),\n                abi,\n                functionName,\n                args,\n            });\n\n            return {\n                value: result,\n            };\n        },\n        async balanceOf(address: string) {\n            const resolvedAddress = await this.resolveAddress(address);\n\n            const balance = await publicClient.getBalance({\n                address: resolvedAddress,\n            });\n\n            return {\n                value: balance,\n                decimals: 18,\n                symbol: \"ETH\",\n                name: \"Ether\",\n            };\n        },\n    };\n}\n"],"mappings":"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","names":["transaction"]}