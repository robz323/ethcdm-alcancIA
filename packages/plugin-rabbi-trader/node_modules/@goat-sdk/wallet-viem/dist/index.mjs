// src/index.ts
import { publicActions } from "viem";
import { normalize } from "viem/ens";
function viem(client) {
  const publicClient = client.extend(publicActions);
  return {
    getAddress: () => client.account?.address ?? "",
    getChain() {
      return {
        type: "evm",
        id: client.chain?.id ?? 0
      };
    },
    async resolveAddress(address) {
      if (/^0x[a-fA-F0-9]{40}$/.test(address)) {
        return address;
      }
      try {
        const resolvedAddress = await publicClient.getEnsAddress({
          name: normalize(address)
        });
        if (!resolvedAddress) {
          throw new Error("ENS name could not be resolved.");
        }
        return resolvedAddress;
      } catch (error) {
        throw new Error(`Failed to resolve ENS name: ${error}`);
      }
    },
    async signMessage(message) {
      if (!client.account) throw new Error("No account connected");
      const signature = await client.signMessage({
        message,
        account: client.account
      });
      return {
        signature
      };
    },
    async signTypedData(data) {
      if (!client.account) throw new Error("No account connected");
      const signature = await client.signTypedData({
        domain: data.domain,
        types: data.types,
        primaryType: data.primaryType,
        message: data.message,
        account: client.account
      });
      return {
        signature
      };
    },
    async sendTransaction(transaction) {
      const { to, abi, functionName, args, value } = transaction;
      const toAddress = await this.resolveAddress(to);
      if (!client.account) throw new Error("No account connected");
      if (!abi) {
        const tx = await client.sendTransaction({
          account: client.account,
          to: toAddress,
          chain: client.chain,
          value
        });
        const transaction2 = await publicClient.waitForTransactionReceipt({
          hash: tx
        });
        return {
          hash: transaction2.transactionHash,
          status: transaction2.status
        };
      }
      if (!functionName) {
        throw new Error("Function name is required");
      }
      await publicClient.simulateContract({
        account: client.account,
        address: toAddress,
        abi,
        functionName,
        args,
        chain: client.chain
      });
      const hash = await client.writeContract({
        account: client.account,
        address: toAddress,
        abi,
        functionName,
        args,
        chain: client.chain,
        value
      });
      const t = await publicClient.waitForTransactionReceipt({
        hash
      });
      return {
        hash: t.transactionHash,
        status: t.status
      };
    },
    async read(request) {
      const { address, abi, functionName, args } = request;
      if (!abi) throw new Error("Read request must include ABI for EVM");
      const result = await publicClient.readContract({
        address: await this.resolveAddress(address),
        abi,
        functionName,
        args
      });
      return {
        value: result
      };
    },
    async balanceOf(address) {
      const resolvedAddress = await this.resolveAddress(address);
      const balance = await publicClient.getBalance({
        address: resolvedAddress
      });
      return {
        value: balance,
        decimals: 18,
        symbol: "ETH",
        name: "Ether"
      };
    }
  };
}
export {
  viem
};
//# sourceMappingURL=index.mjs.map