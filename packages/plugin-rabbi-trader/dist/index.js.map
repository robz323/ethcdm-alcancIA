{"version":3,"sources":["../src/index.ts","../src/providers/token.ts","../src/utils/bignumber.ts","../src/providers/trustScoreProvider.ts","../src/services/simulationService.ts","../src/constants.ts","../../../node_modules/uuid/dist/esm-node/stringify.js","../../../node_modules/uuid/dist/esm-node/rng.js","../../../node_modules/uuid/dist/esm-node/native.js","../../../node_modules/uuid/dist/esm-node/v4.js","../src/actions/analyzeTrade.ts","../src/actions.ts","../src/services/twitter.ts","../src/wallet.ts","../src/utils.ts","../src/config.ts"],"sourcesContent":["import type { Plugin, IAgentRuntime, Memory, State } from \"@elizaos/core\";\nimport { elizaLogger, settings } from \"@elizaos/core\";\nimport { z } from \"zod\";\nimport { TwitterClientInterface } from \"@elizaos/client-twitter\";\nimport {\n    solanaPlugin,\n    trustScoreProvider,\n    trustEvaluator,\n    getTokenBalance,\n} from \"@elizaos/plugin-solana\";\nimport { TokenProvider } from \"./providers/token\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport type { Chain, WalletClient, Signature, Balance } from \"@goat-sdk/core\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { TrustScoreProvider } from \"./providers/trustScoreProvider\";\nimport { SimulationService } from \"./services/simulationService\";\nimport { SAFETY_LIMITS } from \"./constants\";\nimport NodeCache from \"node-cache\";\nimport { TrustScoreDatabase } from \"@elizaos/plugin-trustdb\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { actions } from \"./actions\";\nimport {\n    TradeAlert,\n    TradeBuyAlert,\n    tweetTrade,\n    TwitterConfigSchema,\n    TwitterService,\n} from \"./services/twitter\";\nimport {\n    executeTrade,\n    getChainWalletBalance,\n    getWalletBalance,\n    getWalletKeypair,\n} from \"./wallet\";\nimport { ProcessedTokenData } from \"./types\";\nimport { analyzeTradeAction } from \"./actions/analyzeTrade\";\n\n// Update Balance interface to include formatted\ninterface ExtendedBalance extends Balance {\n    formatted: string;\n}\n\n// Extended WalletProvider interface to ensure proper typing\ninterface ExtendedWalletProvider extends WalletClient {\n    connection: Connection;\n    signMessage(message: string): Promise<Signature>;\n    getFormattedPortfolio: (runtime: IAgentRuntime) => Promise<string>;\n    balanceOf: (tokenAddress: string) => Promise<ExtendedBalance>;\n    getMaxBuyAmount: (tokenAddress: string) => Promise<number>;\n    executeTrade: (params: {\n        tokenIn: string;\n        tokenOut: string;\n        amountIn: number;\n        slippage: number;\n    }) => Promise<any>;\n}\n\nconst REQUIRED_SETTINGS = {\n    WALLET_PUBLIC_KEY: \"Solana wallet public key\",\n    DEXSCREENER_WATCHLIST_ID: \"DexScreener watchlist ID\",\n    COINGECKO_API_KEY: \"CoinGecko API key\",\n} as const;\n\n// Add near the top imports\ninterface ExtendedPlugin extends Plugin {\n    name: string;\n    description: string;\n    evaluators: any[];\n    providers: any[];\n    actions: any[];\n    services: any[];\n    autoStart?: boolean;\n}\n\n// Add this helper function\nfunction validateSolanaAddress(address: string | undefined): boolean {\n    if (!address) return false;\n    try {\n        // Handle Solana addresses\n        if (!/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address)) {\n            elizaLogger.warn(`Solana address failed format check: ${address}`);\n            return false;\n        }\n\n        // Verify it's a valid Solana public key\n        const pubKey = new PublicKey(address);\n        const isValid = Boolean(pubKey.toBase58());\n        elizaLogger.log(\n            `Solana address validation result for ${address}: ${isValid}`\n        );\n        return isValid;\n    } catch (error) {\n        elizaLogger.error(`Address validation error for ${address}:`, error);\n        return false;\n    }\n}\n\n// Add function to load token addresses\nexport function loadTokenAddresses(): string[] {\n    try {\n        const filePath = path.resolve(\n            process.cwd(),\n            \"../characters/tokens/tokenaddresses.json\"\n        );\n        const data = fs.readFileSync(filePath, \"utf8\");\n        const addresses = JSON.parse(data);\n\n        // Validate addresses\n        const validAddresses = addresses.filter((addr: string) => {\n            // Solana address validation\n            return validateSolanaAddress(addr);\n        });\n\n        elizaLogger.log(\"Loaded token addresses:\", {\n            total: validAddresses.length,\n            solana: validAddresses.filter((addr) => !addr.startsWith(\"0x\"))\n                .length,\n            base: validAddresses.filter((addr) => addr.startsWith(\"0x\")).length,\n        });\n\n        return validAddresses;\n    } catch (error) {\n        elizaLogger.error(\"Failed to load token addresses:\", error);\n        throw new Error(\"Token addresses file not found or invalid\");\n    }\n}\n\n// Add cache configuration after other interfaces\ninterface CacheEntry {\n    lastAnalysis: number;\n    tokenData: any;\n    trustScore: number;\n    analysisResult: any;\n}\n\n// Add cache instance before createGoatPlugin\nconst tokenCache = new NodeCache({\n    stdTTL: 1200, // 20 minutes in seconds\n    checkperiod: 120, // Check for expired entries every 2 minutes\n});\n\n// Add near the top with other interfaces\ninterface SkipWaitCache {\n    lastTweet: number;\n    action: \"WAIT\" | \"SKIP\";\n}\n\n// Add near other cache instances\nconst skipWaitCache = new NodeCache({\n    stdTTL: 7200, // 2 hours in seconds\n    checkperiod: 600, // Check for expired entries every 10 minutes\n});\n\n// Add near other interfaces\ninterface TweetRateLimit {\n    lastTweet: number;\n    count: number; // Track number of tweets in the time window\n}\n\n// Add near other cache instances\nconst tweetRateCache = new NodeCache({\n    stdTTL: 86400, // 24 hours in seconds\n    checkperiod: 3600, // Check every hour\n});\n\n// Add helper function\nfunction canTweet(tweetType: \"trade\" | \"market_search\"): boolean {\n    const now = Date.now();\n    const hourKey = `tweets_${tweetType}_${Math.floor(now / 3600000)}`; // Key by hour and type\n    const rateLimit: TweetRateLimit = tweetRateCache.get(hourKey) || {\n        lastTweet: now,\n        count: 0,\n    };\n\n    // Different limits for different tweet types\n    const MAX_TWEETS_PER_HOUR = {\n        trade: 10,\n        market_search: 10, // Lower limit for market search tweets\n    };\n\n    if (rateLimit.count >= MAX_TWEETS_PER_HOUR[tweetType]) {\n        elizaLogger.warn(\n            `Tweet rate limit reached for ${tweetType}: ${rateLimit.count} tweets this hour`\n        );\n        return false;\n    }\n\n    // Update rate limit\n    tweetRateCache.set(hourKey, {\n        lastTweet: now,\n        count: rateLimit.count + 1,\n    });\n\n    return true;\n}\n\n// Add new interfaces near the top with other interfaces\ninterface TradePerformance {\n    token_address: string;\n    recommender_id: string;\n    buy_price: number;\n    sell_price: number;\n    buy_timeStamp: string;\n    sell_timeStamp: string;\n    buy_amount: number;\n    sell_amount: number;\n    buy_value_usd: number;\n    sell_value_usd: number;\n    buy_market_cap: number;\n    sell_market_cap: number;\n    buy_liquidity: number;\n    sell_liquidity: number;\n    profit_usd: number;\n    profit_percent: number;\n    market_cap_change: number;\n    liquidity_change: number;\n    rapidDump: boolean;\n}\n\ninterface TradePosition {\n    token_address: string;\n    entry_price: number;\n    size: number;\n    stop_loss: number;\n    take_profit: number;\n    open_timeStamp: string;\n    close_timeStamp?: string;\n    status?: \"OPEN\" | \"CLOSED\";\n}\n\n// Update the analysisParams interface\ninterface AnalysisParams extends Record<string, any> {\n    walletBalance: number;\n    tokenAddress: string;\n    price: number;\n    volume: number;\n    marketCap: number;\n    liquidity: number;\n    holderDistribution: string;\n    trustScore: number;\n    dexscreener: any;\n    position?: TradePosition;\n    tradeHistory?: TradePerformance[];\n}\n\n// Update the interface to match the SQL parameter order\ninterface SellDetailsData {\n    // SET clause parameters in order\n    sell_price: number;\n    sell_timeStamp: string;\n    sell_amount: number;\n    received_sol: number;\n    sell_value_usd: number;\n    profit_usd: number;\n    profit_percent: number;\n    sell_market_cap: number;\n    market_cap_change: number;\n    sell_liquidity: number;\n    liquidity_change: number;\n    rapidDump: boolean;\n    sell_recommender_id: string | null;\n}\n\nasync function updateSellDetails(\n    runtime: IAgentRuntime,\n    tokenAddress: string,\n    recommenderId: string,\n    tradeAmount: number,\n    latestTrade: any,\n    tokenData: any\n) {\n    const trustScoreDb = new TrustScoreDatabase(runtime.databaseAdapter.db);\n\n    const trade = await trustScoreDb.getLatestTradePerformance(\n        tokenAddress,\n        recommenderId,\n        false\n    );\n\n    if (!trade) {\n        elizaLogger.error(\n            `No trade found for token ${tokenAddress} and recommender ${recommenderId}`\n        );\n        throw new Error(\"No trade found to update\");\n    }\n\n    const currentPrice = tokenData.dexScreenerData.pairs[0]?.priceUsd || 0;\n    const marketCap = tokenData.dexScreenerData.pairs[0]?.marketCap || 0;\n    const liquidity = tokenData.dexScreenerData.pairs[0]?.liquidity?.usd || 0;\n\n    const sellValueUsd = tradeAmount * Number(currentPrice);\n    const profitUsd = sellValueUsd - trade.buy_value_usd;\n    const profitPercent = (profitUsd / trade.buy_value_usd) * 100;\n\n    // Create sellDetailsData object matching SQL parameter order\n    const sellDetails: SellDetailsData = {\n        sell_price: Number(currentPrice),\n        sell_timeStamp: new Date().toISOString(),\n        sell_amount: tradeAmount,\n        received_sol: tradeAmount,\n        sell_value_usd: sellValueUsd,\n        profit_usd: profitUsd,\n        profit_percent: profitPercent,\n        sell_market_cap: marketCap,\n        market_cap_change: marketCap - trade.buy_market_cap,\n        sell_liquidity: liquidity,\n        liquidity_change: liquidity - trade.buy_liquidity,\n        rapidDump: false,\n        sell_recommender_id: recommenderId || null,\n    };\n\n    elizaLogger.log(\"Attempting to update trade performance with data:\", {\n        sellDetails,\n        whereClause: {\n            tokenAddress,\n            recommenderId,\n            buyTimeStamp: trade.buy_timeStamp,\n        },\n        isSimulation: false,\n    });\n\n    try {\n        try {\n            // Pass sellDetails first (SET clause), then WHERE clause parameters\n            elizaLogger.log(\n                \"Verifying parameters for updateTradePerformanceOnSell:\",\n                {\n                    sellDetails,\n                    tokenAddress,\n                    recommenderId,\n                    buyTimeStamp: trade.buy_timeStamp,\n                    isSimulation: false,\n                }\n            );\n\n            const success = await trustScoreDb.updateTradePerformanceOnSell(\n                tokenAddress, // 1. WHERE token_address = ?\n                recommenderId, // 2. WHERE recommender_id = ?\n                trade.buy_timeStamp, // 3. WHERE buy_timeStamp = ?\n                sellDetails, // 4. SET clause parameters\n                false // 5. isSimulation flag\n            );\n\n            if (!success) {\n                elizaLogger.warn(\"Trade update returned false\", {\n                    tokenAddress,\n                    recommenderId,\n                    buyTimeStamp: trade.buy_timeStamp,\n                });\n            }\n\n            elizaLogger.log(\"Trade performance update completed\", {\n                success,\n                tokenAddress,\n                recommenderId,\n                profitPercent: profitPercent.toFixed(2) + \"%\",\n                profitUsd: profitUsd.toFixed(4) + \" USD\",\n            });\n        } catch (dbError) {\n            elizaLogger.error(\"Database error during trade update:\", {\n                error: dbError,\n                query: {\n                    sellDetails,\n                    whereClause: {\n                        tokenAddress,\n                        recommenderId,\n                        buyTimeStamp: trade.buy_timeStamp,\n                    },\n                },\n            });\n            throw dbError;\n        }\n    } catch (error) {\n        elizaLogger.error(\"Failed to update trade performance:\", {\n            error,\n            parameters: {\n                sellDetails,\n                whereClause: {\n                    tokenAddress,\n                    recommenderId,\n                    buyTimeStamp: trade.buy_timeStamp,\n                },\n                originalTrade: trade,\n            },\n            errorDetails:\n                error instanceof Error\n                    ? {\n                          message: error.message,\n                          stack: error.stack,\n                          name: error.name,\n                      }\n                    : error,\n        });\n        throw error;\n    }\n\n    return {\n        sellDetails,\n        currentPrice,\n        profitDetails: {\n            profitUsd,\n            profitPercent,\n            sellValueUsd,\n        },\n    };\n}\n\n// Update the module declaration to match the new parameter order\ndeclare module \"@elizaos/plugin-trustdb\" {\n    interface TrustScoreDatabase {\n        updateTradePerformanceOnSell(\n            tokenAddress: string, // Changed order: tokenAddress first\n            recommenderId: string, // recommenderId second\n            buyTimeStamp: string, // buyTimeStamp third\n            sellDetails: SellDetailsData, // sellDetails fourth\n            isSimulation: boolean // isSimulation fifth\n        ): boolean;\n    }\n}\n\nasync function getChainBalance(\n    connection: Connection,\n    walletAddress: PublicKey,\n    tokenAddress: string\n): Promise<number> {\n    // Use existing Solana balance fetching logic\n    return await getTokenBalance(\n        connection,\n        walletAddress,\n        new PublicKey(tokenAddress)\n    );\n}\n\nasync function createRabbiTraderPlugin(\n    getSetting: (key: string) => string | undefined,\n    runtime?: IAgentRuntime\n): Promise<Plugin> {\n    // Define resumeTrading at the start of the function\n    const resumeTrading = async () => {\n        // Load and analyze tokens\n        const tokenAddresses = loadTokenAddresses().filter(\n            (addr) => !addr.startsWith(\"0x\")\n        );\n        elizaLogger.log(`Analyzing ${tokenAddresses.length} Solana tokens...`);\n\n        // Analyze regular token list\n        for (const tokenAddress of tokenAddresses) {\n            await analyzeToken(\n                runtime,\n                connection,\n                twitterService,\n                tokenAddress\n            );\n        }\n\n        // Add delay between iterations\n        await new Promise((resolve) => setTimeout(resolve, 1200000)); // 20 minutes\n    };\n\n    elizaLogger.log(\"Starting GOAT plugin initialization\");\n\n    // Move connection initialization to the top\n    const connection = new Connection(\n        runtime?.getSetting(\"SOLANA_RPC_URL\") || \"https://api.mainnet-beta.solana.com\"\n    );\n\n    const keypair = getWalletKeypair(runtime);\n\n    // Validate required settings\n    const missingSettings: string[] = [];\n    for (const [key, description] of Object.entries(REQUIRED_SETTINGS)) {\n        if (!getSetting(key)) {\n            missingSettings.push(`${key} (${description})`);\n        }\n    }\n\n    if (missingSettings.length > 0) {\n        const errorMsg = `Missing required settings: ${missingSettings.join(\", \")}`;\n        elizaLogger.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    elizaLogger.log(\"Initializing Solana connection...\");\n    let walletProvider: ExtendedWalletProvider = {\n        connection,\n        getChain: () => ({ type: \"solana\" }),\n        getAddress: () => keypair.publicKey.toBase58(),\n        signMessage: async (message: string): Promise<Signature> => {\n            throw new Error(\n                \"Message signing not implemented for Solana wallet\"\n            );\n        },\n        balanceOf: async (tokenAddress: string): Promise<ExtendedBalance> => {\n            try {\n                if (tokenAddress.startsWith(\"0x\")) {\n                    // Handle Base token balance\n                    const baseBalance = await getChainBalance(\n                        connection,\n                        keypair.publicKey,\n                        tokenAddress\n                    );\n                    return {\n                        value: BigInt(baseBalance.toString()),\n                        decimals: 18, // Base uses 18 decimals\n                        formatted: (baseBalance / 1e18).toString(),\n                        symbol: \"ETH\",\n                        name: \"Base\",\n                    };\n                } else {\n                    // Existing Solana logic\n                    const tokenPublicKey = new PublicKey(tokenAddress);\n                    const amount = await getTokenBalance(\n                        connection,\n                        keypair.publicKey,\n                        tokenPublicKey\n                    );\n                    return {\n                        value: BigInt(amount.toString()),\n                        decimals: 9,\n                        formatted: (amount / 1e9).toString(),\n                        symbol: \"SOL\",\n                        name: \"Solana\",\n                    };\n                }\n            } catch (error) {\n                return {\n                    value: BigInt(0),\n                    decimals: tokenAddress.startsWith(\"0x\") ? 18 : 9,\n                    formatted: \"0\",\n                    symbol: tokenAddress.startsWith(\"0x\") ? \"ETH\" : \"SOL\",\n                    name: tokenAddress.startsWith(\"0x\") ? \"Base\" : \"Solana\",\n                };\n            }\n        },\n        getMaxBuyAmount: async (tokenAddress: string) => {\n            try {\n                if (tokenAddress.startsWith(\"0x\")) {\n                    // Handle Base chain balance\n                    const baseBalance = await getChainBalance(\n                        connection,\n                        keypair.publicKey,\n                        tokenAddress\n                    );\n                    return (baseBalance * 0.9) / 1e18; // Base uses 18 decimals\n                } else {\n                    // Handle Solana balance\n                    const balance = await connection.getBalance(\n                        keypair.publicKey\n                    );\n                    return (balance * 0.9) / 1e9; // Solana uses 9 decimals\n                }\n            } catch (error) {\n                elizaLogger.error(\n                    `Failed to get max buy amount for ${tokenAddress}:`,\n                    error\n                );\n                return 0;\n            }\n        },\n        executeTrade: async (params) => {\n            try {\n                return { success: true };\n            } catch (error) {\n                throw error;\n            }\n        },\n        getFormattedPortfolio: async () => \"\",\n    };\n\n    elizaLogger.log(\n        \"Solana connection and wallet provider initialized successfully\"\n    );\n\n    // Initialize Twitter service if enabled\n    let twitterService: TwitterService | undefined;\n    try {\n        elizaLogger.log(\n            \"Configuring Twitter service for trade notifications...\"\n        );\n        const twitterConfig = TwitterConfigSchema.parse({\n            enabled: getSetting(\"TWITTER_ENABLED\") === \"true\",\n            username: getSetting(\"TWITTER_USERNAME\"),\n            dryRun: false,\n        });\n\n        if (twitterConfig.enabled && runtime) {\n            elizaLogger.log(\"Starting Twitter client initialization...\");\n            const twitterClient = await TwitterClientInterface.start(runtime);\n            twitterService = new TwitterService(twitterClient, twitterConfig);\n\n            // Add delay after initialization\n            await new Promise((resolve) => setTimeout(resolve, 5000));\n\n            elizaLogger.log(\"Twitter service initialized successfully\", {\n                username: twitterConfig.username,\n                dryRun: twitterConfig.dryRun,\n            });\n        }\n    } catch (error) {\n        elizaLogger.error(\"Failed to initialize Twitter service:\", error);\n    }\n\n    elizaLogger.log(\"Initializing Solana plugin components...\");\n\n    try {\n        const customActions = actions;\n\n        // Then update the plugin creation\n        const plugin: ExtendedPlugin = {\n            name: \"[Rabbi Trader] Onchain Actions with Solana Integration\",\n            description: \"Autonomous trading integration with AI analysis\",\n            evaluators: [trustEvaluator, ...(solanaPlugin.evaluators || [])],\n            providers: [\n                walletProvider,\n                trustScoreProvider,\n                ...(solanaPlugin.providers || []),\n            ],\n            actions: [...customActions, ...(solanaPlugin.actions || [])],\n            services: [],\n            autoStart: true,\n        };\n\n        // Add auto-start trading analysis\n        if (!runtime) return;\n\n        elizaLogger.log(\"Starting autonomous trading system...\");\n        const analyzeTradeAction = plugin.actions.find(\n            (a) => a.name === \"ANALYZE_TRADE\"\n        );\n\n        if (!analyzeTradeAction) return;\n\n        const interval =\n            Number(runtime.getSetting(\"TRADING_INTERVAL\")) || 300000;\n\n        // Then start trading loop if enabled\n        if (!settings.ENABLE_TRADING) return;\n\n        elizaLogger.log(\"Initializing trading loop...\");\n        await resumeTrading();\n        setInterval(resumeTrading, interval);\n\n        elizaLogger.log(\"GOAT plugin initialization completed successfully\");\n        return plugin;\n    } catch (error) {\n        elizaLogger.error(\"Failed to initialize plugin components:\", error);\n        throw new Error(\n            `Plugin initialization failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n    }\n}\n\nasync function analyzeToken(\n    runtime: IAgentRuntime,\n    connection: Connection,\n    twitterService: TwitterService,\n    tokenAddress: string\n) {\n    try {\n        // Check cache first\n        const cachedData: CacheEntry | undefined = tokenCache.get(tokenAddress);\n        const now = Date.now();\n\n        // Skip if analyzed within last 20 minutes\n        if (cachedData && now - cachedData.lastAnalysis < 1200000) {\n            elizaLogger.log(\n                `Using cached data for ${tokenAddress}, last analyzed ${Math.floor((now - cachedData.lastAnalysis) / 1000)}s ago`\n            );\n            return;\n        }\n\n        elizaLogger.log(`Starting analysis for token: ${tokenAddress}`);\n\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n\n        if (!validateSolanaAddress(tokenAddress)) {\n            elizaLogger.error(`Invalid token address format: ${tokenAddress}`);\n            return;\n        }\n\n        // Initialize TokenProvider directly with just the token address\n        const tokenProvider = new TokenProvider(tokenAddress);\n\n        // Get processed token data which includes DexScreener data\n        elizaLogger.log(`Fetching token data for ${tokenAddress}`);\n        const tokenData = await tokenProvider.getProcessedTokenData();\n        elizaLogger.log(`Token data fetched for ${tokenAddress}:`, tokenData);\n\n        // Get trust score and cache it\n        const trustProvider = new TrustScoreProvider();\n        const trustEvaluation = await trustProvider.evaluateToken(tokenAddress);\n        const { trustScore } = trustEvaluation;\n\n        // Cache the new data\n        const cacheEntry: CacheEntry = {\n            lastAnalysis: Date.now(),\n            tokenData,\n            trustScore,\n            analysisResult: null, // Will be updated after analysis\n        };\n        tokenCache.set(tokenAddress, cacheEntry);\n\n        const walletPublicKey = runtime.getSetting(\"WALLET_PUBLIC_KEY\");\n        if (!walletPublicKey) {\n            elizaLogger.error(\"No wallet public key configured\");\n            return;\n        }\n\n        const balance = await connection.getBalance(\n            new PublicKey(walletPublicKey)\n        );\n\n        const walletSolBalance = {\n            formatted: (balance / 1e9).toString(),\n        };\n\n        // Initialize trustScoreDb\n        const trustScoreDb = new TrustScoreDatabase(runtime.databaseAdapter.db);\n\n        // Before creating analysisParams, get the latest trade performance\n        const latestTrade = trustScoreDb.getLatestTradePerformance(\n            tokenAddress,\n            runtime.agentId,\n            false // not simulation\n        );\n\n        elizaLogger.log(`Latest trade for ${tokenAddress}:`, latestTrade);\n\n        // Before creating analysisParams, get the correct chain balance\n        const walletBalance = await getChainWalletBalance(\n            runtime,\n            tokenAddress\n        );\n\n        const pair = tokenData.dexScreenerData.pairs[0];\n        const analysisParams: AnalysisParams = {\n            walletBalance, // Now using the correct chain's balance\n            tokenAddress,\n            price: Number(pair?.priceUsd || 0),\n            volume: pair?.volume?.h24 || 0,\n            marketCap: pair?.marketCap || 0,\n            liquidity: pair?.liquidity?.usd || 0,\n            holderDistribution: tokenData.holderDistributionTrend,\n            trustScore: trustScore || 0,\n            dexscreener: tokenData.dexScreenerData,\n            position: latestTrade\n                ? {\n                      token_address: latestTrade.token_address,\n                      entry_price: latestTrade.buy_price,\n                      size: latestTrade.buy_amount,\n                      stop_loss: latestTrade.buy_price * 0.85, // 15% stop loss\n                      take_profit: latestTrade.buy_price * 1.3, // 30% take profit\n                      open_timeStamp: latestTrade.buy_timeStamp,\n                      status: latestTrade.sell_timeStamp ? \"CLOSED\" : \"OPEN\",\n                  }\n                : undefined,\n        };\n\n        // Create initial state first\n        const state: State = await runtime.composeState({\n            userId: runtime.agentId,\n            agentId: runtime.agentId,\n            roomId: runtime.agentId,\n            content: {\n                text: `Initialize state for ${tokenAddress}`,\n                type: \"analysis\",\n            },\n        });\n\n        // Then create analysis memory using state\n        const analysisMemory: Memory = {\n            userId: state.userId,\n            agentId: runtime.agentId,\n            roomId: state.roomId,\n            content: {\n                text: `Analyze trade for ${tokenAddress}`,\n                type: \"analysis\",\n            },\n        };\n\n        // Update analysis result in cache after completion\n        const analysisResult = await analyzeTradeAction.handler(\n            runtime,\n            analysisMemory,\n            state,\n            analysisParams,\n            async (response) => {\n                if (!response) {\n                    elizaLogger.error(\n                        `Empty response from analysis for ${tokenAddress}`\n                    );\n                    return [];\n                }\n\n                elizaLogger.log(\n                    `Analysis result for ${tokenAddress}:`,\n                    response\n                );\n                try {\n                    // Parse the JSON response from the analysis\n                    const result =\n                        typeof response.text === \"string\"\n                            ? JSON.parse(response.text)\n                            : response.text;\n\n                    if (!result) {\n                        elizaLogger.error(\n                            `Invalid analysis result for ${tokenAddress}`\n                        );\n\n                        return [];\n                    }\n\n                    if (\n                        result.shouldTrade &&\n                        result.recommendedAction === \"BUY\"\n                    ) {\n                        await buy({\n                            result,\n                            runtime,\n                            state,\n                            tokenAddress,\n                            tokenData,\n                            twitterService,\n                            trustScore,\n                        });\n                    } else if (result.recommendedAction === \"SELL\") {\n                        await sell({\n                            latestTrade,\n                            result,\n                            runtime,\n                            state,\n                            tokenAddress,\n                            tokenProvider,\n                            trustScoreDb,\n                            twitterService,\n                            trustScore,\n                        });\n                    } else {\n                        elizaLogger.log(\n                            `Trade not recommended for ${tokenAddress}:`,\n                            result\n                        );\n                    }\n                } catch (parseError) {}\n                return [];\n            }\n        );\n        cacheEntry.analysisResult = analysisResult;\n        tokenCache.set(tokenAddress, cacheEntry);\n    } catch (tokenError) {\n        elizaLogger.error(`Error processing token ${tokenAddress}:`, {\n            error: tokenError,\n            stack: tokenError instanceof Error ? tokenError.stack : undefined,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n}\n\nasync function buy({\n    runtime,\n    tokenAddress,\n    state,\n    tokenData,\n    result,\n    twitterService,\n    trustScore,\n}: {\n    runtime: IAgentRuntime;\n    tokenAddress: string;\n    state: State;\n    tokenData: ProcessedTokenData;\n    result: any;\n    twitterService: TwitterService;\n    trustScore: number;\n}) {\n    elizaLogger.log(`Trade recommended for ${tokenAddress}:`, result);\n\n    // Continue with simulation if analysis recommends trading\n    const simulationService = new SimulationService();\n    const simulation = await simulationService.simulateTrade(\n        tokenAddress,\n        result.suggestedAmount || SAFETY_LIMITS.MINIMUM_TRADE\n    );\n\n    if (simulation.recommendedAction === \"EXECUTE\") {\n        try {\n            // Check wallet balance before trade\n            const currentBalance = await getWalletBalance(runtime);\n\n            const tradeAmount = Math.min(\n                result.suggestedAmount || SAFETY_LIMITS.MINIMUM_TRADE,\n                currentBalance * 0.95 // Leave some SOL for fees\n            );\n\n            if (tradeAmount < SAFETY_LIMITS.MINIMUM_TRADE) {\n                elizaLogger.warn(\n                    `Insufficient balance for trade: ${currentBalance} SOL`\n                );\n            }\n\n            // Create trade memory object\n            const tradeMemory: Memory = {\n                userId: state.userId,\n                agentId: runtime.agentId,\n                roomId: state.roomId,\n                content: {\n                    text: `Execute trade for ${tokenAddress}`,\n                    tokenAddress,\n                    amount: SAFETY_LIMITS.MINIMUM_TRADE,\n                    action: \"BUY\",\n                    source: \"system\",\n                    type: \"trade\",\n                },\n            };\n\n            // Execute trade using our custom function\n            const tradeResult = await executeTrade(runtime, {\n                tokenAddress,\n                amount: tradeAmount,\n                slippage: tokenAddress.startsWith(\"0x\") ? 0.03 : 0.3, // 3% for Base, 30% for Solana\n                chain: tokenAddress.startsWith(\"0x\") ? \"base\" : \"solana\",\n            });\n\n            if (tradeResult.success) {\n                elizaLogger.log(\n                    `Trade executed successfully for ${tokenAddress}:`,\n                    {\n                        signature: tradeResult.signature,\n                        amount: tradeAmount,\n                        memory: tradeMemory,\n                    }\n                );\n\n                // Check rate limit before tweeting\n                if (twitterService && result.recommendedAction === \"BUY\") {\n                    await tweetTrade(twitterService, {\n                        token:\n                            tokenData.dexScreenerData.pairs[0]?.baseToken\n                                ?.symbol || tokenAddress,\n                        tokenAddress: tokenAddress,\n                        amount: tradeAmount,\n                        trustScore: Number(trustScore) || 0,\n                        riskLevel: result.riskLevel || \"MEDIUM\",\n                        marketData: {\n                            priceChange24h:\n                                tokenData.dexScreenerData.pairs[0]?.priceChange\n                                    ?.h24 || 0,\n                            volume24h:\n                                tokenData.dexScreenerData.pairs[0]?.volume\n                                    ?.h24 || 0,\n                            liquidity: {\n                                usd:\n                                    tokenData.dexScreenerData.pairs[0]\n                                        ?.liquidity?.usd || 0,\n                            },\n                        },\n                        timestamp: Date.now(),\n                        signature: tradeResult.signature,\n                        hash: tradeResult.hash,\n                        action: \"BUY\",\n                        price: Number(\n                            tokenData.dexScreenerData.pairs[0]?.priceUsd || 0\n                        ),\n                    });\n                } else {\n                    elizaLogger.log(\"Skipping tweet due to rate limit\");\n                }\n\n                // Record trade using TrustScoreDatabase methods\n                const trustScoreDb = new TrustScoreDatabase(\n                    runtime.databaseAdapter.db\n                );\n\n                try {\n                    // Remove the PublicKey validation for Base addresses\n                    elizaLogger.log(\n                        `Attempting to validate token address: ${tokenAddress}`\n                    );\n                    const formattedAddress = tokenAddress.startsWith(\"0x\")\n                        ? tokenAddress\n                        : new PublicKey(tokenAddress).toBase58(); // Only convert Solana addresses\n                    elizaLogger.log(\n                        `Token address validated successfully: ${formattedAddress}`\n                    );\n\n                    // Create a new recommender ID for this trade\n                    const uuid = uuidv4();\n                    const recommender =\n                        await trustScoreDb.getOrCreateRecommender({\n                            id: uuid,\n                            address: \"\",\n                            solanaPubkey:\n                                runtime.getSetting(\"WALLET_PUBLIC_KEY\") || \"\",\n                        });\n                    elizaLogger.log(`Created/retrieved recommender:`, {\n                        recommender,\n                        chainType: tokenAddress.startsWith(\"0x\")\n                            ? \"base\"\n                            : \"solana\",\n                    });\n\n                    // Prepare trade data\n                    const tradeData = {\n                        buy_amount: tradeAmount,\n                        is_simulation: false,\n                        token_address: new PublicKey(tokenAddress).toBase58(),\n                        buy_price:\n                            tokenData.dexScreenerData.pairs[0]?.priceUsd || 0,\n                        buy_timeStamp: new Date().toISOString(),\n                        buy_market_cap:\n                            tokenData.dexScreenerData.pairs[0]?.marketCap || 0,\n                        buy_liquidity:\n                            tokenData.dexScreenerData.pairs[0]?.liquidity\n                                ?.usd || 0,\n                        buy_value_usd:\n                            tradeAmount *\n                            Number(\n                                tokenData.dexScreenerData.pairs[0]?.priceUsd ||\n                                    0\n                            ),\n                    };\n                    elizaLogger.log(`Prepared trade data:`, tradeData);\n\n                    // Create trade record directly using trustScoreDb\n                    await trustScoreDb.addTradePerformance(\n                        {\n                            token_address: formattedAddress, // Use the properly formatted address\n                            recommender_id: recommender.id,\n                            buy_price: Number(tradeData.buy_price),\n                            buy_timeStamp: tradeData.buy_timeStamp,\n                            buy_amount: tradeData.buy_amount,\n                            buy_value_usd: tradeData.buy_value_usd,\n                            buy_market_cap: tradeData.buy_market_cap,\n                            buy_liquidity: tradeData.buy_liquidity,\n                            buy_sol: tradeAmount,\n                            last_updated: new Date().toISOString(),\n                            sell_price: 0,\n                            sell_timeStamp: \"\",\n                            sell_amount: 0,\n                            received_sol: 0,\n                            sell_value_usd: 0,\n                            sell_market_cap: 0,\n                            sell_liquidity: 0,\n                            profit_usd: 0,\n                            profit_percent: 0,\n                            market_cap_change: 0,\n                            liquidity_change: 0,\n                            rapidDump: false,\n                        },\n                        false\n                    );\n\n                    elizaLogger.log(\n                        `Successfully recorded trade performance for ${tokenAddress}`\n                    );\n                } catch (error) {\n                    elizaLogger.error(\"Failed to record trade performance:\", {\n                        error,\n                        tokenAddress,\n                        errorMessage:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        stack: error instanceof Error ? error.stack : undefined,\n                        errorType: error?.constructor?.name,\n                    });\n                }\n            } else {\n                elizaLogger.error(\n                    `Trade execution failed for ${tokenAddress}:`,\n                    tradeResult.error\n                );\n            }\n        } catch (tradeError) {\n            elizaLogger.error(\n                `Error during trade execution for ${tokenAddress}:`,\n                {\n                    error: tradeError,\n                    stack:\n                        tradeError instanceof Error\n                            ? tradeError.stack\n                            : undefined,\n                }\n            );\n        }\n    } else {\n        elizaLogger.log(\n            `Simulation rejected trade for ${tokenAddress}:`,\n            simulation\n        );\n    }\n}\n\nasync function sell({\n    state,\n    runtime,\n    tokenAddress,\n    tokenProvider,\n    twitterService,\n    trustScoreDb,\n    latestTrade,\n    result,\n    trustScore,\n}: {\n    state: State;\n    runtime: IAgentRuntime;\n    tokenAddress: string;\n    tokenProvider: TokenProvider;\n    twitterService: TwitterService;\n    trustScoreDb: TrustScoreDatabase;\n    result: any;\n    latestTrade: TradePerformance;\n    trustScore: number;\n}) {\n    // Get the trade amount from the latest trade\n    const tradeAmount = Number(latestTrade?.buy_amount || 0);\n\n    // Create and save trade memory object for sell\n    const tradeMemory: Memory = {\n        userId: state.userId,\n        agentId: runtime.agentId,\n        roomId: state.roomId,\n        content: {\n            text: `Execute sell for ${tokenAddress}`,\n            tokenAddress,\n            amount: tradeAmount,\n            action: \"SELL\",\n            source: \"system\",\n            type: \"trade\",\n        },\n    };\n\n    // Execute sell trade\n    const tradeResult = await executeTrade(runtime, {\n        tokenAddress,\n        amount: tradeAmount,\n        slippage: 0.3, //  30% for Solana\n        chain: \"solana\",\n    });\n\n    if (tradeResult.success) {\n        elizaLogger.log(`Sell executed successfully for ${tokenAddress}:`, {\n            signature: tradeResult.signature,\n            amount: tradeAmount,\n        });\n\n        // Get token data first\n        const tokenData = await tokenProvider.getProcessedTokenData();\n\n        // Create recommender\n        const uuid = uuidv4();\n        const recommender = await trustScoreDb.getOrCreateRecommender({\n            id: uuid,\n            address: \"\", // Empty since we're only handling Solana\n            solanaPubkey: runtime.getSetting(\"WALLET_PUBLIC_KEY\") || \"\",\n        });\n\n        // Update sell details and get prices\n        const { sellDetails, currentPrice } = await updateSellDetails(\n            runtime,\n            tokenAddress,\n            recommender.id,\n            tradeAmount,\n            latestTrade,\n            tokenData\n        );\n\n        // Post tweet if enabled\n        if (twitterService) {\n            await tweetTrade(twitterService, {\n                token:\n                    tokenData.dexScreenerData.pairs[0]?.baseToken?.symbol ||\n                    tokenAddress,\n                tokenAddress: tokenAddress,\n                amount: tradeAmount,\n                trustScore: Number(trustScore) || 0,\n                riskLevel: result.riskLevel || \"MEDIUM\",\n                marketData: {\n                    priceChange24h:\n                        tokenData.dexScreenerData.pairs[0]?.priceChange?.h24 ||\n                        0,\n                    volume24h:\n                        tokenData.dexScreenerData.pairs[0]?.volume?.h24 || 0,\n                    liquidity: {\n                        usd:\n                            tokenData.dexScreenerData.pairs[0]?.liquidity\n                                ?.usd || 0,\n                    },\n                },\n                timestamp: Date.now(),\n                signature: tradeResult.signature,\n                hash: tradeResult.hash,\n                action: \"SELL\",\n                price: Number(currentPrice),\n                profitPercent: `${sellDetails.profit_percent.toFixed(2)}%`,\n                profitUsd: `${sellDetails.profit_usd.toFixed(4)} USD`,\n                reason: `P/L: ${sellDetails.profit_percent.toFixed(2)}%`,\n            });\n        }\n\n        elizaLogger.log(\n            `Successfully updated sell details for ${tokenAddress}`,\n            {\n                sellPrice: currentPrice,\n                sellAmount: tradeAmount,\n            }\n        );\n    } else {\n        elizaLogger.error(\n            `Sell execution failed for ${tokenAddress}:`,\n            tradeResult.error\n        );\n    }\n}\n\nexport default createRabbiTraderPlugin;\n","import { elizaLogger } from \"@elizaos/core\";\nimport NodeCache from \"node-cache\";\nimport { ProcessedTokenData, TokenSecurityData, TokenTradeData, DexScreenerPair } from \"../types/token\";\nimport { toBN } from \"../utils/bignumber\";\n\nexport class TokenProvider {\n    private cache: NodeCache;\n    private isBase: boolean;\n\n    constructor(private tokenAddress: string, options?: { isBase?: boolean }) {\n        this.cache = new NodeCache({ stdTTL: 300 });\n        this.isBase = options?.isBase || false;\n    }\n\n    async getProcessedTokenData(): Promise<ProcessedTokenData> {\n        const cacheKey = `processed_${this.tokenAddress}`;\n        const cached = this.cache.get<ProcessedTokenData>(cacheKey);\n        if (cached) return cached;\n\n        try {\n            // Fetch DexScreener data\n            const dexData = await this.fetchDexScreenerData();\n            const pair = dexData.pairs[0];\n\n            // Calculate security metrics\n            const security: TokenSecurityData = {\n                ownerBalance: toBN(pair.liquidity.base).toString(),\n                creatorBalance: '0',\n                ownerPercentage: 0,\n                creatorPercentage: 0,\n                top10HolderBalance: toBN(pair.liquidity.base).times(0.1).toString(),\n                top10HolderPercent: 10\n            };\n\n            // Calculate trade metrics\n            const tradeData: TokenTradeData = {\n                price: Number(pair.priceUsd),\n                priceChange24h: pair.priceChange.h24,\n                volume24h: pair.volume.h24,\n                volume24hUsd: toBN(pair.volume.h24).toString(),\n                uniqueWallets24h: pair.txns.h24.buys + pair.txns.h24.sells,\n                uniqueWallets24hChange: 0\n            };\n\n            // Analyze holder distribution\n            const holderDistributionTrend = this.analyzeHolderDistribution(tradeData);\n\n            const processedData: ProcessedTokenData = {\n                security,\n                tradeData,\n                dexScreenerData: { pairs: [pair] },\n                holderDistributionTrend,\n                highValueHolders: [],\n                recentTrades: pair.volume.h24 > 0,\n                highSupplyHoldersCount: 0,\n                tokenCodex: { isScam: false }\n            };\n\n            this.cache.set(cacheKey, processedData);\n            return processedData;\n        } catch (error) {\n            elizaLogger.error(`Failed to process token data: ${error}`);\n            throw error;\n        }\n    }\n\n    private analyzeHolderDistribution(tradeData: TokenTradeData): string {\n        const buyRatio = tradeData.uniqueWallets24h > 0 ?\n            tradeData.uniqueWallets24hChange / tradeData.uniqueWallets24h : 0;\n\n        if (buyRatio > 0.1) return \"increasing\";\n        if (buyRatio < -0.1) return \"decreasing\";\n        return \"stable\";\n    }\n\n    async shouldTradeToken(): Promise<boolean> {\n        const data = await this.getProcessedTokenData();\n        const pair = data.dexScreenerData.pairs[0];\n\n        return (\n            pair.liquidity.usd > 50000 &&\n            pair.volume.h24 > 10000 &&\n            Math.abs(pair.priceChange.h24) < 30 &&\n            !data.tokenCodex?.isScam\n        );\n    }\n\n    private async fetchDexScreenerData(): Promise<{ pairs: DexScreenerPair[] }> {\n        const chainParam = this.isBase ? 'base' : 'solana';\n        const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${this.tokenAddress}?chainId=${chainParam}`);\n        const data = await response.json();\n        return data;\n    }\n}\n","import BigNumber from \"bignumber.js\";\n\n// Re-export BigNumber constructor\nexport const BN = BigNumber;\n\n// Helper function to create new BigNumber instances\nexport function toBN(value: string | number | BigNumber): BigNumber {\n    return new BigNumber(value);\n}\n\n","import { elizaLogger } from \"@elizaos/core\";\nimport { TokenProvider } from \"./token\";\nimport { ProcessedTokenData } from \"../types/token\";\n\nexport class TrustScoreProvider {\n    private tokenProviders: Map<string, TokenProvider> = new Map();\n\n    getTokenProvider(tokenAddress: string): TokenProvider {\n        if (!this.tokenProviders.has(tokenAddress)) {\n            this.tokenProviders.set(tokenAddress, new TokenProvider(tokenAddress));\n        }\n        return this.tokenProviders.get(tokenAddress)!;\n    }\n\n    async calculateTrustScore(tokenData: ProcessedTokenData): Promise<number> {\n        const pair = tokenData.dexScreenerData.pairs[0];\n        const {\n            liquidity,\n            volume,\n            marketCap\n        } = pair;\n\n        // Weight factors\n        const LIQUIDITY_WEIGHT = 0.4;\n        const VOLUME_WEIGHT = 0.4;\n        const MCAP_WEIGHT = 0.2;\n\n        // Calculate component scores\n        const liquidityScore = Math.min(liquidity.usd / 100000, 1) * LIQUIDITY_WEIGHT;\n        const volumeScore = Math.min(volume.h24 / 50000, 1) * VOLUME_WEIGHT;\n        const mcapScore = Math.min(marketCap / 1000000, 1) * MCAP_WEIGHT;\n\n        return liquidityScore + volumeScore + mcapScore;\n    }\n\n    async evaluateToken(tokenAddress: string): Promise<{\n        trustScore: number;\n        riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\n        tradingAdvice: \"BUY\" | \"SELL\" | \"HOLD\";\n        reason: string;\n    }> {\n        try {\n            const provider = this.getTokenProvider(tokenAddress);\n            const tokenData = await provider.getProcessedTokenData();\n            const trustScore = await this.calculateTrustScore(tokenData);\n            const pair = tokenData.dexScreenerData.pairs[0];\n\n            // Risk assessment\n            const riskLevel = trustScore > 0.7 ? \"LOW\" :\n                            trustScore > 0.4 ? \"MEDIUM\" : \"HIGH\";\n\n            // Trading signals\n            let tradingAdvice: \"BUY\" | \"SELL\" | \"HOLD\" = \"HOLD\";\n            let reason = \"Market conditions stable\";\n\n            if (pair.priceChange.h24 > 5 && trustScore > 0.4) {\n                tradingAdvice = \"BUY\";\n                reason = \"Strong upward momentum with good trust score\";\n            } else if (pair.priceChange.h24 < -10 || trustScore < 0.3) {\n                tradingAdvice = \"SELL\";\n                reason = \"Deteriorating conditions or low trust score\";\n            }\n\n            return { trustScore, riskLevel, tradingAdvice, reason };\n        } catch (error) {\n            elizaLogger.error(`Trust evaluation failed: ${error}`);\n            throw error;\n        }\n    }\n}\n","import { elizaLogger } from \"@elizaos/core\";\nimport { TokenProvider } from \"../providers/token\";\nimport { TrustScoreProvider } from \"../providers/trustScoreProvider\";\n\nexport class SimulationService {\n    private trustScoreProvider: TrustScoreProvider;\n\n    constructor() {\n        this.trustScoreProvider = new TrustScoreProvider();\n    }\n\n    async simulateTrade(\n        tokenAddress: string,\n        amount: number\n    ): Promise<{\n        expectedPrice: number;\n        priceImpact: number;\n        recommendedAction: \"EXECUTE\" | \"ABORT\";\n        reason: string;\n    }> {\n        try {\n            const evaluation =\n                await this.trustScoreProvider.evaluateToken(tokenAddress);\n            const tokenProvider = new TokenProvider(tokenAddress);\n            const tokenData = await tokenProvider.getProcessedTokenData();\n\n            // Get liquidity from DexScreener data\n            const liquidity =\n                tokenData.dexScreenerData.pairs[0]?.liquidity?.usd || 0;\n            const priceImpact = (amount / liquidity) * 100;\n\n            let recommendedAction: \"EXECUTE\" | \"ABORT\" = \"ABORT\";\n            let reason = \"Default safety check failed\";\n\n            if (evaluation.trustScore > 0.4 && priceImpact < 1) {\n                recommendedAction = \"EXECUTE\";\n                reason = \"Trade meets safety parameters\";\n            }\n\n            return {\n                expectedPrice: tokenData.tradeData.price,\n                priceImpact,\n                recommendedAction,\n                reason,\n            };\n        } catch (error) {\n            elizaLogger.error(\"Trade simulation failed:\", error);\n            throw error;\n        }\n    }\n}\n","export const SAFETY_LIMITS = {\n  MINIMUM_TRADE: 0.01, // Minimum 0.01 SOL per trade\n  MAX_POSITION_SIZE: 0.1, // Maximum 10% of token liquidity\n  MAX_SLIPPAGE: 0.05, // Maximum 5% slippage allowed\n  MIN_LIQUIDITY: 1000, // Minimum $1000 liquidity required\n  MIN_VOLUME: 2000, // Minimum $2000 24h volume required\n  MIN_TRUST_SCORE: 0.4, // Minimum trust score to trade\n  STOP_LOSS: 0.2, // 20% stop loss trigger\n  CHECK_INTERVAL: 5 * 60 * 1000, // Check every 5 minutes\n  TAKE_PROFIT: 0.12, // Take profit at 12% gain\n  TRAILING_STOP: 0.2, // 20% trailing stop from highest\n  PARTIAL_TAKE: 0.06, // Take 50% profit at 6% gain\n  REENTRY_DELAY: 60 * 60 * 1000, // Wait 1 hour before re-entering\n  MAX_ACTIVE_POSITIONS: 5, // Maximum concurrent positions\n  MIN_WALLET_BALANCE: 0.05, // Keep minimum 0.05 SOL in wallet\n};\n\nexport const ANALYSIS_HISTORY_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\nexport const MAX_TWEETS_PER_HOUR = {\n  trade: 10,\n  market_search: 5,\n};\n\nexport const MARKET_SEARCH_INTERVAL = 60 * 60 * 1000; // 1 hour in milliseconds\n","import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import crypto from 'node:crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;","import {\n    Action,\n    composeContext,\n    elizaLogger,\n    generateText,\n    ModelClass,\n    parseJSONObjectFromText,\n} from \"@elizaos/core\";\n\nexport const analyzeTradeAction: Action = {\n    name: \"ANALYZE_TRADE\",\n    description: \"Analyze a token for trading opportunities\",\n    similes: [\n        \"ANALYZE\",\n        \"ANALYZE_TOKEN\",\n        \"TRADE\",\n        \"ANALYZE_TRADE\",\n        \"EVALUATE\",\n        \"ASSESS\",\n    ],\n    examples: [],\n    validate: async () => true,\n    handler: async (runtime, memory, state, params, callback) => {\n        try {\n            // composeState\n            if (!state) {\n                state = await runtime.composeState(memory);\n            } else state = await runtime.updateRecentMessageState(state);\n\n            const tokenData = {\n                walletBalance: params.walletBalance,\n                tokenAddress: params.tokenAddress,\n                price: params.price,\n                volume: params.volume,\n                marketCap: params.marketCap,\n                liquidity: params.liquidity,\n                holderDistribution: params.holderDistribution,\n                trustScore: params.trustScore,\n                dexscreener: params.dexscreener,\n                position: params.position,\n            };\n\n            // Direct prompt instead of template\n            const prompt = `Analyze the following token data and provide a trading recommendation.\nReturn the response as a JSON object with the following structure:\n{\n  \"recommendation\": \"BUY\" | \"SELL\" | \"HOLD\",\n  \"confidence\": number (0-100),\n  \"reasoning\": string,\n  \"risks\": string[],\n  \"opportunities\": string[]\n}\n\nToken Data:\n${JSON.stringify(tokenData, null, 2)}`;\n\n            // Generate analysis using direct prompt\n            const content = await generateText({\n                runtime,\n                context: prompt,\n                modelClass: ModelClass.LARGE,\n            });\n\n            if (!content) {\n                throw new Error(\"No analysis generated\");\n            }\n\n            elizaLogger.log(`Raw analysis response:`, content);\n\n            // Parse the response to get the recommended action\n            const recommendation = parseJSONObjectFromText(content);\n            elizaLogger.log(\n                `Parsed recommendation for ${params.tokenAddress}:`,\n                recommendation\n            );\n\n            // Send result through callback\n            if (callback) {\n                await callback({\n                    text: JSON.stringify(recommendation),\n                    type: \"analysis\",\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(`Analysis failed:`, {\n                error: error instanceof Error ? error.message : \"Unknown error\",\n                stack: error instanceof Error ? error.stack : undefined,\n            });\n            return false;\n        }\n    },\n};\n","import { analyzeTradeAction } from \"./actions/analyzeTrade\";\nexport const actions = [analyzeTradeAction];\n","import { z } from \"zod\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { MAX_TWEETS_PER_HOUR } from \"../constants\";\nimport { MarketData } from \"../types\";\n\nexport const TwitterConfigSchema = z.object({\n  enabled: z.boolean(),\n  username: z.string().min(1),\n  dryRun: z.boolean().optional().default(false),\n  apiKey: z.string().optional(),\n});\n\nexport interface TradeAlert {\n  token: string;\n  amount: number;\n  trustScore: number;\n  riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\n  marketData: {\n    priceChange24h: number;\n    volume24h: number;\n    liquidity: {\n      usd: number;\n    };\n  };\n  timestamp: number;\n  signature?: string;\n  action?: \"BUY\" | \"SELL\" | \"WAIT\" | \"SKIP\";\n  reason?: string;\n  price?: number;\n  profitPercent?: string;\n  profitUsd?: string;\n}\n\nexport interface TradeBuyAlert {\n  token: string;\n  tokenAddress: string;\n  amount: number;\n  trustScore: number;\n  riskLevel: \"LOW\" | \"MEDIUM\" | \"HIGH\";\n  marketData: MarketData;\n  timestamp: number;\n  signature?: string;\n  hash?: string;\n  explorerUrl?: string;\n  action?: \"BUY\" | \"SELL\" | \"WAIT\" | \"SKIP\";\n  reason?: string;\n  price?: number;\n  profitPercent?: string;\n  profitUsd?: string;\n}\n\n// Set up trade notification function\nexport const tweetTrade = async (\n  twitterService: TwitterService,\n  alert: TradeBuyAlert,\n) => {\n  if (twitterService) {\n    await twitterService.postTradeAlert({\n      ...alert,\n      timestamp: Date.now(),\n    });\n  }\n};\n\nexport function canTweet(tweetType: \"trade\" | \"market_search\" | \"shabbat\" | \"holiday\"): boolean {\n  const now = Date.now();\n  const hourKey = `tweets_${tweetType}_${Math.floor(now / 3600000)}`;\n\n  // Simple in-memory rate limiting\n  const tweetCounts = new Map<string, number>();\n  const currentCount = tweetCounts.get(hourKey) || 0;\n\n  if (currentCount >= MAX_TWEETS_PER_HOUR[tweetType]) {\n    elizaLogger.warn(`Tweet rate limit reached for ${tweetType}`);\n    return false;\n  }\n\n  tweetCounts.set(hourKey, currentCount + 1);\n  return true;\n}\n\ninterface TweetOptions {\n  skipRateLimit?: boolean;\n  type?: 'trade' | 'market_search' | 'shabbat' | 'holiday';\n}\n\nexport class TwitterService {\n  private client: any;\n  private config: z.infer<typeof TwitterConfigSchema>;\n\n  // Add public getter for config\n  public getConfig() {\n    return this.config;\n  }\n\n  constructor(client: any, config: z.infer<typeof TwitterConfigSchema>) {\n    this.client = client;\n    this.config = config;\n  }\n\n  async postTradeAlert(alert: TradeBuyAlert): Promise<boolean> {\n    try {\n      const tweetContent = this.formatBuyAlert(alert);\n\n      if (this.config.dryRun) {\n        elizaLogger.log(\n          \"Dry run mode - would have posted tweet:\",\n          tweetContent,\n        );\n        return true;\n      }\n\n      if (!canTweet(\"trade\")) {\n        elizaLogger.warn(\"Trade tweet rate limit reached\");\n        return false;\n      }\n\n      // Use the correct client structure\n      await this.client.post.client.twitterClient.sendTweet(tweetContent);\n      elizaLogger.log(\"Successfully posted trade alert to Twitter:\", {\n        content: tweetContent,\n      });\n\n      return true;\n    } catch (error) {\n      elizaLogger.error(\"Failed to post trade alert to Twitter:\", {\n        error: error instanceof Error ? error.message : String(error),\n        alert,\n      });\n      return false;\n    }\n  }\n\n  private formatBuyAlert(alert: TradeBuyAlert): string {\n    const priceChangePrefix = alert.marketData.priceChange24h >= 0 ? \"+\" : \"\";\n    const trustScoreEmoji =\n      alert.trustScore >= 0.8 ? \"🟢\" : alert.trustScore >= 0.5 ? \"🟡\" : \"🔴\";\n\n\n    // Don't include explorer URL if we don't have a valid signature/hash\n    const hasValidTxId = alert.hash || alert.signature;\n    const explorerUrl = hasValidTxId\n        ? `https://solscan.io/tx/${alert.signature}`\n      : null;\n\n    if (alert.action === \"SELL\") {\n      // Simplified SELL format\n      const actionEmoji =\n        Number(alert.profitPercent?.replace(\"%\", \"\")) >= 0\n          ? \"💰 PROFIT SELL\"\n          : \"🔴 LOSS SELL\";\n\n      const lines = [\n        `${actionEmoji} | ${alert.token}`,\n        `📊 P/L: ${alert.profitPercent}`,\n        `⚠️ Risk: ${alert.riskLevel}`,\n        `💲 Price: $${alert.price?.toFixed(6)}`,\n        `📈 24h: ${priceChangePrefix}${alert.marketData.priceChange24h.toFixed(1)}%`,\n        explorerUrl ? `🔍 ${explorerUrl}` : null,\n        `$${alert.token}`,\n      ];\n\n      return lines.filter(Boolean).join(\"\\n\");\n    } else {\n      // Simplified BUY format\n      const lines = [\n        `🟢 BUY | ${alert.token}`,\n        `🎯 Trust: ${trustScoreEmoji} ${(alert.trustScore * 100).toFixed(0)}%`,\n        `📈 24h: ${priceChangePrefix}${alert.marketData.priceChange24h.toFixed(1)}%`,\n        `⚠️ Risk: ${alert.riskLevel}`,\n        `💲 Price: $${alert.price?.toFixed(6)}`,\n        explorerUrl ? `🔍 ${explorerUrl}` : null,\n        `$${alert.token}`,\n      ];\n\n      return lines.filter(Boolean).join(\"\\n\");\n    }\n  }\n}","import { elizaLogger, IAgentRuntime } from \"@elizaos/core\";\nimport { Connection, Keypair, VersionedTransaction } from \"@solana/web3.js\";\nimport { decodeBase58 } from \"./utils\";\nimport { SAFETY_LIMITS } from \"./constants\";\n\n/**\n * Gets wallet keypair from runtime settings\n * @param runtime Agent runtime environment\n * @returns Solana keypair for transactions\n * @throws Error if private key is missing or invalid\n */\nexport function getWalletKeypair(runtime?: IAgentRuntime): Keypair {\n    // Check chain type from token address or configuration\n\n    const privateKeyString = runtime?.getSetting(\"WALLET_PRIVATE_KEY\");\n    if (!privateKeyString) {\n        throw new Error(\"No wallet private key configured\");\n    }\n\n    try {\n        const privateKeyBytes = decodeBase58(privateKeyString);\n        return Keypair.fromSecretKey(privateKeyBytes);\n    } catch (error) {\n        elizaLogger.error(\"Failed to create wallet keypair:\", error);\n        throw error;\n    }\n}\n\n/**\n * Gets current SOL balance for wallet\n * @param runtime Agent runtime environment\n * @returns Balance in SOL\n */\nexport async function getWalletBalance(\n    runtime: IAgentRuntime\n): Promise<number> {\n    try {\n        // Existing Solana balance logic\n        const walletKeypair = getWalletKeypair(runtime);\n        const walletPubKey = walletKeypair.publicKey;\n        const connection = new Connection(\n            runtime.getSetting(\"SOLANA_RPC_URL\") ||\n                \"https://api.mainnet-beta.solana.com\"\n        );\n\n        const balance = await connection.getBalance(walletPubKey);\n        const solBalance = balance / 1e9;\n\n        elizaLogger.log(\"Fetched Solana wallet balance:\", {\n            address: walletPubKey.toBase58(),\n            lamports: balance,\n            sol: solBalance,\n        });\n\n        return solBalance;\n    } catch (error) {\n        elizaLogger.error(\"Failed to get wallet balance:\", error);\n        return 0;\n    }\n}\n\n// Add helper function to get connection\nasync function getConnection(runtime: IAgentRuntime): Promise<Connection> {\n    return new Connection(\n        runtime.getSetting(\"SOLANA_RPC_URL\") || \"https://api.mainnet-beta.solana.com\"\n    );\n}\n\n// Add executeTrade function\nexport async function executeTrade(\n    runtime: IAgentRuntime,\n    params: {\n        tokenAddress: string;\n        amount: number;\n        slippage: number;\n        isSell?: boolean;\n        chain?: \"base\" | \"solana\";\n    },\n    retryCount = 0\n): Promise<any> {\n    // Existing Solana trade logic remains unchanged\n    try {\n        elizaLogger.log(\"Executing Solana trade with params:\", params);\n\n        const SOL_ADDRESS = \"So11111111111111111111111111111111111111112\";\n\n        if (!params.isSell && params.amount < SAFETY_LIMITS.MINIMUM_TRADE) {\n            elizaLogger.warn(\"Trade amount too small:\", {\n                amount: params.amount,\n                minimumRequired: SAFETY_LIMITS.MINIMUM_TRADE,\n            });\n            return {\n                success: false,\n                error: \"Trade amount too small\",\n                details: {\n                    amount: params.amount,\n                    minimumRequired: SAFETY_LIMITS.MINIMUM_TRADE,\n                },\n            };\n        }\n\n        const walletKeypair = getWalletKeypair(runtime);\n        const connection = await getConnection(runtime);\n\n        // Setup swap parameters\n        const inputTokenCA = params.isSell ? params.tokenAddress : SOL_ADDRESS;\n        const outputTokenCA = params.isSell ? SOL_ADDRESS : params.tokenAddress;\n        const swapAmount = Math.floor(params.amount * 1e9);\n\n        elizaLogger.log(\"Trade execution details:\", {\n            isSell: params.isSell,\n            inputToken: inputTokenCA,\n            outputToken: outputTokenCA,\n            amount: params.amount,\n            slippage: params.slippage,\n        });\n\n        // Get quote\n        const quoteResponse = await fetch(\n            `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}&outputMint=${outputTokenCA}&amount=${swapAmount}&slippageBps=${Math.floor(params.slippage * 10000)}`\n        );\n\n        if (!quoteResponse.ok) {\n            const error = await quoteResponse.text();\n            elizaLogger.warn(\"Quote request failed:\", {\n                status: quoteResponse.status,\n                error,\n            });\n            return {\n                success: false,\n                error: \"Failed to get quote\",\n                details: { status: quoteResponse.status, error },\n            };\n        }\n\n        const quoteData = await quoteResponse.json();\n        if (!quoteData || quoteData.error) {\n            elizaLogger.warn(\"Invalid quote data:\", quoteData);\n            return {\n                success: false,\n                error: \"Invalid quote data\",\n                details: quoteData,\n            };\n        }\n\n        elizaLogger.log(\"Quote received:\", quoteData);\n\n        // Get swap transaction\n        const swapResponse = await fetch(\"https://quote-api.jup.ag/v6/swap\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                quoteResponse: quoteData,\n                userPublicKey: walletKeypair.publicKey.toString(),\n                wrapAndUnwrapSol: true,\n                computeUnitPriceMicroLamports: 2000000,\n                dynamicComputeUnitLimit: true,\n            }),\n        });\n\n        const swapData = await swapResponse.json();\n        if (!swapData?.swapTransaction) {\n            throw new Error(\"No swap transaction returned\");\n        }\n\n        elizaLogger.log(\"Swap transaction received\");\n\n        // Deserialize transaction\n        const transactionBuf = Buffer.from(swapData.swapTransaction, \"base64\");\n        const tx = VersionedTransaction.deserialize(transactionBuf);\n\n        // Get fresh blockhash and sign transaction\n        const { blockhash, lastValidBlockHeight } =\n            await connection.getLatestBlockhash(\"finalized\");\n        tx.message.recentBlockhash = blockhash;\n        tx.sign([walletKeypair]);\n\n        // Send with confirmation using more lenient settings\n        const signature = await connection.sendTransaction(tx, {\n            skipPreflight: false,\n            maxRetries: 5,\n            preflightCommitment: \"processed\",\n        });\n\n        elizaLogger.log(\"Transaction sent:\", signature);\n\n        // Wait for confirmation with more lenient settings\n        const confirmation = await connection.confirmTransaction(\n            {\n                signature,\n                blockhash,\n                lastValidBlockHeight,\n            },\n            \"processed\"\n        ); // Use 'processed' instead of default 'finalized'\n\n        if (confirmation.value.err) {\n            throw new Error(`Transaction failed: ${confirmation.value.err}`);\n        }\n\n        // Add additional verification\n        const status = await connection.getSignatureStatus(signature);\n        if (status.value?.err) {\n            throw new Error(\n                `Transaction verification failed: ${status.value.err}`\n            );\n        }\n\n        elizaLogger.log(\"Solana trade executed successfully:\", {\n            signature,\n            explorer: `https://solscan.io/tx/${signature}`,\n        });\n\n        return {\n            success: true,\n            signature,\n            confirmation,\n            explorer: `https://solscan.io/tx/${signature}`,\n        };\n    } catch (error) {\n        // Handle blockhash errors with retry and longer timeout\n        if (\n            (error.message?.includes(\"Blockhash not found\") ||\n                error.message?.includes(\"block height exceeded\")) &&\n            retryCount < 3\n        ) {\n            elizaLogger.warn(\n                `Transaction error, retrying (${retryCount + 1}/3)...`\n            );\n            await new Promise((resolve) => setTimeout(resolve, 5000)); // Longer delay between retries\n            return executeTrade(runtime, params, retryCount + 1);\n        }\n\n        elizaLogger.error(\"Trade execution failed:\", {\n            error: error instanceof Error ? error.message : error,\n            stack: error instanceof Error ? error.stack : undefined,\n            params,\n            retryCount,\n        });\n\n        return {\n            success: false,\n            error: error.message || error,\n            params,\n            stack: error instanceof Error ? error.stack : undefined,\n        };\n    }\n}\n\nexport async function getChainWalletBalance(\n    runtime: IAgentRuntime,\n    tokenAddress: string\n): Promise<number> {\n    // Get Solana balance\n    return await getWalletBalance(runtime);\n}\n\n// Add this helper function at the top level\nexport async function simulateTransaction(\n    client: any,\n    tx: any\n): Promise<string> {\n    try {\n        const result = await client.call({\n            account: client.account,\n            to: tx.to,\n            data: tx.data,\n            value: tx.value,\n            gas: tx.gas,\n            gasPrice: tx.gasPrice,\n        });\n        return result;\n    } catch (error) {\n        return `Simulation failed: ${error.message}`;\n    }\n}\n","import { elizaLogger, IAgentRuntime, settings, State } from \"@elizaos/core\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { PROVIDER_CONFIG } from \"./config\";\nimport { ANALYSIS_HISTORY_EXPIRY } from \"./constants\";\n\nexport function isValidSolanaAddress(address: string): boolean {\n    try {\n        // Check if it's a valid Solana public key format\n        new PublicKey(address);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport async function fetchWithRetry(\n    url: string,\n    options: RequestInit = {},\n    chain: \"solana\" | \"base\" = \"solana\"\n): Promise<any> {\n    let lastError: Error;\n\n    for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\n        try {\n            elizaLogger.log(`Attempt ${i + 1} for ${url} with chain ${chain}`);\n\n            // Ensure headers are properly initialized\n            const headers = {\n                Accept: \"application/json\",\n                \"x-chain\": chain,\n                \"X-API-KEY\": settings.BIRDEYE_API_KEY || \"\",\n                ...options.headers,\n            };\n\n            const response = await fetch(url, {\n                ...options,\n                headers,\n            });\n\n            const responseText = await response.text();\n\n            if (!response.ok) {\n                throw new Error(\n                    `HTTP error! status: ${response.status}, message: ${responseText}`\n                );\n            }\n\n            try {\n                return JSON.parse(responseText);\n            } catch (parseError) {\n                throw new Error(\n                    `Failed to parse response: ${responseText}, error: ${parseError.message}`\n                );\n            }\n        } catch (error) {\n            elizaLogger.error(`Attempt ${i + 1} failed:`, {\n                error: error instanceof Error ? error.message : String(error),\n                url,\n                chain,\n                attempt: i + 1,\n            });\n            lastError =\n                error instanceof Error ? error : new Error(String(error));\n\n            if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\n                await new Promise((resolve) =>\n                    setTimeout(\n                        resolve,\n                        PROVIDER_CONFIG.RETRY_DELAY * Math.pow(2, i)\n                    )\n                );\n                continue;\n            }\n        }\n    }\n\n    throw lastError;\n}\n\nexport function decodeBase58(str: string): Uint8Array {\n    const ALPHABET =\n        \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    const ALPHABET_MAP = new Map(\n        ALPHABET.split(\"\").map((c, i) => [c, BigInt(i)])\n    );\n\n    let result = BigInt(0);\n    for (const char of str) {\n        const value = ALPHABET_MAP.get(char);\n        if (value === undefined) throw new Error(\"Invalid base58 character\");\n        result = result * BigInt(58) + value;\n    }\n\n    const bytes = [];\n    while (result > 0n) {\n        bytes.unshift(Number(result & 0xffn));\n        result = result >> 8n;\n    }\n\n    for (let i = 0; i < str.length && str[i] === \"1\"; i++) {\n        bytes.unshift(0);\n    }\n\n    return new Uint8Array(bytes);\n}\n\ninterface AnalyzedToken {\n    address: string;\n    timestamp: number;\n    symbol: string;\n}\n\nexport async function manageAnalyzedTokens(\n    runtime: IAgentRuntime,\n    state: any,\n    newToken?: AnalyzedToken\n): Promise<AnalyzedToken[]> {\n    try {\n        const historyKey = \"analyzed_tokens_history\";\n        let history: AnalyzedToken[] = [];\n\n        if (!state) {\n            state = {};\n        }\n\n        if (state[historyKey]) {\n            try {\n                const parsed = JSON.parse(state[historyKey]);\n                if (Array.isArray(parsed)) {\n                    history = parsed;\n                }\n            } catch (e) {\n                elizaLogger.warn(\"Failed to parse history, resetting\", e);\n            }\n        }\n\n        const now = Date.now();\n        history = history.filter(\n            (token) =>\n                token &&\n                token.timestamp &&\n                now - token.timestamp < ANALYSIS_HISTORY_EXPIRY\n        );\n\n        if (newToken) {\n            history.push(newToken);\n        }\n\n        // Update state with roomId\n        state = await runtime.updateRecentMessageState({\n            ...state,\n            userId: runtime.agentId,\n            agentId: runtime.agentId,\n            roomId: runtime.agentId,\n            content: {\n                ...state.content,\n                [historyKey]: JSON.stringify(history),\n            },\n        } as State);\n\n        return history;\n    } catch (error) {\n        elizaLogger.error(\"Failed to manage analyzed tokens history:\", {\n            error: error instanceof Error ? error.message : error,\n        });\n        return [];\n    }\n}\n","export const PROVIDER_CONFIG = {\n  BIRDEYE_API: \"https://public-api.birdeye.so\",\n  TOKEN_SECURITY_ENDPOINT: \"/defi/token_security?address=\",\n  TOKEN_METADATA_ENDPOINT: \"/defi/v3/token/meta-data/single?address=\",\n  MARKET_SEARCH_ENDPOINT: \"/defi/v3/token/trade-data/single?address=\",\n  TOKEN_PRICE_CHANGE_ENDPOINT:\n    \"/defi/v3/search?chain=solana&target=token&sort_by=price_change_24h_percent&sort_type=desc&verify_token=true&markets=Raydium&limit=20\",\n  TOKEN_VOLUME_24_CHANGE_ENDPOINT:\n    \"/defi/v3/search?chain=solana&target=token&sort_by=volume_24h_change_percent&sort_type=desc&verify_token=true&markets=Raydium&limit=20\",\n  TOKEN_BUY_24_CHANGE_ENDPOINT:\n    \"/defi/v3/search?chain=solana&target=token&sort_by=buy_24h_change_percent&sort_type=desc&verify_token=true&markets=Raydium&offset=0&limit=20\",\n\n  TOKEN_SECURITY_ENDPOINT_BASE: \"/defi/token_security?address=\",\n  TOKEN_METADATA_ENDPOINT_BASE: \"/defi/v3/token/meta-data/single?address=\",\n  MARKET_SEARCH_ENDPOINT_BASE: \"/defi/v3/token/trade-data/single?address=\",\n  TOKEN_PRICE_CHANGE_ENDPOINT_BASE:\n    \"/defi/v3/search?chain=base&target=token&sort_by=price_change_24h_percent&sort_type=desc&offset=0&limit=20\",\n  TOKEN_VOLUME_24_ENDPOINT_BASE:\n    \"/defi/v3/search?chain=base&target=token&sort_by=volume_24h_usd&sort_type=desc&offset=2&limit=20\",\n  TOKEN_BUY_24_ENDPOINT_BASE:\n    \"/defi/v3/search?chain=base&target=token&sort_by=buy_24h&sort_type=desc&offset=2&limit=20\",\n\n  MAX_RETRIES: 3,\n  RETRY_DELAY: 2000,\n};\n\n// Add configuration for enabled chains\nexport const CHAIN_CONFIG = {\n  SOLANA_ENABLED: false, // Can be controlled via settings\n  BASE_ENABLED: true, // Can be controlled via settings\n};\n\n// Add Base chain configuration near other export constants\nexport const BASE_CONFIG = {\n  RPC_URL: process.env.EVM_PROVIDER_URL || \"https://mainnet.base.org\",\n  ROUTER_ADDRESS: \"0x327Df1E6de05895d2ab08513aaDD9313Fe505d86\", // Base Uniswap V2 Router\n  WETH_ADDRESS: \"0x4200000000000000000000000000000000000006\", // Base WETH\n  CHAIN_ID: 8453,\n  // Add Aerodrome-specific addresses\n  AERODROME: {\n    WETH: \"0x4200000000000000000000000000000000000006\",\n    USDC: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    USDT: \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\",\n  },\n};\n\n// Add 0x API configuration near other export constants\nexport const ZEROEX_CONFIG = {\n  API_URL: \"https://api.0x.org\",\n  API_KEY: process.env.ZEROEX_API_KEY || \"\",\n  QUOTE_ENDPOINT: \"/swap/permit2/quote\",\n  PRICE_ENDPOINT: \"/swap/permit2/price\",\n  SUPPORTED_CHAINS: {\n    BASE: 8453,\n  },\n  HEADERS: {\n    \"Content-Type\": \"application/json\",\n    \"0x-api-key\": process.env.ZEROEX_API_KEY || \"\",\n    \"0x-version\": \"v2\",\n  },\n};\n"],"mappings":"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","names":["elizaLogger","settings","Connection","PublicKey","elizaLogger","elizaLogger","elizaLogger","elizaLogger","NodeCache","crypto","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","resolve","elizaLogger","PublicKey","NodeCache","elizaLogger","PublicKey","resolve","Connection","analyzeTradeAction","settings"]}