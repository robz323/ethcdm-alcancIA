{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { v4 } from \"uuid\";\n\nimport {\n    Account,\n    Actor,\n    GoalStatus,\n    type Goal,\n    type Memory,\n    type Relationship,\n    type UUID,\n    type IDatabaseCacheAdapter,\n    Participant,\n    elizaLogger,\n    getEmbeddingConfig,\n    DatabaseAdapter,\n    EmbeddingProvider,\n    RAGKnowledgeItem,\n} from \"@elizaos/core\";\nimport fs from \"fs\";\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\nimport {\n    PGlite,\n    PGliteOptions,\n    Results,\n    Transaction,\n} from \"@electric-sql/pglite\";\nimport { vector } from \"@electric-sql/pglite/vector\";\nimport { fuzzystrmatch } from \"@electric-sql/pglite/contrib/fuzzystrmatch\";\n\nconst __filename = fileURLToPath(import.meta.url); // get the resolved path to the file\nconst __dirname = path.dirname(__filename); // get the name of the directory\n\nexport class PGLiteDatabaseAdapter\n    extends DatabaseAdapter<PGlite>\n    implements IDatabaseCacheAdapter\n{\n    constructor(options: PGliteOptions) {\n        super();\n        this.db = new PGlite({\n            ...options,\n            // Add the vector and fuzzystrmatch extensions\n            extensions: {\n                ...(options.extensions ?? {}),\n                vector,\n                fuzzystrmatch,\n            },\n        });\n    }\n\n    async init() {\n        await this.db.waitReady;\n\n        await this.withTransaction(async (tx) => {\n            // Set application settings for embedding dimension\n            const embeddingConfig = getEmbeddingConfig();\n            if (embeddingConfig.provider === EmbeddingProvider.OpenAI) {\n                await tx.query(\"SET app.use_openai_embedding = 'true'\");\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\n            } else if (embeddingConfig.provider === EmbeddingProvider.Ollama) {\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\n                await tx.query(\"SET app.use_ollama_embedding = 'true'\");\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\n            } else if (embeddingConfig.provider === EmbeddingProvider.GaiaNet) {\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\n                await tx.query(\"SET app.use_gaianet_embedding = 'true'\");\n            } else {\n                await tx.query(\"SET app.use_openai_embedding = 'false'\");\n                await tx.query(\"SET app.use_ollama_embedding = 'false'\");\n                await tx.query(\"SET app.use_gaianet_embedding = 'false'\");\n            }\n\n            const schema = fs.readFileSync(\n                path.resolve(__dirname, \"../schema.sql\"),\n                \"utf8\"\n            );\n            await tx.exec(schema);\n        }, \"init\");\n    }\n\n    async close() {\n        await this.db.close();\n    }\n\n    private async withDatabase<T>(\n        operation: () => Promise<T>,\n        context: string\n    ): Promise<T> {\n        return this.withCircuitBreaker(async () => {\n            return operation();\n        }, context);\n    }\n\n    private async withTransaction<T>(\n        operation: (tx: Transaction) => Promise<T>,\n        context: string\n    ): Promise<T | undefined> {\n        return this.withCircuitBreaker(async () => {\n            return this.db.transaction(operation);\n        }, context);\n    }\n\n    async query<R>(\n        queryTextOrConfig: string,\n        values?: unknown[]\n    ): Promise<Results<R>> {\n        return this.withDatabase(async () => {\n            return await this.db.query<R>(queryTextOrConfig, values);\n        }, \"query\");\n    }\n\n    async getRoom(roomId: UUID): Promise<UUID | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<{ id: UUID }>(\n                \"SELECT id FROM rooms WHERE id = $1\",\n                [roomId]\n            );\n            return rows.length > 0 ? rows[0].id : null;\n        }, \"getRoom\");\n    }\n\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<Participant>(\n                `SELECT id, \"userId\", \"roomId\", \"last_message_read\"\n                FROM participants\n                WHERE \"userId\" = $1`,\n                [userId]\n            );\n            return rows;\n        }, \"getParticipantsForAccount\");\n    }\n\n    async getParticipantUserState(\n        roomId: UUID,\n        userId: UUID\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<{\n                userState: \"FOLLOWED\" | \"MUTED\";\n            }>(\n                `SELECT \"userState\" FROM participants WHERE \"roomId\" = $1 AND \"userId\" = $2`,\n                [roomId, userId]\n            );\n            return rows.length > 0 ? rows[0].userState : null;\n        }, \"getParticipantUserState\");\n    }\n\n    async getMemoriesByRoomIds(params: {\n        roomIds: UUID[];\n        agentId?: UUID;\n        tableName: string;\n    }): Promise<Memory[]> {\n        return this.withDatabase(async () => {\n            if (params.roomIds.length === 0) return [];\n            const placeholders = params.roomIds\n                .map((_, i) => `$${i + 2}`)\n                .join(\", \");\n\n            let query = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" IN (${placeholders})`;\n            let queryParams = [params.tableName, ...params.roomIds];\n\n            if (params.agentId) {\n                query += ` AND \"agentId\" = $${params.roomIds.length + 2}`;\n                queryParams = [...queryParams, params.agentId];\n            }\n\n            const { rows } = await this.query<Memory>(query, queryParams);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n            }));\n        }, \"getMemoriesByRoomIds\");\n    }\n\n    async setParticipantUserState(\n        roomId: UUID,\n        userId: UUID,\n        state: \"FOLLOWED\" | \"MUTED\" | null\n    ): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(\n                `UPDATE participants SET \"userState\" = $1 WHERE \"roomId\" = $2 AND \"userId\" = $3`,\n                [state, roomId, userId]\n            );\n        }, \"setParticipantUserState\");\n    }\n\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<{ userId: UUID }>(\n                'SELECT \"userId\" FROM participants WHERE \"roomId\" = $1',\n                [roomId]\n            );\n            return rows.map((row) => row.userId);\n        }, \"getParticipantsForRoom\");\n    }\n\n    async getAccountById(userId: UUID): Promise<Account | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<Account>(\n                \"SELECT * FROM accounts WHERE id = $1\",\n                [userId]\n            );\n            if (rows.length === 0) {\n                elizaLogger.debug(\"Account not found:\", { userId });\n                return null;\n            }\n\n            const account = rows[0];\n            // elizaLogger.debug(\"Account retrieved:\", {\n            //     userId,\n            //     hasDetails: !!account.details,\n            // });\n\n            return {\n                ...account,\n                details:\n                    typeof account.details === \"string\"\n                        ? JSON.parse(account.details)\n                        : account.details,\n            };\n        }, \"getAccountById\");\n    }\n\n    async createAccount(account: Account): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                const accountId = account.id ?? v4();\n                await this.query(\n                    `INSERT INTO accounts (id, name, username, email, \"avatarUrl\", details)\n                    VALUES ($1, $2, $3, $4, $5, $6)`,\n                    [\n                        accountId,\n                        account.name,\n                        account.username || \"\",\n                        account.email || \"\",\n                        account.avatarUrl || \"\",\n                        JSON.stringify(account.details),\n                    ]\n                );\n                elizaLogger.debug(\"Account created successfully:\", {\n                    accountId,\n                });\n                return true;\n            } catch (error) {\n                elizaLogger.error(\"Error creating account:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    accountId: account.id,\n                    name: account.name, // Only log non-sensitive fields\n                });\n                return false; // Return false instead of throwing to maintain existing behavior\n            }\n        }, \"createAccount\");\n    }\n\n    async getActorById(params: { roomId: UUID }): Promise<Actor[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<Actor>(\n                `SELECT a.id, a.name, a.username, a.details\n                FROM participants p\n                LEFT JOIN accounts a ON p.\"userId\" = a.id\n                WHERE p.\"roomId\" = $1`,\n                [params.roomId]\n            );\n\n            elizaLogger.debug(\"Retrieved actors:\", {\n                roomId: params.roomId,\n                actorCount: rows.length,\n            });\n\n            return rows.map((row) => {\n                try {\n                    return {\n                        ...row,\n                        details:\n                            typeof row.details === \"string\"\n                                ? JSON.parse(row.details)\n                                : row.details,\n                    };\n                } catch (error) {\n                    elizaLogger.warn(\"Failed to parse actor details:\", {\n                        actorId: row.id,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                    return {\n                        ...row,\n                        details: {}, // Provide default empty details on parse error\n                    };\n                }\n            });\n        }, \"getActorById\").catch((error) => {\n            elizaLogger.error(\"Failed to get actors:\", {\n                roomId: params.roomId,\n                error: error.message,\n            });\n            throw error; // Re-throw to let caller handle database errors\n        });\n    }\n\n    async getMemoryById(id: UUID): Promise<Memory | null> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<Memory>(\n                \"SELECT * FROM memories WHERE id = $1\",\n                [id]\n            );\n            if (rows.length === 0) return null;\n\n            return {\n                ...rows[0],\n                content:\n                    typeof rows[0].content === \"string\"\n                        ? JSON.parse(rows[0].content)\n                        : rows[0].content,\n            };\n        }, \"getMemoryById\");\n    }\n\n    async createMemory(memory: Memory, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            elizaLogger.debug(\"PostgresAdapter createMemory:\", {\n                memoryId: memory.id,\n                embeddingLength: memory.embedding?.length,\n                contentLength: memory.content?.text?.length,\n            });\n\n            let isUnique = true;\n            if (memory.embedding) {\n                const similarMemories = await this.searchMemoriesByEmbedding(\n                    memory.embedding,\n                    {\n                        tableName,\n                        roomId: memory.roomId,\n                        match_threshold: 0.95,\n                        count: 1,\n                    }\n                );\n                isUnique = similarMemories.length === 0;\n            }\n\n            await this.query(\n                `INSERT INTO memories (\n                    id, type, content, embedding, \"userId\", \"roomId\", \"agentId\", \"unique\", \"createdAt\"\n                ) VALUES ($1, $2, $3, $4, $5::uuid, $6::uuid, $7::uuid, $8, to_timestamp($9/1000.0))`,\n                [\n                    memory.id ?? v4(),\n                    tableName,\n                    JSON.stringify(memory.content),\n                    memory.embedding ? `[${memory.embedding.join(\",\")}]` : null,\n                    memory.userId,\n                    memory.roomId,\n                    memory.agentId,\n                    memory.unique ?? isUnique,\n                    Date.now(),\n                ]\n            );\n        }, \"createMemory\");\n    }\n\n    async searchMemories(params: {\n        tableName: string;\n        agentId: UUID;\n        roomId: UUID;\n        embedding: number[];\n        match_threshold: number;\n        match_count: number;\n        unique: boolean;\n    }): Promise<Memory[]> {\n        return await this.searchMemoriesByEmbedding(params.embedding, {\n            match_threshold: params.match_threshold,\n            count: params.match_count,\n            agentId: params.agentId,\n            roomId: params.roomId,\n            unique: params.unique,\n            tableName: params.tableName,\n        });\n    }\n\n    async getMemories(params: {\n        roomId: UUID;\n        count?: number;\n        unique?: boolean;\n        tableName: string;\n        agentId?: UUID;\n        start?: number;\n        end?: number;\n    }): Promise<Memory[]> {\n        // Parameter validation\n        if (!params.tableName) throw new Error(\"tableName is required\");\n        if (!params.roomId) throw new Error(\"roomId is required\");\n\n        return this.withDatabase(async () => {\n            // Build query\n            let sql = `SELECT * FROM memories WHERE type = $1 AND \"roomId\" = $2`;\n            const values: unknown[] = [params.tableName, params.roomId];\n            let paramCount = 2;\n\n            // Add time range filters\n            if (params.start) {\n                paramCount++;\n                sql += ` AND \"createdAt\" >= to_timestamp($${paramCount})`;\n                values.push(params.start / 1000);\n            }\n\n            if (params.end) {\n                paramCount++;\n                sql += ` AND \"createdAt\" <= to_timestamp($${paramCount})`;\n                values.push(params.end / 1000);\n            }\n\n            // Add other filters\n            if (params.unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            if (params.agentId) {\n                paramCount++;\n                sql += ` AND \"agentId\" = $${paramCount}`;\n                values.push(params.agentId);\n            }\n\n            // Add ordering and limit\n            sql += ' ORDER BY \"createdAt\" DESC';\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            elizaLogger.debug(\"Fetching memories:\", {\n                roomId: params.roomId,\n                tableName: params.tableName,\n                unique: params.unique,\n                agentId: params.agentId,\n                timeRange:\n                    params.start || params.end\n                        ? {\n                              start: params.start\n                                  ? new Date(params.start).toISOString()\n                                  : undefined,\n                              end: params.end\n                                  ? new Date(params.end).toISOString()\n                                  : undefined,\n                          }\n                        : undefined,\n                limit: params.count,\n            });\n\n            const { rows } = await this.query<Memory>(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n            }));\n        }, \"getMemories\");\n    }\n\n    async getGoals(params: {\n        roomId: UUID;\n        userId?: UUID | null;\n        onlyInProgress?: boolean;\n        count?: number;\n    }): Promise<Goal[]> {\n        return this.withDatabase(async () => {\n            let sql = `SELECT * FROM goals WHERE \"roomId\" = $1`;\n            const values: unknown[] = [params.roomId];\n            let paramCount = 1;\n\n            if (params.userId) {\n                paramCount++;\n                sql += ` AND \"userId\" = $${paramCount}`;\n                values.push(params.userId);\n            }\n\n            if (params.onlyInProgress) {\n                sql += \" AND status = 'IN_PROGRESS'\";\n            }\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            const { rows } = await this.query<Goal>(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                objectives:\n                    typeof row.objectives === \"string\"\n                        ? JSON.parse(row.objectives)\n                        : row.objectives,\n            }));\n        }, \"getGoals\");\n    }\n\n    async updateGoal(goal: Goal): Promise<void> {\n        return this.withDatabase(async () => {\n            try {\n                await this.query(\n                    `UPDATE goals SET name = $1, status = $2, objectives = $3 WHERE id = $4`,\n                    [\n                        goal.name,\n                        goal.status,\n                        JSON.stringify(goal.objectives),\n                        goal.id,\n                    ]\n                );\n            } catch (error) {\n                elizaLogger.error(\"Failed to update goal:\", {\n                    goalId: goal.id,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    status: goal.status,\n                });\n                throw error;\n            }\n        }, \"updateGoal\");\n    }\n\n    async createGoal(goal: Goal): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(\n                `INSERT INTO goals (id, \"roomId\", \"userId\", name, status, objectives)\n                VALUES ($1, $2, $3, $4, $5, $6)`,\n                [\n                    goal.id ?? v4(),\n                    goal.roomId,\n                    goal.userId,\n                    goal.name,\n                    goal.status,\n                    JSON.stringify(goal.objectives),\n                ]\n            );\n        }, \"createGoal\");\n    }\n\n    async removeGoal(goalId: UUID): Promise<void> {\n        if (!goalId) throw new Error(\"Goal ID is required\");\n\n        return this.withDatabase(async () => {\n            try {\n                const result = await this.query(\n                    \"DELETE FROM goals WHERE id = $1 RETURNING id\",\n                    [goalId]\n                );\n\n                elizaLogger.debug(\"Goal removal attempt:\", {\n                    goalId,\n                    removed: result?.affectedRows ?? 0 > 0,\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to remove goal:\", {\n                    goalId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"removeGoal\");\n    }\n\n    async createRoom(roomId?: UUID): Promise<UUID> {\n        return this.withDatabase(async () => {\n            const newRoomId = roomId || v4();\n            await this.query(\"INSERT INTO rooms (id) VALUES ($1)\", [newRoomId]);\n            return newRoomId as UUID;\n        }, \"createRoom\");\n    }\n\n    async removeRoom(roomId: UUID): Promise<void> {\n        if (!roomId) throw new Error(\"Room ID is required\");\n\n        return this.withTransaction(async (tx) => {\n            try {\n                // First check if room exists\n                const checkResult = await tx.query(\n                    \"SELECT id FROM rooms WHERE id = $1\",\n                    [roomId]\n                );\n\n                if (checkResult.rows.length === 0) {\n                    elizaLogger.warn(\"No room found to remove:\", {\n                        roomId,\n                    });\n                    throw new Error(`Room not found: ${roomId}`);\n                }\n\n                // Remove related data first (if not using CASCADE)\n                await tx.query('DELETE FROM memories WHERE \"roomId\" = $1', [\n                    roomId,\n                ]);\n                await tx.query('DELETE FROM participants WHERE \"roomId\" = $1', [\n                    roomId,\n                ]);\n                await tx.query('DELETE FROM goals WHERE \"roomId\" = $1', [\n                    roomId,\n                ]);\n\n                // Finally remove the room\n                const result = await tx.query(\n                    \"DELETE FROM rooms WHERE id = $1 RETURNING id\",\n                    [roomId]\n                );\n\n                elizaLogger.debug(\n                    \"Room and related data removed successfully:\",\n                    {\n                        roomId,\n                        removed: result?.affectedRows ?? 0 > 0,\n                    }\n                );\n            } catch (error) {\n                elizaLogger.error(\"Failed to remove room:\", {\n                    roomId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"removeRoom\");\n    }\n\n    async createRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<boolean> {\n        // Input validation\n        if (!params.userA || !params.userB) {\n            throw new Error(\"userA and userB are required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const relationshipId = v4();\n                await this.query(\n                    `INSERT INTO relationships (id, \"userA\", \"userB\", \"userId\")\n                    VALUES ($1, $2, $3, $4)\n                    RETURNING id`,\n                    [relationshipId, params.userA, params.userB, params.userA]\n                );\n\n                elizaLogger.debug(\"Relationship created successfully:\", {\n                    relationshipId,\n                    userA: params.userA,\n                    userB: params.userB,\n                });\n\n                return true;\n            } catch (error) {\n                // Check for unique constraint violation or other specific errors\n                if ((error as { code?: string }).code === \"23505\") {\n                    // Unique violation\n                    elizaLogger.warn(\"Relationship already exists:\", {\n                        userA: params.userA,\n                        userB: params.userB,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                } else {\n                    elizaLogger.error(\"Failed to create relationship:\", {\n                        userA: params.userA,\n                        userB: params.userB,\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                    });\n                }\n                return false;\n            }\n        }, \"createRelationship\");\n    }\n\n    async getRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<Relationship | null> {\n        if (!params.userA || !params.userB) {\n            throw new Error(\"userA and userB are required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const { rows } = await this.query<Relationship>(\n                    `SELECT * FROM relationships\n                    WHERE (\"userA\" = $1 AND \"userB\" = $2)\n                    OR (\"userA\" = $2 AND \"userB\" = $1)`,\n                    [params.userA, params.userB]\n                );\n\n                if (rows.length > 0) {\n                    elizaLogger.debug(\"Relationship found:\", {\n                        relationshipId: rows[0].id,\n                        userA: params.userA,\n                        userB: params.userB,\n                    });\n                    return rows[0];\n                }\n\n                elizaLogger.debug(\"No relationship found between users:\", {\n                    userA: params.userA,\n                    userB: params.userB,\n                });\n                return null;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching relationship:\", {\n                    userA: params.userA,\n                    userB: params.userB,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"getRelationship\");\n    }\n\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\n        if (!params.userId) {\n            throw new Error(\"userId is required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const { rows } = await this.query<Relationship>(\n                    `SELECT * FROM relationships\n                    WHERE \"userA\" = $1 OR \"userB\" = $1\n                    ORDER BY \"createdAt\" DESC`, // Add ordering if you have this field\n                    [params.userId]\n                );\n\n                elizaLogger.debug(\"Retrieved relationships:\", {\n                    userId: params.userId,\n                    count: rows.length,\n                });\n\n                return rows;\n            } catch (error) {\n                elizaLogger.error(\"Failed to fetch relationships:\", {\n                    userId: params.userId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"getRelationships\");\n    }\n\n    async getCachedEmbeddings(opts: {\n        query_table_name: string;\n        query_threshold: number;\n        query_input: string;\n        query_field_name: string;\n        query_field_sub_name: string;\n        query_match_count: number;\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]> {\n        // Input validation\n        if (!opts.query_table_name)\n            throw new Error(\"query_table_name is required\");\n        if (!opts.query_input) throw new Error(\"query_input is required\");\n        if (!opts.query_field_name)\n            throw new Error(\"query_field_name is required\");\n        if (!opts.query_field_sub_name)\n            throw new Error(\"query_field_sub_name is required\");\n        if (opts.query_match_count <= 0)\n            throw new Error(\"query_match_count must be positive\");\n\n        return this.withDatabase(async () => {\n            try {\n                elizaLogger.debug(\"Fetching cached embeddings:\", {\n                    tableName: opts.query_table_name,\n                    fieldName: opts.query_field_name,\n                    subFieldName: opts.query_field_sub_name,\n                    matchCount: opts.query_match_count,\n                    inputLength: opts.query_input.length,\n                });\n\n                const sql = `\n                    WITH content_text AS (\n                        SELECT\n                            embedding,\n                            COALESCE(\n                                content->$2->>$3,\n                                ''\n                            ) as content_text\n                        FROM memories\n                        WHERE type = $4\n                        AND content->$2->>$3 IS NOT NULL\n                    )\n                    SELECT\n                        embedding,\n                        levenshtein(\n                            $1,\n                            content_text\n                        ) as levenshtein_score\n                    FROM content_text\n                    WHERE levenshtein(\n                        $1,\n                        content_text\n                    ) <= $6  -- Add threshold check\n                    ORDER BY levenshtein_score\n                    LIMIT $5\n                `;\n\n                const { rows } = await this.query<{\n                    embedding: number[];\n                    levenshtein_score: number;\n                }>(sql, [\n                    opts.query_input,\n                    opts.query_field_name,\n                    opts.query_field_sub_name,\n                    opts.query_table_name,\n                    opts.query_match_count,\n                    opts.query_threshold,\n                ]);\n\n                elizaLogger.debug(\"Retrieved cached embeddings:\", {\n                    count: rows.length,\n                    tableName: opts.query_table_name,\n                    matchCount: opts.query_match_count,\n                });\n\n                return rows\n                    .map(\n                        (\n                            row\n                        ): {\n                            embedding: number[];\n                            levenshtein_score: number;\n                        } | null => {\n                            if (!Array.isArray(row.embedding)) return null;\n                            return {\n                                embedding: row.embedding,\n                                levenshtein_score: Number(\n                                    row.levenshtein_score\n                                ),\n                            };\n                        }\n                    )\n                    .filter(\n                        (\n                            row\n                        ): row is {\n                            embedding: number[];\n                            levenshtein_score: number;\n                        } => row !== null\n                    );\n            } catch (error) {\n                elizaLogger.error(\"Error in getCachedEmbeddings:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    tableName: opts.query_table_name,\n                    fieldName: opts.query_field_name,\n                });\n                throw error;\n            }\n        }, \"getCachedEmbeddings\");\n    }\n\n    async log(params: {\n        body: { [key: string]: unknown };\n        userId: UUID;\n        roomId: UUID;\n        type: string;\n    }): Promise<void> {\n        // Input validation\n        if (!params.userId) throw new Error(\"userId is required\");\n        if (!params.roomId) throw new Error(\"roomId is required\");\n        if (!params.type) throw new Error(\"type is required\");\n        if (!params.body || typeof params.body !== \"object\") {\n            throw new Error(\"body must be a valid object\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const logId = v4(); // Generate ID for tracking\n                await this.query(\n                    `INSERT INTO logs (\n                        id,\n                        body,\n                        \"userId\",\n                        \"roomId\",\n                        type,\n                        \"createdAt\"\n                    ) VALUES ($1, $2, $3, $4, $5, NOW())\n                    RETURNING id`,\n                    [\n                        logId,\n                        JSON.stringify(params.body), // Ensure body is stringified\n                        params.userId,\n                        params.roomId,\n                        params.type,\n                    ]\n                );\n\n                elizaLogger.debug(\"Log entry created:\", {\n                    logId,\n                    type: params.type,\n                    roomId: params.roomId,\n                    userId: params.userId,\n                    bodyKeys: Object.keys(params.body),\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to create log entry:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    type: params.type,\n                    roomId: params.roomId,\n                    userId: params.userId,\n                });\n                throw error;\n            }\n        }, \"log\");\n    }\n\n    async searchMemoriesByEmbedding(\n        embedding: number[],\n        params: {\n            match_threshold?: number;\n            count?: number;\n            agentId?: UUID;\n            roomId?: UUID;\n            unique?: boolean;\n            tableName: string;\n        }\n    ): Promise<Memory[]> {\n        return this.withDatabase(async () => {\n            elizaLogger.debug(\"Incoming vector:\", {\n                length: embedding.length,\n                sample: embedding.slice(0, 5),\n                isArray: Array.isArray(embedding),\n                allNumbers: embedding.every((n) => typeof n === \"number\"),\n            });\n\n            // Validate embedding dimension\n            if (embedding.length !== getEmbeddingConfig().dimensions) {\n                throw new Error(\n                    `Invalid embedding dimension: expected ${getEmbeddingConfig().dimensions}, got ${embedding.length}`\n                );\n            }\n\n            // Ensure vector is properly formatted\n            const cleanVector = embedding.map((n) => {\n                if (!Number.isFinite(n)) return 0;\n                // Limit precision to avoid floating point issues\n                return Number(n.toFixed(6));\n            });\n\n            // Format for Postgres pgvector\n            const vectorStr = `[${cleanVector.join(\",\")}]`;\n\n            elizaLogger.debug(\"Vector debug:\", {\n                originalLength: embedding.length,\n                cleanLength: cleanVector.length,\n                sampleStr: vectorStr.slice(0, 100),\n            });\n\n            let sql = `\n                SELECT *,\n                1 - (embedding <-> $1::vector(${getEmbeddingConfig().dimensions})) as similarity\n                FROM memories\n                WHERE type = $2\n            `;\n\n            const values: unknown[] = [vectorStr, params.tableName];\n\n            // Log the query for debugging\n            elizaLogger.debug(\"Query debug:\", {\n                sql: sql.slice(0, 200),\n                paramTypes: values.map((v) => typeof v),\n                vectorStrLength: vectorStr.length,\n            });\n\n            let paramCount = 2;\n\n            if (params.unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            if (params.agentId) {\n                paramCount++;\n                sql += ` AND \"agentId\" = $${paramCount}`;\n                values.push(params.agentId);\n            }\n\n            if (params.roomId) {\n                paramCount++;\n                sql += ` AND \"roomId\" = $${paramCount}::uuid`;\n                values.push(params.roomId);\n            }\n\n            if (params.match_threshold) {\n                paramCount++;\n                sql += ` AND 1 - (embedding <-> $1::vector) >= $${paramCount}`;\n                values.push(params.match_threshold);\n            }\n\n            sql += ` ORDER BY embedding <-> $1::vector`;\n\n            if (params.count) {\n                paramCount++;\n                sql += ` LIMIT $${paramCount}`;\n                values.push(params.count);\n            }\n\n            const { rows } = await this.query<Memory>(sql, values);\n            return rows.map((row) => ({\n                ...row,\n                content:\n                    typeof row.content === \"string\"\n                        ? JSON.parse(row.content)\n                        : row.content,\n                similarity: row.similarity,\n            }));\n        }, \"searchMemoriesByEmbedding\");\n    }\n\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                await this.query(\n                    `INSERT INTO participants (id, \"userId\", \"roomId\")\n                    VALUES ($1, $2, $3)`,\n                    [v4(), userId, roomId]\n                );\n                return true;\n            } catch (error) {\n                console.log(\"Error adding participant\", error);\n                return false;\n            }\n        }, \"addParticpant\");\n    }\n\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        return this.withDatabase(async () => {\n            try {\n                await this.query(\n                    `DELETE FROM participants WHERE \"userId\" = $1 AND \"roomId\" = $2`,\n                    [userId, roomId]\n                );\n                return true;\n            } catch (error) {\n                console.log(\"Error removing participant\", error);\n                return false;\n            }\n        }, \"removeParticipant\");\n    }\n\n    async updateGoalStatus(params: {\n        goalId: UUID;\n        status: GoalStatus;\n    }): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(\"UPDATE goals SET status = $1 WHERE id = $2\", [\n                params.status,\n                params.goalId,\n            ]);\n        }, \"updateGoalStatus\");\n    }\n\n    async removeMemory(memoryId: UUID, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(\n                \"DELETE FROM memories WHERE type = $1 AND id = $2\",\n                [tableName, memoryId]\n            );\n        }, \"removeMemory\");\n    }\n\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(\n                `DELETE FROM memories WHERE type = $1 AND \"roomId\" = $2`,\n                [tableName, roomId]\n            );\n        }, \"removeAllMemories\");\n    }\n\n    async countMemories(\n        roomId: UUID,\n        unique = true,\n        tableName = \"\"\n    ): Promise<number> {\n        if (!tableName) throw new Error(\"tableName is required\");\n\n        return this.withDatabase(async () => {\n            let sql = `SELECT COUNT(*) as count FROM memories WHERE type = $1 AND \"roomId\" = $2`;\n            if (unique) {\n                sql += ` AND \"unique\" = true`;\n            }\n\n            const { rows } = await this.query<{ count: number }>(sql, [\n                tableName,\n                roomId,\n            ]);\n            return rows[0].count;\n        }, \"countMemories\");\n    }\n\n    async removeAllGoals(roomId: UUID): Promise<void> {\n        return this.withDatabase(async () => {\n            await this.query(`DELETE FROM goals WHERE \"roomId\" = $1`, [roomId]);\n        }, \"removeAllGoals\");\n    }\n\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const { rows } = await this.query<{ roomId: UUID }>(\n                `SELECT \"roomId\" FROM participants WHERE \"userId\" = $1`,\n                [userId]\n            );\n            return rows.map((row) => row.roomId);\n        }, \"getRoomsForParticipant\");\n    }\n\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\n        return this.withDatabase(async () => {\n            const placeholders = userIds.map((_, i) => `$${i + 1}`).join(\", \");\n            const { rows } = await this.query<{ roomId: UUID }>(\n                `SELECT DISTINCT \"roomId\" FROM participants WHERE \"userId\" IN (${placeholders})`,\n                userIds\n            );\n            return rows.map((row) => row.roomId);\n        }, \"getRoomsForParticipants\");\n    }\n\n    async getActorDetails(params: { roomId: string }): Promise<Actor[]> {\n        if (!params.roomId) {\n            throw new Error(\"roomId is required\");\n        }\n\n        return this.withDatabase(async () => {\n            try {\n                const sql = `\n                    SELECT\n                        a.id,\n                        a.name,\n                        a.username,\n                        a.\"avatarUrl\",\n                        COALESCE(a.details::jsonb, '{}'::jsonb) as details\n                    FROM participants p\n                    LEFT JOIN accounts a ON p.\"userId\" = a.id\n                    WHERE p.\"roomId\" = $1\n                    ORDER BY a.name\n                `;\n\n                const result = await this.query<Actor>(sql, [params.roomId]);\n\n                elizaLogger.debug(\"Retrieved actor details:\", {\n                    roomId: params.roomId,\n                    actorCount: result.rows.length,\n                });\n\n                return result.rows.map((row) => {\n                    try {\n                        return {\n                            ...row,\n                            details:\n                                typeof row.details === \"string\"\n                                    ? JSON.parse(row.details)\n                                    : row.details,\n                        };\n                    } catch (parseError) {\n                        elizaLogger.warn(\"Failed to parse actor details:\", {\n                            actorId: row.id,\n                            error:\n                                parseError instanceof Error\n                                    ? parseError.message\n                                    : String(parseError),\n                        });\n                        return {\n                            ...row,\n                            details: {}, // Fallback to empty object if parsing fails\n                        };\n                    }\n                });\n            } catch (error) {\n                elizaLogger.error(\"Failed to fetch actor details:\", {\n                    roomId: params.roomId,\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw new Error(\n                    `Failed to fetch actor details: ${error instanceof Error ? error.message : String(error)}`\n                );\n            }\n        }, \"getActorDetails\");\n    }\n\n    async getCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<string | undefined> {\n        return this.withDatabase(async () => {\n            try {\n                const sql = `SELECT \"value\"::TEXT FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`;\n                const { rows } = await this.query<{ value: string }>(sql, [\n                    params.key,\n                    params.agentId,\n                ]);\n                return rows[0]?.value ?? undefined;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching cache\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    key: params.key,\n                    agentId: params.agentId,\n                });\n                return undefined;\n            }\n        }, \"getCache\");\n    }\n\n    async setCache(params: {\n        key: string;\n        agentId: UUID;\n        value: string;\n    }): Promise<boolean> {\n        return (\n            (await this.withTransaction(async (tx) => {\n                try {\n                    await tx.query(\n                        `INSERT INTO cache (\"key\", \"agentId\", \"value\", \"createdAt\")\n                                 VALUES ($1, $2, $3, CURRENT_TIMESTAMP)\n                                 ON CONFLICT (\"key\", \"agentId\")\n                                 DO UPDATE SET \"value\" = EXCLUDED.value, \"createdAt\" = CURRENT_TIMESTAMP`,\n                        [params.key, params.agentId, params.value]\n                    );\n                    return true;\n                } catch (error) {\n                    await tx.rollback();\n                    elizaLogger.error(\"Error setting cache\", {\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        key: params.key,\n                        agentId: params.agentId,\n                    });\n                    return false;\n                }\n            }, \"setCache\")) ?? false\n        );\n    }\n\n    async deleteCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<boolean> {\n        return (\n            (await this.withTransaction(async (tx) => {\n                try {\n                    await tx.query(\n                        `DELETE FROM cache WHERE \"key\" = $1 AND \"agentId\" = $2`,\n                        [params.key, params.agentId]\n                    );\n                    return true;\n                } catch (error) {\n                    tx.rollback();\n                    elizaLogger.error(\"Error deleting cache\", {\n                        error:\n                            error instanceof Error\n                                ? error.message\n                                : String(error),\n                        key: params.key,\n                        agentId: params.agentId,\n                    });\n                    return false;\n                }\n            }, \"deleteCache\")) ?? false\n        );\n    }\n\n    async getKnowledge(params: {\n        id?: UUID;\n        agentId: UUID;\n        limit?: number;\n        query?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        return this.withDatabase(async () => {\n            try {\n                let sql = `SELECT * FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)`;\n                const queryParams: any[] = [params.agentId];\n                let paramCount = 1;\n\n                if (params.id) {\n                    paramCount++;\n                    sql += ` AND id = $${paramCount}`;\n                    queryParams.push(params.id);\n                }\n\n                if (params.limit) {\n                    paramCount++;\n                    sql += ` LIMIT $${paramCount}`;\n                    queryParams.push(params.limit);\n                }\n\n                const { rows } = await this.query<RAGKnowledgeItem>(\n                    sql,\n                    queryParams\n                );\n\n                return rows.map((row) => ({\n                    id: row.id,\n                    agentId: row.agentId,\n                    content:\n                        typeof row.content === \"string\"\n                            ? JSON.parse(row.content)\n                            : row.content,\n                    embedding: row.embedding\n                        ? new Float32Array(row.embedding)\n                        : undefined,\n                    createdAt: row.createdAt\n                        ? new Date(row.createdAt).getTime()\n                        : undefined,\n                }));\n            } catch (error) {\n                elizaLogger.error(\"Error getting knowledge\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    id: params.id,\n                    agentId: params.agentId,\n                });\n                throw new Error(\n                    `Failed to getting knowledge: ${error instanceof Error ? error.message : String(error)}`\n                );\n            }\n        }, \"getKnowledge\");\n    }\n\n    async searchKnowledge(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        match_count: number;\n        searchText?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        return this.withDatabase(async () => {\n            interface KnowledgeSearchRow {\n                id: UUID;\n                agentId: UUID;\n                content: string;\n                embedding: Buffer | null;\n                createdAt: string | number;\n                vector_score: number;\n                keyword_score: number;\n                combined_score: number;\n            }\n            try {\n                const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\n                const cachedResult = await this.getCache({\n                    key: cacheKey,\n                    agentId: params.agentId,\n                });\n\n                if (cachedResult) {\n                    return JSON.parse(cachedResult);\n                }\n\n                const vectorStr = `[${Array.from(params.embedding).join(\",\")}]`;\n\n                const sql = `\n                WITH vector_scores AS (\n                    SELECT id,\n                        1 - (embedding <-> $1::vector) as vector_score\n                    FROM knowledge\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\n                    AND embedding IS NOT NULL\n                ),\n                keyword_matches AS (\n                    SELECT id,\n                    CASE\n                        WHEN content->>'text' ILIKE $3 THEN 3.0\n                        ELSE 1.0\n                    END *\n                    CASE\n                        WHEN (content->'metadata'->>'isChunk')::boolean = true THEN 1.5\n                        WHEN (content->'metadata'->>'isMain')::boolean = true THEN 1.2\n                        ELSE 1.0\n                    END as keyword_score\n                    FROM knowledge\n                    WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR \"agentId\" = $2\n                )\n                SELECT k.*,\n                    v.vector_score,\n                    kw.keyword_score,\n                    (v.vector_score * kw.keyword_score) as combined_score\n                FROM knowledge k\n                JOIN vector_scores v ON k.id = v.id\n                LEFT JOIN keyword_matches kw ON k.id = kw.id\n                WHERE (\"agentId\" IS NULL AND \"isShared\" = true) OR k.\"agentId\" = $2\n                AND (\n                    v.vector_score >= $4\n                    OR (kw.keyword_score > 1.0 AND v.vector_score >= 0.3)\n                )\n                ORDER BY combined_score DESC\n                LIMIT $5\n            `;\n\n                const { rows } = await this.query<KnowledgeSearchRow>(sql, [\n                    vectorStr,\n                    params.agentId,\n                    `%${params.searchText || \"\"}%`,\n                    params.match_threshold,\n                    params.match_count,\n                ]);\n\n                const results = rows.map((row) => ({\n                    id: row.id,\n                    agentId: row.agentId,\n                    content:\n                        typeof row.content === \"string\"\n                            ? JSON.parse(row.content)\n                            : row.content,\n                    embedding: row.embedding\n                        ? new Float32Array(row.embedding)\n                        : undefined,\n                    createdAt: row.createdAt\n                        ? new Date(row.createdAt).getTime()\n                        : undefined,\n                    similarity: row.combined_score,\n                }));\n\n                await this.setCache({\n                    key: cacheKey,\n                    agentId: params.agentId,\n                    value: JSON.stringify(results),\n                });\n\n                return results;\n            } catch (error) {\n                elizaLogger.error(\"Error searching knowledge\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    searchText: params.searchText,\n                    agentId: params.agentId,\n                });\n                throw new Error(\n                    `Failed to search knowledge: ${error instanceof Error ? error.message : String(error)}`\n                );\n            }\n        }, \"searchKnowledge\");\n    }\n\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\n        return this.withTransaction(async (tx) => {\n            try {\n                const sql = `\n                    INSERT INTO knowledge (\n                        id, \"agentId\", content, embedding, \"createdAt\",\n                        \"isMain\", \"originalId\", \"chunkIndex\", \"isShared\"\n                    ) VALUES ($1, $2, $3, $4, to_timestamp($5/1000.0), $6, $7, $8, $9)\n                    ON CONFLICT (id) DO NOTHING\n                `;\n\n                const metadata = knowledge.content.metadata || {};\n                const vectorStr = knowledge.embedding\n                    ? `[${Array.from(knowledge.embedding).join(\",\")}]`\n                    : null;\n\n                await tx.query(sql, [\n                    knowledge.id,\n                    metadata.isShared ? null : knowledge.agentId,\n                    knowledge.content,\n                    vectorStr,\n                    knowledge.createdAt || Date.now(),\n                    metadata.isMain || false,\n                    metadata.originalId || null,\n                    metadata.chunkIndex || null,\n                    metadata.isShared || false,\n                ]);\n            } catch (error) {\n                elizaLogger.error(\"Failed to create knowledge:\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        }, \"createKnowledge\");\n    }\n\n    async removeKnowledge(id: UUID): Promise<void> {\n        return await this.withTransaction(async (tx) => {\n            try {\n                await tx.query(\"DELETE FROM knowledge WHERE id = $1\", [id]);\n            } catch (error) {\n                tx.rollback();\n                elizaLogger.error(\"Error removing knowledge\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    id,\n                });\n            }\n        }, \"removeKnowledge\");\n    }\n\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\n        return await this.withTransaction(async (tx) => {\n            try {\n                const sql = shared\n                    ? 'DELETE FROM knowledge WHERE (\"agentId\" = $1 OR \"isShared\" = true)'\n                    : 'DELETE FROM knowledge WHERE \"agentId\" = $1';\n                await tx.query(sql, [agentId]);\n            } catch (error) {\n                tx.rollback();\n                elizaLogger.error(\"Error clearing knowledge\", {\n                    error:\n                        error instanceof Error ? error.message : String(error),\n                    agentId,\n                });\n            }\n        }, \"clearKnowledge\");\n    }\n}\n\nexport default PGLiteDatabaseAdapter;\n"],"mappings":"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","names":[]}