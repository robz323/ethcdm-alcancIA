{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\nimport {\n    type Memory,\n    type Goal,\n    type Relationship,\n    Actor,\n    GoalStatus,\n    Account,\n    type UUID,\n    Participant,\n    Room,\n    RAGKnowledgeItem,\n    elizaLogger\n} from \"@elizaos/core\";\nimport { DatabaseAdapter } from \"@elizaos/core\";\nimport { v4 as uuid } from \"uuid\";\nexport class SupabaseDatabaseAdapter extends DatabaseAdapter {\n    async getRoom(roomId: UUID): Promise<UUID | null> {\n        const { data, error } = await this.supabase\n            .from(\"rooms\")\n            .select(\"id\")\n            .eq(\"id\", roomId)\n            .maybeSingle();\n\n        if (error) {\n            elizaLogger.error(`Error getting room: ${error.message}`);\n            return null;\n        }\n        return data ? (data.id as UUID) : null;\n    }\n\n    async getParticipantsForAccount(userId: UUID): Promise<Participant[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"*\")\n            .eq(\"userId\", userId);\n\n        if (error) {\n            throw new Error(\n                `Error getting participants for account: ${error.message}`\n            );\n        }\n\n        return data as Participant[];\n    }\n\n    async getParticipantUserState(\n        roomId: UUID,\n        userId: UUID\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"userState\")\n            .eq(\"roomId\", roomId)\n            .eq(\"userId\", userId)\n            .single();\n\n        if (error) {\n            elizaLogger.error(\"Error getting participant user state:\", error);\n            return null;\n        }\n\n        return data?.userState as \"FOLLOWED\" | \"MUTED\" | null;\n    }\n\n    async setParticipantUserState(\n        roomId: UUID,\n        userId: UUID,\n        state: \"FOLLOWED\" | \"MUTED\" | null\n    ): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .update({ userState: state })\n            .eq(\"roomId\", roomId)\n            .eq(\"userId\", userId);\n\n        if (error) {\n            elizaLogger.error(\"Error setting participant user state:\", error);\n            throw new Error(\"Failed to set participant user state\");\n        }\n    }\n\n    async getParticipantsForRoom(roomId: UUID): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"userId\")\n            .eq(\"roomId\", roomId);\n\n        if (error) {\n            throw new Error(\n                `Error getting participants for room: ${error.message}`\n            );\n        }\n\n        return data.map((row) => row.userId as UUID);\n    }\n\n    supabase: SupabaseClient;\n\n    constructor(supabaseUrl: string, supabaseKey: string) {\n        super();\n        this.supabase = createClient(supabaseUrl, supabaseKey);\n    }\n\n    async init() {\n        // noop\n    }\n\n    async close() {\n        // noop\n    }\n\n    async getMemoriesByRoomIds(params: {\n        roomIds: UUID[];\n        agentId?: UUID;\n        tableName: string;\n    }): Promise<Memory[]> {\n        let query = this.supabase\n            .from(params.tableName)\n            .select(\"*\")\n            .in(\"roomId\", params.roomIds);\n\n        if (params.agentId) {\n            query = query.eq(\"agentId\", params.agentId);\n        }\n\n        const { data, error } = await query;\n\n        if (error) {\n            elizaLogger.error(\"Error retrieving memories by room IDs:\", error);\n            return [];\n        }\n\n        // map createdAt to Date\n        const memories = data.map((memory) => ({\n            ...memory,\n        }));\n\n        return memories as Memory[];\n    }\n\n    async getAccountById(userId: UUID): Promise<Account | null> {\n        const { data, error } = await this.supabase\n            .from(\"accounts\")\n            .select(\"*\")\n            .eq(\"id\", userId);\n        if (error) {\n            throw new Error(error.message);\n        }\n        return (data?.[0] as Account) || null;\n    }\n\n    async createAccount(account: Account): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"accounts\")\n            .upsert([account]);\n        if (error) {\n            elizaLogger.error(error.message);\n            return false;\n        }\n        return true;\n    }\n\n    async getActorDetails(params: { roomId: UUID }): Promise<Actor[]> {\n        try {\n            const response = await this.supabase\n                .from(\"rooms\")\n                .select(\n                    `\n          participants:participants(\n            account:accounts(id, name, username, details)\n          )\n      `\n                )\n                .eq(\"id\", params.roomId);\n\n            if (response.error) {\n                elizaLogger.error(\"Error!\" + response.error);\n                return [];\n            }\n            const { data } = response;\n\n            return data\n                .map((room) =>\n                    room.participants.map((participant) => {\n                        const user = participant.account as unknown as Actor;\n                        return {\n                            name: user?.name,\n                            details: user?.details,\n                            id: user?.id,\n                            username: user?.username,\n                        };\n                    })\n                )\n                .flat();\n        } catch (error) {\n            elizaLogger.error(\"error\", error);\n            throw error;\n        }\n    }\n\n    async searchMemories(params: {\n        tableName: string;\n        roomId: UUID;\n        embedding: number[];\n        match_threshold: number;\n        match_count: number;\n        unique: boolean;\n    }): Promise<Memory[]> {\n        const result = await this.supabase.rpc(\"search_memories\", {\n            query_table_name: params.tableName,\n            query_roomId: params.roomId,\n            query_embedding: params.embedding,\n            query_match_threshold: params.match_threshold,\n            query_match_count: params.match_count,\n            query_unique: params.unique,\n        });\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data.map((memory) => ({\n            ...memory,\n        }));\n    }\n\n    async getCachedEmbeddings(opts: {\n        query_table_name: string;\n        query_threshold: number;\n        query_input: string;\n        query_field_name: string;\n        query_field_sub_name: string;\n        query_match_count: number;\n    }): Promise<\n        {\n            embedding: number[];\n            levenshtein_score: number;\n        }[]\n    > {\n        const result = await this.supabase.rpc(\"get_embedding_list\", opts);\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data;\n    }\n\n    async updateGoalStatus(params: {\n        goalId: UUID;\n        status: GoalStatus;\n    }): Promise<void> {\n        await this.supabase\n            .from(\"goals\")\n            .update({ status: params.status })\n            .match({ id: params.goalId });\n    }\n\n    async log(params: {\n        body: { [key: string]: unknown };\n        userId: UUID;\n        roomId: UUID;\n        type: string;\n    }): Promise<void> {\n        const { error } = await this.supabase.from(\"logs\").insert({\n            body: params.body,\n            userId: params.userId,\n            roomId: params.roomId,\n            type: params.type,\n        });\n\n        if (error) {\n            elizaLogger.error(\"Error inserting log:\", error);\n            throw new Error(error.message);\n        }\n    }\n\n    async getMemories(params: {\n        roomId: UUID;\n        count?: number;\n        unique?: boolean;\n        tableName: string;\n        agentId?: UUID;\n        start?: number;\n        end?: number;\n    }): Promise<Memory[]> {\n        const query = this.supabase\n            .from(params.tableName)\n            .select(\"*\")\n            .eq(\"roomId\", params.roomId);\n\n        if (params.start) {\n            query.gte(\"createdAt\", params.start);\n        }\n\n        if (params.end) {\n            query.lte(\"createdAt\", params.end);\n        }\n\n        if (params.unique) {\n            query.eq(\"unique\", true);\n        }\n\n        if (params.agentId) {\n            query.eq(\"agentId\", params.agentId);\n        }\n\n        query.order(\"createdAt\", { ascending: false });\n\n        if (params.count) {\n            query.limit(params.count);\n        }\n\n        const { data, error } = await query;\n\n        if (error) {\n            throw new Error(`Error retrieving memories: ${error.message}`);\n        }\n\n        return data as Memory[];\n    }\n\n    async searchMemoriesByEmbedding(\n        embedding: number[],\n        params: {\n            match_threshold?: number;\n            count?: number;\n            roomId?: UUID;\n            agentId?: UUID;\n            unique?: boolean;\n            tableName: string;\n        }\n    ): Promise<Memory[]> {\n        const queryParams = {\n            query_table_name: params.tableName,\n            query_roomId: params.roomId,\n            query_embedding: embedding,\n            query_match_threshold: params.match_threshold,\n            query_match_count: params.count,\n            query_unique: !!params.unique,\n        };\n        if (params.agentId) {\n            (queryParams as any).query_agentId = params.agentId;\n        }\n\n        const result = await this.supabase.rpc(\"search_memories\", queryParams);\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n        return result.data.map((memory) => ({\n            ...memory,\n        }));\n    }\n\n    async getMemoryById(memoryId: UUID): Promise<Memory | null> {\n        const { data, error } = await this.supabase\n            .from(\"memories\")\n            .select(\"*\")\n            .eq(\"id\", memoryId)\n            .single();\n\n        if (error) {\n            elizaLogger.error(\"Error retrieving memory by ID:\", error);\n            return null;\n        }\n\n        return data as Memory;\n    }\n\n    async createMemory(\n        memory: Memory,\n        tableName: string,\n        unique = false\n    ): Promise<void> {\n        const createdAt = memory.createdAt ?? Date.now();\n        if (unique) {\n            const opts = {\n                // TODO: Add ID option, optionally\n                query_table_name: tableName,\n                query_userId: memory.userId,\n                query_content: memory.content.text,\n                query_roomId: memory.roomId,\n                query_embedding: memory.embedding,\n                query_createdAt: createdAt,\n                similarity_threshold: 0.95,\n            };\n\n            const result = await this.supabase.rpc(\n                \"check_similarity_and_insert\",\n                opts\n            );\n\n            if (result.error) {\n                throw new Error(JSON.stringify(result.error));\n            }\n        } else {\n            const result = await this.supabase\n                .from(\"memories\")\n                .insert({ ...memory, createdAt, type: tableName });\n            const { error } = result;\n            if (error) {\n                throw new Error(JSON.stringify(error));\n            }\n        }\n    }\n\n    async removeMemory(memoryId: UUID): Promise<void> {\n        const result = await this.supabase\n            .from(\"memories\")\n            .delete()\n            .eq(\"id\", memoryId);\n        const { error } = result;\n        if (error) {\n            throw new Error(JSON.stringify(error));\n        }\n    }\n\n    async removeAllMemories(roomId: UUID, tableName: string): Promise<void> {\n        const result = await this.supabase.rpc(\"remove_memories\", {\n            query_table_name: tableName,\n            query_roomId: roomId,\n        });\n\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n    }\n\n    async countMemories(\n        roomId: UUID,\n        unique = true,\n        tableName: string\n    ): Promise<number> {\n        if (!tableName) {\n            throw new Error(\"tableName is required\");\n        }\n        const query = {\n            query_table_name: tableName,\n            query_roomId: roomId,\n            query_unique: !!unique,\n        };\n        const result = await this.supabase.rpc(\"count_memories\", query);\n\n        if (result.error) {\n            throw new Error(JSON.stringify(result.error));\n        }\n\n        return result.data;\n    }\n\n    async getGoals(params: {\n        roomId: UUID;\n        userId?: UUID | null;\n        onlyInProgress?: boolean;\n        count?: number;\n    }): Promise<Goal[]> {\n        const opts = {\n            query_roomId: params.roomId,\n            query_userId: params.userId,\n            only_in_progress: params.onlyInProgress,\n            row_count: params.count,\n        };\n\n        const { data: goals, error } = await this.supabase.rpc(\n            \"get_goals\",\n            opts\n        );\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return goals;\n    }\n\n    async updateGoal(goal: Goal): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .update(goal)\n            .match({ id: goal.id });\n        if (error) {\n            throw new Error(`Error creating goal: ${error.message}`);\n        }\n    }\n\n    async createGoal(goal: Goal): Promise<void> {\n        const { error } = await this.supabase.from(\"goals\").insert(goal);\n        if (error) {\n            throw new Error(`Error creating goal: ${error.message}`);\n        }\n    }\n\n    async removeGoal(goalId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .delete()\n            .eq(\"id\", goalId);\n        if (error) {\n            throw new Error(`Error removing goal: ${error.message}`);\n        }\n    }\n\n    async removeAllGoals(roomId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"goals\")\n            .delete()\n            .eq(\"roomId\", roomId);\n        if (error) {\n            throw new Error(`Error removing goals: ${error.message}`);\n        }\n    }\n\n    async getRoomsForParticipant(userId: UUID): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"roomId\")\n            .eq(\"userId\", userId);\n\n        if (error) {\n            throw new Error(\n                `Error getting rooms by participant: ${error.message}`\n            );\n        }\n\n        return data.map((row) => row.roomId as UUID);\n    }\n\n    async getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]> {\n        const { data, error } = await this.supabase\n            .from(\"participants\")\n            .select(\"roomId\")\n            .in(\"userId\", userIds);\n\n        if (error) {\n            throw new Error(\n                `Error getting rooms by participants: ${error.message}`\n            );\n        }\n\n        return [...new Set(data.map((row) => row.roomId as UUID))] as UUID[];\n    }\n\n    async createRoom(roomId?: UUID): Promise<UUID> {\n        roomId = roomId ?? (uuid() as UUID);\n        const { data, error } = await this.supabase.rpc(\"create_room\", {\n            roomId,\n        });\n\n        if (error) {\n            throw new Error(`Error creating room: ${error.message}`);\n        }\n\n        if (!data || data.length === 0) {\n            throw new Error(\"No data returned from room creation\");\n        }\n\n        return data[0].id as UUID;\n    }\n\n    async removeRoom(roomId: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from(\"rooms\")\n            .delete()\n            .eq(\"id\", roomId);\n\n        if (error) {\n            throw new Error(`Error removing room: ${error.message}`);\n        }\n    }\n\n    async addParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .insert({ userId: userId, roomId: roomId });\n\n        if (error) {\n            elizaLogger.error(`Error adding participant: ${error.message}`);\n            return false;\n        }\n        return true;\n    }\n\n    async removeParticipant(userId: UUID, roomId: UUID): Promise<boolean> {\n        const { error } = await this.supabase\n            .from(\"participants\")\n            .delete()\n            .eq(\"userId\", userId)\n            .eq(\"roomId\", roomId);\n\n        if (error) {\n            elizaLogger.error(`Error removing participant: ${error.message}`);\n            return false;\n        }\n        return true;\n    }\n\n    async createRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<boolean> {\n        const allRoomData = await this.getRoomsForParticipants([\n            params.userA,\n            params.userB,\n        ]);\n\n        let roomId: UUID;\n\n        if (!allRoomData || allRoomData.length === 0) {\n            // If no existing room is found, create a new room\n            const { data: newRoomData, error: roomsError } = await this.supabase\n                .from(\"rooms\")\n                .insert({})\n                .single();\n\n            if (roomsError) {\n                throw new Error(\"Room creation error: \" + roomsError.message);\n            }\n\n            roomId = (newRoomData as Room)?.id as UUID;\n        } else {\n            // If an existing room is found, use the first room's ID\n            roomId = allRoomData[0];\n        }\n\n        const { error: participantsError } = await this.supabase\n            .from(\"participants\")\n            .insert([\n                { userId: params.userA, roomId },\n                { userId: params.userB, roomId },\n            ]);\n\n        if (participantsError) {\n            throw new Error(\n                \"Participants creation error: \" + participantsError.message\n            );\n        }\n\n        // Create or update the relationship between the two users\n        const { error: relationshipError } = await this.supabase\n            .from(\"relationships\")\n            .upsert({\n                userA: params.userA,\n                userB: params.userB,\n                userId: params.userA,\n                status: \"FRIENDS\",\n            })\n            .eq(\"userA\", params.userA)\n            .eq(\"userB\", params.userB);\n\n        if (relationshipError) {\n            throw new Error(\n                \"Relationship creation error: \" + relationshipError.message\n            );\n        }\n\n        return true;\n    }\n\n    async getRelationship(params: {\n        userA: UUID;\n        userB: UUID;\n    }): Promise<Relationship | null> {\n        const { data, error } = await this.supabase.rpc(\"get_relationship\", {\n            usera: params.userA,\n            userb: params.userB,\n        });\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return data[0];\n    }\n\n    async getRelationships(params: { userId: UUID }): Promise<Relationship[]> {\n        const { data, error } = await this.supabase\n            .from(\"relationships\")\n            .select(\"*\")\n            .or(`userA.eq.${params.userId},userB.eq.${params.userId}`)\n            .eq(\"status\", \"FRIENDS\");\n\n        if (error) {\n            throw new Error(error.message);\n        }\n\n        return data as Relationship[];\n    }\n\n    async getCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<string | undefined> {\n        const { data, error } = await this.supabase\n            .from('cache')\n            .select('value')\n            .eq('key', params.key)\n            .eq('agentId', params.agentId)\n            .single();\n\n        if (error) {\n            elizaLogger.error('Error fetching cache:', error);\n            return undefined;\n        }\n\n        return data?.value;\n    }\n\n    async setCache(params: {\n        key: string;\n        agentId: UUID;\n        value: string;\n    }): Promise<boolean> {\n        const { error } = await this.supabase\n            .from('cache')\n            .upsert({\n                key: params.key,\n                agentId: params.agentId,\n                value: params.value,\n                createdAt: new Date()\n            });\n\n        if (error) {\n            elizaLogger.error('Error setting cache:', error);\n            return false;\n        }\n\n        return true;\n    }\n\n    async deleteCache(params: {\n        key: string;\n        agentId: UUID;\n    }): Promise<boolean> {\n        try {\n            const { error } = await this.supabase\n                .from('cache')\n                .delete()\n                .eq('key', params.key)\n                .eq('agentId', params.agentId);\n\n            if (error) {\n                elizaLogger.error(\"Error deleting cache\", {\n                    error: error.message,\n                    key: params.key,\n                    agentId: params.agentId,\n                });\n                return false;\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\n                \"Database connection error in deleteCache\",\n                error instanceof Error ? error.message : String(error)\n            );\n            return false;\n        }\n    }\n\n    async getKnowledge(params: {\n        id?: UUID;\n        agentId: UUID;\n        limit?: number;\n        query?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        let query = this.supabase\n            .from('knowledge')\n            .select('*')\n            .or(`agentId.eq.${params.agentId},isShared.eq.true`);\n\n        if (params.id) {\n            query = query.eq('id', params.id);\n        }\n\n        if (params.limit) {\n            query = query.limit(params.limit);\n        }\n\n        const { data, error } = await query;\n\n        if (error) {\n            throw new Error(`Error getting knowledge: ${error.message}`);\n        }\n\n        return data.map(row => ({\n            id: row.id,\n            agentId: row.agentId,\n            content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\n            embedding: row.embedding ? new Float32Array(row.embedding) : undefined,\n            createdAt: new Date(row.createdAt).getTime()\n        }));\n    }\n\n    async searchKnowledge(params: {\n        agentId: UUID;\n        embedding: Float32Array;\n        match_threshold: number;\n        match_count: number;\n        searchText?: string;\n    }): Promise<RAGKnowledgeItem[]> {\n        const cacheKey = `embedding_${params.agentId}_${params.searchText}`;\n        const cachedResult = await this.getCache({\n            key: cacheKey,\n            agentId: params.agentId\n        });\n\n        if (cachedResult) {\n            return JSON.parse(cachedResult);\n        }\n\n        // Convert Float32Array to array for Postgres vector\n        const embedding = Array.from(params.embedding);\n\n        const { data, error } = await this.supabase.rpc('search_knowledge', {\n            query_embedding: embedding,\n            query_agent_id: params.agentId,\n            match_threshold: params.match_threshold,\n            match_count: params.match_count,\n            search_text: params.searchText || ''\n        });\n\n        if (error) {\n            throw new Error(`Error searching knowledge: ${error.message}`);\n        }\n\n        const results = data.map(row => ({\n            id: row.id,\n            agentId: row.agentId,\n            content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,\n            embedding: row.embedding ? new Float32Array(row.embedding) : undefined,\n            createdAt: new Date(row.createdAt).getTime(),\n            similarity: row.similarity\n        }));\n\n        await this.setCache({\n            key: cacheKey,\n            agentId: params.agentId,\n            value: JSON.stringify(results)\n        });\n\n        return results;\n    }\n\n    async createKnowledge(knowledge: RAGKnowledgeItem): Promise<void> {\n        try {\n            const metadata = knowledge.content.metadata || {};\n\n            const { error } = await this.supabase\n                .from('knowledge')\n                .insert({\n                    id: knowledge.id,\n                    agentId: metadata.isShared ? null : knowledge.agentId,\n                    content: knowledge.content,\n                    embedding: knowledge.embedding ? Array.from(knowledge.embedding) : null,\n                    createdAt: knowledge.createdAt || new Date(),\n                    isMain: metadata.isMain || false,\n                    originalId: metadata.originalId || null,\n                    chunkIndex: metadata.chunkIndex || null,\n                    isShared: metadata.isShared || false\n                });\n\n            if (error) {\n                if (metadata.isShared && error.code === '23505') { // Unique violation\n                    elizaLogger.info(`Shared knowledge ${knowledge.id} already exists, skipping`);\n                    return;\n                }\n                throw error;\n            }\n        } catch (error: any) {\n            elizaLogger.error(`Error creating knowledge ${knowledge.id}:`, {\n                error,\n                embeddingLength: knowledge.embedding?.length,\n                content: knowledge.content\n            });\n            throw error;\n        }\n    }\n\n    async removeKnowledge(id: UUID): Promise<void> {\n        const { error } = await this.supabase\n            .from('knowledge')\n            .delete()\n            .eq('id', id);\n\n        if (error) {\n            throw new Error(`Error removing knowledge: ${error.message}`);\n        }\n    }\n\n    async clearKnowledge(agentId: UUID, shared?: boolean): Promise<void> {\n        if (shared) {\n            const { error } = await this.supabase\n                .from('knowledge')\n                .delete()\n                .filter('agentId', 'eq', agentId)\n                .filter('isShared', 'eq', true);\n\n            if (error) {\n                elizaLogger.error(`Error clearing shared knowledge for agent ${agentId}:`, error);\n                throw error;\n            }\n        } else {\n            const { error } = await this.supabase\n                .from('knowledge')\n                .delete()\n                .eq('agentId', agentId);\n\n            if (error) {\n                elizaLogger.error(`Error clearing knowledge for agent ${agentId}:`, error);\n                throw error;\n            }\n        }\n    }\n}\n"],"mappings":"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","names":[]}