{"version":3,"sources":["../src/services/irysService.ts","../src/index.ts"],"sourcesContent":["import {\n    IAgentRuntime,\n    Service,\n    ServiceType,\n    IIrysService,\n    UploadIrysResult,\n    DataIrysFetchedFromGQL,\n    GraphQLTag,\n    IrysMessageType,\n    generateMessageResponse,\n    ModelClass,\n    IrysDataType,\n    IrysTimestamp,\n} from \"@elizaos/core\";\nimport { Uploader } from \"@irys/upload\";\nimport { BaseEth } from \"@irys/upload-ethereum\";\nimport { GraphQLClient, gql } from 'graphql-request';\nimport crypto from 'crypto';\n\ninterface NodeGQL {\n    id: string;\n    address: string;\n}\n\ninterface TransactionsIdAddress {\n    success: boolean;\n    data: NodeGQL[];\n    error?: string;\n}\n\ninterface TransactionGQL {\n    transactions: {\n        edges: {\n            node: {\n                id: string;\n                address: string;\n            }\n        }[]\n    }\n}\n\nexport class IrysService extends Service implements IIrysService {\n    static serviceType: ServiceType = ServiceType.IRYS;\n\n    private runtime: IAgentRuntime | null = null;\n    private irysUploader: any | null = null;\n    private endpointForTransactionId: string = \"https://uploader.irys.xyz/graphql\";\n    private endpointForData: string = \"https://gateway.irys.xyz\";\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        console.log(\"Initializing IrysService\");\n        this.runtime = runtime;\n    }\n\n    private async getTransactionId(owners: string[] = null, tags: GraphQLTag[] = null, timestamp: IrysTimestamp = null): Promise<TransactionsIdAddress> {\n        const graphQLClient = new GraphQLClient(this.endpointForTransactionId);\n        const QUERY = gql`\n            query($owners: [String!], $tags: [TagFilter!], $timestamp: TimestampFilter) {\n                transactions(owners: $owners, tags: $tags, timestamp: $timestamp) {\n                    edges {\n                        node {\n                            id,\n                            address\n                        }\n                    }\n                }\n            }\n        `;\n        try {\n            const variables = {\n                owners: owners,\n                tags: tags,\n                timestamp: timestamp\n            }\n            const data: TransactionGQL = await graphQLClient.request(QUERY, variables);\n            const listOfTransactions : NodeGQL[] = data.transactions.edges.map((edge: any) => edge.node);\n            console.log(\"Transaction IDs retrieved\")\n            return { success: true, data: listOfTransactions };\n        } catch (error) {\n            console.error(\"Error fetching transaction IDs\", error);\n            return { success: false, data: [], error: \"Error fetching transaction IDs\" };\n        }\n    }\n\n    private async initializeIrysUploader(): Promise<boolean> {\n        if (this.irysUploader) return true;\n        if (!this.runtime) return false;\n\n        try {\n            const EVM_WALLET_PRIVATE_KEY = this.runtime.getSetting(\"EVM_WALLET_PRIVATE_KEY\");\n            if (!EVM_WALLET_PRIVATE_KEY) return false;\n\n            const irysUploader = await Uploader(BaseEth).withWallet(EVM_WALLET_PRIVATE_KEY);\n            this.irysUploader = irysUploader;\n            return true;\n        } catch (error) {\n            console.error(\"Error initializing Irys uploader:\", error);\n            return false;\n        }\n    }\n\n    private async fetchDataFromTransactionId(transactionId: string): Promise<DataIrysFetchedFromGQL> {\n        console.log(`Fetching data from transaction ID: ${transactionId}`);\n        const response = await fetch(`${this.endpointForData}/${transactionId}`);\n        if (!response.ok) return { success: false, data: null, error: \"Error fetching data from transaction ID\" };\n        return {\n            success: true,\n            data: response,\n        };\n    }\n    private converToValues(value: any): any[] {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        return [value];\n    }\n\n    private async orchestrateRequest(requestMessage: string, tags: GraphQLTag[], timestamp: IrysTimestamp = null): Promise<DataIrysFetchedFromGQL> {\n        const serviceCategory = tags.find((tag) => tag.name == \"Service-Category\")?.values;\n        const protocol = tags.find((tag) => tag.name == \"Protocol\")?.values;\n        const minimumProviders = Number(tags.find((tag) => tag.name == \"Minimum-Providers\")?.values);\n        /*\n            Further implementation of the orchestrator\n            { name: \"Validation-Threshold\", values: validationThreshold },\n            { name: \"Test-Provider\", values: testProvider },\n            { name: \"Reputation\", values: reputation },\n        */\n        const tagsToRetrieve : GraphQLTag[] = [\n            { name: \"Message-Type\", values: [IrysMessageType.DATA_STORAGE] },\n            { name: \"Service-Category\", values: this.converToValues(serviceCategory) },\n            { name: \"Protocol\", values: this.converToValues(protocol) },\n        ];\n        const data = await this.getDataFromAnAgent(null, tagsToRetrieve, timestamp);\n        if (!data.success) return { success: false, data: null, error: data.error };\n        const dataArray = data.data as Array<any>;\n        try {\n            for (let i = 0; i < dataArray.length; i++) {\n                const node = dataArray[i];\n                const templateRequest = `\n                Determine the truthfulness of the relationship between the given context and text.\n                Context: ${requestMessage}\n                Text: ${node.data}\n                Return True or False\n            `;\n            const responseFromModel = await generateMessageResponse({\n                runtime: this.runtime,\n                context: templateRequest,\n                modelClass: ModelClass.MEDIUM,\n            });\n            console.log(\"RESPONSE FROM MODEL : \", responseFromModel)\n            if (!responseFromModel.success || ((responseFromModel.content?.toString().toLowerCase().includes('false')) && (!responseFromModel.content?.toString().toLowerCase().includes('true')))) {\n                dataArray.splice(i, 1);\n                    i--;\n                }\n            }\n        } catch (error) {\n            if (error.message.includes(\"TypeError: Cannot read properties of undefined (reading 'settings')\")) {\n                return { success: false, data: null, error: \"Error in the orchestrator\" };\n            }\n        }\n        const responseTags: GraphQLTag[] = [\n            { name: \"Message-Type\", values: [IrysMessageType.REQUEST_RESPONSE] },\n            { name: \"Service-Category\", values: [serviceCategory] },\n            { name: \"Protocol\", values: [protocol] },\n            { name: \"Request-Id\", values: [tags.find((tag) => tag.name == \"Request-Id\")?.values[0]] },\n        ];\n        if (dataArray.length == 0) {\n            const response = await this.uploadDataOnIrys(\"No relevant data found from providers\", responseTags, IrysMessageType.REQUEST_RESPONSE);\n            console.log(\"Response from Irys: \", response);\n            return { success: false, data: null, error: \"No relevant data found from providers\" };\n        }\n        const listProviders = new Set(dataArray.map((provider: any) => provider.address));\n        if (listProviders.size < minimumProviders) {\n            const response = await this.uploadDataOnIrys(\"Not enough providers\", responseTags, IrysMessageType.REQUEST_RESPONSE);\n            console.log(\"Response from Irys: \", response);\n            return { success: false, data: null, error: \"Not enough providers\" };\n        }\n        const listData = dataArray.map((provider: any) => provider.data);\n        const response = await this.uploadDataOnIrys(listData, responseTags, IrysMessageType.REQUEST_RESPONSE);\n        console.log(\"Response from Irys: \", response);\n        return {\n            success: true,\n            data: listData\n        }\n    }\n\n    // Orchestrator\n    private async uploadDataOnIrys(data: any, tags: GraphQLTag[], messageType: IrysMessageType, timestamp: IrysTimestamp = null): Promise<UploadIrysResult> {\n        if (!(await this.initializeIrysUploader())) {\n            return {\n                success: false,\n                error: \"Irys uploader not initialized\",\n            };\n        }\n\n        // Transform tags to the correct format\n        const formattedTags = tags.map(tag => ({\n            name: tag.name,\n            value: Array.isArray(tag.values) ? tag.values.join(',') : tag.values\n        }));\n\n        const requestId = String(crypto.createHash('sha256').update(new Date().toISOString()).digest('hex'));\n        formattedTags.push({\n            name: \"Request-Id\",\n            value: requestId\n        });\n        try {\n            const dataToStore = {\n                data: data,\n            };\n            const receipt = await this.irysUploader.upload(JSON.stringify(dataToStore), { tags: formattedTags });\n            if (messageType == IrysMessageType.DATA_STORAGE || messageType == IrysMessageType.REQUEST_RESPONSE) {\n                return { success: true, url: `https://gateway.irys.xyz/${receipt.id}`};\n            } else if (messageType == IrysMessageType.REQUEST) {\n                const response = await this.orchestrateRequest(data, tags, timestamp);\n                return {\n                    success: response.success,\n                    url: `https://gateway.irys.xyz/${receipt.id}`,\n                    data: response.data,\n                    error: response.error ? response.error : null\n                }\n\n            }\n            return { success: true, url: `https://gateway.irys.xyz/${receipt.id}` };\n        } catch (error) {\n            return { success: false, error: \"Error uploading to Irys, \" + error };\n        }\n    }\n\n    private async uploadFileOrImageOnIrys(data: string, tags: GraphQLTag[]): Promise<UploadIrysResult> {\n        if (!(await this.initializeIrysUploader())) {\n            return {\n                success: false,\n                error: \"Irys uploader not initialized\"\n            };\n        }\n\n        const formattedTags = tags.map(tag => ({\n            name: tag.name,\n            value: Array.isArray(tag.values) ? tag.values.join(',') : tag.values\n        }));\n\n        try {\n            const receipt = await this.irysUploader.uploadFile(data, { tags: formattedTags });\n            return { success: true, url: `https://gateway.irys.xyz/${receipt.id}` };\n        } catch (error) {\n            return { success: false, error: \"Error uploading to Irys, \" + error };\n        }\n    }\n\n    private normalizeArrayValues(arr: number[], min: number, max?: number): void {\n        for (let i = 0; i < arr.length; i++) {\n            arr[i] = Math.max(min, max !== undefined ? Math.min(arr[i], max) : arr[i]);\n        }\n    }\n\n    private normalizeArraySize(arr: any[]): any {\n        if (arr.length == 1) {\n            return arr[0];\n        }\n        return arr;\n    }\n\n    async workerUploadDataOnIrys(data: any, dataType: IrysDataType, messageType: IrysMessageType, serviceCategory: string[], protocol: string[], validationThreshold: number[] = [], minimumProviders: number[] = [], testProvider: boolean[] = [], reputation: number[] = []): Promise<UploadIrysResult> {\n        this.normalizeArrayValues(validationThreshold, 0, 1);\n        this.normalizeArrayValues(minimumProviders, 0);\n        this.normalizeArrayValues(reputation, 0, 1);\n\n        const tags = [\n            { name: \"Message-Type\", values: messageType },\n            { name: \"Service-Category\", values: this.normalizeArraySize(serviceCategory) },\n            { name: \"Protocol\", values: this.normalizeArraySize(protocol) },\n        ] as GraphQLTag[];\n\n        if (messageType == IrysMessageType.REQUEST) {\n            if (validationThreshold.length > 0) {\n                tags.push({ name: \"Validation-Threshold\", values: this.normalizeArraySize(validationThreshold) });\n            }\n            if (minimumProviders.length > 0) {\n                tags.push({ name: \"Minimum-Providers\", values: this.normalizeArraySize(minimumProviders) });\n            }\n            if (testProvider.length > 0) {\n                tags.push({ name: \"Test-Provider\", values: this.normalizeArraySize(testProvider) });\n            }\n            if (reputation.length > 0) {\n                tags.push({ name: \"Reputation\", values: this.normalizeArraySize(reputation) });\n            }\n        }\n        if (dataType == IrysDataType.FILE || dataType == IrysDataType.IMAGE) {\n            return await this.uploadFileOrImageOnIrys(data, tags);\n        }\n\n        return await this.uploadDataOnIrys(data, tags, messageType);\n    }\n\n    async providerUploadDataOnIrys(data: any, dataType: IrysDataType, serviceCategory: string[], protocol: string[]): Promise<UploadIrysResult> {\n        const tags = [\n            { name: \"Message-Type\", values: [IrysMessageType.DATA_STORAGE] },\n            { name: \"Service-Category\", values: serviceCategory },\n            { name: \"Protocol\", values: protocol },\n        ] as GraphQLTag[];\n\n        if (dataType == IrysDataType.FILE || dataType == IrysDataType.IMAGE) {\n            return await this.uploadFileOrImageOnIrys(data, tags);\n        }\n\n        return await this.uploadDataOnIrys(data, tags, IrysMessageType.DATA_STORAGE);\n    }\n\n    async getDataFromAnAgent(agentsWalletPublicKeys: string[] = null, tags: GraphQLTag[] = null, timestamp: IrysTimestamp = null): Promise<DataIrysFetchedFromGQL> {\n        try {\n            const transactionIdsResponse = await this.getTransactionId(agentsWalletPublicKeys, tags, timestamp);\n            if (!transactionIdsResponse.success) return { success: false, data: null, error: \"Error fetching transaction IDs\" };\n            const transactionIdsAndResponse = transactionIdsResponse.data.map((node: NodeGQL) => node);\n            const dataPromises: Promise<any>[] = transactionIdsAndResponse.map(async (node: NodeGQL) => {\n                const fetchDataFromTransactionIdResponse = await this.fetchDataFromTransactionId(node.id);\n                if (await fetchDataFromTransactionIdResponse.data.headers.get('content-type') == \"application/octet-stream\") {\n                    let data = null;\n                    const responseText = await fetchDataFromTransactionIdResponse.data.text();\n                    try {\n                        data = JSON.parse(responseText);\n                    } catch {\n                        data = responseText;\n                    }\n                    return {\n                        data: data,\n                        address: node.address\n                    }\n                }\n                else {\n                    return {\n                        data: fetchDataFromTransactionIdResponse.data.url,\n                        address: node.address\n                    }\n                }\n            });\n            const data = await Promise.all(dataPromises);\n            return { success: true, data: data };\n        } catch (error) {\n            return { success: false, data: null, error: \"Error fetching data from transaction IDs \" + error };\n        }\n    }\n}\n\nexport default IrysService;","import { Plugin } from \"@elizaos/core\";\nimport IrysService from \"./services/irysService\";\n\nconst irysPlugin: Plugin = {\n    name: \"plugin-irys\",\n    description: \"Store and retrieve data on Irys to create a decentralized knowledge base and enable multi-agent collaboration\",\n    actions: [],\n    providers: [],\n    evaluators: [],\n    clients: [],\n    services: [new IrysService()],\n}\n\nexport default irysPlugin;\n"],"mappings":"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","names":["response","data"]}