{"version":3,"sources":["../src/actions/spotTrade.ts","../src/types.ts","../src/templates.ts","../src/actions/priceCheck.ts","../src/actions/cancelOrders.ts","../src/index.ts"],"sourcesContent":["import {\n    Action,\n    ActionExample,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    ModelClass,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\nimport {\n    SpotOrderSchema,\n    HyperliquidError,\n    PRICE_VALIDATION,\n} from \"../types.js\";\nimport { spotTradeTemplate } from \"../templates.js\";\n\nexport const spotTrade: Action = {\n    name: \"SPOT_TRADE\",\n    similes: [\"SPOT_ORDER\", \"SPOT_BUY\", \"SPOT_SELL\"],\n    description: \"Place a spot trade order on Hyperliquid\",\n    validate: async (runtime: IAgentRuntime) => {\n        return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Initialize or update state\n            state = !state\n                ? await runtime.composeState(message)\n                : await runtime.updateRecentMessageState(state);\n\n            const context = composeContext({\n                state,\n                template: spotTradeTemplate,\n            });\n\n            const content = await generateObjectDeprecated({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (!content) {\n                throw new HyperliquidError(\n                    \"Could not parse trading parameters from conversation\"\n                );\n            }\n\n            elizaLogger.info(\n                \"Raw content from LLM:\",\n                JSON.stringify(content, null, 2)\n            );\n\n            // Validate order parameters\n            const validatedOrder = SpotOrderSchema.parse(content);\n            elizaLogger.info(\"Validated order:\", validatedOrder);\n\n            // Initialize SDK\n            const sdk = new Hyperliquid({\n                privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\n                testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\n                enableWs: false,\n            });\n            await sdk.connect();\n\n            // Get market data\n            const [meta, assetCtxs] =\n                await sdk.info.spot.getSpotMetaAndAssetCtxs();\n\n            // Find token and market\n            const tokenIndex = meta.tokens.findIndex(\n                (token) =>\n                    token.name.toUpperCase() ===\n                    validatedOrder.coin.toUpperCase()\n            );\n            if (tokenIndex === -1) {\n                throw new HyperliquidError(\n                    `Could not find token ${validatedOrder.coin}`\n                );\n            }\n            const tokenInfo = meta.tokens[tokenIndex];\n            elizaLogger.info(\"Found token:\", tokenInfo.name);\n\n            const marketIndex = assetCtxs.findIndex(\n                (ctx) => ctx.coin === `${validatedOrder.coin}-SPOT`\n            );\n            if (marketIndex === -1) {\n                throw new HyperliquidError(\n                    `Could not find market for ${validatedOrder.coin}`\n                );\n            }\n            const marketCtx = assetCtxs[marketIndex];\n            if (!marketCtx || !marketCtx.midPx) {\n                throw new HyperliquidError(\n                    `Could not get market price for ${validatedOrder.coin}`\n                );\n            }\n\n            // Calculate prices\n            const midPrice = Number(marketCtx.midPx);\n            const isMarketOrder = !validatedOrder.limit_px;\n            let finalPrice: number;\n\n            if (isMarketOrder) {\n                // For market orders, use current price with slippage\n                const slippage = PRICE_VALIDATION.SLIPPAGE;\n                finalPrice = validatedOrder.is_buy\n                    ? midPrice * (1 + slippage)\n                    : midPrice * (1 - slippage);\n\n                // Validate market order price\n                if (\n                    finalPrice <\n                        midPrice * PRICE_VALIDATION.MARKET_ORDER.MIN_RATIO ||\n                    finalPrice >\n                        midPrice * PRICE_VALIDATION.MARKET_ORDER.MAX_RATIO\n                ) {\n                    throw new HyperliquidError(\n                        `Market order price (${finalPrice.toFixed(2)} USDC) is too far from market price (${midPrice.toFixed(2)} USDC). This might be due to low liquidity.`\n                    );\n                }\n            } else {\n                // For limit orders\n                finalPrice = validatedOrder.limit_px;\n\n                // Validate limit order price is optimal\n                if (validatedOrder.is_buy && finalPrice > midPrice) {\n                    throw new HyperliquidError(\n                        `Cannot place buy limit order at ${finalPrice.toFixed(2)} USDC because it's above market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price below ${midPrice.toFixed(2)} USDC.`\n                    );\n                } else if (!validatedOrder.is_buy && finalPrice < midPrice) {\n                    throw new HyperliquidError(\n                        `Cannot place sell limit order at ${finalPrice.toFixed(2)} USDC because it's below market price (${midPrice.toFixed(2)} USDC). To execute immediately, use a market order. For a limit order, set a price above ${midPrice.toFixed(2)} USDC.`\n                    );\n                }\n\n                // Log warning if price is very different from market\n                if (\n                    finalPrice <\n                        midPrice *\n                            PRICE_VALIDATION.LIMIT_ORDER.WARNING_MIN_RATIO ||\n                    finalPrice >\n                        midPrice *\n                            PRICE_VALIDATION.LIMIT_ORDER.WARNING_MAX_RATIO\n                ) {\n                    elizaLogger.warn(\n                        `Limit price (${finalPrice.toFixed(2)} USDC) is very different from market price (${midPrice.toFixed(2)} USDC). Make sure this is intentional.`,\n                        {\n                            finalPrice,\n                            midPrice,\n                            ratio: finalPrice / midPrice,\n                        }\n                    );\n                }\n            }\n\n            // Prepare and place order\n            const rounded_px = Number(finalPrice.toFixed(tokenInfo.szDecimals));\n            const orderRequest = {\n                coin: `${validatedOrder.coin}-SPOT`,\n                asset: 10000 + marketIndex,\n                is_buy: validatedOrder.is_buy,\n                sz: validatedOrder.sz,\n                limit_px: rounded_px,\n                reduce_only: false,\n                order_type: isMarketOrder\n                    ? { market: {} }\n                    : { limit: { tif: \"Gtc\" as const } },\n            };\n\n            elizaLogger.info(\"Placing order:\", orderRequest);\n            const result = await sdk.exchange.placeOrder(orderRequest);\n\n            // Check if order was rejected\n            if (\n                result.status === \"ok\" &&\n                result.response?.type === \"order\" &&\n                result.response.data?.statuses?.[0]?.error\n            ) {\n                throw new HyperliquidError(\n                    result.response.data.statuses[0].error\n                );\n            }\n\n            // Send success callback\n            if (callback) {\n                const action = validatedOrder.is_buy ? \"buy\" : \"sell\";\n                const executionPrice =\n                    result.response?.data?.statuses?.[0]?.px || rounded_px;\n                callback({\n                    text: `Successfully placed ${isMarketOrder ? \"a market\" : \"a limit\"} order to ${action} ${validatedOrder.sz} ${validatedOrder.coin} at ${executionPrice}`,\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error placing spot order:\", error);\n            if (callback) {\n                callback({\n                    text: `Error placing spot order: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Buy 0.1 HYPE at 20 USDC\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll place a spot buy order for 0.1 HYPE at 20 USDC.\",\n                    action: \"SPOT_TRADE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Successfully placed a limit order to buy 0.1 HYPE at 20 USDC\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Sell 2 HYPE at 21 USDC\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll place a spot sell order for 2 HYPE at 21 USDC.\",\n                    action: \"SPOT_TRADE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Successfully placed a limit order to sell 2 HYPE at 21 USDC\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n\nexport default spotTrade;\n","import { z } from \"zod\";\n\n// Base configuration types\nexport interface HyperliquidConfig {\n    privateKey: string;\n    testnet?: boolean;\n    walletAddress?: string;\n}\n\n// Enhanced schemas with better validation\nexport const SpotOrderSchema = z.object({\n    coin: z.string().min(1),\n    is_buy: z.boolean(),\n    sz: z.number().positive(),\n    limit_px: z.number().positive().nullable(),\n    reduce_only: z.boolean().default(false),\n    order_type: z\n        .object({\n            limit: z.object({\n                tif: z.enum([\"Ioc\", \"Gtc\"]),\n            }),\n        })\n        .default({ limit: { tif: \"Gtc\" } }),\n});\n\n// Inferred types from schemas\nexport type SpotOrder = z.infer<typeof SpotOrderSchema>;\n\n// Response types\nexport interface OrderResponse {\n    coin: string;\n    orderId: string;\n    status: \"open\" | \"filled\" | \"cancelled\" | \"rejected\";\n    size: number;\n    price: number;\n    is_buy: boolean;\n}\n\n// Error handling types\nexport class HyperliquidError extends Error {\n    constructor(\n        message: string,\n        public code?: number,\n        public details?: unknown\n    ) {\n        super(message);\n        this.name = \"HyperliquidError\";\n    }\n}\n\n// Constants\nexport const ORDER_STATUS = {\n    OPEN: \"open\",\n    FILLED: \"filled\",\n    CANCELLED: \"cancelled\",\n    REJECTED: \"rejected\",\n} as const;\n\nexport const PRICE_VALIDATION = {\n    MARKET_ORDER: {\n        MIN_RATIO: 0.5, // -50% from mid price\n        MAX_RATIO: 1.5, // +50% from mid price\n    },\n    LIMIT_ORDER: {\n        WARNING_MIN_RATIO: 0.2, // -80% from mid price\n        WARNING_MAX_RATIO: 5, // +500% from mid price\n    },\n    SLIPPAGE: 0.01, // 1% slippage for market orders\n} as const;\n\nexport type OrderStatus = keyof typeof ORDER_STATUS;\n\n// Balance types\nexport interface BalanceResponse {\n    coin: string;\n    free: number;\n    locked: number;\n}\n","export const spotTradeTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed a trade request.\nBased on ONLY that last message, extract the trading details:\n\nFor Hyperliquid spot trading:\n- Market orders (executes immediately at best available price):\n  \"buy 1 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1 }\n  \"sell 2 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 2 }\n  \"market buy 1 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1 }\n  \"market sell 2 HYPE\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 2 }\n\n- Limit orders (waits for specified price):\n  \"buy 1 HYPE at 20 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1, \"limit_px\": 20 }\n  \"sell 0.5 HYPE at 21 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 0.5, \"limit_px\": 21 }\n  \"limit buy 1 HYPE at 20 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": true, \"sz\": 1, \"limit_px\": 20 }\n  \"limit sell 0.5 HYPE at 21 USDC\" -> { \"coin\": \"HYPE\", \"is_buy\": false, \"sz\": 0.5, \"limit_px\": 21 }\n\n\\`\\`\\`json\n{\n    \"coin\": \"<coin symbol>\",\n    \"is_buy\": \"<true for buy, false for sell>\",\n    \"sz\": \"<quantity to trade>\",\n    \"limit_px\": \"<price in USDC if limit order, null if market order>\"\n}\n\\`\\`\\`\n\nNote:\n- Just use the coin symbol (HYPE, ETH, etc.)\n- sz is the size/quantity to trade (exactly as specified in the message)\n- limit_px is optional:\n  - If specified (with \"at X USDC\"), order will be placed at that exact price\n  - If not specified, order will be placed at current market price\n- Words like \"market\" or \"limit\" at the start are optional but help clarify intent\n\nRecent conversation:\n{{recentMessages}}`;\n\nexport const priceCheckTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed which token price to check.\nBased on ONLY that last message, extract the token symbol.\n\nFor example:\n- \"I'll check PIP price for you\" -> { \"symbol\": \"PIP\" }\n- \"Let me check the price of HYPE\" -> { \"symbol\": \"HYPE\" }\n- \"I'll get the current ETH price\" -> { \"symbol\": \"ETH\" }\n\n\\`\\`\\`json\n{\n    \"symbol\": \"<token symbol from your last message>\"\n}\n\\`\\`\\`\n\nNote:\n- Just return the token symbol (PIP, HYPE, ETH, etc.)\n- Remove any suffixes like \"-SPOT\" or \"USDC\"\n- If multiple tokens are mentioned, use the last one\n\nRecent conversation:\n{{recentMessages}}`;\n","import {\n    Action,\n    ActionExample,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    ModelClass,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\nimport { HyperliquidError } from \"../types.js\";\nimport { priceCheckTemplate } from \"../templates.js\";\n\nexport const priceCheck: Action = {\n    name: \"PRICE_CHECK\",\n    similes: [\"CHECK_PRICE\", \"GET_PRICE\", \"PRICE\", \"CURRENT_PRICE\"],\n    description: \"Get current price for a token on Hyperliquid\",\n    validate: async () => true, // Public endpoint\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Initialize or update state\n            state = !state\n                ? await runtime.composeState(message)\n                : await runtime.updateRecentMessageState(state);\n\n            const context = composeContext({\n                state,\n                template: priceCheckTemplate,\n            });\n\n            const content = await generateObjectDeprecated({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (!content?.symbol) {\n                throw new HyperliquidError(\n                    \"Could not determine which token price to check\"\n                );\n            }\n\n            elizaLogger.info(\"Checking price for token:\", content.symbol);\n\n            // Initialize SDK\n            const sdk = new Hyperliquid({\n                enableWs: false,\n            });\n            await sdk.connect();\n\n            // Get market data\n            const [meta, assetCtxs] =\n                await sdk.info.spot.getSpotMetaAndAssetCtxs();\n\n            // Find token and market\n            const tokenIndex = meta.tokens.findIndex(\n                (token) =>\n                    token.name.toUpperCase() === content.symbol.toUpperCase()\n            );\n            if (tokenIndex === -1) {\n                throw new HyperliquidError(\n                    `Could not find token ${content.symbol}`\n                );\n            }\n\n            const marketIndex = assetCtxs.findIndex(\n                (ctx) => ctx.coin === `${content.symbol}-SPOT`\n            );\n            if (marketIndex === -1) {\n                throw new HyperliquidError(\n                    `Could not find market for ${content.symbol}`\n                );\n            }\n\n            const marketCtx = assetCtxs[marketIndex];\n            if (!marketCtx || !marketCtx.midPx) {\n                throw new HyperliquidError(\n                    `Could not get market price for ${content.symbol}`\n                );\n            }\n\n            const price = Number(marketCtx.midPx);\n            const dayChange = (\n                ((price - Number(marketCtx.prevDayPx)) /\n                    Number(marketCtx.prevDayPx)) *\n                100\n            ).toFixed(2);\n            const volume = Number(marketCtx.dayNtlVlm).toFixed(2);\n\n            if (callback) {\n                callback({\n                    text: `${content.symbol} price: ${price.toFixed(2)} USDC (24h change: ${dayChange}%, volume: ${volume} USDC)`,\n                    content: {\n                        symbol: content.symbol,\n                        price: price,\n                        dayChange: dayChange,\n                        volume: volume,\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error checking price:\", error);\n            if (callback) {\n                callback({\n                    text: `Error checking price: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's the current price of PIP?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the current PIP price for you.\",\n                    action: \"PRICE_CHECK\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"PIP price: 19.73 USDC (24h change: -1.82%, volume: 1053445.75 USDC)\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n\nexport default priceCheck;\n","import {\n    Action,\n    ActionExample,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { Hyperliquid } from \"hyperliquid\";\n\nexport const cancelOrders: Action = {\n    name: \"CANCEL_ORDERS\",\n    similes: [\"CANCEL_ALL_ORDERS\", \"CANCEL\", \"CANCEL_ALL\"],\n    description: \"Cancel all open orders on Hyperliquid\",\n    validate: async (runtime: IAgentRuntime) => {\n        return !!runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\");\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ) => {\n        try {\n            // Initialize SDK\n            const sdk = new Hyperliquid({\n                privateKey: runtime.getSetting(\"HYPERLIQUID_PRIVATE_KEY\"),\n                testnet: runtime.getSetting(\"HYPERLIQUID_TESTNET\") === \"true\",\n                enableWs: false,\n            });\n            await sdk.connect();\n\n            elizaLogger.info(\"Cancelling all open orders...\");\n            const result = await sdk.custom.cancelAllOrders();\n            elizaLogger.info(\"Cancel result:\", result);\n\n            if (callback) {\n                const cancelledCount =\n                    result?.response?.data?.statuses?.length || 0;\n                callback({\n                    text:\n                        cancelledCount > 0\n                            ? `Successfully cancelled ${cancelledCount} open order${cancelledCount > 1 ? \"s\" : \"\"}`\n                            : \"No open orders to cancel\",\n                    content: result,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error cancelling orders:\", error);\n            if (callback) {\n                callback({\n                    text: `Error cancelling orders: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Cancel all my orders\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll cancel all your open orders.\",\n                    action: \"CANCEL_ORDERS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Successfully cancelled 2 open orders\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n};\n\nexport default cancelOrders;\n","import { Plugin } from \"@elizaos/core\";\nimport { spotTrade } from \"./actions/spotTrade\";\nimport { priceCheck } from \"./actions/priceCheck\";\nimport { cancelOrders } from \"./actions/cancelOrders\";\n\nexport const hyperliquidPlugin: Plugin = {\n    name: \"hyperliquid\",\n    description: \"Hyperliquid plugin\",\n    actions: [spotTrade, priceCheck, cancelOrders],\n    providers: [],\n    evaluators: [],\n    services: [],\n    clients: [],\n};\n\nexport default hyperliquidPlugin;\n"],"mappings":"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","names":["composeContext","elizaLogger","generateObjectDeprecated","ModelClass","Hyperliquid","composeContext","generateObjectDeprecated","ModelClass","elizaLogger","Hyperliquid","elizaLogger","Hyperliquid"]}