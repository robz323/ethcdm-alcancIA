'use strict';

const node_fs = require('node:fs');
const pathe = require('pathe');
const mlly = require('mlly');
const perfectDebounce = require('perfect-debounce');
const MagicString = require('magic-string');
const scule = require('scule');
const pkgTypes = require('pkg-types');
const defu = require('defu');
const mdbox = require('mdbox');
const promises = require('node:fs/promises');
const destr = require('destr');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);

function defineGenerator(generator) {
  return generator;
}

function resolvePath(path, { url, dir }) {
  if (path.startsWith("/")) {
    return pathe.join(dir, path);
  }
  return url ? mlly.fileURLToPath(new URL(path, url)) : pathe.resolve(dir, path);
}
async function getPkg(dir, input = {}) {
  const pkg = await pkgTypes.readPackageJSON(dir).catch(() => void 0);
  return defu.defu(
    {
      name: input.name,
      version: typeof input.version === "string" ? input.version : void 0,
      github: input.github || input.gh
    },
    {
      name: pkg?.name,
      version: pkg?.version,
      github: _getGitRepo(pkg?.repository)
    },
    {
      name: process.env.npm_package_name,
      version: process.env.npm_package_version
    }
  );
}
function _getGitRepo(repo) {
  const url = typeof repo === "string" ? repo : repo?.url;
  if (!url || typeof url !== "string") {
    return;
  }
  const match = /(?:https:\/\/github\.com\/|gh:|github:|)([\w-]+)\/([\w-]+)/.exec(url);
  if (match && match[1] && match[2]) {
    return `${match[1]}/${match[2]}`;
  }
}

const jsdocs = defineGenerator({
  name: "jsdocs",
  async generate({ config, args, url }) {
    const { loadSchema } = await import('untyped/loader');
    const fullPath = resolvePath(args.src, { url, dir: config.dir });
    const schema = await loadSchema(fullPath, {
      jiti: {
        // TODO: untyped should be able to reuse same jiti instance to avoid race conditions
        fsCache: false,
        moduleCache: false
      }
    });
    return {
      contents: _render(
        schema,
        args,
        Number.parseInt(args.headingLevel) || 2
      ).join("\n").replace(/\n{3,}/g, "\n\n")
    };
  }
});
function _render(schema, opts, headingLevel) {
  const sections = /* @__PURE__ */ Object.create(null);
  for (const [key, keySchema] of Object.entries(schema.properties || {})) {
    const section = _renderSection(key, keySchema, opts, headingLevel + 1);
    if (!section) {
      continue;
    }
    sections[section.group] = sections[section.group] || [];
    sections[section.group].push([section.heading, section.lines]);
  }
  const lines = [];
  const sortedGroups = Object.keys(sections).sort((a, b) => {
    if (a === "") {
      return 1;
    }
    if (b === "") {
      return -1;
    }
    return a.localeCompare(b);
  });
  for (const group of sortedGroups) {
    if (group) {
      lines.push(`
${"#".repeat(headingLevel)} ${scule.titleCase(group)}
`);
    }
    const sortedSections = sections[group].sort(
      (a, b) => a[0].localeCompare(b[0])
    );
    for (const section of sortedSections) {
      const heading = `
${"#".repeat(headingLevel + 1)} ${section[0]}
`;
      lines.push(heading, ...section[1]);
    }
  }
  return lines;
}
function _renderSection(key, schema, opts, headingLevel) {
  const tags = _parseTags(schema.tags);
  if (tags.some((t) => t.tag === "@deprecated" || t.tag === "@internal")) {
    return;
  }
  const group = tags.find((t) => t.tag === "@group")?.contents || opts.defaultGroup || "";
  if (opts.group && (typeof opts.group === "string" ? group !== opts.group : !opts.group.includes(group))) {
    return;
  }
  let heading = `\`${key}\``;
  const lines = [];
  if (schema.type === "function") {
    heading = `\`${_generateFunctionSig(key, schema)}\``;
  } else if (schema.type !== "object") {
    lines.push(
      `- **Type**: \`${schema.markdownType || schema.tsType || schema.type}\``
    );
    if ("default" in schema) {
      lines.push(`- **Default**: \`${JSON.stringify(schema.default)}\``);
    }
    lines.push("");
  }
  lines.push(..._renderBody(schema));
  for (const tag of tags) {
    if (tag.tag === "@example") {
      const codeBlock = tag.contents.startsWith("`") ? tag.contents : `\`\`\`ts
${tag.contents}
\`\`\``;
      lines.push("", "**Example:**", "", codeBlock);
    }
  }
  if (schema.type === "object") {
    lines.push(..._render(schema, opts, headingLevel));
  }
  return {
    heading,
    lines,
    group
  };
}
function _renderBody(schema) {
  const lines = [];
  if (schema.title) {
    lines.push(schema.title.trim());
  }
  if (schema.title && schema.description) {
    lines.push("");
  }
  if (schema.description) {
    lines.push(
      ...schema.description.split("\n").map((line) => line.trim()).join("\n\n").split("\n")
    );
  }
  return lines;
}
function _parseTags(lines = []) {
  const parsedTags = [];
  let tag = "";
  let contentLines = [];
  for (const line of lines.join("\n").split("\n")) {
    if (line.startsWith("@")) {
      if (tag) {
        parsedTags.push({
          tag,
          contents: contentLines.join("\n")
        });
      }
      const [_tag, ...rest] = line.split(" ");
      tag = _tag;
      contentLines = rest;
    } else {
      contentLines.push(line);
    }
  }
  if (tag) {
    parsedTags.push({ tag, contents: contentLines.join("\n") });
  }
  return parsedTags;
}
function _generateFunctionSig(name, meta) {
  return `${name}(${(meta.args || []).map((arg) => {
    let str = arg.name;
    if (arg.optional) {
      str += "?";
    }
    const tsType = _simpleArgType(arg.tsType);
    if (tsType) {
      str += `: ${tsType}`;
    }
    return str;
  }).join(", ")})`;
}
function _simpleArgType(tsType = "") {
  return tsType.split(/\s*\|\s*/).filter((t) => t && t !== "object" && t.startsWith("{")).map(
    (ot) => ot.split(/\s*[,;]\s*/g).map((p) => p.replaceAll(/\s*:\s*(string|boolean|number)/g, "")).join(", ")
  ).join(" | ");
}

const badgeTypes = {
  npmVersion: {
    name: "npm version",
    to: "https://npmjs.com/package/{name}"
  },
  npmDownloads: {
    name: "npm downloads",
    to: "https://npm.chart.dev/{name}"
  },
  bundlephobia: {
    name: "bundle size",
    to: "https://bundlephobia.com/package/{name}"
  },
  bundlejs: {
    name: "bundle size",
    to: "https://bundlejs.com/?q={name}"
  },
  packagephobia: {
    name: "install size",
    to: "https://packagephobia.com/result?p={name}"
  },
  codecov: {
    name: "codecov",
    to: "https://codecov.io/gh/{github}"
  },
  license: {
    name: "license",
    to: "https://github.com/{github}/blob/{licenseBranch}/LICENSE"
  }
};
const badgeProviders = {
  // https://shields.io/badges/static-badge
  shields: {
    npmVersion: "https://img.shields.io/npm/v/{name}",
    npmDownloads: "https://img.shields.io/npm/dm/{name}",
    bundlephobia: "https://img.shields.io/bundlephobia/minzip/{name}",
    packagephobia: false,
    // https://github.com/badges/shields/issues/1701
    bundlejs: "https://img.shields.io/bundlejs/size/{name}",
    codecov: "https://img.shields.io/codecov/c/gh/{github}",
    license: "https://img.shields.io/github/license/{github}"
  },
  // https://badgen.net/help
  badgen: {
    npmVersion: "https://flat.badgen.net/npm/v/{name}",
    npmDownloads: "https://flat.badgen.net/npm/dm/{name}",
    bundlephobia: "https://flat.badgen.net/bundlephobia/minzip/{name}",
    bundlejs: false,
    // https://github.com/badgen/badgen/issues/82
    packagephobia: "https://flat.badgen.net/packagephobia/publish/{name}",
    codecov: "https://flat.badgen.net/codecov/c/github/{github}",
    license: "https://flat.badgen.net/github/license/{github}"
  },
  badgenClassic: {
    npmVersion: "https://badgen.net/npm/v/{name}",
    npmDownloads: "https://badgen.net/npm/dm/{name}",
    bundlephobia: "https://badgen.net/bundlephobia/minzip/{name}",
    bundlejs: false,
    // https://github.com/badgen/badgen/issues/82
    packagephobia: "https://badgen.net/packagephobia/publish/{name}",
    codecov: "https://badgen.net/codecov/c/github/{github}",
    license: "https://badgen.net/github/license/{github}"
  }
};
const badges = defineGenerator({
  name: "badges",
  async generate({ config, args }) {
    const pkg = await getPkg(config.dir, args);
    const ctx = {
      name: pkg.name,
      github: pkg.github,
      licenseBranch: "main",
      ...args
    };
    const fillStr = (str) => str.replace(/{(\w+)}/g, (_, key) => ctx[key] || "");
    const provider = badgeProviders[args.provider] || badgeProviders.shields;
    const providerParams = Object.entries({
      color: args.color,
      labelColor: args.labelColor,
      ...args.styleParams
    }).filter(([, value]) => value).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join("&");
    const badges2 = {
      npmVersion: {
        enabled: ctx.name && args.npmVersion !== false,
        ...badgeTypes.npmVersion
      },
      npmDownloads: {
        enabled: ctx.name && args.npmDownloads !== false,
        ...badgeTypes.npmDownloads
      },
      bundlephobia: {
        enabled: args.bundlephobia && ctx.name,
        ...badgeTypes.bundlephobia
      },
      bundlejs: {
        enabled: args.bundlejs && ctx.name,
        ...badgeTypes.bundlejs
      },
      packagephobia: {
        enabled: args.packagephobia && ctx.name,
        ...badgeTypes.packagephobia
      },
      codecov: {
        enabled: args.codecov && ctx.github,
        ...badgeTypes.codecov
      },
      license: {
        enabled: args.license && ctx.github,
        ...badgeTypes.license
      }
    };
    const md = [];
    for (const [badgeType, badge] of Object.entries(badges2)) {
      if (!badge.enabled || !provider[badgeType]) {
        continue;
      }
      const to = fillStr(badge.to);
      const imgURL = fillStr(provider[badgeType]) + (providerParams ? `?${providerParams}` : "");
      md.push(mdbox.link(to, mdbox.image(imgURL, badge.name)));
    }
    return {
      contents: md.join("\n")
    };
  }
});

const INSTALL_COMMANDS = [
  ["npm", "install"],
  ["yarn", "add"],
  ["pnpm", "install"],
  ["bun", "install"],
  ["deno", "install", " --dev"]
];
const NYPM_COMMAND = ["npx nypm", "install"];
const RUN_COMMANDS = [
  ["npm", "npx "],
  ["pnpm", "pnpm dlx "],
  ["bun", "bunx "],
  ["deno", "deno run -A npm:"]
];
const pmInstall = defineGenerator({
  name: "pm-install",
  async generate({ config, args }) {
    const { name, version } = await getPkg(config.dir, args);
    if (!name) {
      return {
        contents: "<!-- package name is unspecified -->"
      };
    }
    let versionSuffix = "";
    if (args.version) {
      versionSuffix = typeof args.version === "string" ? `@${args.version}` : `@^${version}`;
    }
    const commands = args.auto === false ? INSTALL_COMMANDS : [NYPM_COMMAND, ...INSTALL_COMMANDS];
    const contents = commands.map(
      ([cmd, install, dev = " -D"]) => `# ${cmd.includes("nypm") ? "\u2728 Auto-detect" : cmd}
${cmd} ${install}${args.dev ? dev : ""} ${name}${versionSuffix}`
    );
    if ((args.separate ?? false) === false) {
      return {
        contents: mdbox.md.codeBlock(contents.join("\n\n"), "sh")
      };
    }
    return {
      contents: contents.map((cmd) => mdbox.md.codeBlock(cmd, "sh")).join("\n\n")
    };
  }
});
const pmX = defineGenerator({
  name: "pm-x",
  async generate({ config, args }) {
    const { name, version } = await getPkg(config.dir, args);
    if (!name) {
      return {
        contents: "<!-- package name is unspecified -->"
      };
    }
    let versionSuffix = "";
    if (args.version) {
      versionSuffix = typeof args.version === "string" ? `@${args.version}` : `@${version}`;
    }
    const contents = RUN_COMMANDS.map(
      ([pm, cmd]) => `# ${pm}
${cmd}${name}${versionSuffix}${args.args ? ` ${args.args}` : ""}`
    );
    if ((args.separate ?? false) === false) {
      return {
        contents: mdbox.md.codeBlock(contents.join("\n\n"), "sh")
      };
    }
    return {
      contents: contents.map((cmd) => mdbox.md.codeBlock(cmd, "sh")).join("\n\n")
    };
  }
});

const fetch = defineGenerator({
  name: "fetch",
  async generate({ args }) {
    const { $fetch } = await import('ofetch');
    let url = args.url;
    if (!url) {
      throw new Error("URL is required!");
    }
    if (url.startsWith("gh:")) {
      url = `https://raw.githubusercontent.com/${url.slice(3)}`;
    }
    const contents = await $fetch(url);
    return {
      contents
    };
  }
});

const DEFAULT_CDN = "https://esm.sh/";
const jsimport = defineGenerator({
  name: "jsimport",
  async generate({ config, args }) {
    const { name } = await getPkg(config.dir, args);
    const importPath = name + (args.path || "");
    const importNames = [].concat(args.import, args.imports).filter(Boolean).flatMap((i) => i.split(/\s*,\s*/));
    if (args.src) {
      const resolved = await mlly.resolvePath(args.src, { url: config.dir });
      const contents = await promises.readFile(resolved, "utf8");
      const exportNames = mlly.findExportNames(contents);
      if (exportNames && exportNames.length > 0) {
        importNames.push(...exportNames);
      }
    }
    const lines = [];
    const fmtImports = importNames.length > 1 ? `
${importNames.map((i) => "  " + i + ",").join("\n")}
` : importNames[0] && ` ${importNames[0]} ` || "";
    const formatMultiLine = (str) => {
      return str.length > (args.printWidth || 80) ? str : str.replace(/\n/g, "").replace(/,\s*}/, "}").replace(/(\w)}/, "$1 }").replace(/\s+/g, " ");
    };
    if (args.esm !== false) {
      const code = formatMultiLine(
        `import {${fmtImports}} from "${importPath}";`
      );
      lines.push("**ESM** (Node.js, Bun, Deno)", mdbox.md.codeBlock(code, "js"));
    }
    if (args.cjs) {
      const code = formatMultiLine(
        `const {${fmtImports}} = require("${importPath}");`
      );
      lines.push("**CommonJS** (Legacy Node.js)", mdbox.md.codeBlock(code, "js"));
    }
    if (args.cdn) {
      const cdnBase = typeof args.cdn === "string" ? args.cdn : DEFAULT_CDN;
      const code = formatMultiLine(
        `import {${fmtImports}} from "${cdnBase}${importPath}";`
      );
      lines.push("**CDN** (Deno, Bun and Browsers)", mdbox.md.codeBlock(code, "js"));
    }
    return {
      contents: lines.join("\n\n")
    };
  }
});

const withAutomd = defineGenerator({
  name: "with-automd",
  generate({ args }) {
    const lastUpdate = args.lastUpdate ? ` (last updated: ${typeof args.lastUpdate === "string" ? args.lastUpdate : ( new Date()).toDateString()})` : "";
    const emoji = args.emoji === false ? "" : "\u{1F916} ";
    const lines = [];
    if (args.separator !== false) {
      lines.push("---", "");
    }
    lines.push(
      `_${emoji}auto updated with [automd](https://automd.unjs.io)${lastUpdate}_`
    );
    return {
      contents: lines.join("\n")
    };
  }
});

const file = defineGenerator({
  name: "file",
  async generate({ args, config, url }) {
    const fullPath = resolvePath(args.src, { url, dir: config.dir });
    let contents = await promises.readFile(fullPath, "utf8");
    if (args.code) {
      contents = mdbox.md.codeBlock(
        contents,
        args.lang || pathe.extname(fullPath).slice(1),
        {
          // prettier-ignore
          ext: args.name === false ? void 0 : typeof args.name === "string" ? args.name : `[${pathe.basename(fullPath)}]`
        }
      );
    }
    return {
      contents
    };
  }
});

const contributors = defineGenerator({
  name: "contributors",
  async generate({ config, args }) {
    const { github } = await getPkg(config.dir, args);
    if (!github) {
      throw new Error("`github` is required!");
    }
    const lines = [];
    if (typeof args.license === "string") {
      lines.push(
        `Published under the [${args.license.toUpperCase()}](https://github.com/${github}/blob/main/LICENSE) license.`
      );
    }
    let madeBy = `[community](https://github.com/${github}/graphs/contributors) \u{1F49B}`;
    if (typeof args.author === "string") {
      const authors = args.author.split(",").map((author) => author.trim()).map((user) => `[@${user}](https://github.com/${user})`).join(", ");
      if (authors.length > 0) {
        madeBy = `${authors} and ${madeBy}`;
      }
    }
    lines.push(`Made by ${madeBy}`);
    const params = [["repo", github]];
    if (args.max) {
      params.push(["max", args.max]);
    }
    if (args.anon) {
      params.push(["anon", args.anon]);
    }
    const paramsStr = params.map(([k, v]) => `${k}=${v}`).join("&");
    lines.push(
      `<br><br>`,
      `<a href="https://github.com/${github}/graphs/contributors">`,
      `<img src="https://contrib.rocks/image?${paramsStr}" />`,
      `</a>`
    );
    return {
      contents: lines.join("\n")
    };
  }
});

const builtinGenerators = {
  jsdocs,
  badges,
  "pm-i": pmInstall,
  "pm-install": pmInstall,
  "pm-x": pmX,
  fetch: fetch,
  file,
  jsimport,
  "with-automd": withAutomd,
  contributors
};

function findBlocks(md) {
  const blocks = [];
  const AUTOMD_RE = /^(?<open><!--\s*automd:(?<generator>.+?)\s+(?<args>.*?)\s*-->)(?<contents>.+?)(?<close>^<!--\s*\/automd\s*-->)/gimsu;
  for (const match of md.matchAll(AUTOMD_RE)) {
    if (match.index === void 0 || !match.groups) {
      continue;
    }
    const start = match.index + match.groups.open.length;
    const end = start + match.groups.contents.length;
    blocks.push({
      generator: match.groups.generator,
      rawArgs: match.groups.args,
      contents: match.groups.contents,
      loc: { start, end },
      _loc: { start: match.index, end: match.index + match[0].length }
    });
  }
  return blocks;
}
function containsAutomd(md) {
  return /^<!--\s*automd:/gimsu.test(md);
}
function parseRawArgs(rawArgs) {
  const args = /* @__PURE__ */ Object.create(null);
  for (const part of rawArgs.split(/\s+/)) {
    const [_key, value] = part.split("=");
    const key = _key && scule.camelCase(_key);
    if (key && value) {
      args[key] = destr.destr(value);
    } else if (part.startsWith("no-")) {
      args[part.slice(3)] = false;
    } else {
      args[part] = true;
    }
  }
  return args;
}

const RESOLVED_CONFIG_SYMBOL = Symbol("automdConfig");
function resolveConfig(config) {
  if (config && RESOLVED_CONFIG_SYMBOL in config) {
    return config;
  }
  const _config = {
    dir: ".",
    input: "README.md",
    generators: {},
    [RESOLVED_CONFIG_SYMBOL]: true,
    ...config
  };
  _config.dir = pathe.resolve(_config.dir);
  _config.input = (Array.isArray(_config.input) ? _config.input : [_config.input]).filter(Boolean);
  return _config;
}
async function loadConfig(dir = ".", overrides) {
  const { loadConfig: loadConfig2 } = await import('c12');
  dir = pathe.resolve(dir);
  const { config } = await loadConfig2({
    cwd: dir,
    name: "automd",
    dotenv: true,
    overrides,
    defaults: {
      ignore: ["**/node_modules", "**/dist", "**/.*"],
      dir
    }
  });
  return resolveConfig(config);
}

async function transform(contents, _config, url) {
  const start = performance.now();
  const config = resolveConfig(_config);
  const editor = new MagicString__default(contents);
  const updates = [];
  const generators = {
    ...builtinGenerators,
    ...config.generators
  };
  const blocks = findBlocks(contents);
  for (const block of blocks) {
    const result = await _transformBlock(block, config, generators, url);
    if (result.unwrap) {
      editor.overwrite(
        block._loc.start,
        block._loc.end,
        `${result.contents.trim()}`
      );
    } else {
      editor.overwrite(
        block.loc.start,
        block.loc.end,
        `

${result.contents.trim()}

`
      );
    }
    updates.push({ block, result });
  }
  const hasChanged = editor.hasChanged();
  const hasIssues = updates.some(
    (u) => u.result.issues?.filter(Boolean).length
  );
  const time = performance.now() - start;
  return {
    hasChanged,
    hasIssues,
    contents: hasChanged ? editor.toString() : contents,
    updates,
    time
  };
}
async function _transformBlock(block, config, generators, url) {
  const args = parseRawArgs(block.rawArgs);
  const generator = generators[block.generator];
  if (!generator) {
    const didYouMean = await import('didyoumean2').then((r) => r.default || r);
    const suggestions = didYouMean(block.generator, Object.keys(generators));
    const error = `Unknown generator:\`${block.generator}\`.${suggestions ? ` Did you mean "generator:\`${suggestions}\`"?` : ""}`;
    return {
      contents: `<!-- \u26A0\uFE0F  ${error} -->`,
      issues: [error]
    };
  }
  const context = {
    args,
    config,
    block,
    transform: (contents) => transform(contents, config, url),
    url
  };
  try {
    const result = await generator.generate(context);
    if (!result.unwrap && containsAutomd(result.contents)) {
      result.unwrap = true;
    }
    if (result.unwrap) {
      const nestedRes = await context.transform(result.contents);
      result.contents = nestedRes.contents;
      if (nestedRes.hasIssues) {
        result.issues = [
          ...result.issues || [],
          ...nestedRes.updates.flatMap((u) => u.result.issues || [])
        ].filter(Boolean);
      }
    }
    return result;
  } catch (error) {
    return {
      contents: `<!-- \u26A0\uFE0F  (${block.generator}) ${error.message || error} -->`,
      issues: [error]
    };
  }
}

async function automd(_config = {}) {
  const start = performance.now();
  const config = await loadConfig(_config.dir, _config);
  let inputFiles = config.input;
  if (inputFiles.some((i) => i.includes("*"))) {
    const { globby } = await import('globby');
    inputFiles = await globby(inputFiles, {
      cwd: config.dir,
      absolute: false,
      onlyFiles: true,
      ignore: config.ignore
    });
  } else {
    inputFiles = inputFiles.map((i) => pathe.resolve(config.dir, i)).filter((i) => node_fs.existsSync(i)).map((i) => pathe.relative(config.dir, i));
  }
  const multiFiles = inputFiles.length > 1;
  const cache = /* @__PURE__ */ new Map();
  const results = await Promise.all(
    inputFiles.map((i) => _automd(i, config, multiFiles, cache))
  );
  let unwatch;
  if (config.watch) {
    unwatch = await _watch(inputFiles, config, multiFiles, cache);
  }
  const time = performance.now() - start;
  return {
    time,
    results,
    config,
    unwatch
  };
}
async function _automd(relativeInput, config, multiFiles, cache) {
  const start = performance.now();
  const input = pathe.resolve(config.dir, relativeInput);
  const contents = await node_fs.promises.readFile(input, "utf8");
  const cachedResult = await cache.get(input);
  if (cachedResult?.contents === contents) {
    cachedResult.time = performance.now() - start;
    return cachedResult;
  }
  const transformResult = await transform(
    contents,
    config,
    mlly.pathToFileURL(input)
  );
  const output = multiFiles ? pathe.resolve(config.dir, config.output || ".", relativeInput) : pathe.resolve(config.dir, config.output || relativeInput);
  await node_fs.promises.writeFile(output, transformResult.contents, "utf8");
  const result = {
    input,
    output,
    ...transformResult
  };
  cache.set(input, result);
  result.time = performance.now() - start;
  return result;
}
async function _watch(inputFiles, config, multiFiles, cache) {
  const watcher = await import('@parcel/watcher');
  const watchCb = perfectDebounce.debounce(async (_err, events) => {
    const filesToUpdate = events.map((e) => pathe.relative(config.dir, e.path)).filter((p) => inputFiles.includes(p));
    const start = performance.now();
    const results = await Promise.all(
      filesToUpdate.map((f) => _automd(f, config, multiFiles, cache))
    );
    const time = performance.now() - start;
    if (config.onWatch) {
      config.onWatch({ results, time });
    }
  });
  const subscription = await watcher.subscribe(config.dir, watchCb, {
    ignore: config.ignore
  });
  process.on("SIGINT", () => {
    subscription.unsubscribe();
  });
  return subscription.unsubscribe;
}

exports.automd = automd;
exports.defineGenerator = defineGenerator;
exports.loadConfig = loadConfig;
exports.resolveConfig = resolveConfig;
exports.transform = transform;
