#!/usr/bin/env node
'use strict';

const pathe = require('pathe');
const citty = require('citty');
const consola = require('consola');
const utils = require('consola/utils');
const index = require('./index.cjs');
require('node:fs');
require('mlly');
require('perfect-debounce');
require('magic-string');
require('scule');
require('pkg-types');
require('defu');
require('mdbox');
require('node:fs/promises');
require('destr');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const consola__default = /*#__PURE__*/_interopDefaultCompat(consola);

const name = "automd";
const version = "0.3.12";
const description = "Your automated markdown maintainer!";

const main = citty.defineCommand({
  meta: {
    name,
    description,
    version
  },
  args: {
    dir: {
      description: "current working directory",
      type: "string"
    },
    input: {
      description: "name or path the markdown input to update",
      type: "string",
      default: "README.md"
    },
    output: {
      description: "name or path the markdown output (defaults to input)",
      type: "string"
    },
    watch: {
      description: "watch for changes in input files and regenerate output",
      type: "boolean"
    }
  },
  async setup({ args }) {
    const { results, config, time } = await index.automd({
      dir: args.dir,
      input: args.input?.split(",").map((i) => i.trim()),
      output: args.output,
      watch: args.watch,
      onWatch: (event) => {
        console.clear();
        _printResults(event.results, event.time, config);
      }
    });
    if (args.watch) {
      console.clear();
      consola__default.info(`Watching for changes in \`${args.input}\``);
    }
    if (results.length === 0) {
      consola__default.warn(`No files processed!`);
      process.exit(1);
    }
    _printResults(results, time, config);
  }
});
citty.runMain(main);
const _types = {
  updated: { label: "updated", color: "blue" },
  noChanges: { label: "no changes", color: "gray" },
  alreadyUpdate: { label: "already up-to-date", color: "green" },
  issues: { label: "with issues", color: "yellow" }
};
function _printResults(results, time, config) {
  const rDir = pathe.relative(process.cwd(), config.dir);
  consola__default.success(
    `Automd updated${rDir ? ` in \`${rDir}\` dir` : ""} ${_formatTime(time)}
`
  );
  for (const res of results) {
    const type = _getChangeType(res);
    const input = pathe.relative(config.dir, res.input);
    const output = pathe.relative(config.dir, res.output);
    const name2 = `${input === output ? `  ${input}` : `  ${input} ~> ${output}`}`;
    consola__default.log(
      utils.colorize(
        type.color,
        `  \u2500  ${name2} ${type.label} ${_formatTime(res.time)}`
      )
    );
  }
  const issues = results.filter((res) => res.hasIssues).map((res) => _formatIssues(res, config));
  if (issues.length > 0) {
    consola__default.warn(`Some issues happened during automd update:`);
    for (const issue of issues) {
      consola__default.log(issue);
    }
  }
  consola__default.log("");
}
function _getChangeType(res) {
  if (res.updates.length === 0) {
    return _types.noChanges;
  }
  if (res.hasIssues) {
    return _types.issues;
  }
  return res.hasChanged ? _types.updated : _types.alreadyUpdate;
}
function _formatIssues(res, config) {
  return `${utils.colorize(_types.issues.color, pathe.relative(config.dir, res.input))} 

 ${res.updates.flatMap((u) => u.result.issues).join("\n")}`;
}
function _formatTime(time) {
  return utils.colorize("gray", `(${Math.round(time * 100) / 100 + "ms"})`);
}
