import * as viem from 'viem';
import { Address, Hex, Hash, Chain, Account, Client, Transport, ChainContract } from 'viem';
import { SendRawTransactionParameters, SendRawTransactionErrorType } from 'viem/actions';
export { SendRawTransactionErrorType, SendRawTransactionParameters } from 'viem/actions';
import { ZkSyncRpcLog } from 'viem/zksync';
import { T as TimeDirection, S as SecondsSinceEpoch, a as TxHistoryRequest, C as ContractCreationAddresses, b as TokenTxHistoryRequest } from '../types-CcyQzLXZ.cjs';
export { c as PagingInformation, P as PagingResult } from '../types-CcyQzLXZ.cjs';
import { Prettify, Assign } from 'viem/chains';

type StorageEntry = {
    address: Address;
    key: Hex;
    writtenValue: Hex;
};
type SendRawTransactionDetails = {
    transactionHash: Hash;
    storageLogs: StorageEntry[];
    events: ZkSyncRpcLog[];
};
type ContractsCreationResult = {
    contractAddress: Address;
    contractCreator: Address;
    txHash: Hex;
};
type TokenInfoResult = {
    contractAddress: Address;
    tokenName: string;
    symbol: string;
    tokenDecimal: number;
    tokenPriceUSD: string | null;
    liquidity: string | null;
    l1Address: Address | null;
    iconURL: string | null;
};
type TxHistoryItem = {
    /**
     * The transaction hash.
     */
    hash: Hash;
    to: Address;
    from: Address;
    transactionIndex: Hex;
    input: Hex;
    value: Hex;
    gas: Hex;
    gasPrice: Hex;
    gasUsed: Hex;
    cumulativeGasUsed: Hex;
    fee: Hex;
    nonce: Hex;
    confirmations: Hex;
    blockNumber: Hex;
    blockHash: Hash;
    /**
     * Timestamp in seconds since the Unix epoch.
     */
    timeStamp: Hex;
    commitTxHash: Hash | null;
    proveTxHash: Hash | null;
    executeTxHash: Hash | null;
    isL1Originated: Hex;
    l1BatchNumber: Hex;
    contractAddress: Address | null;
    isError: Hex;
    txreceipt_status: Hex;
    methodId: Hex;
    functionName: string;
    type: Hex;
};
type TokenTxHistoryItem = {
    hash: Hash;
    to: Address;
    from: Address;
    transactionIndex: Hex;
    input: Hex;
    value: Hex | null;
    gas: Hex;
    gasPrice: Hex;
    gasUsed: Hex;
    cumulativeGasUsed: Hex;
    fee: Hex;
    nonce: Hex;
    confirmations: Hex;
    blockNumber: Hex;
    blockHash: Hash;
    l1BatchNumber: Hex;
    timeStamp: Hex;
    contractAddress: Address;
    tokenId: string | null;
    tokenName: string | null;
    tokenSymbol: string | null;
    tokenDecimal: string | null;
    transactionType: Hex;
};
type TokenBalanceRequest = {
    address: Address;
    contractAddress: Address;
};
type PublicLensNetworkRpcSchema = [
    {
        Method: 'zks_sendRawTransactionWithDetailedOutput';
        Parameters: [Hex];
        ReturnType: SendRawTransactionDetails;
    },
    {
        Method: 'lens_getBlockNumberByTime';
        Parameters: [TimeDirection, SecondsSinceEpoch];
        ReturnType: Hex;
    },
    {
        Method: 'lens_getTxHistory';
        Parameters: [TxHistoryRequest<Address>];
        ReturnType: readonly TxHistoryItem[];
    },
    {
        Method: 'lens_getContractCreation';
        Parameters: ContractCreationAddresses<Address>;
        ReturnType: readonly ContractsCreationResult[] | null;
    },
    {
        Method: 'lens_getTokenInfo';
        Parameters: [string];
        ReturnType: TokenInfoResult | null;
    },
    {
        Method: 'lens_getTokenTxHistory';
        Parameters: [TokenTxHistoryRequest<Address>];
        ReturnType: readonly TokenTxHistoryItem[];
    },
    {
        Method: 'lens_getNftTxHistory';
        Parameters: [TokenTxHistoryRequest<Address>];
        ReturnType: readonly TokenTxHistoryItem[];
    },
    {
        Method: 'lens_getContractABI';
        Parameters: [string];
        ReturnType: string;
    },
    {
        Method: 'lens_getTokenBalance';
        Parameters: [TokenBalanceRequest];
        ReturnType: string;
    }
];

type SendRawTransactionWithDetailedOutputParameters = SendRawTransactionParameters;
type SendRawTransactionWithDetailedOutputReturnType = SendRawTransactionDetails;
type SendRawTransactionWithDetailedOutputErrorType = SendRawTransactionErrorType;
/**
 * Executes a transaction and returns its hash, storage logs, and events that would have
 * been generated if the transaction had already been included in the block.
 *
 * @param client - Client to use
 * @param parameters - {@link SendRawTransactionWithDetailedOutputParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash, storage logs, and events. {@link SendRawTransactionWithDetailedOutputReturnType}
 *
 * @example
 * ```ts
 * import { createWalletClient, Hex, http, privateKeyToAccount } from 'viem';
 * import { chains, sendRawTransactionWithDetailedOutput } from '@lens-network/sdk/viem';
 *
 * const account = privateKeyToAccount(process.env.PRIVATE_KEY as Hex);
 *
 * const walletClient = createWalletClient({
 *   account,
 *   chain: chains.testnet,
 *   transport: http(),
 * });
 *
 * const result = await sendRawTransactionWithDetailedOutput(client, {
 *   serializedTransaction: '0x02f8500182031180…',
 * });
 * ```
 */
declare function sendRawTransactionWithDetailedOutput<TChain extends Chain | undefined, TAccount extends Account | undefined>(client: Client<Transport, TChain, TAccount, PublicLensNetworkRpcSchema>, { serializedTransaction }: SendRawTransactionWithDetailedOutputParameters): Promise<SendRawTransactionWithDetailedOutputReturnType>;

type LensNetworkChain = Prettify<Assign<Chain, {
    contracts: {
        multicall3: ChainContract;
        erc20Factory: ChainContract;
        erc721Factory: ChainContract;
    };
}>>;
declare const testnet: {
    blockExplorers?: {
        [key: string]: {
            name: string;
            url: string;
            apiUrl?: string | undefined;
        };
        default: {
            name: string;
            url: string;
            apiUrl?: string | undefined;
        };
    } | undefined;
    contracts: {
        multicall3: ChainContract;
        erc20Factory: ChainContract;
        erc721Factory: ChainContract;
    };
    id: number;
    name: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: {
        [key: string]: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
    };
    sourceId?: number | undefined;
    testnet?: boolean | undefined;
    custom?: Record<string, unknown> | undefined;
    fees?: viem.ChainFees<viem.ChainFormatters | undefined> | undefined;
    formatters?: viem.ChainFormatters | undefined;
    serializers?: viem.ChainSerializers<viem.ChainFormatters | undefined, viem.TransactionSerializable> | undefined;
};

type chains_LensNetworkChain = LensNetworkChain;
declare const chains_testnet: typeof testnet;
declare namespace chains {
  export { type chains_LensNetworkChain as LensNetworkChain, chains_testnet as testnet };
}

type WalletActions = {
    /**
     * Create an ERC-20 contract with the given parameters.
     *
     * @param client - Client to use
     * @param parameters - {@link CreateErc20Parameters}
     * @returns The newly created ERC-20 contract address. {@link CreateErc20ReturnType}
     *
     * @example
     * ```ts
     * import { createWalletClient, Hex, http, privateKeyToAccount } from 'viem';
     * import { chains, walletActions } from '@lens-network/sdk/viem';
     *
     * const account = privateKeyToAccount(process.env.PRIVATE_KEY as Hex);
     *
     * export const walletClient = createWalletClient({
     *   account,
     *   chain: chains.testnet,
     *   transport: http(),
     * }).extend(walletActions());
     *
     * const tokenAddress = await client.createErc20({
     *   initialOwner: account.address,
     *   initialSupply: 100_000_000_000_000_000_000n,
     *   name: 'SDK Test Token',
     *   symbol: 'SDK',
     * });
     *
     * // tokenAddress: 0x…
     * ```
     */
    /**
     * Create an ERC-721 contract with the given parameters.
     *
     * @param client - Client to use
     * @param parameters - {@link CreateErc20Parameters}
     * @returns The newly created ERC-721 contract address. {@link CreateErc20ReturnType}
     *
     * @example
     * ```ts
     * import { createWalletClient, Hex, http, privateKeyToAccount } from 'viem';
     * import { chains, walletActions } from '@lens-network/sdk/viem';
     *
     * const account = privateKeyToAccount(process.env.PRIVATE_KEY as Hex);
     *
     * export const walletClient = createWalletClient({
     *   account,
     *   chain: chains.testnet,
     *   transport: http(),
     * }).extend(walletActions());
     *
     * const tokenAddress = await client.createErc721({
     *   initialOwner: account.address,
     *   maxSupply: 100n,
     *   name: 'My collection',
     *   symbol: 'SDK',
     * });
     *
     * // tokenAddress: 0x…
     * ```
     */
    /**
     * Executes a transaction and returns its hash, storage logs, and events that would have
     * been generated if the transaction had already been included in the block.
     *
     * @param params - {@link SendRawTransactionWithDetailedOutputParameters}
     * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash, storage logs, and events. {@link SendRawTransactionWithDetailedOutputReturnType}
     *
     * @example
     * ```ts
     * import { createWalletClient, Hex, http, privateKeyToAccount } from 'viem';
     * import { chains, walletActions } from '@lens-network/sdk/viem';
     *
     * const account = privateKeyToAccount(process.env.PRIVATE_KEY as Hex);
     *
     * export const walletClient = createWalletClient({
     *   account,
     *   chain: chains.testnet,
     *   transport: http(),
     * }).extend(walletActions());
     *
     * const result = await client.sendRawTransactionWithDetailedOutput({
     *   serializedTransaction: '0x02f8500182031180…',
     * });
     * ```
     */
    sendRawTransactionWithDetailedOutput: (params: SendRawTransactionWithDetailedOutputParameters) => Promise<SendRawTransactionWithDetailedOutputReturnType>;
};
declare function walletActions(): <TChain extends LensNetworkChain = {
    blockExplorers?: {
        [key: string]: {
            name: string;
            url: string;
            apiUrl?: string | undefined;
        };
        default: {
            name: string;
            url: string;
            apiUrl?: string | undefined;
        };
    } | undefined;
    contracts: {
        multicall3: viem.ChainContract;
        erc20Factory: viem.ChainContract;
        erc721Factory: viem.ChainContract;
    };
    id: number;
    name: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: {
        [key: string]: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
        default: {
            http: readonly string[];
            webSocket?: readonly string[] | undefined;
        };
    };
    sourceId?: number | undefined;
    testnet?: boolean | undefined;
    custom?: Record<string, unknown> | undefined;
    fees?: viem.ChainFees<viem.ChainFormatters | undefined> | undefined;
    formatters?: viem.ChainFormatters | undefined;
    serializers?: viem.ChainSerializers<viem.ChainFormatters | undefined, viem.TransactionSerializable> | undefined;
}, TAccount extends Account | undefined = Account | undefined>(client: Client<Transport, TChain, TAccount>) => WalletActions;

export { type ContractsCreationResult, type PublicLensNetworkRpcSchema, SecondsSinceEpoch, type SendRawTransactionDetails, type SendRawTransactionWithDetailedOutputErrorType, type SendRawTransactionWithDetailedOutputParameters, type SendRawTransactionWithDetailedOutputReturnType, type StorageEntry, TimeDirection, type TokenBalanceRequest, type TokenInfoResult, type TokenTxHistoryItem, type TxHistoryItem, type WalletActions, chains, sendRawTransactionWithDetailedOutput, walletActions };
