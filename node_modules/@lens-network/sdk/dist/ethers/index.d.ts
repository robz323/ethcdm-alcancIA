import { ethers, JsonRpcPayload, JsonRpcResult, JsonRpcError } from 'ethers';
import * as zksync from 'zksync-ethers';
import { P as PagingResult, A as AddEthereumChainParameter } from '../types-CcyQzLXZ.js';
export { S as SecondsSinceEpoch, T as TimeDirection } from '../types-CcyQzLXZ.js';

type DeployedContracts = {
    multicall3: `0x${string}`;
    WETH: `0x${string}`;
    WGRASS: `0x${string}`;
    erc20Factory: `0x${string}`;
    erc721Factory: `0x${string}`;
};

/**
 * Network types.
 */
declare enum Network {
    Mainnet = NaN,
    Testnet
}
type StorageEntry = {
    address: string;
    key: string;
    writtenValue: string;
};
type OptimisticLog = {
    /**
     *  The transaction hash for the transaction the log occurred in.
     */
    transactionHash: string;
    /**
     *  The address of the contract that emitted this log.
     */
    address: string;
    /**
     *  The data emitted with this log.
     */
    data: string;
    /**
     *  The topics emitted with this log.
     */
    topics: ReadonlyArray<string>;
    /**
     * The batch number on L1.
     * */
    readonly l1BatchNumber: null | number;
    /**
     * No block hash for optimistic logs.
     */
    readonly blockHash: null;
    /**
     * No block number for optimistic logs.
     */
    readonly blockNumber: null;
    /**
     * No log index for optimistic logs.
     */
    readonly logIndex: null;
    /**
     * No transaction index for optimistic logs.
     */
    readonly transactionIndex: null;
    /**
     * Never removed.
     */
    readonly removed: false;
};
type SendRawTransactionDetails = {
    transactionHash: string;
    storageLogs: StorageEntry[];
    events: OptimisticLog[];
};
type TxHistoryItem = {
    /**
     * The transaction hash.
     */
    hash: string;
    to: string;
    from: string;
    transactionIndex: string;
    input: string;
    value: string;
    gas: string;
    gasPrice: string;
    gasUsed: string;
    cumulativeGasUsed: string;
    fee: string;
    nonce: string;
    confirmations: string;
    blockNumber: string;
    blockHash: string;
    /**
     * Timestamp in seconds since the Unix epoch.
     */
    timeStamp: string;
    commitTxHash: string | null;
    proveTxHash: string | null;
    executeTxHash: string | null;
    isL1Originated: string;
    l1BatchNumber: string;
    contractAddress: string | null;
    isError: string;
    txreceipt_status: string;
    methodId: string;
    functionName: string;
    type: string;
};
type TxHistoryResponse = PagingResult<TxHistoryItem>;
type ContractsCreationResult = {
    contractAddress: string;
    contractCreator: string;
    txHash: string;
};
type ContractCreationResponse = ReadonlyArray<ContractsCreationResult>;
type TokenInfoResult = {
    contractAddress: string;
    tokenName: string;
    symbol: string;
    tokenDecimal: number;
    tokenPriceUSD: string | null;
    liquidity: string | null;
    l1Address: string | null;
    iconURL: string | null;
};
type TokenTxHistoryItem = {
    hash: string;
    to: string;
    from: string;
    transactionIndex: string;
    input: string;
    value: string | null;
    gas: string;
    gasPrice: string;
    gasUsed: string;
    cumulativeGasUsed: string;
    fee: string;
    nonce: string;
    confirmations: string;
    blockNumber: string;
    blockHash: string;
    l1BatchNumber: string;
    timeStamp: string;
    contractAddress: string;
    tokenID: string | null;
    tokenName: string | null;
    tokenSymbol: string | null;
    tokenDecimal: string | null;
    transactionType: string;
};
type TokenTxHistoryResponse = PagingResult<TokenTxHistoryItem>;

declare const Provider_base: {
    new (...args: any[]): {
        /**
         * Executes a transaction and returns its hash, storage logs, and events that would have
         * been generated if the transaction had already been included in the block.
         *
         * @param serializedTransaction - The serialized transaction to send.
         * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash, storage logs, and events. {@link SendRawTransactionDetails}
         */
        sendRawTransactionWithDetailedOutput(serializedTransaction: string): Promise<SendRawTransactionDetails>;
        "__#6042@#private": any;
        _getOption<K extends keyof ethers.JsonRpcApiProviderOptions>(key: K): ethers.JsonRpcApiProviderOptions[K];
        readonly _network: ethers.Network;
        _send: ((payload: JsonRpcPayload | Array<JsonRpcPayload>) => Promise<Array<JsonRpcResult | JsonRpcError>>) & ((payload: JsonRpcPayload | Array<JsonRpcPayload>) => Promise<Array<JsonRpcResult | JsonRpcError>>);
        _perform(req: ethers.PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<ethers.Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        _getSubscriber(sub: ethers.Subscription): ethers.Subscriber;
        readonly ready: boolean;
        getRpcTransaction(tx: ethers.TransactionRequest): ethers.JsonRpcTransactionRequest;
        getRpcRequest(req: ethers.PerformActionRequest): null | {
            method: string;
            args: Array<any>;
        };
        getRpcError(payload: JsonRpcPayload, _error: JsonRpcError): Error;
        send(method: string, params: Array<any> | Record<string, any>): Promise<any>;
        getSigner(address?: number | string): Promise<ethers.JsonRpcSigner>;
        listAccounts(): Promise<Array<ethers.JsonRpcSigner>>;
        destroy(): void;
        "__#6039@#private": any;
        readonly pollingInterval: number;
        readonly provider: any;
        readonly plugins: ethers.AbstractProviderPlugin[];
        attachPlugin(plugin: ethers.AbstractProviderPlugin): any;
        getPlugin<T extends ethers.AbstractProviderPlugin = ethers.AbstractProviderPlugin>(name: string): null | T;
        disableCcipRead: boolean;
        ccipReadFetch(tx: ethers.PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string>;
        _wrapBlock(value: ethers.BlockParams, network: ethers.Network): ethers.Block;
        _wrapLog(value: ethers.LogParams, network: ethers.Network): ethers.Log;
        _wrapTransactionReceipt(value: ethers.TransactionReceiptParams, network: ethers.Network): ethers.TransactionReceipt;
        _wrapTransactionResponse(tx: ethers.TransactionResponseParams, network: ethers.Network): ethers.TransactionResponse;
        getBlockNumber(): Promise<number>;
        _getAddress(address: ethers.AddressLike): string | Promise<string>;
        _getBlockTag(blockTag?: ethers.BlockTag): string | Promise<string>;
        _getFilter(filter: ethers.Filter | ethers.FilterByBlockHash): ethers.PerformActionFilter | Promise<ethers.PerformActionFilter>;
        _getTransactionRequest(_request: ethers.TransactionRequest): ethers.PerformActionTransaction | Promise<ethers.PerformActionTransaction>;
        getNetwork(): Promise<ethers.Network>;
        getFeeData(): Promise<ethers.FeeData>;
        estimateGas(_tx: ethers.TransactionRequest): Promise<bigint>;
        call(_tx: ethers.TransactionRequest): Promise<string>;
        getBalance(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<bigint>;
        getTransactionCount(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<number>;
        getCode(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<string>;
        getStorage(address: ethers.AddressLike, _position: ethers.BigNumberish, blockTag?: ethers.BlockTag): Promise<string>;
        broadcastTransaction(signedTx: string): Promise<ethers.TransactionResponse>;
        getBlock(block: ethers.BlockTag | string, prefetchTxs?: boolean): Promise<null | ethers.Block>;
        getTransaction(hash: string): Promise<null | ethers.TransactionResponse>;
        getTransactionReceipt(hash: string): Promise<null | ethers.TransactionReceipt>;
        getTransactionResult(hash: string): Promise<null | string>;
        getLogs(_filter: ethers.Filter | ethers.FilterByBlockHash): Promise<Array<ethers.Log>>;
        _getProvider(chainId: number): ethers.AbstractProvider;
        getResolver(name: string): Promise<null | ethers.EnsResolver>;
        getAvatar(name: string): Promise<null | string>;
        resolveName(name: string): Promise<null | string>;
        lookupAddress(address: string): Promise<null | string>;
        waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | ethers.TransactionReceipt>;
        waitForBlock(blockTag?: ethers.BlockTag): Promise<ethers.Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number): number;
        _forEachSubscriber(func: (s: ethers.Subscriber) => void): void;
        _recoverSubscriber(oldSub: ethers.Subscriber, newSub: ethers.Subscriber): void;
        on(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        once(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        emit(event: ethers.ProviderEvent, ...args: Array<any>): Promise<boolean>;
        listenerCount(event?: ethers.ProviderEvent): Promise<number>;
        listeners(event?: ethers.ProviderEvent): Promise<Array<ethers.Listener>>;
        off(event: ethers.ProviderEvent, listener?: ethers.Listener): Promise<any>;
        removeAllListeners(event?: ethers.ProviderEvent): Promise<any>;
        addListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        removeListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        readonly destroyed: boolean;
        paused: boolean;
        pause(dropWhilePaused?: boolean): void;
        resume(): void;
    };
    /**
     * @deprecated Use `getDefaultProvider` from `@lens-network/sdk/ethers` instead.
     * @internal
     */
    getDefaultProvider(_: unknown): typeof zksync.Provider;
} & typeof zksync.Provider;
/**
 * A `Provider` extends {@link zksync.Provider} and over time it will include additional features for interacting with the Lens Network.
 *
 * It supports RPC methods within the `zks` and namespaces.
 */
declare class Provider extends Provider_base {
    /**
     * @inheritDoc
     *
     * @example
     * ```ts
     * import { Provider, Network } from '@lens-network/sdk/ethers';
     *
     * const provider = getDefaultProvider(Network.Testnet);
     *
     * const signedTransaction = '0x02f8500182031180…';
     * const result = await provider.sendRawTransactionWithDetailedOutput(signedTransaction);
     * ```
     */
    sendRawTransactionWithDetailedOutput(serializedTransaction: string): Promise<SendRawTransactionDetails>;
}
declare const BrowserProvider_base: {
    new (...args: any[]): {
        /**
         * Executes a transaction and returns its hash, storage logs, and events that would have
         * been generated if the transaction had already been included in the block.
         *
         * @param serializedTransaction - The serialized transaction to send.
         * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash, storage logs, and events. {@link SendRawTransactionDetails}
         */
        sendRawTransactionWithDetailedOutput(serializedTransaction: string): Promise<SendRawTransactionDetails>;
        "__#6042@#private": any;
        _getOption<K extends keyof ethers.JsonRpcApiProviderOptions>(key: K): ethers.JsonRpcApiProviderOptions[K];
        readonly _network: ethers.Network;
        _send: ((payload: JsonRpcPayload | Array<JsonRpcPayload>) => Promise<Array<JsonRpcResult | JsonRpcError>>) & ((payload: JsonRpcPayload | Array<JsonRpcPayload>) => Promise<Array<JsonRpcResult | JsonRpcError>>);
        _perform(req: ethers.PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<ethers.Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        _getSubscriber(sub: ethers.Subscription): ethers.Subscriber;
        readonly ready: boolean;
        getRpcTransaction(tx: ethers.TransactionRequest): ethers.JsonRpcTransactionRequest;
        getRpcRequest(req: ethers.PerformActionRequest): null | {
            method: string;
            args: Array<any>;
        };
        getRpcError(payload: JsonRpcPayload, _error: JsonRpcError): Error;
        send(method: string, params: Array<any> | Record<string, any>): Promise<any>;
        getSigner(address?: number | string): Promise<ethers.JsonRpcSigner>;
        listAccounts(): Promise<Array<ethers.JsonRpcSigner>>;
        destroy(): void;
        "__#6039@#private": any;
        readonly pollingInterval: number;
        readonly provider: any;
        readonly plugins: ethers.AbstractProviderPlugin[];
        attachPlugin(plugin: ethers.AbstractProviderPlugin): any;
        getPlugin<T extends ethers.AbstractProviderPlugin = ethers.AbstractProviderPlugin>(name: string): null | T;
        disableCcipRead: boolean;
        ccipReadFetch(tx: ethers.PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string>;
        _wrapBlock(value: ethers.BlockParams, network: ethers.Network): ethers.Block;
        _wrapLog(value: ethers.LogParams, network: ethers.Network): ethers.Log;
        _wrapTransactionReceipt(value: ethers.TransactionReceiptParams, network: ethers.Network): ethers.TransactionReceipt;
        _wrapTransactionResponse(tx: ethers.TransactionResponseParams, network: ethers.Network): ethers.TransactionResponse;
        getBlockNumber(): Promise<number>;
        _getAddress(address: ethers.AddressLike): string | Promise<string>;
        _getBlockTag(blockTag?: ethers.BlockTag): string | Promise<string>;
        _getFilter(filter: ethers.Filter | ethers.FilterByBlockHash): ethers.PerformActionFilter | Promise<ethers.PerformActionFilter>;
        _getTransactionRequest(_request: ethers.TransactionRequest): ethers.PerformActionTransaction | Promise<ethers.PerformActionTransaction>;
        getNetwork(): Promise<ethers.Network>;
        getFeeData(): Promise<ethers.FeeData>;
        estimateGas(_tx: ethers.TransactionRequest): Promise<bigint>;
        call(_tx: ethers.TransactionRequest): Promise<string>;
        getBalance(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<bigint>;
        getTransactionCount(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<number>;
        getCode(address: ethers.AddressLike, blockTag?: ethers.BlockTag): Promise<string>;
        getStorage(address: ethers.AddressLike, _position: ethers.BigNumberish, blockTag?: ethers.BlockTag): Promise<string>;
        broadcastTransaction(signedTx: string): Promise<ethers.TransactionResponse>;
        getBlock(block: ethers.BlockTag | string, prefetchTxs?: boolean): Promise<null | ethers.Block>;
        getTransaction(hash: string): Promise<null | ethers.TransactionResponse>;
        getTransactionReceipt(hash: string): Promise<null | ethers.TransactionReceipt>;
        getTransactionResult(hash: string): Promise<null | string>;
        getLogs(_filter: ethers.Filter | ethers.FilterByBlockHash): Promise<Array<ethers.Log>>;
        _getProvider(chainId: number): ethers.AbstractProvider;
        getResolver(name: string): Promise<null | ethers.EnsResolver>;
        getAvatar(name: string): Promise<null | string>;
        resolveName(name: string): Promise<null | string>;
        lookupAddress(address: string): Promise<null | string>;
        waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | ethers.TransactionReceipt>;
        waitForBlock(blockTag?: ethers.BlockTag): Promise<ethers.Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number): number;
        _forEachSubscriber(func: (s: ethers.Subscriber) => void): void;
        _recoverSubscriber(oldSub: ethers.Subscriber, newSub: ethers.Subscriber): void;
        on(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        once(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        emit(event: ethers.ProviderEvent, ...args: Array<any>): Promise<boolean>;
        listenerCount(event?: ethers.ProviderEvent): Promise<number>;
        listeners(event?: ethers.ProviderEvent): Promise<Array<ethers.Listener>>;
        off(event: ethers.ProviderEvent, listener?: ethers.Listener): Promise<any>;
        removeAllListeners(event?: ethers.ProviderEvent): Promise<any>;
        addListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        removeListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        readonly destroyed: boolean;
        paused: boolean;
        pause(dropWhilePaused?: boolean): void;
        resume(): void;
    };
    /**
     * @deprecated Use `getDefaultProvider` from `@lens-network/sdk/ethers` instead.
     * @internal
     */
    getDefaultProvider(_: unknown): typeof zksync.BrowserProvider;
} & typeof zksync.BrowserProvider;
/**
 * A `BrowserProvider` extends {@link zksync.BrowserProvider} and includes additional features for interacting with the Lens Network.
 *
 * It supports RPC methods within the `zks` and `lens` namespaces.
 *
 * This provider is designed for frontend use in a browser environment and integration for browser wallets
 * (e.g., MetaMask, WalletConnect).
 */
declare class BrowserProvider extends BrowserProvider_base {
    /**
     * @inheritDoc
     *
     * @example
     * ```ts
     * import { BrowserProvider } from '@lens-network/sdk/ethers';
     *
     * const provider = new BrowserProvider(window.ethereum);
     *
     * const signedTransaction = '0x02f8500182031180…';
     * const result = await provider.sendRawTransactionWithDetailedOutput(signedTransaction);
     * ```
     */
    sendRawTransactionWithDetailedOutput(serializedTransaction: string): Promise<SendRawTransactionDetails>;
}

/**
 * Returns a default provider for the `network`.
 *
 * If `network` is a string that begins with `"http:"` or `"https:"`,
 * a `Provider` is returned connected to that URL.
 *
 * @example
 * ```ts
 * import { getDefaultProvider, Network } from '@lens-network/sdk/ethers';
 *
 * const provider = getDefaultProvider(Network.Testnet); // Lens Network testnet (L2)
 * ```
 */
declare function getDefaultProvider(network: Network): Provider;

declare const testnet: AddEthereumChainParameter;

declare const chains_AddEthereumChainParameter: typeof AddEthereumChainParameter;
declare const chains_testnet: typeof testnet;
declare namespace chains {
  export { chains_AddEthereumChainParameter as AddEthereumChainParameter, chains_testnet as testnet };
}

type Erc20TokenParams = {
    initialOwner: string;
    initialSupply: ethers.BigNumberish;
    name: string;
    symbol: string;
};
type Erc721TokenParams = {
    initialOwner: string;
    maxSupply: ethers.BigNumberish;
    name: string;
    symbol: string;
};
declare const Wallet_base: {
    new (...args: any[]): {
        /**
         * Create an ERC-20 contract with the given parameters.
         *
         * @params params - The parameters to create the ERC-20 contract.
         * @returns The ERC-20 contract address.
         */
        experimental_createErc20(params: Erc20TokenParams): Promise<string>;
        /**
         * Create an ERC-721 contract with the given parameters.
         *
         * @params params - The parameters to create the ERC-721 contract.
         * @returns The ERC-721 contract address.
         */
        experimental_createErc721(params: Erc721TokenParams): Promise<string>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
        _signerL2(): ethers.Signer;
        _providerL2(): zksync.Provider;
    };
} & typeof zksync.Wallet;
/**
 * A `Wallet` is an extension of {@link zksync.Wallet} with additional features for interacting with Lens Network.
 * It facilitates bridging assets between different networks.
 * All transactions must originate from the address corresponding to the provided private key.
 */
declare class Wallet extends Wallet_base {
    /**
     * @inheritdoc
     *
     * @example
     * ```ts
     * import { getDefaultProvider, Network, Wallet } from '@lens-network/sdk/ethers';
     *
     * const provider = getDefaultProvider(Network.Testnet);
     *
     * const wallet = new Wallet(process.env.PRIVATE_KEY, provider);
     *
     * const address = await wallet.experimental_createErc20({
     *   initialOwner: wallet.address,
     *   initialSupply: 100_000_000_000_000_000_000n,
     *   name: 'SDK Test Token',
     *   symbol: 'SDK',
     * });
     * ```
     */
    experimental_createErc20(params: Erc20TokenParams): Promise<string>;
    /**
     * @inheritdoc
     *
     * @example
     * ```ts
     * import { getDefaultProvider, Network, Wallet } from '@lens-network/sdk/ethers';
     *
     * const provider = getDefaultProvider(Network.Testnet);
     *
     * const wallet = new Wallet(process.env.PRIVATE_KEY, provider);
     *
     * const address = await wallet.createErc721({
     *   initialOwner: wallet.address,
     *   maxSupply: 100,
     *   name: 'My Collection',
     *   symbol: 'SDK',
     * });
     * ```
     */
    experimental_createErc721(params: Erc721TokenParams): Promise<string>;
    /**
     * Connects to the Lens Network using `provider`.
     *
     * @param provider The provider instance for connecting to an L2 network.
     *
     * @see {@link connectToL1} in order to connect to L1 network.
     *
     * @example
     * ```ts
     * import { getDefaultProvider, Network, Wallet } from '@lens-network/sdk/ethers';
     *
     * const unconnectedWallet = new Wallet(process.env.PRIVATE_KEY,
     *
     * const provider = getDefaultProvider(Network.Testnet);
     * const wallet = unconnectedWallet.connect(provider);
     * ```
     */
    connect(provider: Provider): zksync.Wallet;
}
declare const Signer_base: {
    new (...args: any[]): {
        /**
         * Create an ERC-20 contract with the given parameters.
         *
         * @params params - The parameters to create the ERC-20 contract.
         * @returns The ERC-20 contract address.
         */
        experimental_createErc20(params: Erc20TokenParams): Promise<string>;
        /**
         * Create an ERC-721 contract with the given parameters.
         *
         * @params params - The parameters to create the ERC-721 contract.
         * @returns The ERC-721 contract address.
         */
        experimental_createErc721(params: Erc721TokenParams): Promise<string>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
        _signerL2(): ethers.Signer;
        _providerL2(): zksync.Provider;
    };
} & typeof zksync.Signer;
/**
 * A `Signer` is designed for frontend use with browser wallet injection (e.g., MetaMask),
 * providing only Lens Network (L2) operations.
 *
 * @see {@link zksync.L1Signer} for L1 operations.
 */
declare class Signer extends Signer_base {
    /**
     * @inheritdoc
     *
     * @example
     * ```ts
     * import { BrowserProvider, getDefaultProvider, Network } from '@lens-network/sdk/ethers';
     *
     * const browserProvider = new BrowserProvider(window.ethereum);
     * const lensProvider = getDefaultProvider(Network.Testnet);
     *
     * const network = await browserProvider.getNetwork();
     *
     * const signer = Signer.from(
     *   await browserProvider.getSigner(),
     *   Number(network.chainId),
     *   lensProvider,
     * );
     *
     * const address = await signer.experimental_createErc20({
     *   initialOwner: signer.address,
     *   initialSupply: 100_000_000_000_000_000_000n,
     *   name: 'SDK Test Token',
     *   symbol: 'SDK',
     * });
     * ```
     */
    experimental_createErc20(params: Erc20TokenParams): Promise<string>;
    /**
     * @inheritdoc
     *
     * @example
     * ```ts
     * import { BrowserProvider, getDefaultProvider, Network } from '@lens-network/sdk/ethers';
     *
     * const browserProvider = new BrowserProvider(window.ethereum);
     * const lensProvider = getDefaultProvider(Network.Testnet);
     *
     * const network = await browserProvider.getNetwork();
     *
     * const signer = Signer.from(
     *   await browserProvider.getSigner(),
     *   Number(network.chainId),
     *   lensProvider,
     * );
     *
     * const address = await signer.experimental_createErc721({
     *   initialOwner: signer.address,
     *   maxSupply: 100,
     *   name: 'My Collection',
     *   symbol: 'SDK',
     * });
     * ```
     */
    experimental_createErc721(params: Erc721TokenParams): Promise<string>;
    /**
     * Creates a new Singer with provided `signer` and `chainId`.
     *
     * @param signer The signer from browser wallet.
     * @param chainId The chain ID of the network.
     * @param lensProvider The provider instance for connecting to the Lens Network. If not provided,
     * the methods from the `zks` and `lens` namespace are not supported, and interaction with them
     * will result in an error.
     *
     * @example
     * ```ts
     * import { BrowserProvider, getDefaultProvider, Network } from '@lens-network/sdk/ethers';
     *
     * const browserProvider = new BrowserProvider(window.ethereum);
     * const lensProvider = getDefaultProvider(Network.Testnet);
     *
     * const network = await browserProvider.getNetwork();
     *
     * const signer = Signer.from(
     *   await browserProvider.getSigner(),
     *   Number(network.chainId),
     *   lensProvider,
     * );
     * ```
     */
    static from(signer: ethers.JsonRpcSigner & {
        provider: Provider;
    }, chainId: number, lensProvider?: Provider): Signer;
}

export { BrowserProvider, type ContractCreationResponse, type ContractsCreationResult, type DeployedContracts, type Erc20TokenParams, type Erc721TokenParams, Network, type OptimisticLog, PagingResult, Provider, type SendRawTransactionDetails, Signer, type StorageEntry, type TokenInfoResult, type TokenTxHistoryItem, type TokenTxHistoryResponse, type TxHistoryItem, type TxHistoryResponse, Wallet, chains, getDefaultProvider };
