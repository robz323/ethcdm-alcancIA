"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosSigner = exports.getAptosSigner = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const platform_js_1 = require("./platform.js");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
// returns a SignOnlySigner for the Aptos platform
async function getAptosSigner(rpc, privateKey) {
    const [_, chain] = await platform_js_1.AptosPlatform.chainFromRpc(rpc);
    const account = ts_sdk_1.Account.fromPrivateKey({
        // TODO: support secp256k1
        privateKey: new ts_sdk_1.Ed25519PrivateKey(sdk_connect_1.encoding.hex.decode(privateKey)),
    });
    return new AptosSigner(chain, account, rpc);
}
exports.getAptosSigner = getAptosSigner;
class AptosSigner {
    _chain;
    _account;
    _rpc;
    _debug;
    constructor(_chain, _account, _rpc, _debug) {
        this._chain = _chain;
        this._account = _account;
        this._rpc = _rpc;
        this._debug = _debug;
    }
    chain() {
        return this._chain;
    }
    address() {
        return this._account.accountAddress.toString();
    }
    async signAndSend(tx) {
        const txhashes = [];
        for (const txn of tx) {
            const { description, transaction } = txn;
            if (this._debug)
                console.log(`Signing: ${description} for ${this.address()}`);
            const tx = await this._rpc.transaction.build.simple({
                sender: this._account.accountAddress,
                data: transaction,
            });
            const { hash } = await this._simSignSend(tx);
            txhashes.push(hash);
        }
        return txhashes;
    }
    async _simSignSend(rawTx) {
        // simulate transaction
        await this._rpc.transaction.simulate
            .simple({
            signerPublicKey: this._account.publicKey,
            transaction: rawTx,
        })
            .then((sims) => sims.forEach((tx) => {
            if (!tx.success) {
                throw new Error(`Transaction failed: ${tx.vm_status}\n${JSON.stringify(tx, null, 2)}`);
            }
        }));
        return this._rpc
            .signAndSubmitTransaction({ signer: this._account, transaction: rawTx })
            .then((pendingTx) => this._rpc.waitForTransaction({ transactionHash: pendingTx.hash }));
    }
}
exports.AptosSigner = AptosSigner;
//# sourceMappingURL=signer.js.map