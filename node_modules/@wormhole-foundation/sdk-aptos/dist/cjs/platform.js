"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosPlatform = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const chain_js_1 = require("./chain.js");
const types_js_1 = require("./types.js");
const address_js_1 = require("./address.js");
const constants_js_1 = require("./constants.js");
/**
 * @category Aptos
 */
class AptosPlatform extends sdk_connect_1.PlatformContext {
    static _platform = types_js_1._platform;
    constructor(network, config) {
        super(network, config ?? (0, sdk_connect_1.networkPlatformConfigs)(network, AptosPlatform._platform));
    }
    getRpc(chain) {
        if (chain in this.config) {
            const network = this.network === "Mainnet" ? ts_sdk_1.Network.MAINNET : ts_sdk_1.Network.TESTNET;
            const config = new ts_sdk_1.AptosConfig({ fullnode: this.config[chain].rpc, network });
            return new ts_sdk_1.Aptos(config);
        }
        throw new Error("No configuration available for chain: " + chain);
    }
    getChain(chain, rpc) {
        if (chain in this.config)
            return new chain_js_1.AptosChain(chain, this);
        throw new Error("No configuration available for chain: " + chain);
    }
    static nativeTokenId(network, chain) {
        if (!this.isSupportedChain(chain))
            throw new Error(`invalid chain: ${chain}`);
        return sdk_connect_1.Wormhole.tokenId(chain, constants_js_1.APTOS_COIN);
    }
    static isNativeTokenId(network, chain, tokenId) {
        if (!this.isSupportedChain(chain))
            return false;
        if (tokenId.chain !== chain)
            return false;
        const native = this.nativeTokenId(network, chain);
        return native == tokenId;
    }
    static isSupportedChain(chain) {
        const platform = (0, sdk_connect_1.chainToPlatform)(chain);
        return platform === AptosPlatform._platform;
    }
    static async getDecimals(chain, rpc, token) {
        if ((0, sdk_connect_1.isNative)(token) || token === constants_js_1.APTOS_COIN)
            return sdk_connect_1.decimals.nativeDecimals(AptosPlatform._platform);
        const assetType = token.toString();
        const data = await rpc.getFungibleAssetMetadataByAssetType({ assetType });
        return data.decimals;
    }
    static async getBalance(chain, rpc, walletAddress, token) {
        const assetType = (0, sdk_connect_1.isNative)(token) ? constants_js_1.APTOS_COIN : token.toString();
        try {
            const data = await rpc.getCurrentFungibleAssetBalances({
                options: {
                    where: {
                        owner_address: { _eq: walletAddress },
                        asset_type: { _eq: assetType },
                    },
                },
            });
            return data[0]?.amount ?? null;
        }
        catch (e) {
            if (e.status === 404) {
                return null;
            }
            throw e;
        }
    }
    static async getBalances(chain, rpc, walletAddress, tokens) {
        const balancesArr = await Promise.all(tokens.map(async (token) => {
            const balance = await this.getBalance(chain, rpc, walletAddress, token);
            const address = (0, sdk_connect_1.isNative)(token) ? "native" : new address_js_1.AptosAddress(token).toString();
            return { [address]: balance };
        }));
        return balancesArr.reduce((obj, item) => Object.assign(obj, item), {});
    }
    static async sendWait(chain, rpc, stxns) {
        const txhashes = [];
        for (const stxn of stxns) {
            const pendingTx = await rpc.transaction.submit.simple(stxn.transaction);
            const res = await rpc.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
            txhashes.push(res.hash);
        }
        return txhashes;
    }
    static async getLatestBlock(rpc) {
        const li = await rpc.getLedgerInfo();
        return Number(li.block_height);
    }
    static async getLatestFinalizedBlock(rpc) {
        const li = await rpc.getLedgerInfo();
        return Number(li.block_height);
    }
    static chainFromChainId(chainId) {
        const netChain = sdk_connect_1.nativeChainIds.platformNativeChainIdToNetworkChain(AptosPlatform._platform, BigInt(chainId));
        if (!netChain)
            throw new Error(`No matching chainId to determine network and chain: ${chainId}`);
        const [network, chain] = netChain;
        return [network, chain];
    }
    static async chainFromRpc(rpc) {
        const li = await rpc.getLedgerInfo();
        return this.chainFromChainId(li.chain_id.toString());
    }
}
exports.AptosPlatform = AptosPlatform;
//# sourceMappingURL=platform.js.map