import { chainToChainId, circle, nativeChainIds, toChainId, } from '@wormhole-foundation/sdk-connect';
import { ethers_contracts } from './index.js';
import { EvmAddress, EvmPlatform, EvmUnsignedTransaction, addChainId, addFrom, } from '@wormhole-foundation/sdk-evm';
import '@wormhole-foundation/sdk-evm-tokenbridge';
import { EvmWormholeCore } from '@wormhole-foundation/sdk-evm-core';
export class EvmAutomaticCircleBridge {
    network;
    chain;
    provider;
    contracts;
    circleRelayer;
    chainId;
    tokenAddr;
    core;
    // https://github.com/wormhole-foundation/wormhole-connect/blob/development/sdk/src/contexts/eth/context.ts#L379
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (network === 'Devnet')
            throw new Error('AutomaticCircleBridge not supported on Devnet');
        this.chainId = nativeChainIds.networkChainToNativeChainId.get(network, chain);
        const relayerAddress = this.contracts.cctp?.wormholeRelayer;
        if (!relayerAddress)
            throw new Error(`Wormhole Circle relayer contract for domain ${chain} not found`);
        this.circleRelayer = ethers_contracts.CircleRelayer__factory.connect(relayerAddress, provider);
        const tokenAddr = circle.usdcContract.get(this.network, this.chain);
        if (!tokenAddr)
            throw new Error(`USDC contract not found for ${this.network} ${this.chain}`);
        this.tokenAddr = tokenAddr;
        this.core = new EvmWormholeCore(network, chain, provider, contracts);
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmAutomaticCircleBridge(network, chain, provider, conf.contracts);
    }
    async getRelayerFee(destination) {
        return this.circleRelayer.relayerFee(toChainId(destination), this.tokenAddr);
    }
    async *transfer(sender, recipient, amount, nativeGas) {
        const senderAddr = new EvmAddress(sender).toString();
        const recipientChainId = chainToChainId(recipient.chain);
        const recipientAddress = recipient.address
            .toUniversalAddress()
            .toUint8Array();
        const nativeTokenGas = nativeGas ? nativeGas : 0n;
        const tokenContract = EvmPlatform.getTokenImplementation(this.provider, this.tokenAddr);
        const allowance = await tokenContract.allowance(senderAddr, this.circleRelayer.target);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(this.circleRelayer.target, amount);
            yield this.createUnsignedTx(addFrom(txReq, senderAddr), 'ERC20.approve of CircleRelayer');
        }
        const messageFee = await this.core.getMessageFee();
        const txReq = await this.circleRelayer.transferTokensWithRelay.populateTransaction(this.tokenAddr, amount, nativeTokenGas, recipientChainId, recipientAddress, { value: messageFee });
        yield this.createUnsignedTx(addFrom(txReq, senderAddr), 'CircleRelayer.transfer');
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new EvmUnsignedTransaction(addChainId(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
    async nativeTokenAmount(amount) {
        return await this.circleRelayer.calculateNativeSwapAmountOut(this.tokenAddr, amount);
    }
    async maxSwapAmount() {
        return await this.circleRelayer.calculateMaxSwapAmountIn(this.tokenAddr);
    }
}
//# sourceMappingURL=automaticCircleBridge.js.map