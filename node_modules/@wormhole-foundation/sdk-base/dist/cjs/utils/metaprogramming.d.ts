export type Extends<T, U> = [T] extends [U] ? true : false;
export type NeTuple<T = unknown> = [T, ...T[]];
export type Tuple<T = unknown> = NeTuple<T> | [];
export type RoTuple<T = unknown> = Readonly<Tuple<T>>;
export type RoNeTuple<T = unknown> = Readonly<NeTuple<T>>;
export type RoArray<T = unknown> = readonly T[];
export type RoPair<T = unknown, U = unknown> = readonly [T, U];
export type Function<P extends RoArray<unknown> = RoArray<any>, R = unknown> = (...args: P) => R;
export type Widen<T> = T extends string ? string : T extends number ? number : T extends boolean ? boolean : T extends bigint ? bigint : T extends object ? object : T;
export type DefinedOrDefault<T, D> = undefined extends T ? D : NonNullable<T>;
export type IsAny<T> = Extends<0, 1 & T>;
export type IsNever<T> = Extends<T, never>;
export type Not<B extends boolean> = B extends true ? false : true;
export type And<T extends RoTuple<boolean> | boolean, R extends boolean = true> = R extends true ? T extends RoTuple<boolean> ? false extends T[number] ? false : true : T : false;
export type Or<T extends RoTuple<boolean> | boolean, R extends boolean = false> = R extends false ? T extends RoTuple<boolean> ? true extends T[number] ? true : false : T : true;
type XorImpl<T extends RoTuple<boolean>> = T extends readonly [infer First, infer Second, ...infer Tail extends RoArray<boolean>] ? XorImpl<[boolean extends First | Second ? true : false, ...Tail]> : T extends readonly [infer Final] ? Final : never;
export type Xor<T extends RoTuple<boolean> | boolean, R extends boolean | undefined = undefined> = T extends RoTuple<boolean> ? [...T, ...(undefined extends R ? [] : [Exclude<R, undefined>])] extends infer V extends RoTuple<boolean> ? XorImpl<V> : never : boolean extends Exclude<R, undefined> | T ? true : false;
export type ParseNumber<T> = T extends `${infer N extends number}` ? N : never;
export type UnionToIntersection<U> = (U extends any ? (_: U) => void : never) extends ((_: infer I) => void) ? I : never;
export type IsUnion<T> = Not<Extends<T, UnionToIntersection<T>>>;
export type IsUnionMember<T, U> = And<[Extends<T, U>, IsUnion<U>, Not<IsUnion<T>>, Not<IsNever<T>>, Not<IsAny<T>>]>;
export type ConcatStringLiterals<A extends RoArray<string>> = A extends readonly [infer S extends string, ...infer Tail extends RoArray<string>] ? `${S}${ConcatStringLiterals<Tail>}` : "";
export type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
export type CombineObjects<T, U> = {
    [K in keyof T | keyof U]: K extends keyof T ? T[K] : K extends keyof U ? U[K] : never;
};
export {};
//# sourceMappingURL=metaprogramming.d.ts.map