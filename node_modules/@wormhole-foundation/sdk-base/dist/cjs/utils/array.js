"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.median = exports.filterIndexes = exports.pickWithOrder = exports.zip = exports.column = exports.flatten = exports.entries = exports.range = void 0;
const range = (length) => [...Array(length).keys()];
exports.range = range;
function entries(arr) {
    return [...arr.entries()];
}
exports.entries = entries;
const flatten = (arr) => arr.flat();
exports.flatten = flatten;
const column = (tupArr, index) => tupArr.map((tuple) => tuple[index]);
exports.column = column;
const zip = (arr) => (0, exports.range)(arr[0].length).map(col => (0, exports.range)(arr.length).map(row => arr[row][col]));
exports.zip = zip;
const pickWithOrder = (arr, indexes) => indexes.map((i) => arr[i]);
exports.pickWithOrder = pickWithOrder;
const filterIndexes = (arr, indexes, exclude) => {
    const indexSet = new Set(Array.isArray(indexes) ? indexes : [indexes]);
    return arr.filter((_, i) => indexSet.has(i) !== exclude);
};
exports.filterIndexes = filterIndexes;
function median(arr, isSorted = false) {
    if (arr.length === 0)
        throw new Error("Can't calculate median of empty array");
    const sorted = isSorted ? arr : [...arr].sort((a, b) => (a > b ? 1 : a < b ? -1 : 0)); // handle bigint and number
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 1) {
        return sorted[mid];
    }
    const left = sorted[mid - 1];
    const right = sorted[mid];
    if (typeof left === "bigint" && typeof right === "bigint") {
        return (left + right) / 2n;
    }
    if (typeof left === "number" && typeof right === "number") {
        return (left + right) / 2;
    }
    throw new Error("Can't calculate median of array with mixed number and bigint");
}
exports.median = median;
//# sourceMappingURL=array.js.map