import type { RoTuple2D, HeadTail, Entries, Flatten, InnerFlatten, IsRectangular, TupleZip, Cartesian, TuplePickWithOrder } from './array.js';
import type { Widen, RoTuple, RoNeTuple, RoPair } from './metaprogramming.js';
export type ShallowMapping<M extends RoTuple<readonly [PropertyKey, unknown]>> = {
    readonly [E in M[number] as E[0]]: E[1];
};
export type MappableKey = PropertyKey | bigint | boolean;
export type MapLevel<K extends MappableKey, V> = RoTuple<RoPair<K, V>>;
type MapLevelsTuple = readonly [MappableKey, ...RoTuple<MappableKey>, unknown];
export type MapLevels<T extends MapLevelsTuple> = T extends HeadTail<T, infer Head extends MappableKey, infer Tail> ? Tail extends MapLevelsTuple ? MapLevel<Head, MapLevels<Tail>> : MapLevel<Head, Tail[0]> : never;
type Depth = [never, 0, 1, 2, 3, 4];
type ToExtPropKey<T extends MappableKey> = T extends bigint ? `bigint(${T})` : T extends boolean ? `boolean(${T})` : T;
type FromExtPropKey<T extends PropertyKey> = T extends `bigint(${infer V extends bigint})` ? V : T extends `boolean(${infer V extends boolean})` ? V : T;
type MappingEntry<V = unknown> = RoPair<MappableKey, V>;
type MappingEntries<V = unknown> = RoTuple<MappingEntry<V>>;
type CombineKeyRowIndexes<K extends MappableKey, T extends MappingEntries<number>, IA extends RoTuple<number>, //all values associated with K
U extends MappingEntries<number> = []> = T extends HeadTail<T, infer Head, infer Tail> ? Head[0] extends K ? CombineKeyRowIndexes<K, Tail, [...IA, Head[1]], U> : CombineKeyRowIndexes<K, Tail, IA, [...U, Head]> : [IA, U];
type ToMapEntries<KCI extends MappingEntries<number>, M extends MappingEntries = []> = KCI extends HeadTail<KCI, infer Head, infer Tail> ? Head extends RoPair<infer K extends MappableKey, infer V extends number> ? CombineKeyRowIndexes<K, Tail, [V]> extends RoPair<infer IA extends RoTuple, infer KCIU extends MappingEntries<number>> ? ToMapEntries<KCIU, [...M, [K, IA]]> : never : never : M;
type CartesianRightRecursive<M extends RoTuple> = M extends infer IM extends MappingEntries<RoTuple> ? Flatten<[
    ...{
        [K in keyof IM]: K extends `${number}` ? InnerFlatten<Cartesian<IM[K][0], CartesianRightRecursive<IM[K][1]>>> : never;
    }
]> : M extends infer IM extends MappingEntry<RoTuple> ? Cartesian<IM[0], IM[1]> : M;
type Shape = RoPair<RoTuple<number>, RoTuple<number>>;
type IndexLike = number | RoNeTuple<number>;
type ShapeLike = RoPair<IndexLike, IndexLike>;
type ShapeLikeToShape<S extends ShapeLike> = S extends RoPair<infer KC extends IndexLike, infer VC extends IndexLike> ? [KC extends number ? [KC] : KC, VC extends number ? [VC] : VC] : never;
type CartesianSet<T = unknown> = RoTuple2D<T>;
type Transpose<T extends RoTuple2D, E = unknown> = TupleZip<T> extends infer R extends RoTuple2D<E> ? R : never;
type FlipInnerPair<T extends RoTuple<RoPair>> = [
    ...{
        [K in keyof T]: K extends `${number}` ? [T[K][1], T[K][0]] : never;
    }
];
type KeyRowIndexes = MappingEntries<RoTuple<number>>;
type KeyColumnToKeyRowIndexes<KC extends RoTuple<MappableKey>> = FlipInnerPair<Entries<KC>> extends infer FIP extends MappingEntries<number> ? ToMapEntries<FIP> : never;
type ProcessNextKeyColmn<KC extends CartesianSet<MappableKey>, VR extends RoTuple> = KC extends HeadTail<KC, infer Head, infer Tail> ? KeyColumnToKeyRowIndexes<Exclude<Head, undefined>> extends infer KRI extends KeyRowIndexes ? [
    ...{
        [K in keyof KRI]: [
            KRI[K][0],
            ProcessNextKeyColmn<Transpose<TuplePickWithOrder<Transpose<Tail>, KRI[K][1]>, MappableKey>, TuplePickWithOrder<VR, KRI[K][1]>>
        ];
    }
] : never : VR;
type LeafValue<T = unknown> = RoPair<void, T>;
type CombineValueColumnsToLeafValues<VC extends CartesianSet> = (VC["length"] extends 1 ? VC[0] : Transpose<VC>) extends infer VCT extends RoTuple ? [...{
    [K in keyof VCT]: K extends `${number}` ? LeafValue<VCT[K]> : never;
}] : never;
type SplitAndReorderKeyValueColumns<R extends CartesianSet, S extends Shape> = Transpose<R> extends infer C extends CartesianSet ? [TuplePickWithOrder<C, S[0]>, TuplePickWithOrder<C, S[1]>] : never;
type UnwrapValuesIfAllAreSingletons<M extends MappingEntries, D extends Depth[number]> = D extends 1 ? M extends infer IM extends MappingEntries<readonly [LeafValue]> ? [...{
    [K in keyof IM]: K extends `${number}` ? [M[K][0], M[K][1][0][1]] : never;
}] : void : M extends infer IM extends MappingEntries<MappingEntries> ? [
    ...{
        [K in keyof IM]: K extends `${number}` ? [IM[K][0], UnwrapValuesIfAllAreSingletons<IM[K][1], Depth[D]>] : never;
    }
] extends infer U extends MappingEntries ? U : void : never;
type MaybeUnwrapValuesIfAllAreSingletons<M extends MappingEntries, D extends Depth[number]> = UnwrapValuesIfAllAreSingletons<M, D> extends infer V extends MappingEntries ? V : M;
type TransformMapping<M extends MappingEntries, S extends Shape | void = void> = CartesianRightRecursive<M> extends infer CRR extends RoTuple2D ? IsRectangular<CRR> extends true ? CRR extends RoNeTuple<RoTuple> ? S extends Shape ? SplitAndReorderKeyValueColumns<CRR, S> extends [
    infer KC extends CartesianSet<MappableKey>,
    infer VC extends CartesianSet
] ? KC["length"] extends infer D extends Depth[number] ? CombineValueColumnsToLeafValues<VC> extends infer VR extends RoTuple<LeafValue> ? ProcessNextKeyColmn<KC, VR> extends infer TM extends MappingEntries ? [MaybeUnwrapValuesIfAllAreSingletons<TM, D>, D] : never : never : never : never : CRR[0] extends readonly [...infer KC extends RoTuple, unknown] ? KC["length"] extends infer D extends Depth[number] ? [M, D] : never : never : never : never : never;
type ObjectFromMappingEntries<M extends MappingEntries, D extends Depth[number]> = {
    [K in keyof M as (K extends `${number}` ? ToExtPropKey<M[K][0]> : never)]: M[K] extends infer ME extends MappingEntry ? ME[1] extends infer V ? D extends 1 ? V extends LeafValue<infer T> ? T : V extends RoTuple<LeafValue> ? [...{
        [K2 in keyof V]: K2 extends `${number}` ? V[K2][1] : never;
    }] : V : V extends MappingEntries ? ObjectFromMappingEntries<V, Depth[D]> : never : never : never;
};
export type ToMappingAndDepth<M extends MappingEntries, S extends ShapeLike | undefined> = TransformMapping<M, S extends ShapeLike ? ShapeLikeToShape<S> : void> extends [
    infer TM extends MappingEntries,
    infer D extends Depth[number]
] ? [ObjectFromMappingEntries<TM, D>, D] : never;
export type ToMapping<M extends MappingEntries, S extends ShapeLike | undefined = undefined> = ToMappingAndDepth<M, S>[0];
type Mapped = {
    [key: PropertyKey]: unknown | Mapped;
};
type RecursiveAccess<M, KA extends RoTuple<MappableKey>> = KA extends HeadTail<KA, infer Head, infer Tail> ? M extends Mapped ? RecursiveAccess<M[ToExtPropKey<Head>], Tail> : never : M;
type GenericMappingFunc<M extends Mapped, D extends number> = D extends 1 ? <const K1 extends FromExtPropKey<keyof M>>(...args: readonly [K1]) => RecursiveAccess<M, [K1]> : D extends 2 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>>(...args: readonly [K1, K2]) => RecursiveAccess<M, [K1, K2]> : D extends 3 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>, const K3 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2]>>>(...args: readonly [K1, K2, K3]) => RecursiveAccess<M, [K1, K2, K3]> : D extends 4 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>, const K3 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2]>>, const K4 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2, K3]>>>(...args: readonly [K1, K2, K3, K4]) => RecursiveAccess<M, [K1, K2, K3, K4]> : never;
type SubMap<M extends Mapped, D extends number, K extends PropertyKey> = K extends keyof M ? M[K] extends Mapped ? ConstMapImpl<M[K], Depth[D]> : never : never;
type SubMapFunc<M extends Mapped, D extends number> = {
    readonly subMap: <const K extends FromExtPropKey<keyof M>>(key: K) => SubMap<M, D, ToExtPropKey<K>>;
};
type KeysOfObjectUnion<T extends Object> = T extends Object ? keyof T : never;
type ValsOfObjectUnion<T extends Object> = T extends Object ? T[keyof T] : never;
type WidenedParamsAndRetRec<M extends Mapped, D extends number> = D extends 1 ? [ValsOfObjectUnion<M>] : M[keyof M] extends infer SubMapUnion extends Mapped ? WidenedParamsAndRet<SubMapUnion, Depth[D]> : never;
type WidenedParamsAndRet<M extends Mapped, D extends number> = [
    Widen<FromExtPropKey<KeysOfObjectUnion<M>>>,
    ...WidenedParamsAndRetRec<M, D>
];
type HasGetFuncs<M extends Mapped, D extends number> = WidenedParamsAndRet<M, D> extends [...infer P extends RoTuple<unknown>, infer R] ? {
    readonly has: (...args: P) => boolean;
    readonly get: (...args: P) => R | undefined;
} : never;
type ConstMapImpl<M extends Mapped, D extends number> = D extends 1 ? GenericMappingFunc<M, D> & HasGetFuncs<M, D> : GenericMappingFunc<M, D> & HasGetFuncs<M, D> & SubMapFunc<M, D>;
type ConstMap<M extends MappingEntries, S extends ShapeLike | undefined = undefined> = ToMappingAndDepth<M, S> extends [infer TM extends Mapped, infer D extends Depth[number]] ? ConstMapImpl<TM, D> : never;
export declare const cartesianRightRecursive: <const T extends RoTuple>(arr: T) => CartesianRightRecursive<T>;
export declare function constMap<const M extends MappingEntries, const S extends ShapeLike | undefined = undefined>(mappingEntries: M, shape?: S): ConstMap<M, S>;
export {};
//# sourceMappingURL=mapping.d.ts.map