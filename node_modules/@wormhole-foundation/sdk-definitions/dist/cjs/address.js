"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUniversal = exports.toNative = exports.nativeIsRegistered = exports.registerNative = exports.isChainSpecificAddress = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
//TODO BRRRR circular include!!
//I have yet to figure out how to get the equivalent of a forward declaration to work (without
//  yet again having to rely on global scope...)
//I first tried `declare class UniversalAddress {};` but this actually introduces a new, separate
//  type in this module rather than telling the compiler that we already have this type elsewhere
//I could also create an interface via `interface IUnverisalAddress {}` but that seems like an
//  even worse solution, as is just throwing everything into this file here and just brushing
//  things under the rug by not separating them out.
const universalAddress_js_1 = require("./universalAddress.js");
function isChainSpecificAddress(thing) {
    return typeof thing === "object" && "setChain" in thing;
}
exports.isChainSpecificAddress = isChainSpecificAddress;
const nativeFactory = new Map();
function registerNative(platform, ctr) {
    if (nativeFactory.has(platform))
        return;
    // TODO:
    // throw new Error(`Native address type for platform ${platform} has already registered`);
    nativeFactory.set(platform, ctr);
}
exports.registerNative = registerNative;
function nativeIsRegistered(chain) {
    const platform = sdk_base_1.chainToPlatform.get(chain);
    return nativeFactory.has(platform);
}
exports.nativeIsRegistered = nativeIsRegistered;
/** Parse an address into its NativeAddress representation */
function toNative(chain, ua) {
    const platform = sdk_base_1.chainToPlatform.get(chain);
    const nativeCtr = nativeFactory.get(platform);
    if (!nativeCtr)
        throw new Error(`No native address type registered for platform ${platform}, import the platform directly or, if using sdk package, import the addresses conditional export`);
    try {
        const nativeAddress = new nativeCtr(ua);
        if (isChainSpecificAddress(nativeAddress)) {
            // idk why but this typeguard doesnt actually work?
            nativeAddress.setChain(chain);
        }
        return nativeAddress;
    }
    catch (e) {
        const err = `Error parsing address as a native ${chain} address: ${e.message}`;
        if (universalAddress_js_1.UniversalAddress.instanceof(ua)) {
            throw err;
        }
        else {
            // If we were given a string or Uint8Array value, which is ambiguously either a
            // NativeAddress or UniversalAddress, and it failed to parse directly
            // as a NativeAddress, we try one more time to parse it as a UniversalAddress
            // first and then convert that to a NativeAddress.
            return (new universalAddress_js_1.UniversalAddress(ua)).toNative(chain);
        }
    }
}
exports.toNative = toNative;
function toUniversal(chain, address) {
    const platform = sdk_base_1.chainToPlatform.get(chain);
    return new universalAddress_js_1.UniversalAddress(address, sdk_base_1.platformToAddressFormat.get(platform));
}
exports.toUniversal = toUniversal;
//# sourceMappingURL=address.js.map