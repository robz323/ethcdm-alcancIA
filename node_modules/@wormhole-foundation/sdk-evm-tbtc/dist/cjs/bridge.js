"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmTBTCBridge = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const ethers_1 = require("ethers");
const sdk_evm_core_1 = require("@wormhole-foundation/sdk-evm-core");
class EvmTBTCBridge {
    network;
    chain;
    provider;
    contracts;
    chainId;
    core;
    gatewayAddress;
    gateway;
    tbtcTokenAddr;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (this.network !== 'Mainnet') {
            throw new Error('TBTC is only supported on Mainnet');
        }
        if (!this.contracts.tbtc) {
            throw new Error('TBTC contract address is required');
        }
        const tbtcToken = sdk_connect_1.TBTCBridge.getNativeTbtcToken(this.chain);
        if (!tbtcToken) {
            throw new Error('Native tbtc token not found');
        }
        this.chainId = sdk_connect_1.nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.core = new sdk_evm_core_1.EvmWormholeCore(network, chain, provider, contracts);
        this.gatewayAddress = this.contracts.tbtc;
        this.gateway = new ethers_1.Contract(this.gatewayAddress, [
            'function sendTbtc(uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) payable returns (uint64)',
            'function receiveTbtc(bytes calldata encodedVm)',
        ], provider);
        this.tbtcTokenAddr = (0, sdk_definitions_1.canonicalAddress)(tbtcToken);
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_evm_1.EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmTBTCBridge(network, chain, provider, conf.contracts);
    }
    async *transfer(sender, recipient, amount) {
        const senderAddress = new sdk_evm_1.EvmAddress(sender).toString();
        const tx = await this.gateway.sendTbtc.populateTransaction(amount, (0, sdk_base_1.toChainId)(recipient.chain), recipient.address.toUniversalAddress().toUint8Array(), 0n, 0n);
        tx.value = await this.core.getMessageFee();
        yield* this.approve(senderAddress, amount, this.gatewayAddress);
        yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(tx, senderAddress), 'TBTCBridge.Send');
    }
    async *redeem(sender, vaa) {
        if (vaa.payloadName !== 'GatewayTransfer') {
            throw new Error('Invalid VAA payload');
        }
        const address = new sdk_evm_1.EvmAddress(sender).toString();
        const tx = await this.gateway.receiveTbtc.populateTransaction((0, sdk_definitions_1.serialize)(vaa));
        yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(tx, address), 'TBTCBridge.Redeem');
    }
    async *approve(senderAddr, amount, contract) {
        const tokenContract = sdk_evm_1.EvmPlatform.getTokenImplementation(this.provider, this.tbtcTokenAddr);
        const allowance = await tokenContract.allowance(senderAddr, contract);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(contract, amount);
            yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(txReq, senderAddr), 'TBTC.Approve');
        }
    }
    createUnsignedTransaction(txReq, description) {
        return new sdk_evm_1.EvmUnsignedTransaction((0, sdk_evm_1.addChainId)(txReq, this.chainId), this.network, this.chain, description, false);
    }
}
exports.EvmTBTCBridge = EvmTBTCBridge;
//# sourceMappingURL=bridge.js.map