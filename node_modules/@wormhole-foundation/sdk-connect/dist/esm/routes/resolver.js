import { canonicalAddress, isNative, resolveWrappedToken, } from "@wormhole-foundation/sdk-definitions";
import { uniqueTokens } from "./token.js";
export class RouteResolver {
    wh;
    routeConstructors;
    inputTokenList;
    constructor(wh, routeConstructors) {
        this.wh = wh;
        this.routeConstructors = routeConstructors;
    }
    async supportedDestinationTokens(inputToken, fromChain, toChain) {
        const [, inputTokenId] = resolveWrappedToken(fromChain.network, fromChain.chain, inputToken);
        const tokens = await Promise.all(this.routeConstructors.map(async (rc) => {
            const supportedNetworks = rc.supportedNetworks();
            if (!supportedNetworks.includes(fromChain.network)) {
                return [];
            }
            const supportedChains = rc.supportedChains(fromChain.network);
            if (!supportedChains.includes(fromChain.chain) ||
                !supportedChains.includes(toChain.chain)) {
                return [];
            }
            try {
                return await rc.supportedDestinationTokens(inputTokenId, fromChain, toChain);
            }
            catch (e) {
                return [];
            }
        }));
        return uniqueTokens(tokens.flat());
    }
    async findRoutes(request) {
        // First we find all routes which support the request inputs (network, chains, and tokens)
        const supportedRoutes = await Promise.all(this.routeConstructors.map(async (rc) => {
            try {
                const protocolSupported = rc.supportedNetworks().includes(this.wh.network) &&
                    rc.supportedChains(this.wh.network).includes(request.toChain.chain) &&
                    rc.supportedChains(this.wh.network).includes(request.fromChain.chain);
                const dstTokenAddress = canonicalAddress(isNative(request.destination.id.address)
                    ? request.destination.wrapped
                    : request.destination.id);
                const destinationTokenSupported = (await rc.supportedDestinationTokens(request.source.id, request.fromChain, request.toChain)).filter((tokenId) => {
                    return canonicalAddress(tokenId) === dstTokenAddress;
                }).length > 0;
                return protocolSupported && destinationTokenSupported;
            }
            catch (e) {
                return false;
            }
        })).then((routesSupported) => this.routeConstructors.filter((_, index) => routesSupported[index]));
        return supportedRoutes.map((rc) => new rc(this.wh));
    }
}
//# sourceMappingURL=resolver.js.map