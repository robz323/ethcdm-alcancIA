import type { Chain, Network } from "@wormhole-foundation/sdk-base";
import type { ChainContext, Signer, TokenId, TransactionId } from "@wormhole-foundation/sdk-definitions";
import type { Wormhole } from "../wormhole.js";
import type { RouteTransferRequest } from "./request.js";
import type { Options, Quote, QuoteResult, Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "./types.js";
import type { ChainAddress } from "@wormhole-foundation/sdk-definitions";
export declare abstract class Route<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> {
    wh: Wormhole<N>;
    constructor(wh: Wormhole<N>);
    abstract validate(request: RouteTransferRequest<N>, params: TransferParams<OP>): Promise<ValidationResult<OP>>;
    abstract quote(request: RouteTransferRequest<N>, params: ValidatedTransferParams<OP>): Promise<QuoteResult<OP, VP>>;
    abstract initiate(request: RouteTransferRequest<N>, sender: Signer, quote: Quote<OP, VP>, to: ChainAddress): Promise<R>;
    abstract track(receipt: R, timeout?: number): AsyncGenerator<R>;
    transferUrl(txid: string): string;
    abstract getDefaultOptions(): OP;
}
export interface RouteMeta {
    name: string;
    provider?: string;
    logo?: string;
    support?: string;
    source?: string;
}
export interface RouteConstructor<OP extends Options = Options> {
    new <N extends Network>(wh: Wormhole<N>): Route<N, OP>;
    /**  Details about the route provided by the implementation */
    readonly meta: RouteMeta;
    /** true means this route supports native gas dropoff */
    readonly NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    /** true means this is a one-transaction route (using a relayer) */
    readonly IS_AUTOMATIC: boolean;
    /** get the list of networks this route supports */
    supportedNetworks(): Network[];
    /** get the list of chains this route supports */
    supportedChains(network: Network): Chain[];
    /** get the list of destination tokens that may be received on the destination chain */
    supportedDestinationTokens<N extends Network>(token: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<TokenId[]>;
}
export type StaticRouteMethods<I extends RouteConstructor> = InstanceType<I>;
/**
 * AutomaticRoute is used whenever a relayer is delivering the
 * Attestation to the destination chain
 */
export declare abstract class AutomaticRoute<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> extends Route<N, OP, VP, R> {
    static IS_AUTOMATIC: boolean;
}
export declare function isAutomatic<N extends Network>(route: Route<N>): route is AutomaticRoute<N>;
/**
 * Manual route is used whenever a manual delivery of the Attestation
 * is necessary
 */
export declare abstract class ManualRoute<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> extends Route<N, OP, VP, R> {
    static NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    static IS_AUTOMATIC: boolean;
    abstract complete(sender: Signer, receipt: R): Promise<R>;
    abstract resume(tx: TransactionId): Promise<R>;
}
export declare function isManual<N extends Network>(route: Route<N>): route is ManualRoute<N>;
/**
 * FinalizableRoute is used whenever the route has a step after
 * completion that needs to be done
 */
export declare abstract class FinalizableRoute<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> extends Route<N, OP, VP, R> {
    abstract finalize(sender: Signer, receipt: R): Promise<R>;
    abstract resume(tx: TransactionId): Promise<R>;
}
export declare function isFinalizable<N extends Network>(route: Route<N>): route is FinalizableRoute<N>;
//# sourceMappingURL=route.d.ts.map