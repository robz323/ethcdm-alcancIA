"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteResolver = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const token_js_1 = require("./token.js");
class RouteResolver {
    wh;
    routeConstructors;
    inputTokenList;
    constructor(wh, routeConstructors) {
        this.wh = wh;
        this.routeConstructors = routeConstructors;
    }
    async supportedDestinationTokens(inputToken, fromChain, toChain) {
        const [, inputTokenId] = (0, sdk_definitions_1.resolveWrappedToken)(fromChain.network, fromChain.chain, inputToken);
        const tokens = await Promise.all(this.routeConstructors.map(async (rc) => {
            const supportedNetworks = rc.supportedNetworks();
            if (!supportedNetworks.includes(fromChain.network)) {
                return [];
            }
            const supportedChains = rc.supportedChains(fromChain.network);
            if (!supportedChains.includes(fromChain.chain) ||
                !supportedChains.includes(toChain.chain)) {
                return [];
            }
            try {
                return await rc.supportedDestinationTokens(inputTokenId, fromChain, toChain);
            }
            catch (e) {
                return [];
            }
        }));
        return (0, token_js_1.uniqueTokens)(tokens.flat());
    }
    async findRoutes(request) {
        // First we find all routes which support the request inputs (network, chains, and tokens)
        const supportedRoutes = await Promise.all(this.routeConstructors.map(async (rc) => {
            try {
                const protocolSupported = rc.supportedNetworks().includes(this.wh.network) &&
                    rc.supportedChains(this.wh.network).includes(request.toChain.chain) &&
                    rc.supportedChains(this.wh.network).includes(request.fromChain.chain);
                const dstTokenAddress = (0, sdk_definitions_1.canonicalAddress)((0, sdk_definitions_1.isNative)(request.destination.id.address)
                    ? request.destination.wrapped
                    : request.destination.id);
                const destinationTokenSupported = (await rc.supportedDestinationTokens(request.source.id, request.fromChain, request.toChain)).filter((tokenId) => {
                    return (0, sdk_definitions_1.canonicalAddress)(tokenId) === dstTokenAddress;
                }).length > 0;
                return protocolSupported && destinationTokenSupported;
            }
            catch (e) {
                return false;
            }
        })).then((routesSupported) => this.routeConstructors.filter((_, index) => routesSupported[index]));
        return supportedRoutes.map((rc) => new rc(this.wh));
    }
}
exports.RouteResolver = RouteResolver;
//# sourceMappingURL=resolver.js.map