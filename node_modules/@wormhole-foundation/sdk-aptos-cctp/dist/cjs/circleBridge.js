"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosCircleBridge = void 0;
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const sdk_aptos_1 = require("@wormhole-foundation/sdk-aptos");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const moveScripts_js_1 = require("./moveScripts.js");
class AptosCircleBridge {
    network;
    chain;
    provider;
    contracts;
    usdcId;
    tokenMessengerId;
    messageTransmitterId;
    moveScripts;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (network === "Devnet")
            throw new Error("CircleBridge not supported on Devnet");
        const usdcId = sdk_connect_1.circle.usdcContract.get(this.network, this.chain);
        if (!usdcId) {
            throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);
        }
        if (!contracts.cctp?.tokenMessenger)
            throw new Error(`Circle Token Messenger contract for domain ${chain} not found`);
        if (!contracts.cctp?.messageTransmitter)
            throw new Error(`Circle Message Transmitter contract for domain ${chain} not found`);
        if (!moveScripts_js_1.aptosCCTPMoveScripts.has(network))
            throw new Error("No Aptos CCTP move scripts found");
        this.usdcId = usdcId;
        this.tokenMessengerId = contracts.cctp?.tokenMessenger;
        this.messageTransmitterId = contracts.cctp.messageTransmitter;
        this.moveScripts = moveScripts_js_1.aptosCCTPMoveScripts.get(network);
    }
    async *transfer(sender, recipient, amount) {
        const destinationDomain = new ts_sdk_1.U32(sdk_connect_1.circle.circleChainId.get(this.network, recipient.chain));
        const burnToken = ts_sdk_1.AccountAddress.from(this.usdcId);
        const mintRecipient = ts_sdk_1.AccountAddress.from(recipient.address.toUniversalAddress().toUint8Array());
        const functionArguments = [new ts_sdk_1.U64(amount), destinationDomain, mintRecipient, burnToken];
        const txData = {
            bytecode: this.moveScripts.depositForBurn,
            functionArguments,
        };
        yield this.createUnsignedTx(txData, "Aptos.CircleBridge.Transfer");
    }
    async isTransferCompleted(message) {
        const sourceBytes = new ts_sdk_1.U32(message.sourceDomain).bcsToBytes();
        const nonceBytes = new ts_sdk_1.U64(message.nonce).bcsToBytes();
        const hash = (0, sdk_connect_1.keccak256)(new Uint8Array([...sourceBytes, "-".charCodeAt(0), ...nonceBytes]));
        const hashStr = sdk_connect_1.encoding.hex.encode(hash);
        const isNonceUsed = await this.provider.view({
            payload: {
                function: `${this.messageTransmitterId}::message_transmitter::is_nonce_used`,
                functionArguments: [hashStr],
            },
        });
        return isNonceUsed[0];
    }
    async *redeem(sender, message, attestation) {
        const functionArguments = [
            ts_sdk_1.MoveVector.U8(sdk_connect_1.CircleBridge.serialize(message)),
            ts_sdk_1.MoveVector.U8(sdk_connect_1.encoding.hex.decode(attestation)),
        ];
        const txData = {
            bytecode: this.moveScripts.handleReceiveMessage,
            functionArguments,
        };
        yield this.createUnsignedTx(txData, "Aptos.CircleBridge.Redeem");
    }
    async parseTransactionDetails(digest) {
        const tx = await this.provider.getTransactionByHash({ transactionHash: digest });
        const messageTransmitterId = this.messageTransmitterId.replace(/^0x0+/, "0x"); // remove any leading zeros to match event
        const circleMessageSentEvent = tx.events?.find((e) => e.type === `${messageTransmitterId}::message_transmitter::MessageSent`);
        if (!circleMessageSentEvent) {
            throw new Error("No MessageSent event found");
        }
        const circleMessage = sdk_connect_1.encoding.hex.decode(circleMessageSentEvent.data.message);
        const [msg, hash] = sdk_connect_1.CircleBridge.deserialize(circleMessage);
        const { payload } = msg;
        const xferSender = payload.messageSender;
        const xferReceiver = payload.mintRecipient;
        const sendChain = sdk_connect_1.circle.toCircleChain(this.network, msg.sourceDomain);
        const rcvChain = sdk_connect_1.circle.toCircleChain(this.network, msg.destinationDomain);
        const token = { chain: sendChain, address: payload.burnToken };
        return {
            from: { chain: sendChain, address: xferSender },
            to: { chain: rcvChain, address: xferReceiver },
            token: token,
            amount: payload.amount,
            message: msg,
            id: { hash },
        };
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_aptos_1.AptosPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network) {
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        }
        return new AptosCircleBridge(network, chain, provider, conf.contracts);
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new sdk_aptos_1.AptosUnsignedTransaction(txReq, this.network, this.chain, description, parallelizable);
    }
}
exports.AptosCircleBridge = AptosCircleBridge;
//# sourceMappingURL=circleBridge.js.map