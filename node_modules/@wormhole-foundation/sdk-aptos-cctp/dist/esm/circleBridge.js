import { AccountAddress as AptosAccountAddress, MoveVector, U32, U64, } from "@aptos-labs/ts-sdk";
import { AptosPlatform, AptosUnsignedTransaction, } from "@wormhole-foundation/sdk-aptos";
import { CircleBridge, circle, encoding, keccak256, } from "@wormhole-foundation/sdk-connect";
import { aptosCCTPMoveScripts } from "./moveScripts.js";
export class AptosCircleBridge {
    network;
    chain;
    provider;
    contracts;
    usdcId;
    tokenMessengerId;
    messageTransmitterId;
    moveScripts;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (network === "Devnet")
            throw new Error("CircleBridge not supported on Devnet");
        const usdcId = circle.usdcContract.get(this.network, this.chain);
        if (!usdcId) {
            throw new Error(`No USDC contract configured for network=${this.network} chain=${this.chain}`);
        }
        if (!contracts.cctp?.tokenMessenger)
            throw new Error(`Circle Token Messenger contract for domain ${chain} not found`);
        if (!contracts.cctp?.messageTransmitter)
            throw new Error(`Circle Message Transmitter contract for domain ${chain} not found`);
        if (!aptosCCTPMoveScripts.has(network))
            throw new Error("No Aptos CCTP move scripts found");
        this.usdcId = usdcId;
        this.tokenMessengerId = contracts.cctp?.tokenMessenger;
        this.messageTransmitterId = contracts.cctp.messageTransmitter;
        this.moveScripts = aptosCCTPMoveScripts.get(network);
    }
    async *transfer(sender, recipient, amount) {
        const destinationDomain = new U32(circle.circleChainId.get(this.network, recipient.chain));
        const burnToken = AptosAccountAddress.from(this.usdcId);
        const mintRecipient = AptosAccountAddress.from(recipient.address.toUniversalAddress().toUint8Array());
        const functionArguments = [new U64(amount), destinationDomain, mintRecipient, burnToken];
        const txData = {
            bytecode: this.moveScripts.depositForBurn,
            functionArguments,
        };
        yield this.createUnsignedTx(txData, "Aptos.CircleBridge.Transfer");
    }
    async isTransferCompleted(message) {
        const sourceBytes = new U32(message.sourceDomain).bcsToBytes();
        const nonceBytes = new U64(message.nonce).bcsToBytes();
        const hash = keccak256(new Uint8Array([...sourceBytes, "-".charCodeAt(0), ...nonceBytes]));
        const hashStr = encoding.hex.encode(hash);
        const isNonceUsed = await this.provider.view({
            payload: {
                function: `${this.messageTransmitterId}::message_transmitter::is_nonce_used`,
                functionArguments: [hashStr],
            },
        });
        return isNonceUsed[0];
    }
    async *redeem(sender, message, attestation) {
        const functionArguments = [
            MoveVector.U8(CircleBridge.serialize(message)),
            MoveVector.U8(encoding.hex.decode(attestation)),
        ];
        const txData = {
            bytecode: this.moveScripts.handleReceiveMessage,
            functionArguments,
        };
        yield this.createUnsignedTx(txData, "Aptos.CircleBridge.Redeem");
    }
    async parseTransactionDetails(digest) {
        const tx = await this.provider.getTransactionByHash({ transactionHash: digest });
        const messageTransmitterId = this.messageTransmitterId.replace(/^0x0+/, "0x"); // remove any leading zeros to match event
        const circleMessageSentEvent = tx.events?.find((e) => e.type === `${messageTransmitterId}::message_transmitter::MessageSent`);
        if (!circleMessageSentEvent) {
            throw new Error("No MessageSent event found");
        }
        const circleMessage = encoding.hex.decode(circleMessageSentEvent.data.message);
        const [msg, hash] = CircleBridge.deserialize(circleMessage);
        const { payload } = msg;
        const xferSender = payload.messageSender;
        const xferReceiver = payload.mintRecipient;
        const sendChain = circle.toCircleChain(this.network, msg.sourceDomain);
        const rcvChain = circle.toCircleChain(this.network, msg.destinationDomain);
        const token = { chain: sendChain, address: payload.burnToken };
        return {
            from: { chain: sendChain, address: xferSender },
            to: { chain: rcvChain, address: xferReceiver },
            token: token,
            amount: payload.amount,
            message: msg,
            id: { hash },
        };
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await AptosPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network) {
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        }
        return new AptosCircleBridge(network, chain, provider, conf.contracts);
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new AptosUnsignedTransaction(txReq, this.network, this.chain, description, parallelizable);
    }
}
//# sourceMappingURL=circleBridge.js.map