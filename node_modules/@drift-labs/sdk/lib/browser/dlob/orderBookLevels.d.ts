/// <reference types="bn.js" />
import { BN, DLOBNode, OraclePriceData, PerpMarketAccount } from '..';
import { PublicKey } from '@solana/web3.js';
type liquiditySource = 'serum' | 'vamm' | 'dlob' | 'phoenix' | 'openbook';
export type L2Level = {
    price: BN;
    size: BN;
    sources: {
        [key in liquiditySource]?: BN;
    };
};
export type L2OrderBook = {
    asks: L2Level[];
    bids: L2Level[];
    slot?: number;
};
export interface L2OrderBookGenerator {
    getL2Asks(): Generator<L2Level>;
    getL2Bids(): Generator<L2Level>;
}
export type L3Level = {
    price: BN;
    size: BN;
    maker: PublicKey;
    orderId: number;
};
export type L3OrderBook = {
    asks: L3Level[];
    bids: L3Level[];
    slot?: number;
};
export declare const DEFAULT_TOP_OF_BOOK_QUOTE_AMOUNTS: BN[];
/**
 * Get an {@link Generator<L2Level>} generator from a {@link Generator<DLOBNode>}
 * @param dlobNodes e.g. {@link DLOB#getRestingLimitAsks} or {@link DLOB#getRestingLimitBids}
 * @param oraclePriceData
 * @param slot
 */
export declare function getL2GeneratorFromDLOBNodes(dlobNodes: Generator<DLOBNode>, oraclePriceData: OraclePriceData, slot: number): Generator<L2Level>;
export declare function mergeL2LevelGenerators(l2LevelGenerators: Generator<L2Level>[], compare: (a: L2Level, b: L2Level) => boolean): Generator<L2Level>;
export declare function createL2Levels(generator: Generator<L2Level>, depth: number): L2Level[];
export declare function getVammL2Generator({ marketAccount, oraclePriceData, numOrders, now, topOfBookQuoteAmounts, }: {
    marketAccount: PerpMarketAccount;
    oraclePriceData: OraclePriceData;
    numOrders: number;
    now?: BN;
    topOfBookQuoteAmounts?: BN[];
}): L2OrderBookGenerator;
export declare function groupL2(l2: L2OrderBook, grouping: BN, depth: number): L2OrderBook;
/**
 * The purpose of this function is uncross the L2 orderbook by modifying the bid/ask price at the top of the book
 * This will make the liquidity look worse but more intuitive (users familiar with clob get confused w temporarily
 * crossing book)
 *
 * Things to note about how it works:
 * - it will not uncross the user's liquidity
 * - it does the uncrossing by "shifting" the crossing liquidity to the nearest uncrossed levels. Thus the output liquidity maintains the same total size.
 *
 * @param bids
 * @param asks
 * @param oraclePrice
 * @param oracleTwap5Min
 * @param markTwap5Min
 * @param grouping
 * @param userBids
 * @param userAsks
 */
export declare function uncrossL2(bids: L2Level[], asks: L2Level[], oraclePrice: BN, oracleTwap5Min: BN, markTwap5Min: BN, grouping: BN, userBids: Set<string>, userAsks: Set<string>): {
    bids: L2Level[];
    asks: L2Level[];
};
export {};
