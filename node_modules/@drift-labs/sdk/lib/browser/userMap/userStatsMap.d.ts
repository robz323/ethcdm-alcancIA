import { DriftClient, OrderRecord, UserStatsAccount, UserStats, WrappedEvent, BulkAccountLoader, SyncConfig } from '..';
import { PublicKey } from '@solana/web3.js';
import { UserMap } from './userMap';
export declare class UserStatsMap {
    /**
     * map from authority pubkey to UserStats
     */
    private userStatsMap;
    private driftClient;
    private bulkAccountLoader;
    private decode;
    private syncConfig;
    private syncPromise?;
    private syncPromiseResolver;
    /**
     * Creates a new UserStatsMap instance.
     *
     * @param {DriftClient} driftClient - The DriftClient instance.
     * @param {BulkAccountLoader} [bulkAccountLoader] - If not provided, a new BulkAccountLoader with polling disabled will be created.
     */
    constructor(driftClient: DriftClient, bulkAccountLoader?: BulkAccountLoader, syncConfig?: SyncConfig);
    subscribe(authorities: PublicKey[]): Promise<void>;
    /**
     *
     * @param authority that owns the UserStatsAccount
     * @param userStatsAccount optional UserStatsAccount to subscribe to, if undefined will be fetched later
     * @param skipFetch if true, will not immediately fetch the UserStatsAccount
     */
    addUserStat(authority: PublicKey, userStatsAccount?: UserStatsAccount, skipFetch?: boolean): Promise<void>;
    updateWithOrderRecord(record: OrderRecord, userMap: UserMap): Promise<void>;
    updateWithEventRecord(record: WrappedEvent<any>, userMap?: UserMap): Promise<void>;
    has(authorityPublicKey: string): boolean;
    get(authorityPublicKey: string): UserStats;
    /**
     * Enforce that a UserStats will exist for the given authorityPublicKey,
     * reading one from the blockchain if necessary.
     * @param authorityPublicKey
     * @returns
     */
    mustGet(authorityPublicKey: string): Promise<UserStats>;
    values(): IterableIterator<UserStats>;
    size(): number;
    /**
     * Sync the UserStatsMap
     * @param authorities list of authorities to derive UserStatsAccount public keys from.
     * You may want to get this list from UserMap in order to filter out idle users
     */
    sync(authorities: PublicKey[]): Promise<void>;
    /**
     * Sync the UserStatsMap using the default sync method, which loads individual users into the bulkAccountLoader and
     * loads them. (bulkAccountLoader uses batch getMultipleAccounts)
     * @param authorities
     */
    private defaultSync;
    /**
     * Sync the UserStatsMap using the paginated sync method, which uses multiple getMultipleAccounts calls (without RPC batching), and limits concurrency.
     * @param authorities
     */
    private paginatedSync;
    unsubscribe(): Promise<void>;
}
