/// <reference types="node" />
/// <reference types="node" />
/// <reference types="bn.js" />
import { AccountInfo, Keypair, PublicKey, Transaction, RpcResponseAndContext, Commitment, TransactionSignature, SignatureStatusConfig, SignatureStatus, GetVersionedTransactionConfig, GetTransactionConfig, VersionedTransaction, SimulateTransactionConfig, SimulatedTransactionResponse, TransactionError, SignatureResultCallback, ClientSubscriptionId, Connection as SolanaConnection, Blockhash, LogsFilter, LogsCallback, AccountChangeCallback, AddressLookupTableAccount } from '@solana/web3.js';
import { ProgramTestContext, BanksClient } from 'solana-bankrun';
import { BankrunProvider } from 'anchor-bankrun';
import { BN, Wallet } from '@coral-xyz/anchor';
import { Account } from '@solana/spl-token';
export type Connection = SolanaConnection | BankrunConnection;
type BankrunTransactionMetaNormalized = {
    logMessages: string[];
    err: TransactionError;
};
type BankrunTransactionRespose = {
    slot: number;
    meta: BankrunTransactionMetaNormalized;
};
export declare class BankrunContextWrapper {
    readonly connection: BankrunConnection;
    readonly context: ProgramTestContext;
    readonly provider: BankrunProvider;
    readonly commitment: Commitment;
    constructor(context: ProgramTestContext, verifySignatures?: boolean);
    sendTransaction(tx: Transaction | VersionedTransaction, additionalSigners?: Keypair[]): Promise<TransactionSignature>;
    getMinimumBalanceForRentExemption(_: number): Promise<number>;
    fundKeypair(keypair: Keypair | Wallet, lamports: number | bigint): Promise<TransactionSignature>;
    getLatestBlockhash(): Promise<Blockhash>;
    printTxLogs(signature: string): void;
    moveTimeForward(increment: number): Promise<void>;
    setTimestamp(unix_timestamp: number): Promise<void>;
}
export declare class BankrunConnection {
    private readonly _banksClient;
    private readonly context;
    private transactionToMeta;
    private clock;
    private nextClientSubscriptionId;
    private onLogCallbacks;
    private onAccountChangeCallbacks;
    private verifySignatures;
    constructor(banksClient: BanksClient, context: ProgramTestContext, verifySignatures?: boolean);
    getSlot(): Promise<bigint>;
    toConnection(): SolanaConnection;
    getTokenAccount(publicKey: PublicKey): Promise<Account>;
    getMultipleAccountsInfo(publicKeys: PublicKey[], _commitmentOrConfig?: Commitment): Promise<AccountInfo<Buffer>[]>;
    getAccountInfo(publicKey: PublicKey): Promise<null | AccountInfo<Buffer>>;
    getAccountInfoAndContext(publicKey: PublicKey, _commitment?: Commitment): Promise<RpcResponseAndContext<null | AccountInfo<Buffer>>>;
    sendRawTransaction(rawTransaction: Buffer | Uint8Array | Array<number>, _options?: any): Promise<TransactionSignature>;
    sendTransaction(tx: Transaction | VersionedTransaction): Promise<TransactionSignature>;
    private updateSlotAndClock;
    getTime(): number;
    getParsedAccountInfo(publicKey: PublicKey): Promise<RpcResponseAndContext<AccountInfo<Buffer>>>;
    getLatestBlockhash(commitment?: Commitment): Promise<Readonly<{
        blockhash: string;
        lastValidBlockHeight: number;
    }>>;
    getAddressLookupTable(accountKey: PublicKey): Promise<RpcResponseAndContext<null | AddressLookupTableAccount>>;
    getSignatureStatus(signature: string, _config?: SignatureStatusConfig): Promise<RpcResponseAndContext<null | SignatureStatus>>;
    /**
     * There's really no direct equivalent to getTransaction exposed by SolanaProgramTest, so we do the best that we can here - it's a little hacky.
     */
    getTransaction(signature: string, _rawConfig?: GetTransactionConfig | GetVersionedTransactionConfig): Promise<BankrunTransactionRespose | null>;
    findComputeUnitConsumption(signature: string): bigint;
    printTxLogs(signature: string): void;
    simulateTransaction(transaction: Transaction | VersionedTransaction, _config?: SimulateTransactionConfig): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;
    onSignature(signature: string, callback: SignatureResultCallback, commitment?: Commitment): ClientSubscriptionId;
    removeSignatureListener(_clientSubscriptionId: number): Promise<void>;
    onLogs(filter: LogsFilter, callback: LogsCallback, _commitment?: Commitment): ClientSubscriptionId;
    removeOnLogsListener(clientSubscriptionId: ClientSubscriptionId): Promise<void>;
    onAccountChange(publicKey: PublicKey, callback: AccountChangeCallback, _commitment?: Commitment): ClientSubscriptionId;
    removeAccountChangeListener(clientSubscriptionId: ClientSubscriptionId): Promise<void>;
    getMinimumBalanceForRentExemption(_: number): Promise<number>;
}
export declare function asBN(value: number | bigint): BN;
export {};
