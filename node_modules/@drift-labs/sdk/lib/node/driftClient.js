"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriftClient = void 0;
const anchor = __importStar(require("@coral-xyz/anchor"));
const anchor_1 = require("@coral-xyz/anchor");
const anchor_30_1 = require("@coral-xyz/anchor-30");
const bs58_1 = __importDefault(require("bs58"));
const spl_token_1 = require("@solana/spl-token");
const types_1 = require("./types");
const drift_json_1 = __importDefault(require("./idl/drift.json"));
const web3_js_1 = require("@solana/web3.js");
const events_1 = require("events");
const pda_1 = require("./addresses/pda");
const types_2 = require("./accounts/types");
const numericConstants_1 = require("./constants/numericConstants");
const position_1 = require("./math/position");
const spotBalance_1 = require("./math/spotBalance");
const userName_1 = require("./userName");
const pollingDriftClientAccountSubscriber_1 = require("./accounts/pollingDriftClientAccountSubscriber");
const webSocketDriftClientAccountSubscriber_1 = require("./accounts/webSocketDriftClientAccountSubscriber");
const retryTxSender_1 = require("./tx/retryTxSender");
const user_1 = require("./user");
const config_1 = require("./config");
const spotMarkets_1 = require("./constants/spotMarkets");
const userStats_1 = require("./userStats");
const spotPosition_1 = require("./math/spotPosition");
const market_1 = require("./math/market");
const fetch_1 = require("./accounts/fetch");
const spotMarket_1 = require("./math/spotMarket");
const memcmp_1 = require("./memcmp");
const marinade_1 = require("./marinade");
const orderParams_1 = require("./orderParams");
const utils_1 = require("./math/utils");
const txParamProcessor_1 = require("./tx/txParamProcessor");
const oracles_1 = require("./math/oracles");
const txHandler_1 = require("./tx/txHandler");
const pyth_solana_receiver_1 = require("@pythnetwork/pyth-solana-receiver");
const price_service_sdk_1 = require("@pythnetwork/price-service-sdk");
const address_1 = require("@pythnetwork/pyth-solana-receiver/lib/address");
const pythOracleUtils_1 = require("./util/pythOracleUtils");
const utils_2 = require("./tx/utils");
const pyth_solana_receiver_json_1 = __importDefault(require("./idl/pyth_solana_receiver.json"));
const on_demand_1 = require("@switchboard-xyz/on-demand");
const grpcDriftClientAccountSubscriber_1 = require("./accounts/grpcDriftClientAccountSubscriber");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const oracleId_1 = require("./oracles/oracleId");
const sha256_1 = require("@noble/hashes/sha256");
/**
 * # DriftClient
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 */
class DriftClient {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;
        this.users = new Map();
        this._isSubscribed = false;
        this.perpMarketLastSlotCache = new Map();
        this.spotMarketLastSlotCache = new Map();
        this.mustIncludePerpMarketIndexes = new Set();
        this.mustIncludeSpotMarketIndexes = new Set();
        this.connection = config.connection;
        this.wallet = config.wallet;
        this.env = (_a = config.env) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.opts = config.opts || {
            ...config_1.DEFAULT_CONFIRMATION_OPTS,
        };
        this.useHotWalletAdmin = (_b = config.useHotWalletAdmin) !== null && _b !== void 0 ? _b : false;
        if ((_c = config === null || config === void 0 ? void 0 : config.connection) === null || _c === void 0 ? void 0 : _c.commitment) {
            // At the moment this ensures that our transaction simulations (which use Connection object) will use the same commitment level as our Transaction blockhashes (which use these opts)
            this.opts.commitment = config.connection.commitment;
            this.opts.preflightCommitment = config.connection.commitment;
        }
        this.provider = new anchor_1.AnchorProvider(config.connection, 
        // @ts-ignore
        config.wallet, this.opts);
        this.program = new anchor_1.Program(drift_json_1.default, (_d = config.programID) !== null && _d !== void 0 ? _d : new web3_js_1.PublicKey(config_1.DRIFT_PROGRAM_ID), this.provider);
        this.authority = (_e = config.authority) !== null && _e !== void 0 ? _e : this.wallet.publicKey;
        this.activeSubAccountId = (_f = config.activeSubAccountId) !== null && _f !== void 0 ? _f : 0;
        this.skipLoadUsers = (_g = config.skipLoadUsers) !== null && _g !== void 0 ? _g : false;
        this.txVersion = (_h = config.txVersion) !== null && _h !== void 0 ? _h : 0;
        this.txParams = {
            computeUnits: (_k = (_j = config.txParams) === null || _j === void 0 ? void 0 : _j.computeUnits) !== null && _k !== void 0 ? _k : 600000,
            computeUnitsPrice: (_m = (_l = config.txParams) === null || _l === void 0 ? void 0 : _l.computeUnitsPrice) !== null && _m !== void 0 ? _m : 0,
        };
        this.txHandler =
            (_o = config === null || config === void 0 ? void 0 : config.txHandler) !== null && _o !== void 0 ? _o : new txHandler_1.TxHandler({
                connection: this.connection,
                // @ts-ignore
                wallet: this.provider.wallet,
                confirmationOptions: this.opts,
                opts: {
                    returnBlockHeightsWithSignedTxCallbackData: config.enableMetricsEvents,
                    onSignedCb: this.handleSignedTransaction.bind(this),
                    preSignedCb: this.handlePreSignedTransaction.bind(this),
                },
                config: config.txHandlerConfig,
            });
        if (config.includeDelegates && config.subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (config.authoritySubAccountMap && config.subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (config.authoritySubAccountMap && config.includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = config.authoritySubAccountMap
            ? config.authoritySubAccountMap
            : config.subAccountIds
                ? new Map([[this.authority.toString(), config.subAccountIds]])
                : new Map();
        this.includeDelegates = (_p = config.includeDelegates) !== null && _p !== void 0 ? _p : false;
        if (((_q = config.accountSubscription) === null || _q === void 0 ? void 0 : _q.type) === 'polling') {
            this.userAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
        }
        else if (((_r = config.accountSubscription) === null || _r === void 0 ? void 0 : _r.type) === 'grpc') {
            this.userAccountSubscriptionConfig = {
                type: 'grpc',
                resubTimeoutMs: (_s = config.accountSubscription) === null || _s === void 0 ? void 0 : _s.resubTimeoutMs,
                logResubMessages: (_t = config.accountSubscription) === null || _t === void 0 ? void 0 : _t.logResubMessages,
                grpcConfigs: (_u = config.accountSubscription) === null || _u === void 0 ? void 0 : _u.grpcConfigs,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'grpc',
                grpcConfigs: (_v = config.accountSubscription) === null || _v === void 0 ? void 0 : _v.grpcConfigs,
                resubTimeoutMs: (_w = config.accountSubscription) === null || _w === void 0 ? void 0 : _w.resubTimeoutMs,
                logResubMessages: (_x = config.accountSubscription) === null || _x === void 0 ? void 0 : _x.logResubMessages,
            };
        }
        else {
            this.userAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_y = config.accountSubscription) === null || _y === void 0 ? void 0 : _y.resubTimeoutMs,
                logResubMessages: (_z = config.accountSubscription) === null || _z === void 0 ? void 0 : _z.logResubMessages,
                commitment: (_0 = config.accountSubscription) === null || _0 === void 0 ? void 0 : _0.commitment,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_1 = config.accountSubscription) === null || _1 === void 0 ? void 0 : _1.resubTimeoutMs,
                logResubMessages: (_2 = config.accountSubscription) === null || _2 === void 0 ? void 0 : _2.logResubMessages,
                commitment: (_3 = config.accountSubscription) === null || _3 === void 0 ? void 0 : _3.commitment,
            };
        }
        if (config.userStats) {
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority),
                accountSubscription: this.userAccountSubscriptionConfig,
            });
        }
        this.marketLookupTable = config.marketLookupTable;
        if (!this.marketLookupTable) {
            this.marketLookupTable = new web3_js_1.PublicKey(config_1.configs[this.env].MARKET_LOOKUP_TABLE);
        }
        this.marketLookupTables = config.marketLookupTables;
        if (!this.marketLookupTables) {
            this.marketLookupTables = config_1.configs[this.env].MARKET_LOOKUP_TABLES.map((tableAddr) => new web3_js_1.PublicKey(tableAddr));
        }
        const delistedMarketSetting = config.delistedMarketSetting || types_2.DelistedMarketSetting.Unsubscribe;
        const noMarketsAndOraclesSpecified = config.perpMarketIndexes === undefined &&
            config.spotMarketIndexes === undefined &&
            config.oracleInfos === undefined;
        if (((_4 = config.accountSubscription) === null || _4 === void 0 ? void 0 : _4.type) === 'polling') {
            this.accountSubscriber = new pollingDriftClientAccountSubscriber_1.PollingDriftClientAccountSubscriber(this.program, config.accountSubscription.accountLoader, (_5 = config.perpMarketIndexes) !== null && _5 !== void 0 ? _5 : [], (_6 = config.spotMarketIndexes) !== null && _6 !== void 0 ? _6 : [], (_7 = config.oracleInfos) !== null && _7 !== void 0 ? _7 : [], noMarketsAndOraclesSpecified, delistedMarketSetting);
        }
        else if (((_8 = config.accountSubscription) === null || _8 === void 0 ? void 0 : _8.type) === 'grpc') {
            this.accountSubscriber = new grpcDriftClientAccountSubscriber_1.gprcDriftClientAccountSubscriber(config.accountSubscription.grpcConfigs, this.program, (_9 = config.perpMarketIndexes) !== null && _9 !== void 0 ? _9 : [], (_10 = config.spotMarketIndexes) !== null && _10 !== void 0 ? _10 : [], (_11 = config.oracleInfos) !== null && _11 !== void 0 ? _11 : [], noMarketsAndOraclesSpecified, delistedMarketSetting, {
                resubTimeoutMs: (_12 = config.accountSubscription) === null || _12 === void 0 ? void 0 : _12.resubTimeoutMs,
                logResubMessages: (_13 = config.accountSubscription) === null || _13 === void 0 ? void 0 : _13.logResubMessages,
            });
        }
        else {
            this.accountSubscriber = new webSocketDriftClientAccountSubscriber_1.WebSocketDriftClientAccountSubscriber(this.program, (_14 = config.perpMarketIndexes) !== null && _14 !== void 0 ? _14 : [], (_15 = config.spotMarketIndexes) !== null && _15 !== void 0 ? _15 : [], (_16 = config.oracleInfos) !== null && _16 !== void 0 ? _16 : [], noMarketsAndOraclesSpecified, delistedMarketSetting, {
                resubTimeoutMs: (_17 = config.accountSubscription) === null || _17 === void 0 ? void 0 : _17.resubTimeoutMs,
                logResubMessages: (_18 = config.accountSubscription) === null || _18 === void 0 ? void 0 : _18.logResubMessages,
            }, (_19 = config.accountSubscription) === null || _19 === void 0 ? void 0 : _19.commitment);
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
        this.metricsEventEmitter = new events_1.EventEmitter();
        if (config.enableMetricsEvents) {
            this.enableMetricsEvents = true;
        }
        this.txSender =
            (_20 = config.txSender) !== null && _20 !== void 0 ? _20 : new retryTxSender_1.RetryTxSender({
                connection: this.connection,
                wallet: this.wallet,
                opts: this.opts,
                txHandler: this.txHandler,
            });
        this.sbOnDemandProgramdId = config_1.configs[this.env].SB_ON_DEMAND_PID;
    }
    getUserMapKey(subAccountId, authority) {
        return `${subAccountId}_${authority.toString()}`;
    }
    createUser(subAccountId, accountSubscriptionConfig, authority) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId);
        return new user_1.User({
            driftClient: this,
            userAccountPublicKey,
            accountSubscription: accountSubscriptionConfig,
        });
    }
    async subscribe() {
        let subscribePromises = [this.addAndSubscribeToUsers()].concat(this.accountSubscriber.subscribe());
        if (this.userStats !== undefined) {
            subscribePromises = subscribePromises.concat(this.userStats.subscribe());
        }
        this.isSubscribed = (await Promise.all(subscribePromises)).reduce((success, prevSuccess) => success && prevSuccess);
        return this.isSubscribed;
    }
    subscribeUsers() {
        return [...this.users.values()].map((user) => user.subscribe());
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        let promises = [...this.users.values()]
            .map((user) => user.fetchAccounts())
            .concat(this.accountSubscriber.fetch());
        if (this.userStats) {
            promises = promises.concat(this.userStats.fetchAccounts());
        }
        await Promise.all(promises);
    }
    async unsubscribe() {
        let unsubscribePromises = this.unsubscribeUsers().concat(this.accountSubscriber.unsubscribe());
        if (this.userStats !== undefined) {
            unsubscribePromises = unsubscribePromises.concat(this.userStats.unsubscribe());
        }
        await Promise.all(unsubscribePromises);
        this.isSubscribed = false;
    }
    unsubscribeUsers() {
        return [...this.users.values()].map((user) => user.unsubscribe());
    }
    async getStatePublicKey() {
        if (this.statePublicKey) {
            return this.statePublicKey;
        }
        this.statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        return this.statePublicKey;
    }
    getSignerPublicKey() {
        if (this.signerPublicKey) {
            return this.signerPublicKey;
        }
        this.signerPublicKey = (0, pda_1.getDriftSignerPublicKey)(this.program.programId);
        return this.signerPublicKey;
    }
    getStateAccount() {
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     */
    async forceGetStateAccount() {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    getPerpMarketAccount(marketIndex) {
        var _a;
        return (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetPerpMarketAccount(marketIndex) {
        var _a, _b;
        await this.accountSubscriber.fetch();
        let data = (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
        let i = 0;
        while (data === undefined && i < 10) {
            await this.accountSubscriber.fetch();
            data = (_b = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _b === void 0 ? void 0 : _b.data;
            i++;
        }
        return data;
    }
    getPerpMarketAccounts() {
        return this.accountSubscriber
            .getMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getSpotMarketAccount(marketIndex) {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetSpotMarketAccount(marketIndex) {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    getSpotMarketAccounts() {
        return this.accountSubscriber
            .getSpotMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getQuoteSpotMarketAccount() {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).data;
    }
    getOraclePriceDataAndSlot(oraclePublicKey, oracleSource) {
        return this.accountSubscriber.getOraclePriceDataAndSlot((0, oracleId_1.getOracleId)(oraclePublicKey, oracleSource));
    }
    async getSerumV3FulfillmentConfig(serumMarket) {
        const address = await (0, pda_1.getSerumFulfillmentConfigPublicKey)(this.program.programId, serumMarket);
        return (await this.program.account.serumV3FulfillmentConfig.fetch(address));
    }
    async getSerumV3FulfillmentConfigs() {
        const accounts = await this.program.account.serumV3FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    async getPhoenixV1FulfillmentConfig(phoenixMarket) {
        const address = await (0, pda_1.getPhoenixFulfillmentConfigPublicKey)(this.program.programId, phoenixMarket);
        return (await this.program.account.phoenixV1FulfillmentConfig.fetch(address));
    }
    async getPhoenixV1FulfillmentConfigs() {
        const accounts = await this.program.account.phoenixV1FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    async getOpenbookV2FulfillmentConfig(openbookMarket) {
        const address = (0, pda_1.getOpenbookV2FulfillmentConfigPublicKey)(this.program.programId, openbookMarket);
        return (await this.program.account.openbookV2FulfillmentConfig.fetch(address));
    }
    async getOpenbookV2FulfillmentConfigs() {
        const accounts = await this.program.account.openbookV2FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    /** @deprecated use fetchAllLookupTableAccounts() */
    async fetchMarketLookupTableAccount() {
        if (this.lookupTableAccount)
            return this.lookupTableAccount;
        if (!this.marketLookupTable) {
            console.log('Market lookup table address not set');
            return;
        }
        const lookupTableAccount = (await this.connection.getAddressLookupTable(this.marketLookupTable)).value;
        this.lookupTableAccount = lookupTableAccount;
        return lookupTableAccount;
    }
    async fetchAllLookupTableAccounts() {
        if (this.lookupTableAccounts)
            return this.lookupTableAccounts;
        if (!this.marketLookupTables) {
            console.log('Market lookup table address not set');
            return;
        }
        const lookupTableAccountResults = await Promise.all(this.marketLookupTables.map((lookupTable) => this.connection.getAddressLookupTable(lookupTable)));
        const lookupTableAccounts = lookupTableAccountResults.map((result) => result.value);
        this.lookupTableAccounts = lookupTableAccounts;
        return lookupTableAccounts;
    }
    /**
     * Update the wallet to use for drift transactions and linked user account
     * @param newWallet
     * @param subAccountIds
     * @param activeSubAccountId
     * @param includeDelegates
     */
    async updateWallet(newWallet, subAccountIds, activeSubAccountId, includeDelegates, authoritySubaccountMap) {
        var _a, _b, _c;
        const newProvider = new anchor_1.AnchorProvider(this.connection, 
        // @ts-ignore
        newWallet, this.opts);
        const newProgram = new anchor_1.Program(drift_json_1.default, this.program.programId, newProvider);
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.txSender.wallet = newWallet;
        this.wallet = newWallet;
        this.txHandler.updateWallet(newWallet);
        this.provider = newProvider;
        this.program = newProgram;
        this.authority = newWallet.publicKey;
        this.activeSubAccountId = activeSubAccountId;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = includeDelegates !== null && includeDelegates !== void 0 ? includeDelegates : false;
        const walletSupportsVersionedTxns = 
        //@ts-ignore
        (_b = (_a = this.wallet.supportedTransactionVersions) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 > 1;
        this.txVersion = walletSupportsVersionedTxns ? 0 : 'legacy';
        if (includeDelegates && subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (authoritySubaccountMap && subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (authoritySubaccountMap && includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = authoritySubaccountMap
            ? authoritySubaccountMap
            : subAccountIds
                ? new Map([[this.authority.toString(), subAccountIds]])
                : new Map();
        /* Reset user stats account */
        if ((_c = this.userStats) === null || _c === void 0 ? void 0 : _c.isSubscribed) {
            await this.userStats.unsubscribe();
        }
        this.userStats = undefined;
        this.userStats = new userStats_1.UserStats({
            driftClient: this,
            userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
            accountSubscription: this.userStatsAccountSubscriptionConfig,
        });
        const subscriptionPromises = [this.userStats.subscribe()];
        let success = true;
        if (this.isSubscribed) {
            const reSubscribeUsersPromise = async () => {
                await Promise.all(this.unsubscribeUsers());
                this.users.clear();
                success = await this.addAndSubscribeToUsers();
            };
            subscriptionPromises.push(reSubscribeUsersPromise());
        }
        await Promise.all(subscriptionPromises);
        return success;
    }
    /**
     * Update the subscribed accounts to a given authority, while leaving the
     * connected wallet intact. This allows a user to emulate another user's
     * account on the UI and sign permissionless transactions with their own wallet.
     * @param emulateAuthority
     */
    async emulateAccount(emulateAuthority) {
        var _a, _b, _c;
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.authority = emulateAuthority;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = true;
        const walletSupportsVersionedTxns = 
        //@ts-ignore
        (_b = (_a = this.wallet.supportedTransactionVersions) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 > 1;
        this.txVersion = walletSupportsVersionedTxns ? 0 : 'legacy';
        this.authoritySubAccountMap = new Map();
        /* Reset user stats account */
        if ((_c = this.userStats) === null || _c === void 0 ? void 0 : _c.isSubscribed) {
            await this.userStats.unsubscribe();
        }
        this.userStats = undefined;
        this.userStats = new userStats_1.UserStats({
            driftClient: this,
            userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
            accountSubscription: this.userStatsAccountSubscriptionConfig,
        });
        await this.userStats.subscribe();
        let success = true;
        if (this.isSubscribed) {
            await Promise.all(this.unsubscribeUsers());
            this.users.clear();
            success = await this.addAndSubscribeToUsers(emulateAuthority);
        }
        return success;
    }
    async switchActiveUser(subAccountId, authority) {
        var _a;
        const authorityChanged = authority && !((_a = this.authority) === null || _a === void 0 ? void 0 : _a.equals(authority));
        this.activeSubAccountId = subAccountId;
        this.authority = authority !== null && authority !== void 0 ? authority : this.authority;
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        /* If changing the user authority ie switching from delegate to non-delegate account, need to re-subscribe to the user stats account */
        if (authorityChanged && this.userStats) {
            if (this.userStats.isSubscribed) {
                await this.userStats.unsubscribe();
            }
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: this.userStatsAccountPublicKey,
                accountSubscription: this.userAccountSubscriptionConfig,
            });
            this.userStats.subscribe();
        }
    }
    async addUser(subAccountId, authority, userAccount) {
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userKey = this.getUserMapKey(subAccountId, authority);
        if (this.users.has(userKey) && this.users.get(userKey).isSubscribed) {
            return true;
        }
        const user = this.createUser(subAccountId, this.userAccountSubscriptionConfig, authority);
        const result = await user.subscribe(userAccount);
        if (result) {
            this.users.set(userKey, user);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Adds and subscribes to users based on params set by the constructor or by updateWallet.
     */
    async addAndSubscribeToUsers(authority) {
        var _a, _b, _c, _d, _e, _f, _g;
        // save the rpc calls if driftclient is initialized without a real wallet
        if (this.skipLoadUsers)
            return true;
        let result = true;
        if (this.authoritySubAccountMap && this.authoritySubAccountMap.size > 0) {
            this.authoritySubAccountMap.forEach(async (value, key) => {
                for (const subAccountId of value) {
                    result =
                        result && (await this.addUser(subAccountId, new web3_js_1.PublicKey(key)));
                }
            });
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_a = [...this.authoritySubAccountMap.values()][0][0]) !== null && _a !== void 0 ? _a : 0, new web3_js_1.PublicKey((_b = [...this.authoritySubAccountMap.keys()][0]) !== null && _b !== void 0 ? _b : this.authority.toString()));
            }
        }
        else {
            let userAccounts = [];
            let delegatedAccounts = [];
            const userAccountsPromise = this.getUserAccountsForAuthority(authority !== null && authority !== void 0 ? authority : this.wallet.publicKey);
            if (this.includeDelegates) {
                const delegatedAccountsPromise = this.getUserAccountsForDelegate(authority !== null && authority !== void 0 ? authority : this.wallet.publicKey);
                [userAccounts, delegatedAccounts] = await Promise.all([
                    userAccountsPromise,
                    delegatedAccountsPromise,
                ]);
                !userAccounts && (userAccounts = []);
                !delegatedAccounts && (delegatedAccounts = []);
            }
            else {
                userAccounts = (_c = (await userAccountsPromise)) !== null && _c !== void 0 ? _c : [];
            }
            const allAccounts = userAccounts.concat(delegatedAccounts);
            const addAllAccountsPromise = allAccounts.map((acc) => this.addUser(acc.subAccountId, acc.authority, acc));
            const addAllAccountsResults = await Promise.all(addAllAccountsPromise);
            result = addAllAccountsResults.every((res) => !!res);
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_e = (_d = userAccounts.concat(delegatedAccounts)[0]) === null || _d === void 0 ? void 0 : _d.subAccountId) !== null && _e !== void 0 ? _e : 0, (_g = (_f = userAccounts.concat(delegatedAccounts)[0]) === null || _f === void 0 ? void 0 : _f.authority) !== null && _g !== void 0 ? _g : this.authority);
            }
        }
        return result;
    }
    async initializeUserAccount(subAccountId = 0, name, referrerInfo, txParams) {
        const initializeIxs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                initializeIxs.push(await this.getInitializeUserStatsIx());
            }
        }
        initializeIxs.push(initializeUserAccountIx);
        const tx = await this.buildTransaction(initializeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getInitializeUserStatsIx() {
        return await this.program.instruction.initializeUserStats({
            accounts: {
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async initializeSwiftUserOrders(authority, numOrders, txParams) {
        const initializeIxs = [];
        const [swiftUserAccountPublicKey, initializeUserAccountIx] = await this.getInitializeSwiftUserOrdersAccountIx(authority, numOrders);
        initializeIxs.push(initializeUserAccountIx);
        const tx = await this.buildTransaction(initializeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return [txSig, swiftUserAccountPublicKey];
    }
    async getInitializeSwiftUserOrdersAccountIx(authority, numOrders) {
        const swiftUserAccountPublicKey = (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, authority);
        const initializeUserAccountIx = await this.program.instruction.initializeSwiftUserOrders(numOrders, {
            accounts: {
                swiftUserOrders: swiftUserAccountPublicKey,
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return [swiftUserAccountPublicKey, initializeUserAccountIx];
    }
    async resizeSwiftUserOrders(authority, numOrders, txParams) {
        const resizeUserAccountIx = await this.getResizeSwiftUserOrdersInstruction(authority, numOrders);
        const tx = await this.buildTransaction([resizeUserAccountIx], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getResizeSwiftUserOrdersInstruction(authority, numOrders) {
        const swiftUserAccountPublicKey = (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, authority);
        const resizeUserAccountIx = await this.program.instruction.resizeSwiftUserOrders(numOrders, {
            accounts: {
                swiftUserOrders: swiftUserAccountPublicKey,
                authority: this.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return resizeUserAccountIx;
    }
    async initializeFuelOverflow(authority) {
        const ix = await this.getInitializeFuelOverflowIx(authority);
        const tx = await this.buildTransaction([ix], this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getInitializeFuelOverflowIx(authority) {
        return await this.program.instruction.initializeFuelOverflow({
            accounts: {
                fuelOverflow: (0, pda_1.getFuelOverflowAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                authority: authority !== null && authority !== void 0 ? authority : this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    async sweepFuel(authority) {
        const ix = await this.getSweepFuelIx(authority);
        const tx = await this.buildTransaction([ix], this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSweepFuelIx(authority) {
        return await this.program.instruction.sweepFuel({
            accounts: {
                fuelOverflow: (0, pda_1.getFuelOverflowAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                authority: authority !== null && authority !== void 0 ? authority : this.wallet.publicKey,
                signer: this.wallet.publicKey,
            },
        });
    }
    async getInitializeUserInstructions(subAccountId = 0, name, referrerInfo) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, subAccountId);
        const remainingAccounts = new Array();
        if (referrerInfo !== undefined) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const state = this.getStateAccount();
        if (!state.whitelistMint.equals(web3_js_1.PublicKey.default)) {
            const associatedTokenPublicKey = await (0, spl_token_1.getAssociatedTokenAddress)(state.whitelistMint, this.wallet.publicKey);
            remainingAccounts.push({
                pubkey: associatedTokenPublicKey,
                isWritable: false,
                isSigner: false,
            });
        }
        if (name === undefined) {
            if (subAccountId === 0) {
                name = userName_1.DEFAULT_USER_NAME;
            }
            else {
                name = `Subaccount ${subAccountId + 1}`;
            }
        }
        const nameBuffer = (0, userName_1.encodeName)(name);
        const initializeUserAccountIx = await this.program.instruction.initializeUser(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
            remainingAccounts,
        });
        return [userAccountPublicKey, initializeUserAccountIx];
    }
    async getNextSubAccountId() {
        const userStats = this.getUserStats();
        let userStatsAccount;
        if (!userStats) {
            userStatsAccount = await (0, fetch_1.fetchUserStatsAccount)(this.connection, this.program, this.wallet.publicKey);
        }
        else {
            userStatsAccount = userStats.getAccount();
        }
        return userStatsAccount.numberOfSubAccountsCreated;
    }
    async initializeReferrerName(name) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, 0);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        const tx = await this.program.transaction.initializeReferrerName(nameBuffer, {
            accounts: {
                referrerName: referrerNameAccountPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserName(name, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const tx = await this.program.transaction.updateUserName(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserCustomMarginRatio(updates, txParams) {
        const ixs = await Promise.all(updates.map(async ({ marginRatio, subAccountId }) => {
            const ix = await this.getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId);
            return ix;
        }));
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        const ix = this.program.instruction.updateUserCustomMarginRatio(subAccountId, marginRatio, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId = 0, userAccountPublicKey) {
        const userAccountPublicKeyToUse = userAccountPublicKey ||
            (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        let remainingAccounts;
        try {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.getUserAccount(subAccountId)],
            });
        }
        catch (err) {
            remainingAccounts = [];
        }
        return await this.program.instruction.updateUserMarginTradingEnabled(subAccountId, marginTradingEnabled, {
            accounts: {
                user: userAccountPublicKeyToUse,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserMarginTradingEnabled(updates) {
        const ixs = await Promise.all(updates.map(async ({ marginTradingEnabled, subAccountId }) => {
            return await this.getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserDelegate(delegate, subAccountId = 0) {
        const tx = await this.program.transaction.updateUserDelegate(subAccountId, delegate, {
            accounts: {
                user: await this.getUserAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserAdvancedLp(updates) {
        const ixs = await Promise.all(updates.map(async ({ advancedLp, subAccountId }) => {
            return await this.getUpdateAdvancedDlpIx(advancedLp, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateAdvancedDlpIx(advancedLp, subAccountId) {
        const ix = await this.program.instruction.updateUserAdvancedLp(subAccountId, advancedLp, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async updateUserReduceOnly(updates) {
        const ixs = await Promise.all(updates.map(async ({ reduceOnly, subAccountId }) => {
            return await this.getUpdateUserReduceOnlyIx(reduceOnly, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserReduceOnlyIx(reduceOnly, subAccountId) {
        const ix = await this.program.instruction.updateUserReduceOnly(subAccountId, reduceOnly, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async updateUserPoolId(updates) {
        const ixs = await Promise.all(updates.map(async ({ poolId, subAccountId }) => {
            return await this.getUpdateUserPoolIdIx(poolId, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserPoolIdIx(poolId, subAccountId) {
        const ix = await this.program.instruction.updateUserPoolId(subAccountId, poolId, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async fetchAllUserAccounts(includeIdle = true) {
        let filters = undefined;
        if (!includeIdle) {
            filters = [(0, memcmp_1.getNonIdleUserFilter)()];
        }
        return (await this.program.account.user.all(filters));
    }
    async getUserAccountsForDelegate(delegate) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(delegate.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getUserAccountsAndAddressesForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount);
    }
    async getUserAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getReferredUserStatsAccountsByReferrer(referrer) {
        const programAccounts = await this.program.account.userStats.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(referrer.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async getReferrerNameAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.referrerName.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async deleteUser(subAccountId = 0, txParams) {
        var _a;
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getUserDeletionIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        const userMapKey = this.getUserMapKey(subAccountId, this.wallet.publicKey);
        await ((_a = this.users.get(userMapKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe());
        this.users.delete(userMapKey);
        return txSig;
    }
    async getUserDeletionIx(userAccountPublicKey) {
        const ix = await this.program.instruction.deleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        return ix;
    }
    async forceDeleteUser(userAccountPublicKey, userAccount, txParams) {
        const tx = await this.buildTransaction(await this.getForceDeleteUserIx(userAccountPublicKey, userAccount), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getForceDeleteUserIx(userAccountPublicKey, userAccount) {
        const writableSpotMarketIndexes = [];
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                continue;
            }
            writableSpotMarketIndexes.push(spotPosition.marketIndex);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes,
        });
        const tokenPrograms = new Set();
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                continue;
            }
            const spotMarket = this.getSpotMarketAccount(spotPosition.marketIndex);
            remainingAccounts.push({
                isSigner: false,
                isWritable: true,
                pubkey: spotMarket.vault,
            });
            const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
            const keeperVault = await this.getAssociatedTokenAccount(spotPosition.marketIndex, false, tokenProgram);
            remainingAccounts.push({
                isSigner: false,
                isWritable: true,
                pubkey: keeperVault,
            });
            tokenPrograms.add(tokenProgram.toBase58());
        }
        for (const tokenProgram of tokenPrograms) {
            remainingAccounts.push({
                isSigner: false,
                isWritable: false,
                pubkey: new web3_js_1.PublicKey(tokenProgram),
            });
        }
        const authority = userAccount.authority;
        const userStats = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = await this.program.instruction.forceDeleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats,
                authority,
                state: await this.getStatePublicKey(),
                driftSigner: this.getSignerPublicKey(),
                keeper: this.wallet.publicKey,
            },
            remainingAccounts,
        });
        return ix;
    }
    async deleteSwiftUserOrders(txParams) {
        const ix = await this.getSwiftUserOrdersDeletionIx(this.wallet.publicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async getSwiftUserOrdersDeletionIx(authority) {
        const ix = await this.program.instruction.deleteSwiftUserOrders({
            accounts: {
                user: authority,
                swiftUserOrders: (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, authority),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        return ix;
    }
    /**
     * Checks if a Swift User Orders account exists for the given authority.
     * The account pubkey is derived using the program ID and authority as seeds.
     * Makes an RPC call to check if the account exists on-chain.
     *
     * @param authority The authority public key to check for
     * @returns Promise that resolves to true if the account exists, false otherwise
     */
    async isSwiftUserOrdersAccountInitialized(authority) {
        const swiftUserOrdersAccountPublicKey = (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, authority);
        return this.checkIfAccountExists(swiftUserOrdersAccountPublicKey);
    }
    async reclaimRent(subAccountId = 0, txParams) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getReclaimRentIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async getReclaimRentIx(userAccountPublicKey) {
        return await this.program.instruction.reclaimRent({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
        });
    }
    getUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        if (!this.users.has(userMapKey)) {
            throw new Error(`DriftClient has no user for user id ${userMapKey}`);
        }
        return this.users.get(userMapKey);
    }
    hasUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        return this.users.has(userMapKey);
    }
    getUsers() {
        // delegate users get added to the end
        return [...this.users.values()]
            .filter((acct) => acct.getUserAccount().authority.equals(this.wallet.publicKey))
            .concat([...this.users.values()].filter((acct) => !acct.getUserAccount().authority.equals(this.wallet.publicKey)));
    }
    getUserStats() {
        return this.userStats;
    }
    async fetchReferrerNameAccount(name) {
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        return (await this.program.account.referrerName.fetch(referrerNameAccountPublicKey));
    }
    getUserStatsAccountPublicKey() {
        if (this.userStatsAccountPublicKey) {
            return this.userStatsAccountPublicKey;
        }
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        return this.userStatsAccountPublicKey;
    }
    async getUserAccountPublicKey(subAccountId, authority) {
        return this.getUser(subAccountId, authority).userAccountPublicKey;
    }
    getUserAccount(subAccountId, authority) {
        return this.getUser(subAccountId, authority).getUserAccount();
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param subAccountId
     */
    async forceGetUserAccount(subAccountId) {
        await this.getUser(subAccountId).fetchAccounts();
        return this.getUser(subAccountId).getUserAccount();
    }
    getUserAccountAndSlot(subAccountId) {
        return this.getUser(subAccountId).getUserAccountAndSlot();
    }
    getSpotPosition(marketIndex, subAccountId) {
        return this.getUserAccount(subAccountId).spotPositions.find((spotPosition) => spotPosition.marketIndex === marketIndex);
    }
    getQuoteAssetTokenAmount() {
        return this.getTokenAmount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
    }
    /**
     * Returns the token amount for a given market. The spot market precision is based on the token mint decimals.
     * Positive if it is a deposit, negative if it is a borrow.
     * @param marketIndex
     */
    getTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        if (spotPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType), spotPosition.balanceType);
    }
    /**
     * Converts an amount to the spot precision for a given market. The spot market precision is based on the token mint decimals.
     * @param marketIndex
     * @param amount
     */
    convertToSpotPrecision(marketIndex, amount) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotMarket_1.castNumberToSpotPrecision)(amount, spotMarket);
    }
    /**
     * Converts an amount to the perp precision. The perp market precision is {@link BASE_PRECISION} (1e9).
     * @param amount
     */
    convertToPerpPrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_1.numberToSafeBN)(amount, numericConstants_1.BASE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Converts an amount to the price precision. The perp market precision is {@link PRICE_PRECISION} (1e6).
     * @param amount
     */
    convertToPricePrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_1.numberToSafeBN)(amount, numericConstants_1.PRICE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Each drift instruction must include perp and sport market accounts in the ix remaining accounts.
     * Use this function to force a subset of markets to be included in the remaining accounts for every ix
     *
     * @param perpMarketIndexes
     * @param spotMarketIndexes
     */
    mustIncludeMarketsInIx({ perpMarketIndexes, spotMarketIndexes, }) {
        perpMarketIndexes.forEach((perpMarketIndex) => {
            this.mustIncludePerpMarketIndexes.add(perpMarketIndex);
        });
        spotMarketIndexes.forEach((spotMarketIndex) => {
            this.mustIncludeSpotMarketIndexes.add(spotMarketIndex);
        });
    }
    getRemainingAccounts(params) {
        var _a;
        const { oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap } = this.getRemainingAccountMapsForUsers(params.userAccounts);
        if (params.useMarketLastSlotCache) {
            const lastUserSlot = (_a = this.getUserAccountAndSlot()) === null || _a === void 0 ? void 0 : _a.slot;
            for (const [marketIndex, slot,] of this.perpMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
                else {
                    this.perpMarketLastSlotCache.delete(marketIndex);
                }
            }
            for (const [marketIndex, slot,] of this.spotMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addSpotMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                }
                else {
                    this.spotMarketLastSlotCache.delete(marketIndex);
                }
            }
        }
        if (params.readablePerpMarketIndex !== undefined) {
            const readablePerpMarketIndexes = Array.isArray(params.readablePerpMarketIndex)
                ? params.readablePerpMarketIndex
                : [params.readablePerpMarketIndex];
            for (const marketIndex of readablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        for (const perpMarketIndex of this.mustIncludePerpMarketIndexes.values()) {
            this.addPerpMarketToRemainingAccountMaps(perpMarketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
        }
        if (params.readableSpotMarketIndexes !== undefined) {
            for (const readableSpotMarketIndex of params.readableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(readableSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
            }
        }
        for (const spotMarketIndex of this.mustIncludeSpotMarketIndexes.values()) {
            this.addSpotMarketToRemainingAccountMaps(spotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
        }
        if (params.writablePerpMarketIndexes !== undefined) {
            for (const writablePerpMarketIndex of params.writablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(writablePerpMarketIndex, true, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        if (params.writableSpotMarketIndexes !== undefined) {
            for (const writableSpotMarketIndex of params.writableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(writableSpotMarketIndex, true, oracleAccountMap, spotMarketAccountMap);
            }
        }
        return [
            ...oracleAccountMap.values(),
            ...spotMarketAccountMap.values(),
            ...perpMarketAccountMap.values(),
        ];
    }
    addPerpMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        perpMarketAccountMap.set(marketIndex, {
            pubkey: perpMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        const oracleWritable = writable && (0, types_1.isVariant)(perpMarketAccount.amm.oracleSource, 'prelaunch');
        oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
            pubkey: perpMarketAccount.amm.oracle,
            isSigner: false,
            isWritable: oracleWritable,
        });
        this.addSpotMarketToRemainingAccountMaps(perpMarketAccount.quoteSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
    }
    addSpotMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        spotMarketAccountMap.set(spotMarketAccount.marketIndex, {
            pubkey: spotMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
            oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                pubkey: spotMarketAccount.oracle,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    getRemainingAccountMapsForUsers(userAccounts) {
        const oracleAccountMap = new Map();
        const spotMarketAccountMap = new Map();
        const perpMarketAccountMap = new Map();
        for (const userAccount of userAccounts) {
            for (const spotPosition of userAccount.spotPositions) {
                if (!(0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                    this.addSpotMarketToRemainingAccountMaps(spotPosition.marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                    if (!spotPosition.openAsks.eq(numericConstants_1.ZERO) ||
                        !spotPosition.openBids.eq(numericConstants_1.ZERO)) {
                        this.addSpotMarketToRemainingAccountMaps(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, false, oracleAccountMap, spotMarketAccountMap);
                    }
                }
            }
            for (const position of userAccount.perpPositions) {
                if (!(0, position_1.positionIsAvailable)(position)) {
                    this.addPerpMarketToRemainingAccountMaps(position.marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
            }
        }
        return {
            oracleAccountMap,
            spotMarketAccountMap,
            perpMarketAccountMap,
        };
    }
    getOrder(orderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.orderId === orderId);
    }
    getOrderByUserId(userOrderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.userOrderId === userOrderId);
    }
    /**
     * Get the associated token address for the given spot market
     * @param marketIndex
     * @param useNative
     * @param tokenProgram
     */
    async getAssociatedTokenAccount(marketIndex, useNative = true, tokenProgram = spl_token_1.TOKEN_PROGRAM_ID) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        if (useNative && spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT)) {
            return this.wallet.publicKey;
        }
        const mint = spotMarket.mint;
        return await (0, spl_token_1.getAssociatedTokenAddress)(mint, this.wallet.publicKey, undefined, tokenProgram);
    }
    createAssociatedTokenAccountIdempotentInstruction(account, payer, owner, mint, tokenProgram = spl_token_1.TOKEN_PROGRAM_ID) {
        return new web3_js_1.TransactionInstruction({
            keys: [
                { pubkey: payer, isSigner: true, isWritable: true },
                { pubkey: account, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: false, isWritable: false },
                { pubkey: mint, isSigner: false, isWritable: false },
                {
                    pubkey: anchor.web3.SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                { pubkey: tokenProgram, isSigner: false, isWritable: false },
            ],
            programId: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
            data: Buffer.from([0x1]),
        });
    }
    async getDepositTxnIx(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const signerAuthority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && associatedTokenAccount.equals(signerAuthority);
        const instructions = [];
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            associatedTokenAccount = pubkey;
            instructions.push(...ixs);
        }
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, true);
        instructions.push(depositCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            instructions.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAccount, signerAuthority, signerAuthority, []));
        }
        return instructions;
    }
    async createDepositTxn(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, txParams) {
        const instructions = await this.getDepositTxnIx(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly);
        txParams = { ...(txParams !== null && txParams !== void 0 ? txParams : this.txParams), computeUnits: 600000 };
        const tx = await this.buildTransaction(instructions, txParams);
        return tx;
    }
    /**
     * Deposit funds into the given spot market
     *
     * @param amount to deposit
     * @param marketIndex spot market index to deposit into
     * @param associatedTokenAccount can be the wallet public key if using native sol
     * @param subAccountId subaccountId to deposit
     * @param reduceOnly if true, deposit must not increase account risk
     */
    async deposit(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, txParams) {
        const tx = await this.createDepositTxn(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, txParams);
        const { txSig, slot } = await this.sendTransaction(tx, [], this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, reduceOnly = false, userInitialized = true) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        let remainingAccounts = [];
        if (userInitialized) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [await this.forceGetUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [],
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        return await this.program.instruction.deposit(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
    }
    async checkIfAccountExists(account) {
        try {
            const accountInfo = await this.connection.getAccountInfo(account);
            return accountInfo != null;
        }
        catch (e) {
            // Doesn't already exist
            return false;
        }
    }
    async getWrappedSolAccountCreationIxs(amount, includeRent) {
        const authority = this.wallet.publicKey;
        // Generate a random seed for wrappedSolAccount.
        const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32);
        // Calculate a publicKey that will be controlled by the authority.
        const wrappedSolAccount = await web3_js_1.PublicKey.createWithSeed(authority, seed, spl_token_1.TOKEN_PROGRAM_ID);
        const result = {
            ixs: [],
            signers: [],
            pubkey: wrappedSolAccount,
        };
        const rentSpaceLamports = new anchor_1.BN(web3_js_1.LAMPORTS_PER_SOL / 100);
        const lamports = includeRent
            ? amount.add(rentSpaceLamports)
            : rentSpaceLamports;
        result.ixs.push(web3_js_1.SystemProgram.createAccountWithSeed({
            fromPubkey: authority,
            basePubkey: authority,
            seed,
            newAccountPubkey: wrappedSolAccount,
            lamports: lamports.toNumber(),
            space: 165,
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
        result.ixs.push((0, spl_token_1.createInitializeAccountInstruction)(wrappedSolAccount, spotMarkets_1.WRAPPED_SOL_MINT, authority));
        return result;
    }
    getTokenProgramForSpotMarket(spotMarketAccount) {
        if (spotMarketAccount.tokenProgram === 1) {
            return spl_token_1.TOKEN_2022_PROGRAM_ID;
        }
        return spl_token_1.TOKEN_PROGRAM_ID;
    }
    addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts) {
        if (spotMarketAccount.tokenProgram === 1) {
            remainingAccounts.push({
                pubkey: spotMarketAccount.mint,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    getAssociatedTokenAccountCreationIx(tokenMintAddress, associatedTokenAddress, tokenProgram) {
        return (0, spl_token_1.createAssociatedTokenAccountInstruction)(this.wallet.publicKey, associatedTokenAddress, this.wallet.publicKey, tokenMintAddress, tokenProgram);
    }
    async createInitializeUserAccountAndDepositCollateralIxs(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, customMaxMarginRatio, poolId) {
        const ixs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        const isFromSubaccount = fromSubAccountId !== null &&
            fromSubAccountId !== undefined &&
            !isNaN(fromSubAccountId);
        donateAmount = donateAmount ? donateAmount : numericConstants_1.ZERO;
        const createWSOLTokenAccount = (isSolMarket &&
            userTokenAccount.equals(authority) &&
            !isFromSubaccount) ||
            !donateAmount.eq(numericConstants_1.ZERO);
        const wSolAmount = isSolMarket ? amount.add(donateAmount) : donateAmount;
        let wsolTokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs: startIxs, pubkey } = await this.getWrappedSolAccountCreationIxs(wSolAmount, true);
            wsolTokenAccount = pubkey;
            if (isSolMarket) {
                userTokenAccount = pubkey;
            }
            ixs.push(...startIxs);
        }
        const depositCollateralIx = isFromSubaccount
            ? await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, subAccountId)
            : await this.getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, false, false);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx());
            }
        }
        ixs.push(initializeUserAccountIx);
        if (poolId) {
            ixs.push(await this.getUpdateUserPoolIdIx(poolId, subAccountId));
        }
        ixs.push(depositCollateralIx);
        if (!donateAmount.eq(numericConstants_1.ZERO)) {
            const donateIx = await this.getDepositIntoSpotMarketRevenuePoolIx(1, donateAmount, wsolTokenAccount);
            ixs.push(donateIx);
        }
        // Set the max margin ratio to initialize account with if passed
        if (customMaxMarginRatio) {
            const customMarginRatioIx = await this.getUpdateUserCustomMarginRatioIx(customMaxMarginRatio, subAccountId);
            ixs.push(customMarginRatioIx);
        }
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            ixs.push((0, spl_token_1.createCloseAccountInstruction)(wsolTokenAccount, authority, authority, []));
        }
        return {
            ixs,
            userAccountPublicKey,
        };
    }
    async createInitializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId) {
        const { ixs, userAccountPublicKey } = await this.createInitializeUserAccountAndDepositCollateralIxs(amount, userTokenAccount, marketIndex, subAccountId, name, fromSubAccountId, referrerInfo, donateAmount, customMaxMarginRatio, poolId);
        const tx = await this.buildTransaction(ixs, txParams);
        return [tx, userAccountPublicKey];
    }
    /**
     * Creates the User account for a user, and deposits some initial collateral
     * @param amount
     * @param userTokenAccount
     * @param marketIndex
     * @param subAccountId
     * @param name
     * @param fromSubAccountId
     * @param referrerInfo
     * @param donateAmount
     * @param txParams
     * @returns
     */
    async initializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId) {
        const [tx, userAccountPublicKey] = await this.createInitializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex, subAccountId, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId);
        const additionalSigners = [];
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async initializeUserAccountForDevnet(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, marketIndex, tokenFaucet, amount, referrerInfo, txParams) {
        const ixs = [];
        const [associateTokenPublicKey, createAssociatedAccountIx, mintToIx] = await tokenFaucet.createAssociatedTokenAccountAndMintToInstructions(this.wallet.publicKey, amount);
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associateTokenPublicKey, subAccountId, false, false);
        ixs.push(createAssociatedAccountIx, mintToIx);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx());
            }
        }
        ixs.push(initializeUserAccountIx, depositCollateralIx);
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId, updateFuel = false) {
        const withdrawIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        if (updateFuel) {
            const updateFuelIx = await this.getUpdateUserFuelBonusIx(await this.getUserAccountPublicKey(subAccountId), this.getUserAccount(subAccountId), this.authority);
            withdrawIxs.push(updateFuelIx);
        }
        const createWSOLTokenAccount = isSolMarket && associatedTokenAddress.equals(authority);
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, false);
            associatedTokenAddress = pubkey;
            withdrawIxs.push(...ixs);
        }
        else {
            const accountExists = await this.checkIfAccountExists(associatedTokenAddress);
            if (!accountExists) {
                const createAssociatedTokenAccountIx = this.getAssociatedTokenAccountCreationIx(spotMarketAccount.mint, associatedTokenAddress, this.getTokenProgramForSpotMarket(spotMarketAccount));
                withdrawIxs.push(createAssociatedTokenAccountIx);
            }
        }
        const withdrawCollateralIx = await this.getWithdrawIx(amount, spotMarketAccount.marketIndex, associatedTokenAddress, reduceOnly, subAccountId);
        withdrawIxs.push(withdrawCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            withdrawIxs.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAddress, authority, authority, []));
        }
        return withdrawIxs;
    }
    /**
     * Withdraws from a user account. If deposit doesn't already exist, creates a borrow
     * @param amount
     * @param marketIndex
     * @param associatedTokenAddress - the token account to withdraw to. can be the wallet public key if using native sol
     * @param reduceOnly
     */
    async withdraw(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId, txParams, updateFuel = false) {
        const additionalSigners = [];
        const withdrawIxs = await this.getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly, subAccountId, updateFuel);
        const tx = await this.buildTransaction(withdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async withdrawAllDustPositions(subAccountId, txParams, opts) {
        var _a, _b;
        const user = this.getUser(subAccountId);
        const dustPositionSpotMarketAccounts = user.getSpotMarketAccountsWithDustPosition();
        if (!dustPositionSpotMarketAccounts ||
            dustPositionSpotMarketAccounts.length === 0) {
            (_a = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _a === void 0 ? void 0 : _a.call(opts, 0);
            return undefined;
        }
        (_b = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _b === void 0 ? void 0 : _b.call(opts, dustPositionSpotMarketAccounts.length);
        let allWithdrawIxs = [];
        for (const position of dustPositionSpotMarketAccounts) {
            const tokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(position.mint, this.wallet.publicKey);
            const tokenAmount = await user.getTokenAmount(position.marketIndex);
            const withdrawIxs = await this.getWithdrawalIxs(tokenAmount.muln(2), //  2x to ensure all dust is withdrawn
            position.marketIndex, tokenAccount, true, // reduce-only true to ensure all dust is withdrawn
            subAccountId);
            allWithdrawIxs = allWithdrawIxs.concat(withdrawIxs);
        }
        const tx = await this.buildTransaction(allWithdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getWithdrawIx(amount, marketIndex, userTokenAccount, reduceOnly = false, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        return await this.program.instruction.withdraw(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
    }
    /**
     * Withdraws from the fromSubAccount and deposits into the toSubAccount
     * @param amount
     * @param marketIndex
     * @param fromSubAccountId
     * @param toSubAccountId
     * @param txParams
     */
    async transferDeposit(amount, marketIndex, fromSubAccountId, toSubAccountId, txParams) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId), txParams), [], this.opts);
        if (fromSubAccountId === this.activeSubAccountId ||
            toSubAccountId === this.activeSubAccountId) {
            this.spotMarketLastSlotCache.set(marketIndex, slot);
        }
        return txSig;
    }
    async getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, toSubAccountId);
        let remainingAccounts;
        const userMapKey = this.getUserMapKey(fromSubAccountId, this.wallet.publicKey);
        if (this.users.has(userMapKey)) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.users.get(userMapKey).getUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, fromSubAccountId);
            const fromUserAccount = (await this.program.account.user.fetch(userAccountPublicKey));
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [fromUserAccount],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        return await this.program.instruction.transferDeposit(marketIndex, amount, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
                spotMarketVault: this.getSpotMarketAccount(marketIndex).vault,
            },
            remainingAccounts,
        });
    }
    async updateSpotMarketCumulativeInterest(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.updateSpotMarketCumulativeInterestIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async updateSpotMarketCumulativeInterestIx(marketIndex) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.updateSpotMarketCumulativeInterest({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                spotMarketVault: spotMarket.vault,
                oracle: spotMarket.oracle,
            },
        });
    }
    async settleLP(settleeUserAccountPublicKey, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settleLPIx(settleeUserAccountPublicKey, marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async settleLPIx(settleeUserAccountPublicKey, marketIndex) {
        const settleeUserAccount = (await this.program.account.user.fetch(settleeUserAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.settleLp(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: settleeUserAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async removePerpLpShares(marketIndex, sharesToBurn, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async removePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn), txParams), [], this.opts);
        return txSig;
    }
    async getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpSharesInExpiringMarket(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const userAccount = this.getUserAccount(subAccountId);
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpShares(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async addPerpLpShares(amount, marketIndex, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getAddPerpLpSharesIx(amount, marketIndex, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getAddPerpLpSharesIx(amount, marketIndex, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.addPerpLpShares(amount, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    getQuoteValuePerLpShare(marketIndex) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        const openBids = anchor_1.BN.max(perpMarketAccount.amm.baseAssetReserve.sub(perpMarketAccount.amm.minBaseAssetReserve), numericConstants_1.ZERO);
        const openAsks = anchor_1.BN.max(perpMarketAccount.amm.maxBaseAssetReserve.sub(perpMarketAccount.amm.baseAssetReserve), numericConstants_1.ZERO);
        const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
        const maxOpenBidsAsks = anchor_1.BN.max(openBids, openAsks);
        const quoteValuePerLpShare = maxOpenBidsAsks
            .mul(oraclePriceData.price)
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(numericConstants_1.PRICE_PRECISION)
            .div(perpMarketAccount.amm.sqrtK);
        return quoteValuePerLpShare;
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async openPosition(direction, amount, marketIndex, limitPrice, subAccountId) {
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction,
            baseAssetAmount: amount,
            price: limitPrice,
        }, undefined, undefined, undefined, undefined, undefined, subAccountId);
    }
    async sendSignedTx(tx, opts) {
        const { txSig } = await this.sendTransaction(tx, undefined, opts !== null && opts !== void 0 ? opts : this.opts, true);
        return txSig;
    }
    async prepareMarketOrderTxs(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo, cancelExistingOrders, settlePnl) {
        const marketIndex = orderParams.marketIndex;
        const orderId = userAccount.nextOrderId;
        const ixPromisesForTxs = {
            cancelExistingOrdersTx: undefined,
            settlePnlTx: undefined,
            fillTx: undefined,
            marketOrderTx: undefined,
        };
        const txKeys = Object.keys(ixPromisesForTxs);
        ixPromisesForTxs.marketOrderTx = this.getPlaceOrdersIx([orderParams, ...bracketOrdersParams], userAccount.subAccountId);
        /* Cancel open orders in market if requested */
        if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            ixPromisesForTxs.cancelExistingOrdersTx = this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, userAccount.subAccountId);
        }
        /* Settle PnL after fill if requested */
        if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            ixPromisesForTxs.settlePnlTx = this.settlePNLIx(userAccountPublicKey, userAccount, marketIndex);
        }
        // use versioned transactions if there is a lookup table account and wallet is compatible
        if (this.txVersion === 0) {
            ixPromisesForTxs.fillTx = this.getFillPerpOrderIx(userAccountPublicKey, userAccount, {
                orderId,
                marketIndex,
            }, makerInfo, referrerInfo, userAccount.subAccountId);
        }
        const ixs = await Promise.all(Object.values(ixPromisesForTxs));
        const ixsMap = ixs.reduce((acc, ix, i) => {
            acc[txKeys[i]] = ix;
            return acc;
        }, {});
        const txsMap = (await this.buildTransactionsMap(ixsMap, txParams));
        return txsMap;
    }
    /**
     * Sends a market order and returns a signed tx which can fill the order against the vamm, which the caller can use to fill their own order if required.
     * @param orderParams
     * @param userAccountPublicKey
     * @param userAccount
     * @param makerInfo
     * @param txParams
     * @param bracketOrdersParams
     * @param cancelExistingOrders - Builds and returns an extra transaciton to cancel the existing orders in the same perp market. Intended use is to auto-cancel TP/SL orders when closing a position. Ignored if orderParams.marketType is not MarketType.PERP
     * @returns
     */
    async sendMarketOrderAndGetSignedFillTx(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo, cancelExistingOrders, settlePnl) {
        const preppedTxs = await this.prepareMarketOrderTxs(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams, referrerInfo, cancelExistingOrders, settlePnl);
        const signedTxs = (await this.txHandler.getSignedTransactionMap(preppedTxs, this.wallet)).signedTxMap;
        const { txSig, slot } = await this.sendTransaction(signedTxs.marketOrderTx, [], this.opts, true);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return {
            txSig,
            signedFillTx: signedTxs.fillTx,
            signedCancelExistingOrdersTx: signedTxs.cancelExistingOrdersTx,
            signedSettlePnlTx: signedTxs.settlePnlTx,
        };
    }
    async placePerpOrder(orderParams, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlacePerpOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlacePerpOrderIx(orderParams, subAccountId, depositToTradeArgs) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const isDepositToTradeTx = depositToTradeArgs !== undefined;
        const user = isDepositToTradeTx
            ? (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, subAccountId)
            : await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: (depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.isMakingNewAccount)
                ? []
                : [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: false,
            readablePerpMarketIndex: orderParams.marketIndex,
            readableSpotMarketIndexes: isDepositToTradeTx
                ? [depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.depositMarketIndex]
                : undefined,
        });
        return await this.program.instruction.placePerpOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateAMMs(marketIndexes, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateAMMsIx(marketIndexes), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateAMMsIx(marketIndexes) {
        for (let i = marketIndexes.length; i < 5; i++) {
            marketIndexes.push(100);
        }
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        for (const marketIndex of marketIndexes) {
            if (marketIndex !== 100) {
                const market = this.getPerpMarketAccount(marketIndex);
                marketAccountInfos.push({
                    pubkey: market.pubkey,
                    isWritable: true,
                    isSigner: false,
                });
                oracleAccountInfos.push({
                    pubkey: market.amm.oracle,
                    isWritable: false,
                    isSigner: false,
                });
            }
        }
        const remainingAccounts = oracleAccountInfos.concat(marketAccountInfos);
        return await this.program.instruction.updateAmms(marketIndexes, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarket(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleExpiredMarketIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketIx(marketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, marketIndex);
        return await this.program.instruction.settleExpiredMarket(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.isSubscribed
                    ? this.getStateAccount().admin
                    : this.wallet.publicKey,
                perpMarket: perpMarketPublicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarketPoolsToRevenuePool(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleExpiredMarketPoolsToRevenuePoolIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketPoolsToRevenuePoolIx(perpMarketIndex) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        const spotMarketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        return await this.program.instruction.settleExpiredMarketPoolsToRevenuePool({
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.isSubscribed
                    ? this.getStateAccount().admin
                    : this.wallet.publicKey,
                spotMarket: spotMarketPublicKey,
                perpMarket: perpMarketPublicKey,
            },
        });
    }
    async cancelOrder(orderId, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrderIx(orderId, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderIx(orderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrder(orderId !== null && orderId !== void 0 ? orderId : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrderByUserId(userOrderId, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrderByUserIdIx(userOrderId, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderByUserIdIx(userOrderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const order = this.getOrderByUserId(userOrderId);
        const oracle = this.getPerpMarketAccount(order.marketIndex).amm.oracle;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrderByUserId(userOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
                oracle,
            },
            remainingAccounts,
        });
    }
    async cancelOrdersByIds(orderIds, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersByIdsIx(orderIds, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrdersByIdsIx(orderIds, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrdersByIds(orderIds, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrders(marketType, marketIndex, direction, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersIx(marketType, marketIndex, direction, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrdersIx(marketType, marketIndex, direction, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        let readablePerpMarketIndex = undefined;
        let readableSpotMarketIndexes = undefined;
        if (typeof marketIndex === 'number') {
            if (marketType && (0, types_1.isVariant)(marketType, 'perp')) {
                readablePerpMarketIndex = marketIndex;
            }
            else if (marketType && (0, types_1.isVariant)(marketType, 'spot')) {
                readableSpotMarketIndexes = [marketIndex];
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrders(marketType !== null && marketType !== void 0 ? marketType : null, marketIndex !== null && marketIndex !== void 0 ? marketIndex : null, direction !== null && direction !== void 0 ? direction : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelAndPlaceOrders(cancelOrderParams, placeOrderParams, txParams, subAccountId) {
        const ixs = [
            await this.getCancelOrdersIx(cancelOrderParams.marketType, cancelOrderParams.marketIndex, cancelOrderParams.direction, subAccountId),
            await this.getPlaceOrdersIx(placeOrderParams, subAccountId),
        ];
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async placeOrders(params, txParams, subAccountId, optionalIxs) {
        const { txSig } = await this.sendTransaction((await this.preparePlaceOrdersTx(params, txParams, subAccountId, optionalIxs)).placeOrdersTx, [], this.opts, false);
        return txSig;
    }
    async preparePlaceOrdersTx(params, txParams, subAccountId, optionalIxs) {
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        const tx = await this.buildTransaction(await this.getPlaceOrdersIx(params, subAccountId), txParams, undefined, lookupTableAccounts, undefined, undefined, optionalIxs);
        return {
            placeOrdersTx: tx,
        };
    }
    async getPlaceOrdersIx(params, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const readablePerpMarketIndex = [];
        const readableSpotMarketIndexes = [];
        for (const param of params) {
            if (!param.marketType) {
                throw new Error('must set param.marketType');
            }
            if ((0, types_1.isVariant)(param.marketType, 'perp')) {
                readablePerpMarketIndex.push(param.marketIndex);
            }
            else {
                readableSpotMarketIndexes.push(param.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        const formattedParams = params.map((item) => (0, orderParams_1.getOrderParams)(item));
        return await this.program.instruction.placeOrders(formattedParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillPerpOrder(userAccountPublicKey, user, order, makerInfo, referrerInfo, txParams, fillerSubAccountId, fillerAuthority) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillPerpOrderIx(userAccountPublicKey, user, order, makerInfo, referrerInfo, fillerSubAccountId, undefined, fillerAuthority), txParams), [], this.opts);
        return txSig;
    }
    async getFillPerpOrderIx(userAccountPublicKey, userAccount, order, makerInfo, referrerInfo, fillerSubAccountId, isSwift, fillerAuthority) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        let filler;
        if (fillerAuthority) {
            filler = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, fillerAuthority, fillerSubAccountId);
        }
        else {
            filler = await this.getUserAccountPublicKey(fillerSubAccountId);
        }
        let fillerStatsPublicKey;
        if (fillerAuthority) {
            fillerStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, fillerAuthority);
        }
        else {
            fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        }
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        const orderId = isSwift ? null : order.orderId;
        return await this.program.instruction.fillPerpOrder(orderId, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async getRevertFillIx(fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        return this.program.instruction.revertFill({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async placeSpotOrder(orderParams, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction((await this.preparePlaceSpotOrderTx(orderParams, txParams, subAccountId))
            .placeSpotOrderTx, [], this.opts, false);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async preparePlaceSpotOrderTx(orderParams, txParams, subAccountId) {
        const tx = await this.buildTransaction(await this.getPlaceSpotOrderIx(orderParams, subAccountId), txParams);
        return {
            placeSpotOrderTx: tx,
        };
    }
    async getPlaceSpotOrderIx(orderParams, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            readableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        return await this.program.instruction.placeSpotOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillSpotOrder(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillSpotOrderIx(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo), txParams), [], this.opts);
        return txSig;
    }
    async getFillSpotOrderIx(userAccountPublicKey, userAccount, order, fulfillmentConfig, makerInfo, referrerInfo, fillerPublicKey) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const orderId = order.orderId;
        this.addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.fillSpotOrder(orderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        if (fulfillmentConfig) {
            if ('serumProgramId' in fulfillmentConfig) {
                this.addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('phoenixProgramId' in fulfillmentConfig) {
                this.addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('openbookV2ProgramId' in fulfillmentConfig) {
                this.addOpenbookRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else {
                throw Error('Invalid fulfillment config type');
            }
        }
        else {
            remainingAccounts.push({
                pubkey: this.getSpotMarketAccount(marketIndex).vault,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: this.getQuoteSpotMarketAccount().vault,
                isWritable: false,
                isSigner: false,
            });
        }
    }
    addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumRequestQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumEventQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumAsks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumOpenOrders,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: (0, pda_1.getSerumSignerPublicKey)(fulfillmentConfig.serumProgramId, fulfillmentConfig.serumMarket, fulfillmentConfig.serumSignerNonce),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getStateAccount().srmVault,
            isWritable: false,
            isSigner: false,
        });
    }
    addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixLogAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
    }
    addOpenbookRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2ProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Market,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2MarketAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2EventHeap,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Bids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Asks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2BaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2QuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: web3_js_1.SystemProgram.programId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).pubkey,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().pubkey,
            isWritable: true,
            isSigner: false,
        });
        if (fulfillmentConfig.remainingAccounts) {
            for (const remainingAccount of fulfillmentConfig.remainingAccounts) {
                remainingAccounts.push({
                    pubkey: remainingAccount,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
    }
    /**
     * Swap tokens in drift account using jupiter
     * @param jupiterClient jupiter client to find routes and jupiter instructions
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param outAssociatedTokenAccount the token account to receive the token being sold on jupiter
     * @param inAssociatedTokenAccount the token account to
     * @param amount the amount of TokenIn, regardless of swapMode
     * @param slippageBps the max slippage passed to jupiter api
     * @param swapMode jupiter swapMode (ExactIn or ExactOut), default is ExactIn
     * @param route the jupiter route to use for the swap
     * @param reduceOnly specify if In or Out token on the drift account must reduceOnly, checked at end of swap
     * @param txParams
     */
    async swap({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, route, reduceOnly, txParams, v6, onlyDirectRoutes = false, }) {
        let ixs;
        let lookupTables;
        if (v6) {
            const res = await this.getJupiterSwapIxV6({
                jupiterClient,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                quote: v6.quote,
                reduceOnly,
                onlyDirectRoutes,
            });
            ixs = res.ixs;
            lookupTables = res.lookupTables;
        }
        else {
            const res = await this.getJupiterSwapIx({
                jupiterClient,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                route,
                reduceOnly,
            });
            ixs = res.ixs;
            lookupTables = res.lookupTables;
        }
        const tx = (await this.buildTransaction(ixs, txParams, 0, lookupTables));
        const { txSig, slot } = await this.sendTransaction(tx);
        this.spotMarketLastSlotCache.set(outMarketIndex, slot);
        this.spotMarketLastSlotCache.set(inMarketIndex, slot);
        return txSig;
    }
    async getJupiterSwapIx({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, route, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        if (!route) {
            const routes = await jupiterClient.getRoutes({
                inputMint: inMarket.mint,
                outputMint: outMarket.mint,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
            });
            if (!routes || routes.length === 0) {
                throw new Error('No jupiter routes found');
            }
            route = routes[0];
        }
        const transaction = await jupiterClient.getSwapTransaction({
            route,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint, tokenProgram));
            }
        }
        if (!inAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint, tokenProgram));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: new anchor_1.BN(route.inAmount),
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    async getJupiterSwapIxV6({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, quote, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        if (!quote) {
            const fetchedQuote = await jupiterClient.getQuote({
                inputMint: inMarket.mint,
                outputMint: outMarket.mint,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
            });
            quote = fetchedQuote;
        }
        if (!quote) {
            throw new Error("Could not fetch Jupiter's quote. Please try again.");
        }
        const isExactOut = swapMode === 'ExactOut' || quote.swapMode === 'ExactOut';
        const amountIn = new anchor_1.BN(quote.inAmount);
        const exactOutBufferedAmountIn = amountIn.muln(1001).divn(1000); // Add 10bp buffer
        const transaction = await jupiterClient.getSwap({
            quote,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint, tokenProgram));
            }
        }
        if (!inAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(inMarket);
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint, tokenProgram));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: isExactOut ? exactOutBufferedAmountIn : amountIn,
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    /**
     * Get the drift begin_swap and end_swap instructions
     *
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param amountIn the amount of the token to sell
     * @param inTokenAccount the token account to move the tokens being sold
     * @param outTokenAccount the token account to receive the tokens being bought
     * @param limitPrice the limit price of the swap
     * @param reduceOnly
     * @param userAccountPublicKey optional, specify a custom userAccountPublicKey to use instead of getting the current user account; can be helpful if the account is being created within the current tx
     */
    async getSwapIx({ outMarketIndex, inMarketIndex, amountIn, inTokenAccount, outTokenAccount, limitPrice, reduceOnly, userAccountPublicKey, }) {
        const userAccountPublicKeyToUse = userAccountPublicKey || (await this.getUserAccountPublicKey());
        const userAccounts = [];
        try {
            if (this.hasUser() && this.getUser().getUserAccountAndSlot()) {
                userAccounts.push(this.getUser().getUserAccountAndSlot().data);
            }
        }
        catch (err) {
            // ignore
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [outMarketIndex, inMarketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const outSpotMarket = this.getSpotMarketAccount(outMarketIndex);
        const inSpotMarket = this.getSpotMarketAccount(inMarketIndex);
        const outTokenProgram = this.getTokenProgramForSpotMarket(outSpotMarket);
        const inTokenProgram = this.getTokenProgramForSpotMarket(inSpotMarket);
        if (!outTokenProgram.equals(inTokenProgram)) {
            remainingAccounts.push({
                pubkey: outTokenProgram,
                isWritable: false,
                isSigner: false,
            });
        }
        if (outSpotMarket.tokenProgram === 1 || inSpotMarket.tokenProgram === 1) {
            remainingAccounts.push({
                pubkey: inSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: outSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
        }
        const beginSwapIx = await this.program.instruction.beginSwap(inMarketIndex, outMarketIndex, amountIn, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: inTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.endSwap(inMarketIndex, outMarketIndex, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, reduceOnly !== null && reduceOnly !== void 0 ? reduceOnly : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: inTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async stakeForMSOL({ amount }) {
        const ixs = await this.getStakeForMSOLIx({ amount });
        const tx = await this.buildTransaction(ixs);
        return this.sendTransaction(tx);
    }
    async getStakeForMSOLIx({ amount, userAccountPublicKey, }) {
        const wSOLMint = this.getSpotMarketAccount(1).mint;
        const mSOLAccount = await this.getAssociatedTokenAccount(2);
        const wSOLAccount = await this.getAssociatedTokenAccount(1, false);
        const wSOLAccountExists = await this.checkIfAccountExists(wSOLAccount);
        const closeWSOLIx = (0, spl_token_1.createCloseAccountInstruction)(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey);
        const createWSOLIx = await this.createAssociatedTokenAccountIdempotentInstruction(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey, wSOLMint);
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            inMarketIndex: 1,
            outMarketIndex: 2,
            amountIn: amount,
            inTokenAccount: wSOLAccount,
            outTokenAccount: mSOLAccount,
            userAccountPublicKey,
        });
        const program = (0, marinade_1.getMarinadeFinanceProgram)(this.provider);
        const depositIx = await (0, marinade_1.getMarinadeDepositIx)({
            program,
            mSOLAccount: mSOLAccount,
            transferFrom: this.wallet.publicKey,
            amount,
        });
        const ixs = [];
        if (!wSOLAccountExists) {
            ixs.push(createWSOLIx);
        }
        ixs.push(beginSwapIx, closeWSOLIx, depositIx, createWSOLIx, endSwapIx);
        return ixs;
    }
    async triggerOrder(userAccountPublicKey, user, order, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getTriggerOrderIx(userAccountPublicKey, user, order, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getTriggerOrderIx(userAccountPublicKey, userAccount, order, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        let remainingAccountsParams;
        if ((0, types_1.isVariant)(order.marketType, 'perp')) {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writablePerpMarketIndexes: [order.marketIndex],
            };
        }
        else {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writableSpotMarketIndexes: [order.marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
            };
        }
        const remainingAccounts = this.getRemainingAccounts(remainingAccountsParams);
        const orderId = order.orderId;
        return await this.program.instruction.triggerOrder(orderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async forceCancelOrders(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getForceCancelOrdersIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getForceCancelOrdersIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.forceCancelOrders({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserIdle(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserIdleIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserIdleIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserIdle({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async logUserBalances(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getLogUserBalancesIx(userAccountPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getLogUserBalancesIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.logUserBalances({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserFuelBonus(userAccountPublicKey, user, userAuthority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserFuelBonusIx(userAccountPublicKey, user, userAuthority), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserFuelBonusIx(userAccountPublicKey, userAccount, userAuthority) {
        const userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAuthority);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserFuelBonus({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserStatsReferrerStatus(userAuthority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserStatsReferrerStatusIx(userAuthority), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserStatsReferrerStatusIx(userAuthority) {
        const userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAuthority);
        return await this.program.instruction.updateUserStatsReferrerStatus({
            accounts: {
                state: await this.getStatePublicKey(),
                userStats: userStatsAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async updateUserOpenOrdersCount(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserOpenOrdersCountIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserOpenOrdersCountIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserOpenOrdersCount({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakePerpOrder(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async preparePlaceAndTakePerpOrderWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams = new Array(), txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails, auctionDurationPercentage, optionalIxs) {
        const placeAndTakeIxs = [];
        const txsToSign = {
            placeAndTakeTx: undefined,
            cancelExistingOrdersTx: undefined,
            settlePnlTx: undefined,
        };
        // Get recent block hash so that we can re-use it for all transactions. Makes this logic run faster with fewer RPC requests
        const recentBlockHash = await this.txHandler.getLatestBlockhashForTransaction();
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        let earlyExitFailedPlaceAndTakeSim = false;
        const prepPlaceAndTakeTx = async () => {
            var _a;
            const placeAndTakeIx = await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, undefined, auctionDurationPercentage, subAccountId);
            placeAndTakeIxs.push(placeAndTakeIx);
            if (bracketOrdersParams.length > 0) {
                const bracketOrdersIx = await this.getPlaceOrdersIx(bracketOrdersParams, subAccountId);
                placeAndTakeIxs.push(bracketOrdersIx);
            }
            const shouldUseSimulationComputeUnits = txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnits;
            const shouldExitIfSimulationFails = exitEarlyIfSimFails;
            const txParamsWithoutImplicitSimulation = {
                ...txParams,
                useSimulatedComputeUnits: false,
            };
            if (shouldUseSimulationComputeUnits || shouldExitIfSimulationFails) {
                const placeAndTakeTxToSim = (await this.buildTransaction(placeAndTakeIxs, txParams, undefined, lookupTableAccounts, true, recentBlockHash, optionalIxs));
                const simulationResult = await txParamProcessor_1.TransactionParamProcessor.getTxSimComputeUnits(placeAndTakeTxToSim, this.connection, (_a = txParams.computeUnitsBufferMultiplier) !== null && _a !== void 0 ? _a : 1.2, txParams.lowerBoundCu);
                if (shouldExitIfSimulationFails && !simulationResult.success) {
                    earlyExitFailedPlaceAndTakeSim = true;
                    return;
                }
                txsToSign.placeAndTakeTx = await this.buildTransaction(placeAndTakeIxs, {
                    ...txParamsWithoutImplicitSimulation,
                    computeUnits: simulationResult.computeUnits,
                }, undefined, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            else {
                txsToSign.placeAndTakeTx = await this.buildTransaction(placeAndTakeIxs, txParams, undefined, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        const prepCancelOrderTx = async () => {
            if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
                const cancelOrdersIx = await this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, subAccountId);
                txsToSign.cancelExistingOrdersTx = await this.buildTransaction([cancelOrdersIx], txParams, this.txVersion, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        const prepSettlePnlTx = async () => {
            if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
                const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
                const settlePnlIx = await this.settlePNLIx(userAccountPublicKey, this.getUserAccount(subAccountId), orderParams.marketIndex);
                txsToSign.settlePnlTx = await this.buildTransaction([settlePnlIx], txParams, this.txVersion, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        await Promise.all([
            prepPlaceAndTakeTx(),
            prepCancelOrderTx(),
            prepSettlePnlTx(),
        ]);
        if (earlyExitFailedPlaceAndTakeSim) {
            return null;
        }
        return txsToSign;
    }
    async placeAndTakePerpWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams = new Array(), txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails) {
        const txsToSign = await this.preparePlaceAndTakePerpOrderWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams, txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails);
        if (!txsToSign) {
            return null;
        }
        const signedTxs = (await this.txHandler.getSignedTransactionMap(txsToSign, 
        // @ts-ignore
        this.provider.wallet)).signedTxMap;
        const { txSig, slot } = await this.sendTransaction(signedTxs.placeAndTakeTx, [], this.opts, true);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return {
            txSig,
            signedCancelExistingOrdersTx: signedTxs.cancelExistingOrdersTx,
            signedSettlePnlTx: signedTxs.settlePnlTx,
        };
    }
    async getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [this.getUserAccount(subAccountId)];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        let optionalParams = null;
        if (auctionDurationPercentage || successCondition) {
            optionalParams =
                ((auctionDurationPercentage !== null && auctionDurationPercentage !== void 0 ? auctionDurationPercentage : 100) << 8) | (successCondition !== null && successCondition !== void 0 ? successCondition : 0);
        }
        return await this.program.instruction.placeAndTakePerpOrder(orderParams, optionalParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakePerpOrder(orderParams, takerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakePerpOrder(orderParams, takerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    signSwiftOrderParamsMessage(orderParamsMessage) {
        const borshBuf = this.encodeSwiftOrderParamsMessage(orderParamsMessage);
        const orderParams = Buffer.from(borshBuf.toString('hex'));
        return {
            orderParams,
            signature: this.signMessage(Buffer.from(borshBuf.toString('hex'))),
        };
    }
    /*
     * Borsh encode swift taker order params
     */
    encodeSwiftOrderParamsMessage(orderParamsMessage) {
        const anchorIxName = 'global' + ':' + 'SwiftOrderParamsMessage';
        const prefix = Buffer.from((0, sha256_1.sha256)(anchorIxName).slice(0, 8));
        const buf = Buffer.concat([
            prefix,
            this.program.coder.types.encode('SwiftOrderParamsMessage', orderParamsMessage),
        ]);
        return buf;
    }
    /*
     * Decode swift taker order params from borsh buffer
     */
    decodeSwiftOrderParamsMessage(encodedMessage) {
        return this.program.coder.types.decode('SwiftOrderParamsMessage', encodedMessage.slice(8) // assumes discriminator
        );
    }
    signMessage(message, keypair = this.wallet.payer) {
        return Buffer.from(tweetnacl_1.default.sign.detached(message, keypair.secretKey));
    }
    async placeSwiftTakerOrder(signedSwiftOrderParams, marketIndex, takerInfo, precedingIxs = [], overrideIxCount, txParams) {
        const ixs = await this.getPlaceSwiftTakerPerpOrderIxs(signedSwiftOrderParams, marketIndex, takerInfo, precedingIxs, overrideIxCount);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ixs, txParams), [], this.opts);
        return txSig;
    }
    async getPlaceSwiftTakerPerpOrderIxs(signedSwiftOrderParams, marketIndex, takerInfo, precedingIxs = [], overrideIxCount) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [takerInfo.takerUserAccount],
            useMarketLastSlotCache: true,
            readablePerpMarketIndex: marketIndex,
        });
        const messageLengthBuffer = Buffer.alloc(2);
        messageLengthBuffer.writeUInt16LE(signedSwiftOrderParams.orderParams.length);
        const swiftIxData = Buffer.concat([
            signedSwiftOrderParams.signature,
            takerInfo.signingAuthority.toBytes(),
            messageLengthBuffer,
            signedSwiftOrderParams.orderParams,
        ]);
        const swiftOrderParamsSignatureIx = (0, pythOracleUtils_1.createMinimalEd25519VerifyIx)(overrideIxCount || precedingIxs.length + 1, 12, swiftIxData, 0);
        const isDelegateSigner = takerInfo.signingAuthority.equals(takerInfo.takerUserAccount.delegate);
        const placeTakerSwiftPerpOrderIx = this.program.instruction.placeSwiftTakerOrder(swiftIxData, isDelegateSigner, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: takerInfo.taker,
                userStats: takerInfo.takerStats,
                swiftUserOrders: (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
                authority: this.wallet.publicKey,
                ixSysvar: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return [swiftOrderParamsSignatureIx, placeTakerSwiftPerpOrderIx];
    }
    async placeAndMakeSwiftPerpOrder(signedSwiftOrderParams, swiftOrderUuid, takerInfo, orderParams, referrerInfo, txParams, subAccountId, precedingIxs = [], overrideIxCount) {
        const ixs = await this.getPlaceAndMakeSwiftPerpOrderIxs(signedSwiftOrderParams, swiftOrderUuid, takerInfo, orderParams, referrerInfo, subAccountId, precedingIxs, overrideIxCount);
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(ixs, txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakeSwiftPerpOrderIxs(signedSwiftOrderParams, swiftOrderUuid, takerInfo, orderParams, referrerInfo, subAccountId, precedingIxs = [], overrideIxCount) {
        const [swiftOrderSignatureIx, placeTakerSwiftPerpOrderIx] = await this.getPlaceSwiftTakerPerpOrderIxs(signedSwiftOrderParams, orderParams.marketIndex, takerInfo, precedingIxs, overrideIxCount);
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const placeAndMakeIx = await this.program.instruction.placeAndMakeSwiftPerpOrder(orderParams, swiftOrderUuid, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
                takerSwiftUserOrders: (0, pda_1.getSwiftUserAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
            },
            remainingAccounts,
        });
        return [swiftOrderSignatureIx, placeTakerSwiftPerpOrderIx, placeAndMakeIx];
    }
    async preparePlaceAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId) {
        const tx = await this.buildTransaction(await this.getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId), txParams);
        return {
            placeAndTakeSpotOrderTx: tx,
        };
    }
    async placeAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction((await this.preparePlaceAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId)).placeAndTakeSpotOrderTx, [], this.opts, false);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const userAccounts = [this.getUserAccount(subAccountId)];
        if (makerInfo !== undefined) {
            userAccounts.push(makerInfo.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        let makerOrderId = null;
        if (makerInfo) {
            makerOrderId = makerInfo.order.orderId;
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.placeAndTakeSpotOrder(orderParams, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, makerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakeSpotOrder(orderParams, takerInfo, fulfillmentConfig, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakeSpotOrder(orderParams, takerOrderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async closePosition(marketIndex, limitPrice, subAccountId) {
        const userPosition = this.getUser(subAccountId).getPerpPosition(marketIndex);
        if (!userPosition) {
            throw Error(`No position in market ${marketIndex.toString()}`);
        }
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction: (0, position_1.findDirectionToClose)(userPosition),
            baseAssetAmount: userPosition.baseAssetAmount.abs(),
            reduceOnly: true,
            price: limitPrice,
        }, undefined, undefined, undefined, undefined, undefined, subAccountId);
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrder instead
     * @param orderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrder(orderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrder({
            orderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrderByUserOrderId instead
     * @param userOrderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrderByUserOrderId(userOrderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrderByUserOrderId({
            userOrderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order (spot or perp) by closing it and replacing it with a new order.
     * @param orderParams.orderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration:
     * @param orderParams.auctionStartPrice:
     * @param orderParams.auctionEndPrice:
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.immediateOrCancel:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrder(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getModifyOrderIx({ orderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, policy, }, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly != undefined ? reduceOnly : null,
            postOnly: postOnly != undefined ? postOnly : null,
            immediateOrCancel: immediateOrCancel != undefined ? immediateOrCancel : null,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        return await this.program.instruction.modifyOrder(orderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @param orderParams.userOrderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration: Only required if order type changed to market from something else
     * @param orderParams.auctionStartPrice: Only required if order type changed to market from something else
     * @param orderParams.auctionEndPrice: Only required if order type changed to market from something else
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.immediateOrCancel:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrderByUserOrderId(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderByUserIdIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getModifyOrderByUserIdIx({ userOrderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, immediateOrCancel, maxTs, policy, }, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly || false,
            postOnly: postOnly || null,
            immediateOrCancel: immediateOrCancel || false,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        return await this.program.instruction.modifyOrderByUserId(userOrderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settlePNLs(users, marketIndexes, opts, txParams) {
        const filterInvalidMarkets = opts === null || opts === void 0 ? void 0 : opts.filterInvalidMarkets;
        // # Filter market indexes by markets with valid oracle
        const marketIndexToSettle = filterInvalidMarkets
            ? []
            : marketIndexes;
        if (filterInvalidMarkets) {
            for (const marketIndex of marketIndexes) {
                const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
                const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
                const stateAccountAndSlot = this.accountSubscriber.getStateAccountAndSlot();
                const oracleGuardRails = stateAccountAndSlot.data.oracleGuardRails;
                const isValid = (0, oracles_1.isOracleValid)(perpMarketAccount, oraclePriceData, oracleGuardRails, stateAccountAndSlot.slot);
                if (isValid) {
                    marketIndexToSettle.push(marketIndex);
                }
            }
        }
        // # Settle filtered market indexes
        const ixs = await this.getSettlePNLsIxs(users, marketIndexToSettle);
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : {
            computeUnits: 1400000,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettlePNLsIxs(users, marketIndexes) {
        const ixs = [];
        for (const { settleeUserAccountPublicKey, settleeUserAccount } of users) {
            for (const marketIndex of marketIndexes) {
                ixs.push(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex));
            }
        }
        return ixs;
    }
    async settlePNL(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, txParams, optionalIxs) {
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex), txParams, undefined, lookupTableAccounts, undefined, undefined, optionalIxs), [], this.opts);
        return txSig;
    }
    async settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.settlePnl(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async settleMultiplePNLs(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode), txParams), [], this.opts);
        return txSig;
    }
    async settleMultiplePNLsMultipleTxs(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, txParams) {
        // need multiple TXs because settling more than 4 markets won't fit in a single TX
        const txsToSign = [];
        const marketIndexesInFourGroups = [];
        for (let i = 0; i < marketIndexes.length; i += 4) {
            marketIndexesInFourGroups.push(marketIndexes.slice(i, i + 4));
        }
        for (const marketIndexes of marketIndexesInFourGroups) {
            const ix = await this.settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode);
            const computeUnits = Math.min(300000 * marketIndexes.length, 1400000);
            const tx = await this.buildTransaction(ix, {
                ...txParams,
                computeUnits,
            });
            txsToSign.push(tx);
        }
        const txsMap = {};
        let i = 1;
        for (const tx of txsToSign) {
            txsMap[`tx-${i}`] = tx;
            i++;
        }
        const signedTxs = (await this.txHandler.getSignedTransactionMap(txsMap, this.provider.wallet)).signedTxMap;
        const txSigs = [];
        for (const key in signedTxs) {
            const tx = signedTxs[key];
            const { txSig } = await this.sendTransaction(tx, [], this.opts, true);
            txSigs.push(txSig);
        }
        return txSigs;
    }
    async settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: marketIndexes,
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.settleMultiplePnls(marketIndexes, mode, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getSetUserStatusToBeingLiquidatedIx(userAccountPublicKey, userAccount) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.setUserStatusToBeingLiquidated({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async setUserStatusToBeingLiquidated(userAccountPublicKey, userAccount) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSetUserStatusToBeingLiquidatedIx(userAccountPublicKey, userAccount)), [], this.opts);
        return txSig;
    }
    async liquidatePerp(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return await this.program.instruction.liquidatePerp(marketIndex, maxBaseAssetAmount, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpWithFill(userAccountPublicKey, userAccount, marketIndex, makerInfos, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpWithFillIx(userAccountPublicKey, userAccount, marketIndex, makerInfos, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpWithFillIx(userAccountPublicKey, userAccount, marketIndex, makerInfos, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                userAccount,
                ...makerInfos.map((makerInfo) => makerInfo.makerUserAccount),
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const makerInfo of makerInfos) {
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        return await this.program.instruction.liquidatePerpWithFill(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateSpot(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
        });
        return await this.program.instruction.liquidateSpot(assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getJupiterLiquidateSpotWithSwapIxV6({ jupiterClient, liabilityMarketIndex, assetMarketIndex, swapAmount, assetTokenAccount, liabilityTokenAccount, slippageBps, swapMode, onlyDirectRoutes, quote, userAccount, userAccountPublicKey, userStatsAccountPublicKey, liquidatorSubAccountId, maxAccounts, }) {
        const liabilityMarket = this.getSpotMarketAccount(liabilityMarketIndex);
        const assetMarket = this.getSpotMarketAccount(assetMarketIndex);
        if (!quote) {
            const fetchedQuote = await jupiterClient.getQuote({
                inputMint: assetMarket.mint,
                outputMint: liabilityMarket.mint,
                amount: swapAmount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
                maxAccounts,
            });
            quote = fetchedQuote;
        }
        if (!quote) {
            throw new Error("Could not fetch Jupiter's quote. Please try again.");
        }
        const amountIn = new anchor_1.BN(quote.inAmount);
        const transaction = await jupiterClient.getSwap({
            quote,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: assetMarket.mint,
            outputMint: liabilityMarket.mint,
        });
        const preInstructions = [];
        if (!liabilityTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(liabilityMarket);
            liabilityTokenAccount = await this.getAssociatedTokenAccount(liabilityMarket.marketIndex, false, tokenProgram);
            preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(liabilityTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, liabilityMarket.mint, tokenProgram));
        }
        if (!assetTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(assetMarket);
            assetTokenAccount = await this.getAssociatedTokenAccount(assetMarket.marketIndex, false, tokenProgram);
            preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(assetTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, assetMarket.mint, tokenProgram));
        }
        const { beginSwapIx, endSwapIx } = await this.getLiquidateSpotWithSwapIx({
            liabilityMarketIndex,
            assetMarketIndex,
            swapAmount: amountIn,
            assetTokenAccount,
            liabilityTokenAccount,
            userAccount,
            userAccountPublicKey,
            userStatsAccountPublicKey,
            liquidatorSubAccountId,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    /**
     * Get the drift liquidate_spot_with_swap instructions
     *
     * @param liabilityMarketIndex the market index of the token you're buying
     * @param assetMarketIndex the market index of the token you're selling
     * @param amountIn the amount of the token to sell
     * @param assetTokenAccount the token account to move the tokens being sold
     * @param liabilityTokenAccount the token account to receive the tokens being bought
     * @param userAccount
     * @param userAccountPublicKey
     * @param userStatsAccountPublicKey
     */
    async getLiquidateSpotWithSwapIx({ liabilityMarketIndex, assetMarketIndex, swapAmount: swapAmount, assetTokenAccount, liabilityTokenAccount, userAccount, userAccountPublicKey, userStatsAccountPublicKey, liquidatorSubAccountId, }) {
        const liquidatorAccountPublicKey = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const userAccounts = [userAccount];
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const liabilitySpotMarket = this.getSpotMarketAccount(liabilityMarketIndex);
        const assetSpotMarket = this.getSpotMarketAccount(assetMarketIndex);
        const liabilityTokenProgram = this.getTokenProgramForSpotMarket(liabilitySpotMarket);
        const assetTokenProgram = this.getTokenProgramForSpotMarket(assetSpotMarket);
        if (!liabilityTokenProgram.equals(assetTokenProgram)) {
            remainingAccounts.push({
                pubkey: liabilityTokenProgram,
                isWritable: false,
                isSigner: false,
            });
        }
        if (liabilitySpotMarket.tokenProgram === 1 ||
            assetSpotMarket.tokenProgram === 1) {
            remainingAccounts.push({
                pubkey: assetSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: liabilitySpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
        }
        const beginSwapIx = await this.program.instruction.liquidateSpotWithSwapBegin(assetMarketIndex, liabilityMarketIndex, swapAmount, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                liquidator: liquidatorAccountPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                authority: this.wallet.publicKey,
                liabilitySpotMarketVault: liabilitySpotMarket.vault,
                assetSpotMarketVault: assetSpotMarket.vault,
                assetTokenAccount: assetTokenAccount,
                liabilityTokenAccount: liabilityTokenAccount,
                tokenProgram: assetTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.liquidateSpotWithSwapEnd(assetMarketIndex, liabilityMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                liquidator: liquidatorAccountPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                authority: this.wallet.publicKey,
                liabilitySpotMarketVault: liabilitySpotMarket.vault,
                assetSpotMarketVault: assetSpotMarket.vault,
                assetTokenAccount: assetTokenAccount,
                liabilityTokenAccount: liabilityTokenAccount,
                tokenProgram: assetTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async liquidateBorrowForPerpPnl(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [liabilityMarketIndex],
        });
        return await this.program.instruction.liquidateBorrowForPerpPnl(perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpPnlForDeposit(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [assetMarketIndex],
        });
        return await this.program.instruction.liquidatePerpPnlForDeposit(perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolvePerpBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarket = this.getQuoteSpotMarketAccount();
        return await this.program.instruction.resolvePerpBankruptcy(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolveSpotBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writableSpotMarketIndexes: [marketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarket);
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        return await this.program.instruction.resolveSpotBankruptcy(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                liquidator,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: tokenProgramId,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async updateFundingRate(perpMarketIndex, oracle, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateFundingRateIx(perpMarketIndex, oracle), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateFundingRateIx(perpMarketIndex, oracle) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        return await this.program.instruction.updateFundingRate(perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarketPublicKey,
                oracle: oracle,
            },
        });
    }
    async updatePrelaunchOracle(perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePrelaunchOracleIx(perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePrelaunchOracleIx(perpMarketIndex) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        if (!(0, types_1.isVariant)(perpMarket.amm.oracleSource, 'prelaunch')) {
            throw new Error(`Wrong oracle source ${perpMarket.amm.oracleSource}`);
        }
        return await this.program.instruction.updatePrelaunchOracle({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
            },
        });
    }
    async updatePerpBidAskTwap(perpMarketIndex, makers, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePerpBidAskTwapIx(perpMarketIndex, makers), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePerpBidAskTwapIx(perpMarketIndex, makers) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        const remainingAccounts = [];
        for (const [maker, makerStats] of makers) {
            remainingAccounts.push({
                pubkey: maker,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: makerStats,
                isWritable: false,
                isSigner: false,
            });
        }
        return await this.program.instruction.updatePerpBidAskTwap({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
                authority: this.wallet.publicKey,
                keeperStats: this.getUserStatsAccountPublicKey(),
            },
            remainingAccounts,
        });
    }
    async settleFundingPayment(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleFundingPaymentIx(userAccountPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getSettleFundingPaymentIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const writablePerpMarketIndexes = [];
        for (const position of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(position)) {
                writablePerpMarketIndexes.push(position.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writablePerpMarketIndexes,
        });
        return await this.program.instruction.settleFundingPayment({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts,
        });
    }
    triggerEvent(eventName, data) {
        this.eventEmitter.emit(eventName, data);
    }
    getOracleDataForPerpMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForPerpMarket(marketIndex).data;
    }
    getOracleDataForSpotMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForSpotMarket(marketIndex).data;
    }
    async initializeInsuranceFundStake(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getInitializeInsuranceFundStakeIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getInitializeInsuranceFundStakeIx(marketIndex) {
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        return await this.program.instruction.initializeInsuranceFundStake(marketIndex, {
            accounts: {
                insuranceFundStake: ifStakeAccountPublicKey,
                spotMarket: this.getSpotMarketAccount(marketIndex).pubkey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async getAddInsuranceFundStakeIx(marketIndex, amount, collateralAccountPublicKey) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
        const ix = this.program.instruction.addInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: collateralAccountPublicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
        return ix;
    }
    /**
     * Add to an insurance fund stake and optionally initialize the account
     */
    async addInsuranceFundStake({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, txParams, }) {
        const addIfStakeIxs = [];
        const additionalSigners = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        // create associated token account because it may not exist
        const associatedTokenAccountPublicKey = (0, spl_token_1.getAssociatedTokenAddressSync)(spotMarketAccount.mint, this.wallet.publicKey, true, tokenProgramId);
        addIfStakeIxs.push(await (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(this.wallet.publicKey, associatedTokenAccountPublicKey, this.wallet.publicKey, spotMarketAccount.mint, tokenProgramId));
        let tokenAccount;
        if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
            addIfStakeIxs.push(await this.getInitializeUserStatsIx());
        }
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                addIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
        }
        if (fromSubaccount) {
            const withdrawIx = await this.getWithdrawIx(amount, marketIndex, tokenAccount);
            addIfStakeIxs.push(withdrawIx);
        }
        if (initializeStakeAccount) {
            const initializeIx = await this.getInitializeInsuranceFundStakeIx(marketIndex);
            addIfStakeIxs.push(initializeIx);
        }
        const addFundsIx = await this.getAddInsuranceFundStakeIx(marketIndex, amount, tokenAccount);
        addIfStakeIxs.push(addFundsIx);
        if (createWSOLTokenAccount) {
            addIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const tx = await this.buildTransaction(addIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async requestRemoveInsuranceFundStake(marketIndex, amount, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const ix = await this.program.instruction.requestRemoveInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async cancelRequestRemoveInsuranceFundStake(marketIndex, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const ix = await this.program.instruction.cancelRequestRemoveInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async removeInsuranceFundStake(marketIndex, collateralAccountPublicKey, txParams) {
        const removeIfStakeIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const additionalSigners = [];
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(numericConstants_1.ZERO, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                removeIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
            const tokenAccountExists = await this.checkIfAccountExists(tokenAccount);
            if (!tokenAccountExists) {
                const createTokenAccountIx = await this.createAssociatedTokenAccountIdempotentInstruction(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, spotMarketAccount.mint, tokenProgramId);
                removeIfStakeIxs.push(createTokenAccountIx);
            }
        }
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        const removeStakeIx = await this.program.instruction.removeInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: tokenAccount,
                tokenProgram,
            },
            remainingAccounts,
        });
        removeIfStakeIxs.push(removeStakeIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            removeIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const tx = await this.buildTransaction(removeIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async updateUserQuoteAssetInsuranceStake(authority, txParams) {
        const tx = await this.buildTransaction(await this.getUpdateUserQuoteAssetInsuranceStakeIx(authority), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserQuoteAssetInsuranceStakeIx(authority) {
        const marketIndex = numericConstants_1.QUOTE_SPOT_MARKET_INDEX;
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, authority, marketIndex);
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = this.program.instruction.updateUserQuoteAssetInsuranceStake({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: userStatsPublicKey,
                signer: this.wallet.publicKey,
                insuranceFundVault: spotMarket.insuranceFund.vault,
            },
        });
        return ix;
    }
    async updateUserGovTokenInsuranceStake(authority, txParams, env = 'mainnet-beta') {
        const ix = env == 'mainnet-beta'
            ? await this.getUpdateUserGovTokenInsuranceStakeIx(authority)
            : await this.getUpdateUserGovTokenInsuranceStakeDevnetIx(authority);
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserGovTokenInsuranceStakeIx(authority) {
        const marketIndex = numericConstants_1.GOV_SPOT_MARKET_INDEX;
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, authority, marketIndex);
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = this.program.instruction.updateUserGovTokenInsuranceStake({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: userStatsPublicKey,
                signer: this.wallet.publicKey,
                insuranceFundVault: spotMarket.insuranceFund.vault,
            },
        });
        return ix;
    }
    async getUpdateUserGovTokenInsuranceStakeDevnetIx(authority, amount = new anchor_1.BN(1)) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = this.program.instruction.updateUserGovTokenInsuranceStakeDevnet(amount, {
            accounts: {
                userStats: userStatsPublicKey,
                signer: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async settleRevenueToInsuranceFund(spotMarketIndex, txParams) {
        const tx = await this.buildTransaction(await this.getSettleRevenueToInsuranceFundIx(spotMarketIndex), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettleRevenueToInsuranceFundIx(spotMarketIndex) {
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        const ix = await this.program.instruction.settleRevenueToInsuranceFund(spotMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                tokenProgram: tokenProgramId,
            },
            remainingAccounts,
        });
        return ix;
    }
    async resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [spotMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(spotMarketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarket);
        return await this.program.instruction.resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: tokenProgramId,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey) {
        const spotMarket = await this.getSpotMarketAccount(marketIndex);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
        const ix = await this.program.instruction.depositIntoSpotMarketRevenuePool(amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                userTokenAccount: userTokenAccountPublicKey,
                tokenProgram,
            },
        });
        return ix;
    }
    /**
     * This ix will donate your funds to drift revenue pool. It does not deposit into your user account
     * @param marketIndex
     * @param amount
     * @param userTokenAccountPublicKey
     * @returns
     */
    async depositIntoSpotMarketRevenuePool(marketIndex, amount, userTokenAccountPublicKey) {
        const ix = await this.getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey);
        const tx = await this.buildTransaction([ix]);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    getPerpMarketExtendedInfo(marketIndex) {
        var _a, _b;
        const marketAccount = this.getPerpMarketAccount(marketIndex);
        const quoteAccount = this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const extendedInfo = {
            marketIndex,
            minOrderSize: (_a = marketAccount.amm) === null || _a === void 0 ? void 0 : _a.minOrderSize,
            marginMaintenance: marketAccount.marginRatioMaintenance,
            pnlPoolValue: (0, spotBalance_1.getTokenAmount)((_b = marketAccount.pnlPool) === null || _b === void 0 ? void 0 : _b.scaledBalance, quoteAccount, types_1.SpotBalanceType.DEPOSIT),
            contractTier: marketAccount.contractTier,
            availableInsurance: (0, market_1.calculateMarketMaxAvailableInsurance)(marketAccount, quoteAccount),
        };
        return extendedInfo;
    }
    /**
     * Calculates taker / maker fee (as a percentage, e.g. .001 = 10 basis points) for particular marketType
     * @param marketType
     * @param positionMarketIndex
     * @returns : {takerFee: number, makerFee: number} Precision None
     */
    getMarketFees(marketType, marketIndex, user) {
        let feeTier;
        if (user) {
            feeTier = user.getUserFeeTier(marketType);
        }
        else {
            const state = this.getStateAccount();
            feeTier = (0, types_1.isVariant)(marketType, 'perp')
                ? state.perpFeeStructure.feeTiers[0]
                : state.spotFeeStructure.feeTiers[0];
        }
        let takerFee = feeTier.feeNumerator / feeTier.feeDenominator;
        let makerFee = feeTier.makerRebateNumerator / feeTier.makerRebateDenominator;
        if (marketIndex !== undefined) {
            let marketAccount = null;
            if ((0, types_1.isVariant)(marketType, 'perp')) {
                marketAccount = this.getPerpMarketAccount(marketIndex);
            }
            else {
                marketAccount = this.getSpotMarketAccount(marketIndex);
            }
            takerFee += (takerFee * marketAccount.feeAdjustment) / 100;
            if (user && user.isHighLeverageMode()) {
                takerFee *= 2;
            }
            makerFee += (makerFee * marketAccount.feeAdjustment) / 100;
        }
        return {
            takerFee,
            makerFee,
        };
    }
    /**
     * Returns the market index and type for a given market name
     * E.g. "SOL-PERP" -> { marketIndex: 0, marketType: MarketType.PERP }
     *
     * @param name
     */
    getMarketIndexAndType(name) {
        name = name.toUpperCase();
        for (const perpMarketAccount of this.getPerpMarketAccounts()) {
            if ((0, userName_1.decodeName)(perpMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: perpMarketAccount.marketIndex,
                    marketType: types_1.MarketType.PERP,
                };
            }
        }
        for (const spotMarketAccount of this.getSpotMarketAccounts()) {
            if ((0, userName_1.decodeName)(spotMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: spotMarketAccount.marketIndex,
                    marketType: types_1.MarketType.SPOT,
                };
            }
        }
        return undefined;
    }
    getReceiverProgram() {
        if (this.receiverProgram === undefined) {
            this.receiverProgram = new anchor_1.Program(pyth_solana_receiver_json_1.default, pyth_solana_receiver_1.DEFAULT_RECEIVER_PROGRAM_ID, this.provider);
        }
        return this.receiverProgram;
    }
    async getSwitchboardOnDemandProgram() {
        const idl = (await anchor_30_1.Program.fetchIdl(this.sbOnDemandProgramdId, this.provider));
        if (this.sbOnDemandProgram === undefined) {
            this.sbOnDemandProgram = new anchor_30_1.Program(idl, this.provider);
        }
        return this.sbOnDemandProgram;
    }
    async postPythPullOracleUpdateAtomic(vaaString, feedId) {
        const postIxs = await this.getPostPythPullOracleUpdateAtomicIxs(vaaString, feedId);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async postMultiPythPullOracleUpdatesAtomic(vaaString, feedIds) {
        const postIxs = await this.getPostPythPullOracleUpdateAtomicIxs(vaaString, feedIds);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getPostPythPullOracleUpdateAtomicIxs(vaaString, feedIds, numSignatures = 2) {
        const accumulatorUpdateData = (0, price_service_sdk_1.parseAccumulatorUpdateData)(Buffer.from(vaaString, 'base64'));
        const guardianSetIndex = accumulatorUpdateData.vaa.readUInt32BE(1);
        const guardianSet = (0, address_1.getGuardianSetPda)(guardianSetIndex, address_1.DEFAULT_WORMHOLE_PROGRAM_ID);
        const trimmedVaa = (0, oracles_1.trimVaaSignatures)(accumulatorUpdateData.vaa, numSignatures);
        const postIxs = [];
        if (accumulatorUpdateData.updates.length > 1) {
            const encodedParams = this.getReceiverProgram().coder.types.encode('PostMultiUpdatesAtomicParams', {
                vaa: trimmedVaa,
                merklePriceUpdates: accumulatorUpdateData.updates,
            });
            const feedIdsToUse = typeof feedIds === 'string' ? [feedIds] : feedIds;
            const pubkeys = feedIdsToUse.map((feedId) => {
                return (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId));
            });
            const remainingAccounts = pubkeys.map((pubkey) => {
                return {
                    pubkey,
                    isSigner: false,
                    isWritable: true,
                };
            });
            postIxs.push(this.program.instruction.postMultiPythPullOracleUpdatesAtomic(encodedParams, {
                accounts: {
                    keeper: this.wallet.publicKey,
                    pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                    guardianSet,
                },
                remainingAccounts,
            }));
        }
        else {
            let feedIdToUse = typeof feedIds === 'string' ? feedIds : feedIds[0];
            feedIdToUse = (0, pythOracleUtils_1.trimFeedId)(feedIdToUse);
            postIxs.push(await this.getSinglePostPythPullOracleAtomicIx({
                vaa: trimmedVaa,
                merklePriceUpdate: accumulatorUpdateData.updates[0],
            }, feedIdToUse, guardianSet));
        }
        return postIxs;
    }
    async getSinglePostPythPullOracleAtomicIx(params, feedId, guardianSet) {
        const feedIdBuffer = (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId);
        const receiverProgram = this.getReceiverProgram();
        const encodedParams = receiverProgram.coder.types.encode('PostUpdateAtomicParams', params);
        return this.program.instruction.postPythPullOracleUpdateAtomic(feedIdBuffer, encodedParams, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                guardianSet,
                priceFeed: (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, feedIdBuffer),
            },
        });
    }
    async updatePythPullOracle(vaaString, feedId) {
        feedId = (0, pythOracleUtils_1.trimFeedId)(feedId);
        const accumulatorUpdateData = (0, price_service_sdk_1.parseAccumulatorUpdateData)(Buffer.from(vaaString, 'base64'));
        const guardianSetIndex = accumulatorUpdateData.vaa.readUInt32BE(1);
        const guardianSet = (0, address_1.getGuardianSetPda)(guardianSetIndex, address_1.DEFAULT_WORMHOLE_PROGRAM_ID);
        const [postIxs, encodedVaaAddress] = await this.getBuildEncodedVaaIxs(accumulatorUpdateData.vaa, guardianSet);
        for (const update of accumulatorUpdateData.updates) {
            postIxs.push(await this.getUpdatePythPullOracleIxs({
                merklePriceUpdate: update,
            }, feedId, encodedVaaAddress.publicKey));
        }
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [encodedVaaAddress], this.opts);
        return txSig;
    }
    async getUpdatePythPullOracleIxs(params, feedId, encodedVaaAddress) {
        const feedIdBuffer = (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId);
        const receiverProgram = this.getReceiverProgram();
        const encodedParams = receiverProgram.coder.types.encode('PostUpdateParams', params);
        return this.program.instruction.updatePythPullOracle(feedIdBuffer, encodedParams, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                encodedVaa: encodedVaaAddress,
                priceFeed: (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, feedIdBuffer),
            },
        });
    }
    async postPythLazerOracleUpdate(feedIds, pythMessageHex) {
        const postIxs = await this.getPostPythLazerOracleUpdateIxs(feedIds, pythMessageHex, undefined, 2);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getPostPythLazerOracleUpdateIxs(feedIds, pythMessageHex, precedingIxs = [], overrideIxCount) {
        const pythMessageBytes = Buffer.from(pythMessageHex, 'hex');
        const verifyIx = (0, pythOracleUtils_1.createMinimalEd25519VerifyIx)(overrideIxCount || precedingIxs.length + 1, 12, pythMessageBytes);
        const remainingAccountsMeta = feedIds.map((feedId) => {
            return {
                pubkey: (0, pda_1.getPythLazerOraclePublicKey)(this.program.programId, feedId),
                isSigner: false,
                isWritable: true,
            };
        });
        const ix = this.program.instruction.postPythLazerOracleUpdate(pythMessageBytes, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythLazerStorage: config_1.PYTH_LAZER_STORAGE_ACCOUNT_KEY,
                ixSysvar: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts: remainingAccountsMeta,
        });
        return [verifyIx, ix];
    }
    async getPostSwitchboardOnDemandUpdateAtomicIx(feed, recentSlothash, numSignatures = 3) {
        const program = await this.getSwitchboardOnDemandProgram();
        const feedAccount = new on_demand_1.PullFeed(program, feed);
        if (!this.sbProgramFeedConfigs) {
            this.sbProgramFeedConfigs = new Map();
        }
        if (!this.sbProgramFeedConfigs.has(feedAccount.pubkey.toString())) {
            const feedConfig = await feedAccount.loadConfigs();
            this.sbProgramFeedConfigs.set(feed.toString(), feedConfig);
        }
        const [pullIx, _responses, success] = await feedAccount.fetchUpdateIx({
            numSignatures,
        }, recentSlothash
            ? [[new anchor_1.BN(recentSlothash.slot), recentSlothash.hash]]
            : undefined);
        if (!success) {
            return undefined;
        }
        return pullIx;
    }
    async postSwitchboardOnDemandUpdate(feed, recentSlothash, numSignatures = 3) {
        const pullIx = await this.getPostSwitchboardOnDemandUpdateAtomicIx(feed, recentSlothash, numSignatures);
        if (!pullIx) {
            return undefined;
        }
        const tx = await (0, on_demand_1.asV0Tx)({
            connection: this.connection,
            ixs: [pullIx],
            payer: this.wallet.publicKey,
            computeUnitLimitMultiple: 1.3,
            lookupTables: await this.fetchAllLookupTableAccounts(),
        });
        const { txSig } = await this.sendTransaction(tx, [], {
            commitment: 'processed',
            skipPreflight: true,
            maxRetries: 0,
        });
        return txSig;
    }
    async getBuildEncodedVaaIxs(vaa, guardianSet) {
        const postIxs = [];
        if (this.wormholeProgram === undefined) {
            this.wormholeProgram = new anchor_1.Program(pyth_solana_receiver_1.wormholeCoreBridgeIdl, address_1.DEFAULT_WORMHOLE_PROGRAM_ID, this.provider);
        }
        const encodedVaaKeypair = new web3_js_1.Keypair();
        postIxs.push(await this.wormholeProgram.account.encodedVaa.createInstruction(encodedVaaKeypair, vaa.length + 46));
        // Why do we need this too?
        postIxs.push(await this.wormholeProgram.methods
            .initEncodedVaa()
            .accounts({
            encodedVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        // Split the write into two ixs
        postIxs.push(await this.wormholeProgram.methods
            .writeEncodedVaa({
            index: 0,
            data: vaa.subarray(0, 755),
        })
            .accounts({
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        postIxs.push(await this.wormholeProgram.methods
            .writeEncodedVaa({
            index: 755,
            data: vaa.subarray(755),
        })
            .accounts({
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        // Verify
        postIxs.push(await this.wormholeProgram.methods
            .verifyEncodedVaaV1()
            .accounts({
            guardianSet,
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        return [postIxs, encodedVaaKeypair];
    }
    async enableUserHighLeverageMode(subAccountId, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getEnableHighLeverageModeIx(subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getEnableHighLeverageModeIx(subAccountId, depositToTradeArgs) {
        const isDepositToTradeTx = depositToTradeArgs !== undefined;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: (depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.isMakingNewAccount)
                ? []
                : [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: false,
            readablePerpMarketIndex: depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.orderMarketIndex,
            readableSpotMarketIndexes: isDepositToTradeTx
                ? [depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.depositMarketIndex]
                : undefined,
        });
        const ix = await this.program.instruction.enableUserHighLeverageMode(subAccountId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
                highLeverageModeConfig: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
            },
            remainingAccounts,
        });
        return ix;
    }
    async disableUserHighLeverageMode(user, userAccount, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getDisableHighLeverageModeIx(user, userAccount), txParams), [], this.opts);
        return txSig;
    }
    async getDisableHighLeverageModeIx(user, userAccount) {
        const remainingAccounts = userAccount
            ? this.getRemainingAccounts({
                userAccounts: [userAccount],
            })
            : undefined;
        const ix = await this.program.instruction.disableUserHighLeverageMode({
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
                highLeverageModeConfig: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
            },
            remainingAccounts,
        });
        return ix;
    }
    async fetchHighLeverageModeConfig() {
        const config = await this.program.account.highLeverageModeConfig.fetch((0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId));
        return config;
    }
    async updateUserProtectedMakerOrders(subAccountId, protectedOrders, authority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserProtectedMakerOrdersIx(subAccountId, protectedOrders, authority), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserProtectedMakerOrdersIx(subAccountId, protectedOrders, authority) {
        const ix = await this.program.instruction.updateUserProtectedMakerOrders(subAccountId, protectedOrders, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId),
                authority: this.wallet.publicKey,
                protectedMakerModeConfig: (0, pda_1.getProtectedMakerModeConfigPublicKey)(this.program.programId),
            },
        });
        return ix;
    }
    async getPauseSpotMarketDepositWithdrawIx(spotMarketIndex) {
        const spotMarket = await this.getSpotMarketAccount(spotMarketIndex);
        return this.program.instruction.pauseSpotMarketDepositWithdraw({
            accounts: {
                state: await this.getStatePublicKey(),
                keeper: this.wallet.publicKey,
                spotMarket: spotMarket.pubkey,
                spotMarketVault: spotMarket.vault,
            },
        });
    }
    async pauseSpotMarketDepositWithdraw(spotMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getPauseSpotMarketDepositWithdrawIx(spotMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    handleSignedTransaction(signedTxs) {
        if (this.enableMetricsEvents && this.metricsEventEmitter) {
            this.metricsEventEmitter.emit('txSigned', signedTxs);
        }
    }
    handlePreSignedTransaction() {
        if (this.enableMetricsEvents && this.metricsEventEmitter) {
            this.metricsEventEmitter.emit('preTxSigned');
        }
    }
    isVersionedTransaction(tx) {
        return (0, utils_2.isVersionedTransaction)(tx);
    }
    /**
     * Send a transaction.
     *
     * @param tx
     * @param additionalSigners
     * @param opts :: Will fallback to DriftClient's opts if not provided
     * @param preSigned
     * @returns
     */
    sendTransaction(tx, additionalSigners, opts, preSigned) {
        const isVersionedTx = this.isVersionedTransaction(tx);
        if (isVersionedTx) {
            return this.txSender.sendVersionedTransaction(tx, additionalSigners, opts !== null && opts !== void 0 ? opts : this.opts, preSigned);
        }
        else {
            return this.txSender.send(tx, additionalSigners, opts !== null && opts !== void 0 ? opts : this.opts, preSigned);
        }
    }
    async buildTransaction(instructions, txParams, txVersion, lookupTables, forceVersionedTransaction, recentBlockhash, optionalIxs) {
        return this.txHandler.buildTransaction({
            instructions,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
            recentBlockhash,
            optionalIxs,
        });
    }
    async buildBulkTransactions(instructions, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildBulkTransactions({
            instructions,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
    async buildTransactionsMap(instructionsMap, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildTransactionsMap({
            instructionsMap,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
    async buildAndSignTransactionsMap(instructionsMap, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildAndSignTransactionMap({
            instructionsMap,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
}
exports.DriftClient = DriftClient;
