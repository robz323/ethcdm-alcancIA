"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grpcSubscription = void 0;
const grpcProgramAccountSubscriber_1 = require("../accounts/grpcProgramAccountSubscriber");
const memcmp_1 = require("../memcmp");
class grpcSubscription {
    constructor({ grpcConfigs, orderSubscriber, skipInitialLoad = false, resubOpts, resyncIntervalMs, decoded = true, }) {
        this.orderSubscriber = orderSubscriber;
        this.skipInitialLoad = skipInitialLoad;
        this.resubOpts = resubOpts;
        this.resyncIntervalMs = resyncIntervalMs;
        this.decoded = decoded;
        this.grpcConfigs = grpcConfigs;
    }
    async subscribe() {
        if (this.subscriber) {
            return;
        }
        this.subscriber = await grpcProgramAccountSubscriber_1.grpcProgramAccountSubscriber.create(this.grpcConfigs, 'OrderSubscriber', 'User', this.orderSubscriber.driftClient.program, this.orderSubscriber.decodeFn, {
            filters: [(0, memcmp_1.getUserFilter)(), (0, memcmp_1.getNonIdleUserFilter)()],
        }, this.resubOpts);
        await this.subscriber.subscribe((accountId, account, context, buffer) => {
            var _a;
            const userKey = accountId.toBase58();
            if ((_a = this.decoded) !== null && _a !== void 0 ? _a : true) {
                this.orderSubscriber.tryUpdateUserAccount(userKey, 'decoded', account, context.slot);
            }
            else {
                this.orderSubscriber.tryUpdateUserAccount(userKey, 'buffer', buffer, context.slot);
            }
        });
        if (!this.skipInitialLoad) {
            await this.orderSubscriber.fetch();
        }
        if (this.resyncIntervalMs) {
            const recursiveResync = () => {
                this.resyncTimeoutId = setTimeout(() => {
                    this.orderSubscriber
                        .fetch()
                        .catch((e) => {
                        console.error('Failed to resync in OrderSubscriber');
                        console.log(e);
                    })
                        .finally(() => {
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        if (!this.resyncTimeoutId)
                            return;
                        recursiveResync();
                    });
                }, this.resyncIntervalMs);
            };
            recursiveResync();
        }
    }
    async unsubscribe() {
        if (!this.subscriber)
            return;
        await this.subscriber.unsubscribe();
        this.subscriber = undefined;
        if (this.resyncTimeoutId !== undefined) {
            clearTimeout(this.resyncTimeoutId);
            this.resyncTimeoutId = undefined;
        }
    }
}
exports.grpcSubscription = grpcSubscription;
