/// <reference types="bn.js" />
import { BN } from '@coral-xyz/anchor';
import { AMM, PositionDirection, SwapDirection, PerpMarketAccount } from '../types';
import { OraclePriceData } from '../oracles/types';
export declare function calculatePegFromTargetPrice(targetPrice: BN, baseAssetReserve: BN, quoteAssetReserve: BN): BN;
export declare function calculateOptimalPegAndBudget(amm: AMM, oraclePriceData: OraclePriceData): [BN, BN, BN, boolean];
export declare function calculateNewAmm(amm: AMM, oraclePriceData: OraclePriceData): [BN, BN, BN, BN];
export declare function calculateUpdatedAMM(amm: AMM, oraclePriceData: OraclePriceData): AMM;
export declare function calculateUpdatedAMMSpreadReserves(amm: AMM, direction: PositionDirection, oraclePriceData: OraclePriceData, isPrediction?: boolean): {
    baseAssetReserve: BN;
    quoteAssetReserve: BN;
    sqrtK: BN;
    newPeg: BN;
};
export declare function calculateBidAskPrice(amm: AMM, oraclePriceData: OraclePriceData, withUpdate?: boolean, isPrediction?: boolean): [BN, BN];
/**
 * Calculates a price given an arbitrary base and quote amount (they must have the same precision)
 *
 * @param baseAssetReserves
 * @param quoteAssetReserves
 * @param pegMultiplier
 * @returns price : Precision PRICE_PRECISION
 */
export declare function calculatePrice(baseAssetReserves: BN, quoteAssetReserves: BN, pegMultiplier: BN): BN;
export type AssetType = 'quote' | 'base';
/**
 * Calculates what the amm reserves would be after swapping a quote or base asset amount.
 *
 * @param amm
 * @param inputAssetType
 * @param swapAmount
 * @param swapDirection
 * @returns quoteAssetReserve and baseAssetReserve after swap. : Precision AMM_RESERVE_PRECISION
 */
export declare function calculateAmmReservesAfterSwap(amm: Pick<AMM, 'pegMultiplier' | 'quoteAssetReserve' | 'sqrtK' | 'baseAssetReserve'>, inputAssetType: AssetType, swapAmount: BN, swapDirection: SwapDirection): [BN, BN];
export declare function calculateMarketOpenBidAsk(baseAssetReserve: BN, minBaseAssetReserve: BN, maxBaseAssetReserve: BN, stepSize?: BN): [BN, BN];
export declare function calculateInventoryLiquidityRatio(baseAssetAmountWithAmm: BN, baseAssetReserve: BN, minBaseAssetReserve: BN, maxBaseAssetReserve: BN): BN;
export declare function calculateInventoryScale(baseAssetAmountWithAmm: BN, baseAssetReserve: BN, minBaseAssetReserve: BN, maxBaseAssetReserve: BN, directionalSpread: number, maxSpread: number): number;
export declare function calculateReferencePriceOffset(reservePrice: BN, last24hAvgFundingRate: BN, liquidityFraction: BN, oracleTwapFast: BN, markTwapFast: BN, oracleTwapSlow: BN, markTwapSlow: BN, maxOffsetPct: number): BN;
export declare function calculateEffectiveLeverage(baseSpread: number, quoteAssetReserve: BN, terminalQuoteAssetReserve: BN, pegMultiplier: BN, netBaseAssetAmount: BN, reservePrice: BN, totalFeeMinusDistributions: BN): number;
export declare function calculateMaxSpread(marginRatioInitial: number): number;
export declare function calculateVolSpreadBN(lastOracleConfPct: BN, reservePrice: BN, markStd: BN, oracleStd: BN, longIntensity: BN, shortIntensity: BN, volume24H: BN): [BN, BN];
export declare function calculateSpreadBN(baseSpread: number, lastOracleReservePriceSpreadPct: BN, lastOracleConfPct: BN, maxSpread: number, quoteAssetReserve: BN, terminalQuoteAssetReserve: BN, pegMultiplier: BN, baseAssetAmountWithAmm: BN, reservePrice: BN, totalFeeMinusDistributions: BN, netRevenueSinceLastFunding: BN, baseAssetReserve: BN, minBaseAssetReserve: BN, maxBaseAssetReserve: BN, markStd: BN, oracleStd: BN, longIntensity: BN, shortIntensity: BN, volume24H: BN, returnTerms?: boolean): number[] | {
    longVolSpread: number;
    shortVolSpread: number;
    longSpreadwPS: number;
    shortSpreadwPS: number;
    maxTargetSpread: number;
    inventorySpreadScale: number;
    longSpreadwInvScale: number;
    shortSpreadwInvScale: number;
    effectiveLeverage: number;
    effectiveLeverageCapped: number;
    longSpreadwEL: number;
    shortSpreadwEL: number;
    revenueRetreatAmount: number;
    halfRevenueRetreatAmount: number;
    longSpreadwRevRetreat: number;
    shortSpreadwRevRetreat: number;
    longSpreadwOffsetShrink: number;
    shortSpreadwOffsetShrink: number;
    totalSpread: number;
    longSpread: number;
    shortSpread: number;
};
export declare function calculateSpread(amm: AMM, oraclePriceData: OraclePriceData, now?: BN, reservePrice?: BN): [number, number];
export declare function getQuoteAssetReservePredictionMarketBounds(amm: AMM, direction: PositionDirection): [BN, BN];
export declare function calculateSpreadReserves(amm: AMM, oraclePriceData: OraclePriceData, now?: BN, isPrediction?: boolean): {
    baseAssetReserve: any;
    quoteAssetReserve: any;
}[];
/**
 * Helper function calculating constant product curve output. Agnostic to whether input asset is quote or base
 *
 * @param inputAssetReserve
 * @param swapAmount
 * @param swapDirection
 * @param invariant
 * @returns newInputAssetReserve and newOutputAssetReserve after swap. : Precision AMM_RESERVE_PRECISION
 */
export declare function calculateSwapOutput(inputAssetReserve: BN, swapAmount: BN, swapDirection: SwapDirection, invariant: BN): [BN, BN];
/**
 * Translate long/shorting quote/base asset into amm operation
 *
 * @param inputAssetType
 * @param positionDirection
 */
export declare function getSwapDirection(inputAssetType: AssetType, positionDirection: PositionDirection): SwapDirection;
/**
 * Helper function calculating terminal price of amm
 *
 * @param market
 * @returns cost : Precision PRICE_PRECISION
 */
export declare function calculateTerminalPrice(market: PerpMarketAccount): BN;
export declare function calculateMaxBaseAssetAmountToTrade(amm: AMM, limit_price: BN, direction: PositionDirection, oraclePriceData?: OraclePriceData, now?: BN, isPrediction?: boolean): [BN, PositionDirection];
export declare function calculateQuoteAssetAmountSwapped(quoteAssetReserves: BN, pegMultiplier: BN, swapDirection: SwapDirection): BN;
export declare function calculateMaxBaseAssetAmountFillable(amm: AMM, orderDirection: PositionDirection): BN;
