"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForwardOnlyTxSender = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const baseTxSender_1 = require("./baseTxSender");
const types_1 = require("./types");
const config_1 = require("../config");
const DEFAULT_TIMEOUT = 35000;
const DEFAULT_RETRY = 5000;
class ForwardOnlyTxSender extends baseTxSender_1.BaseTxSender {
    constructor({ connection, wallet, opts = { ...config_1.DEFAULT_CONFIRMATION_OPTS, maxRetries: 0 }, timeout = DEFAULT_TIMEOUT, retrySleep = DEFAULT_RETRY, confirmationStrategy = types_1.ConfirmationStrategy.Combo, additionalTxSenderCallbacks = [], txHandler, trackTxLandRate, txLandRateLookbackWindowMinutes, landRateToFeeFunc, throwOnTimeoutError = true, }) {
        super({
            connection,
            wallet,
            opts,
            timeout,
            additionalConnections: [],
            confirmationStrategy,
            additionalTxSenderCallbacks,
            txHandler,
            trackTxLandRate,
            txLandRateLookbackWindowMinutes,
            landRateToFeeFunc,
            throwOnTimeoutError,
        });
        this.timoutCount = 0;
        this.connection = connection;
        this.wallet = wallet;
        this.opts = opts;
        this.timeout = timeout;
        this.retrySleep = retrySleep;
        this.additionalConnections = [];
    }
    async sleep(reference) {
        return new Promise((resolve) => {
            reference.resolve = resolve;
            setTimeout(resolve, this.retrySleep);
        });
    }
    sendToAdditionalConnections(rawTx, _opts) {
        var _a;
        (_a = this.additionalTxSenderCallbacks) === null || _a === void 0 ? void 0 : _a.map((callback) => {
            callback(bs58_1.default.encode(rawTx));
        });
    }
    async sendRawTransaction(rawTransaction, opts) {
        var _a, _b, _c;
        const deserializedTx = web3_js_1.VersionedTransaction.deserialize(rawTransaction);
        const txSig = deserializedTx.signatures[0];
        const encodedTxSig = bs58_1.default.encode(txSig);
        const startTime = this.getTimestamp();
        this.sendToAdditionalConnections(rawTransaction, opts);
        (_a = this.txSigCache) === null || _a === void 0 ? void 0 : _a.set(encodedTxSig, false);
        let done = false;
        const resolveReference = {
            resolve: undefined,
        };
        const stopWaiting = () => {
            done = true;
            if (resolveReference.resolve) {
                resolveReference.resolve();
            }
        };
        (async () => {
            while (!done && this.getTimestamp() - startTime < this.timeout) {
                await this.sleep(resolveReference);
                if (!done) {
                    this.sendToAdditionalConnections(rawTransaction, opts);
                }
            }
        })();
        let slot;
        try {
            const result = await this.confirmTransaction(encodedTxSig, opts.commitment);
            slot = (_b = result === null || result === void 0 ? void 0 : result.context) === null || _b === void 0 ? void 0 : _b.slot;
            (_c = this.txSigCache) === null || _c === void 0 ? void 0 : _c.set(encodedTxSig, true);
            // eslint-disable-next-line no-useless-catch
        }
        catch (e) {
            throw e;
        }
        finally {
            stopWaiting();
        }
        return { txSig: encodedTxSig, slot };
    }
}
exports.ForwardOnlyTxSender = ForwardOnlyTxSender;
