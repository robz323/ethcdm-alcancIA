"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythLazerClient = void 0;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const __1 = require("..");
const drift_json_1 = __importDefault(require("../idl/drift.json"));
class PythLazerClient {
    constructor(connection, multiple = numericConstants_1.ONE, stableCoin = false) {
        this.connection = connection;
        this.multiple = multiple;
        this.stableCoin = stableCoin;
        const provider = new anchor_1.AnchorProvider(this.connection, 
        //@ts-ignore
        new __1.Wallet(new web3_js_1.Keypair()), {
            commitment: connection.commitment,
        });
        this.program = new anchor_1.Program(drift_json_1.default, new web3_js_1.PublicKey(__1.DRIFT_PROGRAM_ID), provider);
        this.decodeFunc =
            this.program.account.pythLazerOracle.coder.accounts.decodeUnchecked.bind(this.program.account.pythLazerOracle.coder.accounts);
    }
    async getOraclePriceData(pricePublicKey) {
        const accountInfo = await this.connection.getAccountInfo(pricePublicKey);
        return this.getOraclePriceDataFromBuffer(accountInfo.data);
    }
    getOraclePriceDataFromBuffer(buffer) {
        const priceData = this.decodeFunc('PythLazerOracle', buffer);
        const confidence = convertPythPrice(priceData.conf, priceData.exponent, this.multiple);
        let price = convertPythPrice(priceData.price, priceData.exponent, this.multiple);
        if (this.stableCoin) {
            price = getStableCoinPrice(price, confidence);
        }
        return {
            price,
            slot: priceData.postedSlot,
            confidence,
            twap: convertPythPrice(priceData.price, priceData.exponent, this.multiple),
            twapConfidence: convertPythPrice(priceData.price, priceData.exponent, this.multiple),
            hasSufficientNumberOfDataPoints: true,
        };
    }
}
exports.PythLazerClient = PythLazerClient;
function convertPythPrice(price, exponent, multiple) {
    exponent = Math.abs(exponent);
    const pythPrecision = numericConstants_1.TEN.pow(new anchor_1.BN(exponent).abs()).div(multiple);
    return price.mul(numericConstants_1.PRICE_PRECISION).div(pythPrecision);
}
const fiveBPS = new anchor_1.BN(500);
function getStableCoinPrice(price, confidence) {
    if (price.sub(numericConstants_1.QUOTE_PRECISION).abs().lt(anchor_1.BN.min(confidence, fiveBPS))) {
        return numericConstants_1.QUOTE_PRECISION;
    }
    else {
        return price;
    }
}
