/// <reference types="bn.js" />
import { AddressLookupTableAccount, PublicKey, TransactionInstruction } from '@solana/web3.js';
import { JupiterClient, QuoteResponse } from '../jupiter/jupiterClient';
import { DriftClient } from '../driftClient';
import { BN } from '@coral-xyz/anchor';
import { User } from '../user';
import { DepositRecord } from '../types';
import fetch from 'node-fetch';
export type BSOL_STATS_API_RESPONSE = {
    success: boolean;
    stats?: {
        conversion: {
            bsol_to_sol: number;
            sol_to_bsol: number;
        };
        apy: {
            base: number;
            blze: number;
            total: number;
            lending: number;
            liquidity: number;
        };
    };
};
export type BSOL_EMISSIONS_API_RESPONSE = {
    success: boolean;
    emissions?: {
        lend: number;
    };
};
export declare function fetchBSolMetrics(): Promise<fetch.Response>;
export declare function fetchBSolDriftEmissions(): Promise<fetch.Response>;
export declare function findBestSuperStakeIxs({ marketIndex, amount, jupiterClient, driftClient, userAccountPublicKey, price, forceMarinade, onlyDirectRoutes, jupiterQuote, }: {
    marketIndex: number;
    amount: BN;
    jupiterClient: JupiterClient;
    driftClient: DriftClient;
    price?: number;
    userAccountPublicKey?: PublicKey;
    forceMarinade?: boolean;
    onlyDirectRoutes?: boolean;
    jupiterQuote?: QuoteResponse;
}): Promise<{
    ixs: TransactionInstruction[];
    lookupTables: AddressLookupTableAccount[];
    method: 'jupiter' | 'marinade';
    price?: number;
}>;
export declare function findBestMSolSuperStakeIxs({ amount, jupiterClient, driftClient, userAccountPublicKey, price, forceMarinade, onlyDirectRoutes, jupiterQuote, }: {
    amount: BN;
    jupiterClient: JupiterClient;
    driftClient: DriftClient;
    price?: number;
    userAccountPublicKey?: PublicKey;
    forceMarinade?: boolean;
    onlyDirectRoutes?: boolean;
    jupiterQuote?: QuoteResponse;
}): Promise<{
    ixs: TransactionInstruction[];
    lookupTables: AddressLookupTableAccount[];
    method: 'jupiter' | 'marinade';
    price: number;
}>;
export declare function findBestJitoSolSuperStakeIxs({ amount, jupiterClient, driftClient, userAccountPublicKey, onlyDirectRoutes, jupiterQuote, }: {
    amount: BN;
    jupiterClient: JupiterClient;
    driftClient: DriftClient;
    userAccountPublicKey?: PublicKey;
    onlyDirectRoutes?: boolean;
    jupiterQuote?: QuoteResponse;
}): Promise<{
    ixs: TransactionInstruction[];
    lookupTables: AddressLookupTableAccount[];
    method: 'jupiter' | 'marinade';
    price?: number;
}>;
/**
 * Finds best Jupiter Swap instructions for a generic lstMint
 *
 * Without doing any extra steps like checking if you can get a better rate by staking directly with that LST platform
 */
export declare function findBestLstSuperStakeIxs({ amount, jupiterClient, driftClient, userAccountPublicKey, onlyDirectRoutes, lstMarketIndex, jupiterQuote, }: {
    amount: BN;
    lstMint: PublicKey;
    lstMarketIndex: number;
    jupiterClient: JupiterClient;
    driftClient: DriftClient;
    userAccountPublicKey?: PublicKey;
    onlyDirectRoutes?: boolean;
    jupiterQuote?: QuoteResponse;
}): Promise<{
    ixs: TransactionInstruction[];
    lookupTables: AddressLookupTableAccount[];
    method: 'jupiter' | 'marinade';
}>;
export type JITO_SOL_METRICS_ENDPOINT_RESPONSE = {
    tvl: {
        data: number;
        date: string;
    }[];
    supply: {
        data: number;
        date: string;
    }[];
    apy: {
        data: number;
        date: string;
    }[];
};
export declare function fetchJitoSolMetrics(): Promise<JITO_SOL_METRICS_ENDPOINT_RESPONSE>;
export type MSOL_METRICS_ENDPOINT_RESPONSE = {
    total_active_balance: number;
    available_reserve_balance: number;
    emergency_cooling_down: number;
    tvl_sol: number;
    msol_directed_stake_sol: number;
    msol_directed_stake_msol: number;
    mnde_total_supply: number;
    mnde_circulating_supply: number;
    validators_count: number;
    stake_accounts: number;
    staking_sol_cap: number;
    m_sol_price: number;
    avg_staking_apy: number;
    msol_price_apy_14d: number;
    msol_price_apy_30d: number;
    msol_price_apy_90d: number;
    msol_price_apy_365d: number;
    reserve_pda: number;
    treasury_m_sol_amount: number;
    m_sol_mint_supply: number;
    m_sol_supply_state: number;
    liq_pool_sol: number;
    liq_pool_m_sol: number;
    liq_pool_value: number;
    liq_pool_token_supply: number;
    liq_pool_token_price: number;
    liq_pool_target: number;
    liq_pool_min_fee: number;
    liq_pool_max_fee: number;
    liq_pool_current_fee: number;
    liq_pool_treasury_cut: number;
    liq_pool_cap: number;
    total_cooling_down: number;
    last_stake_delta_epoch: number;
    circulating_ticket_count: number;
    circulating_ticket_balance: number;
    reward_fee_bp: number;
    lido_staking: number;
    lido_st_sol_price: number;
    lido_stsol_price_apy_14d: number;
    lido_stsol_price_apy_30d: number;
    lido_stsol_price_apy_90d: number;
    lido_stsol_price_apy_365d: number;
    stake_delta: number;
    bot_balance: number;
    treasury_farm_claim_mnde_balance: number;
    last_3_epochs_avg_duration_hs: number;
    mnde_votes_validators: number;
};
export declare const fetchMSolMetrics: () => Promise<MSOL_METRICS_ENDPOINT_RESPONSE>;
export declare function calculateSolEarned({ marketIndex, user, depositRecords, }: {
    marketIndex: number;
    user: User;
    depositRecords: DepositRecord[];
}): Promise<BN>;
export declare function calculateEstimatedSuperStakeLiquidationPrice(lstDepositAmount: number, lstMaintenanceAssetWeight: number, solBorrowAmount: number, solMaintenanceLiabilityWeight: number, lstPriceRatio: number): number;
