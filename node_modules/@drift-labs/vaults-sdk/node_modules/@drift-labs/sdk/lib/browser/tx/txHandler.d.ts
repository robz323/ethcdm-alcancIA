import { AddressLookupTableAccount, BlockhashWithExpiryBlockHeight, Commitment, ConfirmOptions, Connection, Signer, Transaction, TransactionInstruction, TransactionVersion, VersionedTransaction } from '@solana/web3.js';
import { DriftClientMetricsEvents, IWallet, MappedRecord, SignedTxData, TxParams } from '../types';
export declare const COMPUTE_UNITS_DEFAULT = 200000;
export type TxBuildingProps = {
    instructions: TransactionInstruction | TransactionInstruction[];
    txVersion: TransactionVersion;
    connection: Connection;
    preFlightCommitment: Commitment;
    fetchAllMarketLookupTableAccounts: () => Promise<AddressLookupTableAccount[]>;
    lookupTables?: AddressLookupTableAccount[];
    forceVersionedTransaction?: boolean;
    txParams?: TxParams;
    recentBlockhash?: BlockhashWithExpiryBlockHeight;
    wallet?: IWallet;
    optionalIxs?: TransactionInstruction[];
};
export type TxHandlerConfig = {
    blockhashCachingEnabled?: boolean;
    blockhashCachingConfig?: {
        retryCount: number;
        retrySleepTimeMs: number;
        staleCacheTimeMs: number;
    };
};
/**
 * This class is responsible for creating and signing transactions.
 */
export declare class TxHandler {
    private blockHashToLastValidBlockHeightLookup;
    private returnBlockHeightsWithSignedTxCallbackData;
    private connection;
    private wallet;
    private confirmationOptions;
    private preSignedCb?;
    private onSignedCb?;
    private blockhashCommitment;
    private blockHashFetcher;
    constructor(props: {
        connection: Connection;
        wallet: IWallet;
        confirmationOptions: ConfirmOptions;
        opts?: {
            returnBlockHeightsWithSignedTxCallbackData?: boolean;
            onSignedCb?: (txSigs: DriftClientMetricsEvents['txSigned']) => void;
            preSignedCb?: () => void;
        };
        config?: TxHandlerConfig;
    });
    private addHashAndExpiryToLookup;
    private getProps;
    updateWallet(wallet: IWallet): void;
    /**
     * Created this to prevent non-finalized blockhashes being used when building transactions. We want to always use finalized because otherwise it's easy to get the BlockHashNotFound error (RPC uses finalized to validate a transaction). Using an older blockhash when building transactions should never really be a problem right now.
     *
     * https://www.helius.dev/blog/how-to-deal-with-blockhash-errors-on-solana#why-do-blockhash-errors-occur
     *
     * @returns
     */
    getLatestBlockhashForTransaction(): Promise<Readonly<{
        blockhash: string;
        lastValidBlockHeight: number;
    }>>;
    /**
     * Applies recent blockhash and signs a given transaction
     * @param tx
     * @param additionalSigners
     * @param wallet
     * @param confirmationOpts
     * @param preSigned
     * @param recentBlockhash
     * @returns
     */
    prepareTx(tx: Transaction, additionalSigners: Array<Signer>, wallet?: IWallet, confirmationOpts?: ConfirmOptions, preSigned?: boolean, recentBlockhash?: BlockhashWithExpiryBlockHeight): Promise<Transaction>;
    private isVersionedTransaction;
    private isLegacyTransaction;
    private getTxSigFromSignedTx;
    private getBlockhashFromSignedTx;
    private signTx;
    signVersionedTx(tx: VersionedTransaction, additionalSigners: Array<Signer>, recentBlockhash?: BlockhashWithExpiryBlockHeight, wallet?: IWallet): Promise<VersionedTransaction>;
    private handleSignedTxData;
    /**
     * Gets transaction params with extra processing applied, like using the simulated compute units or using a dynamically calculated compute unit price.
     * @param txBuildingProps
     * @returns
     */
    private getProcessedTransactionParams;
    private _generateVersionedTransaction;
    generateLegacyVersionedTransaction(recentBlockhash: BlockhashWithExpiryBlockHeight, ixs: TransactionInstruction[], wallet?: IWallet): VersionedTransaction;
    generateVersionedTransaction(recentBlockhash: BlockhashWithExpiryBlockHeight, ixs: TransactionInstruction[], lookupTableAccounts: AddressLookupTableAccount[], wallet?: IWallet): VersionedTransaction;
    generateLegacyTransaction(ixs: TransactionInstruction[], recentBlockhash?: BlockhashWithExpiryBlockHeight): Transaction;
    /**
     * Accepts multiple instructions and builds a transaction for each. Prevents needing to spam RPC with requests for the same blockhash.
     * @param props
     * @returns
     */
    buildBulkTransactions(props: Omit<TxBuildingProps, 'instructions'> & {
        instructions: (TransactionInstruction | TransactionInstruction[])[];
    }): Promise<(Transaction | VersionedTransaction)[]>;
    /**
     *
     * @param instructions
     * @param txParams
     * @param txVersion
     * @param lookupTables
     * @param forceVersionedTransaction Return a VersionedTransaction instance even if the version of the transaction is Legacy
     * @returns
     */
    buildTransaction(props: TxBuildingProps): Promise<Transaction | VersionedTransaction>;
    wrapInTx(instruction: TransactionInstruction, computeUnits?: number, computeUnitsPrice?: number): Transaction;
    /**
     * Get a map of signed and prepared transactions from an array of legacy transactions
     * @param txsToSign
     * @param keys
     * @param wallet
     * @param commitment
     * @returns
     */
    getPreparedAndSignedLegacyTransactionMap<T extends Record<string, Transaction | undefined>>(txsMap: T, wallet?: IWallet, commitment?: Commitment, recentBlockhash?: BlockhashWithExpiryBlockHeight): Promise<{
        signedTxMap: T;
        signedTxData: SignedTxData[];
    }>;
    /**
     * Get a map of signed transactions from an array of transactions to sign.
     * @param txsToSign
     * @param keys
     * @param wallet
     * @returns
     */
    getSignedTransactionMap<T extends Record<string, Transaction | VersionedTransaction | undefined>>(txsToSignMap: T, wallet?: IWallet): Promise<{
        signedTxMap: T;
        signedTxData: SignedTxData[];
    }>;
    /**
     * Accepts multiple instructions and builds a transaction for each. Prevents needing to spam RPC with requests for the same blockhash.
     * @param props
     * @returns
     */
    buildTransactionsMap<T extends Record<string, TransactionInstruction | TransactionInstruction[]>>(props: Omit<TxBuildingProps, 'instructions'> & {
        instructionsMap: T;
    }): Promise<MappedRecord<T, Transaction | VersionedTransaction>>;
    /**
     * Builds and signs transactions from a given array of instructions for multiple transactions.
     * @param props
     * @returns
     */
    buildAndSignTransactionMap<T extends Record<string, TransactionInstruction | TransactionInstruction[]>>(props: Omit<TxBuildingProps, 'instructions'> & {
        instructionsMap: T;
    }): Promise<{
        signedTxMap: Record<string, Transaction>;
        signedTxData: SignedTxData[];
    } | {
        signedTxMap: MappedRecord<T, Transaction | VersionedTransaction>;
        signedTxData: SignedTxData[];
    }>;
}
