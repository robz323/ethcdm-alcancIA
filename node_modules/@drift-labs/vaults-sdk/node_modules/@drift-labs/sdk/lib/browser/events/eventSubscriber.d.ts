/// <reference types="node" />
import { Connection, TransactionSignature } from '@solana/web3.js';
import { Program } from '@coral-xyz/anchor';
import { EventSubscriptionOptions, EventType, WrappedEvents, EventMap, EventSubscriberEvents } from './types';
import { EventList } from './eventList';
import { EventEmitter } from 'events';
import StrictEventEmitter from 'strict-event-emitter-types';
export declare class EventSubscriber {
    private connection;
    private program;
    private options;
    private address;
    private eventListMap;
    private txEventCache;
    private awaitTxPromises;
    private awaitTxResolver;
    private logProvider;
    private currentProviderType;
    eventEmitter: StrictEventEmitter<EventEmitter, EventSubscriberEvents>;
    private lastSeenSlot;
    private lastSeenBlockTime;
    lastSeenTxSig: string;
    constructor(connection: Connection, program: Program, options?: EventSubscriptionOptions);
    private initializeLogProvider;
    private populateInitialEventListMap;
    /**
     * Implements fallback logic for reconnecting to LogProvider. Currently terminates at polling,
     * could be improved to try the original type again after some cooldown.
     */
    private updateFallbackProviderType;
    subscribe(): Promise<boolean>;
    private handleTxLogs;
    fetchPreviousTx(fetchMax?: boolean): Promise<void>;
    unsubscribe(): Promise<boolean>;
    private parseEventsFromLogs;
    awaitTx(txSig: TransactionSignature): Promise<void>;
    getEventList<Type extends keyof EventMap>(eventType: Type): EventList<Type>;
    /**
     * This requires the EventList be cast to an array, which requires reallocation of memory.
     * Would bias to using getEventList over getEvents
     *
     * @param eventType
     */
    getEventsArray<Type extends EventType>(eventType: Type): EventMap[Type][];
    getEventsByTx(txSig: TransactionSignature): WrappedEvents | undefined;
}
