/// <reference types="bn.js" />
import { BN } from '@coral-xyz/anchor';
export declare class BigNum {
    val: BN;
    precision: BN;
    static delim: string;
    static spacer: string;
    static setLocale(locale: string): void;
    constructor(val: BN | number | string, precisionVal?: BN | number | string);
    private bigNumFromParam;
    add(bn: BigNum): BigNum;
    sub(bn: BigNum): BigNum;
    mul(bn: BigNum | BN): BigNum;
    /**
     * Multiplies by another big number then scales the result down by the big number's precision so that we're in the same precision space
     * @param bn
     * @returns
     */
    scalarMul(bn: BigNum | BN): BigNum;
    div(bn: BigNum | BN): BigNum;
    /**
     * Shift precision up or down
     * @param exponent
     * @param skipAdjustingPrecision
     * @returns
     */
    shift(exponent: BN | number, skipAdjustingPrecision?: boolean): BigNum;
    /**
     * Shift to a target precision
     * @param targetPrecision
     * @returns
     */
    shiftTo(targetPrecision: BN): BigNum;
    /**
     * Scale the number by a fraction
     * @param numerator
     * @param denominator
     * @returns
     */
    scale(numerator: BN | number, denominator: BN | number): BigNum;
    toPercentage(denominator: BigNum, precision: number): string;
    gt(bn: BigNum | BN, ignorePrecision?: boolean): boolean;
    lt(bn: BigNum | BN, ignorePrecision?: boolean): boolean;
    gte(bn: BigNum | BN, ignorePrecision?: boolean): boolean;
    lte(bn: BigNum | BN, ignorePrecision?: boolean): boolean;
    eq(bn: BigNum | BN, ignorePrecision?: boolean): boolean;
    eqZero(): boolean;
    gtZero(): boolean;
    ltZero(): boolean;
    gteZero(): boolean;
    lteZero(): boolean;
    abs(): BigNum;
    neg(): BigNum;
    toString: (base?: number | 'hex', length?: number) => string;
    /**
     * Pretty print the underlying value in human-readable form. Depends on precision being correct for the output string to be correct
     * @returns
     */
    print(): string;
    prettyPrint(useTradePrecision?: boolean, precisionOverride?: number): string;
    /**
     * Print and remove unnecessary trailing zeroes
     * @returns
     */
    printShort(useTradePrecision?: boolean, precisionOverride?: number): string;
    debug(): void;
    /**
     * Pretty print with the specified number of decimal places
     * @param fixedPrecision
     * @returns
     */
    toFixed(fixedPrecision: number, rounded?: boolean): string;
    private getZeroes;
    toRounded(roundingPrecision: number): BigNum;
    /**
     * Pretty print to the specified number of significant figures
     * @param fixedPrecision
     * @returns
     */
    toPrecision(fixedPrecision: number, trailingZeroes?: boolean, rounded?: boolean): string;
    toTradePrecision(rounded?: boolean): string;
    /**
     * Print dollar formatted value. Defaults to fixed decimals two unless a given precision is given.
     * @param useTradePrecision
     * @param precisionOverride
     * @returns
     */
    toNotional(useTradePrecision?: boolean, precisionOverride?: number): string;
    toMillified(precision?: number, rounded?: boolean, type?: 'financial' | 'scientific'): string;
    toJSON(): {
        val: string;
        precision: string;
    };
    isNeg(): boolean;
    isPos(): boolean;
    /**
     * Get the numerical value of the BigNum. This can break if the BigNum is too large.
     * @returns
     */
    toNum(): number;
    static fromJSON(json: {
        val: string;
        precision: string;
    }): BigNum;
    /**
     * Create a BigNum instance
     * @param val
     * @param precision
     * @returns
     */
    static from(val?: BN | number | string, precision?: BN | number | string): BigNum;
    /**
     * Create a BigNum instance from a printed BigNum
     * @param val
     * @param precisionOverride
     * @returns
     */
    static fromPrint(val: string, precisionShift?: BN): BigNum;
    static max(a: BigNum, b: BigNum): BigNum;
    static min(a: BigNum, b: BigNum): BigNum;
    static zero(precision?: BN | number): BigNum;
}
