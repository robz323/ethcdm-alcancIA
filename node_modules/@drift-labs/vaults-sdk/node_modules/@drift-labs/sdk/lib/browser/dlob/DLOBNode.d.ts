/// <reference types="bn.js" />
import { BN, OraclePriceData, Order } from '..';
export interface DLOBNode {
    getPrice(oraclePriceData: OraclePriceData, slot: number): BN;
    isVammNode(): boolean;
    order: Order | undefined;
    isBaseFilled(): boolean;
    haveFilled: boolean;
    userAccount: string | undefined;
    isProtectedMaker: boolean;
    applyProtectedMakerOffset: boolean;
    isSignedMsg: boolean | undefined;
}
export declare abstract class OrderNode implements DLOBNode {
    order: Order;
    userAccount: string;
    sortValue: BN;
    haveFilled: boolean;
    haveTrigger: boolean;
    isProtectedMaker: boolean;
    applyProtectedMakerOffset: boolean;
    isSignedMsg: boolean;
    constructor(order: Order, userAccount: string, isProtectedMaker: boolean, applyProtectedMakerOffset: boolean, isSignedMsg?: boolean);
    abstract getSortValue(order: Order): BN;
    getLabel(): string;
    getPrice(oraclePriceData: OraclePriceData, slot: number): BN;
    isBaseFilled(): boolean;
    isVammNode(): boolean;
}
export declare class TakingLimitOrderNode extends OrderNode {
    next?: TakingLimitOrderNode;
    previous?: TakingLimitOrderNode;
    getSortValue(order: Order): BN;
}
export declare class RestingLimitOrderNode extends OrderNode {
    next?: RestingLimitOrderNode;
    previous?: RestingLimitOrderNode;
    getSortValue(order: Order): BN;
}
export declare class FloatingLimitOrderNode extends OrderNode {
    next?: FloatingLimitOrderNode;
    previous?: FloatingLimitOrderNode;
    getSortValue(order: Order): BN;
}
export declare class MarketOrderNode extends OrderNode {
    next?: MarketOrderNode;
    previous?: MarketOrderNode;
    getSortValue(order: Order): BN;
}
export declare class TriggerOrderNode extends OrderNode {
    next?: TriggerOrderNode;
    previous?: TriggerOrderNode;
    getSortValue(order: Order): BN;
}
export declare class SignedMsgOrderNode extends OrderNode {
    next?: SignedMsgOrderNode;
    previous?: SignedMsgOrderNode;
    constructor(order: Order, userAccount: string);
    getSortValue(order: Order): BN;
}
export type DLOBNodeMap = {
    restingLimit: RestingLimitOrderNode;
    takingLimit: TakingLimitOrderNode;
    floatingLimit: FloatingLimitOrderNode;
    protectedFloatingLimit: FloatingLimitOrderNode;
    market: MarketOrderNode;
    trigger: TriggerOrderNode;
    signedMsg: SignedMsgOrderNode;
};
export type DLOBNodeType = 'signedMsg' | 'restingLimit' | 'takingLimit' | 'floatingLimit' | 'protectedFloatingLimit' | 'market' | ('trigger' & keyof DLOBNodeMap);
export declare function createNode<T extends DLOBNodeType>(nodeType: T, order: Order, userAccount: string, isProtectedMaker: boolean, applyProtectedMakerOffset: boolean): DLOBNodeMap[T];
