async function initMarkdownItParser(options = {}) {
  const _markdownit = await import('mdbox/lib/markdown-it').then(
    (r) => r.default || r
  );
  const markdownit = _markdownit({
    linkify: true,
    ...options
  });
  return {
    parse: (md) => {
      const tokens = markdownit.parse(md, {});
      const tree = _normalizeTree$2(tokens);
      return {
        // _test: tokens,
        tree
      };
    }
  };
}
function _normalizeTree$2(tokens) {
  let node = {
    type: "",
    children: []
  };
  const stack = [];
  for (const token of tokens) {
    if (token.nesting === 1) {
      const _node = {
        type: getType$1(token),
        children: []
      };
      if (token.attrs) {
        _node.props = Object.fromEntries(token.attrs);
        if (typeof _node.props.style === "string") {
          const textAlign = /^text-align:\s*(\w+);?$/.exec(_node.props.style);
          if (textAlign) {
            delete _node.props.style;
            _node.props.align = textAlign[1];
          }
        }
      }
      node.children || (node.children = []);
      node.children.push(_node);
      stack.push(node);
      node = _node;
      continue;
    }
    if (token.nesting === -1) {
      if (node.type === "li" && node.children) {
        node.children = node.children.flatMap((child) => {
          if (typeof child !== "string" && child.type === "p") {
            return child?.children || [];
          }
          return child;
        });
        if (typeof node.children[0] === "string") {
          const taskRe = /^\s*\[([ Xx])]\s*(.*)/.exec(node.children[0]);
          if (taskRe) {
            node.props = {};
            node.props.checked = taskRe[1] !== " ";
            node.children[0] = taskRe[2] || "";
          }
        }
      }
      node = stack.pop() || node;
      continue;
    }
    switch (token.type) {
      case "text": {
        if (token.content) {
          node.children || (node.children = []);
          node.children.push(token.content);
        }
        break;
      }
      case "softbreak": {
        node.children || (node.children = []);
        node.children.push("\n");
        break;
      }
      case "fence": {
        node.children || (node.children = []);
        node.children.push({
          type: "code",
          children: [token.content],
          props: {
            lang: token.info
          }
        });
        break;
      }
      case "image": {
        const imgProps = Object.fromEntries(token.attrs || []);
        node.children || (node.children = []);
        node.children.push({
          type: "img",
          props: {
            ...imgProps,
            alt: imgProps.alt || token.content
          }
        });
        break;
      }
      default: {
        if (token.children && token.children.length > 0) {
          node.children || (node.children = []);
          node.children.push(..._normalizeTree$2(token.children));
        } else {
          const _node = { type: getType$1(token) };
          const content = token.content;
          if (content) {
            _node.children = [content];
          }
          node.children || (node.children = []);
          node.children.push(_node);
        }
      }
    }
  }
  return node.children || [];
}
const tagMap = {
  s: "del"
};
function getType$1(token) {
  return tagMap[token.tag] || token.tag;
}

function mergeStrings(arr) {
  const res = [];
  let strBuff = [];
  for (const el of arr) {
    if (typeof el === "string") {
      strBuff.push(el);
    } else {
      if (strBuff.length > 0) {
        res.push(strBuff.join(""));
        strBuff = [];
      }
      res.push(el);
    }
  }
  if (strBuff.length > 0) {
    res.push(strBuff.join(""));
  }
  return res;
}

async function initMdAstParser(opts = {}) {
  const { fromMarkdown, gfm, gfmFromMarkdown } = await import('mdbox/lib/mdast');
  return {
    parse: (md) => {
      const root = fromMarkdown(md, {
        ...opts,
        extensions: [...opts.extensions || [], gfm({})],
        mdastExtensions: [...opts.mdastExtensions || [], gfmFromMarkdown()]
      });
      const tree = (_normalizeTree$1(root)?.[0]).children || [];
      return {
        // _test: root,
        tree
      };
    }
  };
}
function _normalizeTree$1(_node) {
  const node = {
    type: getType(_node)
  };
  switch (_node.type) {
    case "code": {
      node.children = [_node.value + "\n"];
      if (_node.lang) {
        node.props = {
          lang: _node.lang
        };
      }
      return [node];
    }
    case "inlineCode": {
      node.children = [_node.value];
      return [node];
    }
    case "text":
    case "html": {
      return [_node.value || ""];
    }
    case "image": {
      node.props = {
        src: _node.url,
        alt: _node.alt || ""
      };
      if (_node.title) {
        node.props.title = _node.title;
      }
      return [node];
    }
    case "table": {
      const _rows = _node.children.flatMap((c) => _normalizeTree$1(c));
      const _align = _node.align || [];
      for (const _row of _rows) {
        if (!_row.children) {
          continue;
        }
        for (let i = 0; i < _row.children.length; i++) {
          const align = _align[i];
          if (align) {
            _row.children[i].props = { align };
          }
        }
      }
      const [head, ...rows] = _rows;
      for (const c of head.children || []) {
        c.type = "th";
      }
      node.children = [
        {
          type: "thead",
          children: [head]
        },
        {
          type: "tbody",
          children: rows
        }
      ];
      return [node];
    }
  }
  if ("children" in _node) {
    node.children = mergeStrings(
      _node.children.flatMap((c) => _normalizeTree$1(c))
    );
    if (_node.type === "listItem") {
      node.children = node.children?.flatMap((c) => {
        if (typeof c !== "string" && c.type === "p") {
          return c.children || [];
        }
        return c;
      });
      if (typeof _node.checked === "boolean") {
        node.props = {
          checked: _node.checked
        };
      }
    }
    if (_node.type === "link") {
      node.props = {
        href: _node.url
      };
    }
  }
  return [node];
}
const typeMap = {
  blockquote: "blockquote",
  strong: "strong",
  table: "table",
  break: "br",
  code: "code",
  inlineCode: "code",
  delete: "del",
  emphasis: "em",
  link: "a",
  listItem: "li",
  paragraph: "p",
  tableRow: "tr",
  tableCell: "td",
  thematicBreak: "hr",
  image: "img"
};
function getType(node) {
  if (node.type === "list") {
    return node.ordered ? "ol" : "ul";
  }
  if (node.type === "heading") {
    return `h${node.depth}`;
  }
  return typeMap[node.type] || node.type;
}

async function initMd4wParser(opts = {}) {
  const { mdToJSON, init } = await import('md4w');
  await init();
  return {
    parse: (md) => {
      const res = mdToJSON(md, {
        parseFlags: [
          "DEFAULT",
          "PERMISSIVE_WWW_AUTO_LINKS",
          "PERMISSIVE_EMAIL_AUTO_LINKS",
          "STRIKETHROUGH"
        ],
        ...opts
      });
      const tree = _normalizeTree(res);
      return {
        // _test: res,
        tree
      };
    }
  };
}
function _normalizeTree(tree) {
  const nodes = [];
  if (!tree.children) {
    return nodes;
  }
  for (const child of tree.children) {
    if (typeof child === "string") {
      nodes.push(child);
      continue;
    }
    if (child.type === 8) {
      nodes.push(child.children?.join("").trimEnd() || "");
      continue;
    }
    const node = {
      type: mapNodeType(child.type)
    };
    if (child.children) {
      node.children = node.type === "code" ? [child.children.join("")] : mergeStrings(_normalizeTree(child));
    }
    if (child.props) {
      node.props = child.props;
      if ("align" in node.props && !node.props.align) {
        delete node.props.align;
      }
      if (node.props.isTask) {
        node.props.checked = node.props.done;
        delete node.props.isTask;
        delete node.props.done;
      }
      if (Object.keys(node.props).length === 0) {
        delete node.props;
      }
    }
    nodes.push(node);
  }
  return nodes;
}
const nodeTypes = {
  1: "blockquote",
  2: "ul",
  3: "ol",
  4: "li",
  5: "hr",
  7: "code",
  8: "html",
  9: "p",
  10: "table",
  11: "thead",
  12: "tbody",
  13: "tr",
  14: "th",
  15: "td",
  21: "h1",
  22: "h2",
  23: "h3",
  24: "h4",
  25: "h5",
  26: "h6",
  30: "em",
  31: "strong",
  32: "a",
  33: "img",
  34: "code",
  35: "del",
  36: "latexmath",
  37: "latexmath_display",
  38: "wikilink",
  39: "u"
};
function mapNodeType(type) {
  return nodeTypes[type] || type;
}

export { initMarkdownItParser, initMd4wParser, initMdAstParser };
