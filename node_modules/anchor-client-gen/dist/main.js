#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
import * as fs from "fs";
import * as path from "path";
import { Project as Project4 } from "ts-morph";

// src/common.ts
import camelcase from "camelcase";
import { sha256 } from "js-sha256";
import { snakeCase } from "snake-case";
function unreachable(_) {
  return void 0;
}
function fieldsInterfaceName(typeName) {
  return `${typeName}Fields`;
}
function valueInterfaceName(typeName) {
  return `${typeName}Value`;
}
function kindInterfaceName(typeName) {
  return `${typeName}Kind`;
}
function jsonInterfaceName(typeName) {
  return `${typeName}JSON`;
}
function isComplexType(ty) {
  return typeof ty === "object" && ty !== null;
}
function tsTypeFromIdl(idl, ty, definedTypesPrefix = "types.", useFieldsInterfaceForStruct = true) {
  var _a, _b;
  switch (ty) {
    case "bool":
      return "boolean";
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
      return "number";
    case "u64":
    case "i64":
      return "BN";
    case "f64":
      return "number";
    case "u128":
    case "i128":
      return "BN";
    case "u256":
    case "i256":
      return "BN";
    case "bytes":
      return "Uint8Array";
    case "string":
      return "string";
    case "publicKey":
      return "PublicKey";
    default:
      if (isComplexType(ty) && "vec" in ty) {
        return `Array<${tsTypeFromIdl(
          idl,
          ty.vec,
          definedTypesPrefix,
          useFieldsInterfaceForStruct
        )}>`;
      }
      if (isComplexType(ty) && "option" in ty) {
        return `${tsTypeFromIdl(
          idl,
          ty.option,
          definedTypesPrefix,
          useFieldsInterfaceForStruct
        )} | null`;
      }
      if (isComplexType(ty) && "coption" in ty) {
        return `${tsTypeFromIdl(
          idl,
          ty.coption,
          definedTypesPrefix,
          useFieldsInterfaceForStruct
        )} | null`;
      }
      if (isComplexType(ty) && "defined" in ty) {
        const filtered = (_b = (_a = idl.types) == null ? void 0 : _a.filter((t) => t.name === ty.defined)) != null ? _b : [];
        if (filtered.length !== 1) {
          throw new Error(`Defined type not found: ${JSON.stringify(ty)}`);
        }
        switch (filtered[0].type.kind) {
          case "struct": {
            const name = useFieldsInterfaceForStruct ? fieldsInterfaceName(ty.defined) : ty.defined;
            return `${definedTypesPrefix}${name}`;
          }
          case "enum": {
            const name = kindInterfaceName(ty.defined);
            return `${definedTypesPrefix}${name}`;
          }
        }
      }
      if (isComplexType(ty) && "array" in ty) {
        return `Array<${tsTypeFromIdl(
          idl,
          ty.array[0],
          definedTypesPrefix,
          useFieldsInterfaceForStruct
        )}>`;
      }
  }
  unreachable(ty);
  throw new Error("Unreachable.");
}
function layoutForType(ty, property, definedTypesPrefix = "types.") {
  const q = (property2) => {
    if (property2 === void 0) {
      return "";
    }
    return `"${property2}"`;
  };
  switch (ty) {
    case "bool":
      return `borsh.bool(${q(property)})`;
    case "u8":
      return `borsh.u8(${q(property)})`;
    case "i8":
      return `borsh.i8(${q(property)})`;
    case "u16":
      return `borsh.u16(${q(property)})`;
    case "i16":
      return `borsh.i16(${q(property)})`;
    case "u32":
      return `borsh.u32(${q(property)})`;
    case "f32":
      return `borsh.f32(${q(property)})`;
    case "i32":
      return `borsh.i32(${q(property)})`;
    case "u64":
      return `borsh.u64(${q(property)})`;
    case "i64":
      return `borsh.i64(${q(property)})`;
    case "f64":
      return `borsh.f64(${q(property)})`;
    case "u128":
      return `borsh.u128(${q(property)})`;
    case "i128":
      return `borsh.i128(${q(property)})`;
    case "u256":
      return `borsh.u256(${q(property)})`;
    case "i256":
      return `borsh.i256(${q(property)})`;
    case "bytes":
      return `borsh.vecU8(${q(property)})`;
    case "string":
      return `borsh.str(${q(property)})`;
    case "publicKey":
      return `borsh.publicKey(${q(property)})`;
    default:
      if (isComplexType(ty) && "vec" in ty) {
        return `borsh.vec(${layoutForType(ty.vec)}, ${q(property)})`;
      }
      if (isComplexType(ty) && "option" in ty) {
        return `borsh.option(${layoutForType(ty.option)}, ${q(property)})`;
      }
      if (isComplexType(ty) && "coption" in ty) {
        throw new Error("coption layout support not implemented");
      }
      if (isComplexType(ty) && "defined" in ty) {
        return `${definedTypesPrefix}${ty.defined}.layout(${q(property)})`;
      }
      if (isComplexType(ty) && "array" in ty) {
        const propTxt = property && `, ${q(property)}` || "";
        return `borsh.array(${layoutForType(ty.array[0])}, ${ty.array[1]}${propTxt})`;
      }
  }
  unreachable(ty);
  throw new Error("Unreachable.");
}
function genIxIdentifier(ixName) {
  const namespace = "global";
  const name = snakeCase(ixName);
  const preimage = `${namespace}:${name}`;
  return sha256.digest(preimage).slice(0, 8);
}
function genAccDiscriminator(accName) {
  return sha256.digest(`account:${camelcase(accName, { pascalCase: true })}`).slice(0, 8);
}
function fieldToEncodable(idl, ty, valPrefix = "", definedTypesPrefix = "types.") {
  var _a, _b;
  switch (ty.type) {
    case "bool":
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "u64":
    case "i64":
    case "f64":
    case "u128":
    case "i128":
    case "u256":
    case "i256":
    case "string":
    case "publicKey":
      return `${valPrefix}${ty.name}`;
    case "bytes": {
      const v = `${valPrefix}${ty.name}`;
      return `Buffer.from(${v}.buffer, ${v}.byteOffset, ${v}.length)`;
    }
    default:
      if (isComplexType(ty.type) && "vec" in ty.type) {
        const mapBody = fieldToEncodable(
          idl,
          {
            name: "item",
            type: ty.type.vec
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "option" in ty.type) {
        const encodable = fieldToEncodable(
          idl,
          { name: ty.name, type: ty.type.option },
          valPrefix,
          definedTypesPrefix
        );
        if (encodable === `${valPrefix}${ty.name}`) {
          return encodable;
        }
        return `(${valPrefix}${ty.name} && ${encodable}) || null`;
      }
      if (isComplexType(ty.type) && "coption" in ty.type) {
        throw new Error("coption layout support not implemented");
      }
      if (isComplexType(ty.type) && "defined" in ty.type) {
        const defined = ty.type.defined;
        const filtered = (_b = (_a = idl.types) == null ? void 0 : _a.filter((t) => t.name === defined)) != null ? _b : [];
        if (filtered.length !== 1) {
          throw new Error(`Defined type not found: ${JSON.stringify(ty)}`);
        }
        switch (filtered[0].type.kind) {
          case "struct": {
            return `${definedTypesPrefix}${ty.type.defined}.toEncodable(${valPrefix}${ty.name})`;
          }
          case "enum": {
            return `${valPrefix}${ty.name}.toEncodable()`;
          }
        }
      }
      if (isComplexType(ty.type) && "array" in ty.type) {
        const mapBody = fieldToEncodable(
          idl,
          {
            name: "item",
            type: ty.type.array[0]
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      unreachable(ty.type);
      throw new Error("Unreachable.");
  }
}
function fieldFromDecoded(idl, ty, valPrefix = "", definedTypesPrefix = "types.") {
  var _a, _b;
  switch (ty.type) {
    case "bool":
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "u64":
    case "i64":
    case "f64":
    case "u128":
    case "i128":
    case "u256":
    case "i256":
    case "string":
    case "publicKey":
      return `${valPrefix}${ty.name}`;
    case "bytes": {
      const v = `${valPrefix}${ty.name}`;
      return `new Uint8Array(${v}.buffer, ${v}.byteOffset, ${v}.length)`;
    }
    default:
      if (isComplexType(ty.type) && "vec" in ty.type) {
        const mapBody = fieldFromDecoded(
          idl,
          {
            name: "item",
            type: ty.type.vec
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "option" in ty.type) {
        const decoded = fieldFromDecoded(
          idl,
          { name: ty.name, type: ty.type.option },
          valPrefix
        );
        if (decoded === `${valPrefix}${ty.name}`) {
          return decoded;
        }
        return `(${valPrefix}${ty.name} && ${decoded}) || null`;
      }
      if (isComplexType(ty.type) && "coption" in ty.type) {
        throw new Error("coption layout support not implemented");
      }
      if (isComplexType(ty.type) && "defined" in ty.type) {
        const defined = ty.type.defined;
        const filtered = (_b = (_a = idl.types) == null ? void 0 : _a.filter((t) => t.name === defined)) != null ? _b : [];
        if (filtered.length !== 1) {
          throw new Error(`Defined type not found: ${JSON.stringify(ty)}`);
        }
        switch (filtered[0].type.kind) {
          case "struct":
          case "enum":
            return `${definedTypesPrefix}${ty.type.defined}.fromDecoded(${valPrefix}${ty.name})`;
          default: {
            unreachable(filtered[0].type);
            throw new Error("Unreachable.");
          }
        }
      }
      if (isComplexType(ty.type) && "array" in ty.type) {
        const mapBody = fieldFromDecoded(
          idl,
          {
            name: "item",
            type: ty.type.array[0]
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => ${mapBody})`;
      }
      unreachable(ty.type);
      throw new Error("Unreachable.");
  }
}
function structFieldInitializer(idl, field, prefix = "fields.") {
  var _a, _b;
  switch (field.type) {
    case "bool":
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "u64":
    case "i64":
    case "f64":
    case "u128":
    case "i128":
    case "u256":
    case "i256":
    case "bytes":
    case "string":
    case "publicKey":
      return `${prefix}${field.name}`;
    default:
      if (isComplexType(field.type) && "defined" in field.type) {
        const defined = field.type.defined;
        const filtered = (_b = (_a = idl.types) == null ? void 0 : _a.filter((t) => t.name === defined)) != null ? _b : [];
        if (filtered.length !== 1) {
          throw new Error(`Defined type not found: ${defined}`);
        }
        switch (filtered[0].type.kind) {
          case "struct":
            return `new types.${filtered[0].name}({ ...${prefix}${field.name} })`;
          case "enum":
            filtered[0].type.kind;
            return `${prefix}${field.name}`;
          default:
            unreachable(filtered[0].type);
            return;
        }
      }
      if (isComplexType(field.type) && "option" in field.type) {
        const initializer = structFieldInitializer(
          idl,
          { name: field.name, type: field.type.option },
          prefix
        );
        if (initializer === `${prefix}${field.name}`) {
          return initializer;
        } else {
          return `(${prefix}${field.name} && ${initializer}) || null`;
        }
      }
      if (isComplexType(field.type) && "coption" in field.type) {
        const initializer = structFieldInitializer(
          idl,
          { name: field.name, type: field.type.coption },
          prefix
        );
        if (initializer === `${prefix}${field.name}`) {
          return initializer;
        } else {
          return `(${prefix}${field.name} && ${initializer}) || null`;
        }
      }
      if (isComplexType(field.type) && "array" in field.type) {
        const mapBody = `${structFieldInitializer(
          idl,
          {
            name: "item",
            type: field.type.array[0]
          },
          ""
        )}`;
        if (mapBody === "item") {
          return `${prefix}${field.name}`;
        }
        return `${prefix}${field.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(field.type) && "vec" in field.type) {
        const mapBody = `${structFieldInitializer(
          idl,
          {
            name: "item",
            type: field.type.vec
          },
          ""
        )}`;
        if (mapBody === "item") {
          return `${prefix}${field.name}`;
        }
        return `${prefix}${field.name}.map((item) => ${mapBody})`;
      }
      unreachable(field.type);
  }
}
function fieldToJSON(idl, ty, valPrefix = "") {
  var _a, _b;
  switch (ty.type) {
    case "bool":
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "f64":
    case "string":
      return `${valPrefix}${ty.name}`;
    case "u64":
    case "i64":
    case "u128":
    case "i128":
    case "u256":
    case "i256":
    case "publicKey":
      return `${valPrefix}${ty.name}.toString()`;
    case "bytes":
      return `Array.from(${valPrefix}${ty.name}.values())`;
    default:
      if (isComplexType(ty.type) && "vec" in ty.type) {
        const mapBody = fieldToJSON(idl, {
          name: "item",
          type: ty.type.vec
        });
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "array" in ty.type) {
        const mapBody = fieldToJSON(idl, {
          name: "item",
          type: ty.type.array[0]
        });
        if (mapBody === "item") {
          return `${valPrefix}${ty.name}`;
        }
        return `${valPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "option" in ty.type) {
        const value = fieldToJSON(
          idl,
          { name: ty.name, type: ty.type.option },
          valPrefix
        );
        if (value === `${valPrefix}${ty.name}`) {
          return value;
        }
        return `(${valPrefix}${ty.name} && ${value}) || null`;
      }
      if (isComplexType(ty.type) && "coption" in ty.type) {
        const value = fieldToJSON(
          idl,
          { name: ty.name, type: ty.type.coption },
          valPrefix
        );
        if (value === `${valPrefix}${ty.name}`) {
          return value;
        }
        return `(${valPrefix}${ty.name} && ${value}) || null`;
      }
      if (isComplexType(ty.type) && "defined" in ty.type) {
        const defined = ty.type.defined;
        const filtered = (_b = (_a = idl.types) == null ? void 0 : _a.filter((t) => t.name === defined)) != null ? _b : [];
        if (filtered.length !== 1) {
          throw new Error(`Defined type not found: ${JSON.stringify(ty)}`);
        }
        switch (filtered[0].type.kind) {
          case "struct":
          case "enum":
            return `${valPrefix}${ty.name}.toJSON()`;
          default: {
            unreachable(filtered[0].type);
            throw new Error("Unreachable.");
          }
        }
      }
      unreachable(ty.type);
      throw new Error("Unreachable.");
  }
}
function idlTypeToJSONType(ty, definedTypesPrefix = "types.") {
  switch (ty) {
    case "bool":
      return "boolean";
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "f64":
      return "number";
    case "string":
    case "u64":
    case "i64":
    case "u128":
    case "i128":
    case "u256":
    case "i256":
    case "publicKey":
      return "string";
    case "bytes":
      return "Array<number>";
    default:
      if (isComplexType(ty) && "vec" in ty) {
        const inner = idlTypeToJSONType(ty.vec, definedTypesPrefix);
        return `Array<${inner}>`;
      }
      if (isComplexType(ty) && "array" in ty) {
        const inner = idlTypeToJSONType(ty.array[0], definedTypesPrefix);
        return `Array<${inner}>`;
      }
      if (isComplexType(ty) && "option" in ty) {
        const inner = idlTypeToJSONType(ty.option, definedTypesPrefix);
        return `${inner} | null`;
      }
      if (isComplexType(ty) && "coption" in ty) {
        const inner = idlTypeToJSONType(ty.coption, definedTypesPrefix);
        return `${inner} | null`;
      }
      if (isComplexType(ty) && "defined" in ty) {
        return `${definedTypesPrefix}${jsonInterfaceName(ty.defined)}`;
      }
      unreachable(ty);
      throw new Error("Unreachable.");
  }
}
function fieldFromJSON(ty, jsonParamName = "obj", definedTypesPrefix = "types.") {
  const paramPrefix = jsonParamName ? jsonParamName + "." : "";
  switch (ty.type) {
    case "bool":
    case "u8":
    case "i8":
    case "u16":
    case "i16":
    case "u32":
    case "i32":
    case "f32":
    case "f64":
    case "string":
      return `${paramPrefix}${ty.name}`;
    case "bytes":
      return `Uint8Array.from(${paramPrefix}${ty.name})`;
    case "u64":
    case "i64":
    case "u128":
    case "i128":
      return `new BN(${paramPrefix}${ty.name})`;
    case "u256":
    case "i256":
    case "publicKey":
      return `new PublicKey(${paramPrefix}${ty.name})`;
    default:
      if (isComplexType(ty.type) && "vec" in ty.type) {
        const mapBody = fieldFromJSON(
          {
            name: "item",
            type: ty.type.vec
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${paramPrefix}${ty.name}`;
        }
        return `${paramPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "array" in ty.type) {
        const mapBody = fieldFromJSON(
          {
            name: "item",
            type: ty.type.array[0]
          },
          "",
          definedTypesPrefix
        );
        if (mapBody === "item") {
          return `${paramPrefix}${ty.name}`;
        }
        return `${paramPrefix}${ty.name}.map((item) => ${mapBody})`;
      }
      if (isComplexType(ty.type) && "option" in ty.type) {
        const inner = fieldFromJSON(
          { name: ty.name, type: ty.type.option },
          jsonParamName,
          definedTypesPrefix
        );
        if (inner === `${paramPrefix}${ty.name}`) {
          return inner;
        }
        return `(${paramPrefix}${ty.name} && ${inner}) || null`;
      }
      if (isComplexType(ty.type) && "coption" in ty.type) {
        const inner = fieldFromJSON(
          { name: ty.name, type: ty.type.coption },
          jsonParamName,
          definedTypesPrefix
        );
        if (inner === `${paramPrefix}${ty.name}`) {
          return inner;
        }
        return `(${paramPrefix}${ty.name} && ${inner}) || null`;
      }
      if (isComplexType(ty.type) && "defined" in ty.type) {
        return `${definedTypesPrefix}${ty.type.defined}.fromJSON(${paramPrefix}${ty.name})`;
      }
      unreachable(ty.type);
      throw new Error("Unreachable.");
  }
}

// src/accounts.ts
function genAccounts(project, idl, outPath) {
  if (idl.accounts === void 0 || idl.accounts.length === 0) {
    return;
  }
  genIndexFile(project, idl, outPath);
  genAccountFiles(project, idl, outPath);
}
function genIndexFile(project, idl, outPath) {
  var _a;
  const src = project.createSourceFile(outPath("accounts/index.ts"), "", {
    overwrite: true
  });
  (_a = idl.accounts) == null ? void 0 : _a.forEach((ix) => {
    src.addExportDeclaration({
      namedExports: [ix.name],
      moduleSpecifier: `./${ix.name}`
    });
    src.addExportDeclaration({
      namedExports: [fieldsInterfaceName(ix.name), jsonInterfaceName(ix.name)],
      isTypeOnly: true,
      moduleSpecifier: `./${ix.name}`
    });
  });
}
function genAccountFiles(project, idl, outPath) {
  var _a;
  (_a = idl.accounts) == null ? void 0 : _a.forEach((acc) => {
    const src = project.createSourceFile(
      outPath(`accounts/${acc.name}.ts`),
      "",
      {
        overwrite: true
      }
    );
    src.addStatements([
      `import { PublicKey, Connection } from "@solana/web3.js"`,
      `import BN from "bn.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
      `import * as borsh from "@coral-xyz/borsh" // eslint-disable-line @typescript-eslint/no-unused-vars`,
      ...idl.types && idl.types.length > 0 ? [
        `import * as types from "../types" // eslint-disable-line @typescript-eslint/no-unused-vars`
      ] : [],
      `import { PROGRAM_ID } from "../programId"`
    ]);
    const fields = acc.type.fields;
    const name = acc.name;
    src.addInterface({
      isExported: true,
      name: fieldsInterfaceName(name),
      properties: fields.map((field) => {
        return {
          name: field.name,
          type: tsTypeFromIdl(idl, field.type),
          docs: field.docs && [field.docs.join("\n")]
        };
      })
    });
    src.addInterface({
      isExported: true,
      name: jsonInterfaceName(name),
      properties: fields.map((field) => {
        return {
          name: field.name,
          type: idlTypeToJSONType(field.type),
          docs: field.docs && [field.docs.join("\n")]
        };
      })
    });
    const cls = src.addClass({
      isExported: true,
      name,
      properties: fields.map((field) => {
        return {
          isReadonly: true,
          name: field.name,
          type: tsTypeFromIdl(idl, field.type, "types.", false),
          docs: field.docs && [field.docs.join("\n")]
        };
      }),
      docs: acc.docs && [acc.docs.join("\n")]
    });
    cls.addProperty({
      isStatic: true,
      isReadonly: true,
      name: "discriminator",
      initializer: `Buffer.from([${genAccDiscriminator(name).toString()}])`
    }).prependWhitespace("\n");
    cls.addProperty({
      isStatic: true,
      isReadonly: true,
      name: "layout",
      initializer: (writer) => {
        writer.write("borsh.struct([");
        fields.forEach((field) => {
          writer.writeLine(layoutForType(field.type, field.name) + ",");
        });
        writer.write("])");
      }
    }).prependWhitespace("\n");
    cls.addConstructor({
      parameters: [
        {
          name: "fields",
          type: fieldsInterfaceName(name)
        }
      ],
      statements: (writer) => {
        fields.forEach((field) => {
          const initializer = structFieldInitializer(idl, field);
          writer.writeLine(`this.${field.name} = ${initializer}`);
        });
      }
    });
    cls.addMethod({
      isStatic: true,
      isAsync: true,
      name: "fetch",
      parameters: [
        {
          name: "c",
          type: "Connection"
        },
        {
          name: "address",
          type: "PublicKey"
        },
        {
          name: "programId",
          type: "PublicKey",
          initializer: "PROGRAM_ID"
        }
      ],
      returnType: `Promise<${name} | null>`,
      statements: [
        (writer) => {
          writer.writeLine("const info = await c.getAccountInfo(address)");
          writer.blankLine();
          writer.write("if (info === null)");
          writer.inlineBlock(() => {
            writer.writeLine("return null");
          });
          writer.write("if (!info.owner.equals(programId))");
          writer.inlineBlock(() => {
            writer.writeLine(
              `throw new Error("account doesn't belong to this program")`
            );
          });
          writer.blankLine();
          writer.writeLine("return this.decode(info.data)");
        }
      ]
    });
    cls.addMethod({
      isStatic: true,
      isAsync: true,
      name: "fetchMultiple",
      parameters: [
        {
          name: "c",
          type: "Connection"
        },
        {
          name: "addresses",
          type: "PublicKey[]"
        },
        {
          name: "programId",
          type: "PublicKey",
          initializer: "PROGRAM_ID"
        }
      ],
      returnType: `Promise<Array<${name} | null>>`,
      statements: [
        (writer) => {
          writer.writeLine(
            "const infos = await c.getMultipleAccountsInfo(addresses)"
          );
          writer.blankLine();
          writer.write("return infos.map((info) => ");
          writer.inlineBlock(() => {
            writer.write("if (info === null)");
            writer.inlineBlock(() => {
              writer.writeLine("return null");
            });
            writer.write("");
            writer.write("if (!info.owner.equals(programId))");
            writer.inlineBlock(() => {
              writer.writeLine(
                `throw new Error("account doesn't belong to this program")`
              );
            });
            writer.blankLine();
            writer.writeLine("return this.decode(info.data)");
          });
          writer.write(")");
        }
      ]
    });
    cls.addMethod({
      isStatic: true,
      name: "decode",
      parameters: [
        {
          name: "data",
          type: "Buffer"
        }
      ],
      returnType: name,
      statements: [
        (writer) => {
          writer.write(`if (!data.slice(0, 8).equals(${name}.discriminator))`);
          writer.inlineBlock(() => {
            writer.writeLine(`throw new Error("invalid account discriminator")`);
          });
          writer.blankLine();
          writer.writeLine(`const dec = ${name}.layout.decode(data.slice(8))`);
          writer.blankLine();
          writer.write(`return new ${name}({`);
          fields.forEach((field) => {
            const decoded = fieldFromDecoded(idl, field, "dec.");
            writer.writeLine(`${field.name}: ${decoded},`);
          });
          writer.write("})");
        }
      ]
    });
    cls.addMethod({
      name: "toJSON",
      returnType: jsonInterfaceName(name),
      statements: [
        (writer) => {
          writer.write(`return {`);
          fields.forEach((field) => {
            writer.writeLine(
              `${field.name}: ${fieldToJSON(idl, field, "this.")},`
            );
          });
          writer.write("}");
        }
      ]
    });
    cls.addMethod({
      isStatic: true,
      name: "fromJSON",
      returnType: name,
      parameters: [
        {
          name: "obj",
          type: jsonInterfaceName(name)
        }
      ],
      statements: [
        (writer) => {
          writer.write(`return new ${name}({`);
          fields.forEach((field) => {
            writer.writeLine(`${field.name}: ${fieldFromJSON(field)},`);
          });
          writer.write("})");
        }
      ]
    });
  });
}

// src/errors.ts
import { LangErrorCode, LangErrorMessage } from "@coral-xyz/anchor";
import {
  VariableDeclarationKind
} from "ts-morph";
function genErrors(project, idl, outPath) {
  genIndex(project, idl, outPath);
  genCustomErrors(project, idl, outPath);
  genAnchorErrors(project, idl, outPath);
}
function genIndex(project, idl, outPath) {
  const src = project.createSourceFile(outPath("errors/index.ts"), "", {
    overwrite: true
  });
  const hasCustomErrors = idl.errors && idl.errors.length > 0;
  src.addStatements([
    `import { PublicKey } from "@solana/web3.js"`
  ]);
  src.addImportDeclaration({
    namedImports: ["PROGRAM_ID"],
    moduleSpecifier: "../programId"
  });
  src.addImportDeclaration({
    namespaceImport: "anchor",
    moduleSpecifier: "./anchor"
  });
  if (hasCustomErrors) {
    src.addImportDeclaration({
      namespaceImport: "custom",
      moduleSpecifier: "./custom"
    });
  }
  const fromCodeFn = src.addFunction({
    isExported: true,
    name: "fromCode",
    parameters: [
      {
        name: "code",
        type: "number"
      },
      {
        name: "logs",
        type: "string[]",
        hasQuestionToken: true
      }
    ],
    returnType: hasCustomErrors ? "custom.CustomError | anchor.AnchorError | null" : "anchor.AnchorError | null"
  });
  hasCustomErrors ? fromCodeFn.setBodyText(
    "return code >= 6000 ? custom.fromCode(code, logs) : anchor.fromCode(code, logs)"
  ) : fromCodeFn.setBodyText("return anchor.fromCode(code, logs)");
  const hasOwnPropertyFn = src.addFunction({
    name: "hasOwnProperty",
    typeParameters: [
      {
        name: "X extends object"
      },
      {
        name: "Y extends PropertyKey"
      }
    ],
    parameters: [
      {
        name: "obj",
        type: "X"
      },
      {
        name: "prop",
        type: "Y"
      }
    ],
    returnType: "obj is X & Record<Y, unknown>"
  });
  hasOwnPropertyFn.setBodyText("return Object.hasOwnProperty.call(obj, prop);");
  src.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [
      {
        name: "errorRe",
        initializer: "/Program (\\w+) failed: custom program error: (\\w+)/"
      }
    ]
  });
  const fromTxErrorFn = src.addFunction({
    isExported: true,
    name: "fromTxError",
    parameters: [
      {
        name: "err",
        type: "unknown"
      },
      {
        name: "programId",
        type: "PublicKey",
        initializer: "PROGRAM_ID"
      }
    ],
    returnType: hasCustomErrors ? "custom.CustomError | anchor.AnchorError | null" : "anchor.AnchorError | null"
  });
  fromTxErrorFn.setBodyText(`if (
  typeof err !== "object" ||
  err === null ||
  !hasOwnProperty(err, "logs") ||
  !Array.isArray(err.logs)
) {
  return null
}

let firstMatch: RegExpExecArray | null = null
for (const logLine of err.logs) {
  firstMatch = errorRe.exec(logLine)
  if (firstMatch !== null) {
    break
  }
}

if (firstMatch === null) {
  return null
}

const [programIdRaw, codeRaw] = firstMatch.slice(1)
if (programIdRaw !== programId.toString()) {
  return null
}

let errorCode: number
try {
  errorCode = parseInt(codeRaw, 16)
} catch (parseErr) {
  return null
}

return fromCode(errorCode, err.logs)`);
}
function genCustomErrors(project, idl, outPath) {
  if (!idl.errors || idl.errors.length === 0) {
    return;
  }
  const errors = idl.errors;
  const src = project.createSourceFile(outPath("errors/custom.ts"), "", {
    overwrite: true
  });
  src.addTypeAlias({
    name: "CustomError",
    type: errors.map((error) => error.name).join(" | "),
    isExported: true
  });
  errors.forEach((error) => {
    const properties = [
      {
        name: "code",
        initializer: error.code.toString(),
        isReadonly: true,
        isStatic: true
      },
      {
        name: "code",
        initializer: error.code.toString(),
        isReadonly: true
      },
      {
        name: "name",
        initializer: `"${error.name}"`,
        isReadonly: true
      }
    ];
    if (error.msg) {
      properties.push({
        name: "msg",
        initializer: `"${error.msg}"`,
        isReadonly: true
      });
    }
    const cls = src.addClass({
      isExported: true,
      name: error.name,
      extends: "Error",
      properties
    });
    const ctor = cls.addConstructor({
      parameters: [
        {
          name: "logs",
          isReadonly: true,
          hasQuestionToken: true,
          type: "string[]"
        }
      ]
    });
    ctor.setBodyText(`super("${error.code}: ${error.msg || ""}")`);
  });
  const fromCodeFn = src.addFunction({
    isExported: true,
    name: "fromCode",
    parameters: [
      {
        name: "code",
        type: "number"
      },
      {
        name: "logs",
        type: "string[]",
        hasQuestionToken: true
      }
    ],
    returnType: "CustomError | null"
  });
  fromCodeFn.setBodyText((writer) => {
    writer.writeLine("switch (code)").block(() => {
      errors.forEach((error) => {
        writer.writeLine(`case ${error.code}:`).indent(() => {
          writer.writeLine(`return new ${error.name}(logs);`);
        });
      });
    }).blankLine().writeLine("return null");
  });
}
function genAnchorErrors(project, idl, outPath) {
  const src = project.createSourceFile(outPath("errors/anchor.ts"), "", {
    overwrite: true
  });
  src.addTypeAlias({
    name: "AnchorError",
    type: Object.keys(LangErrorCode).join(" | "),
    isExported: true
  });
  Object.keys(LangErrorCode).forEach((errorName) => {
    const code = LangErrorCode[errorName];
    const message = LangErrorMessage.get(code) || "";
    const cls = src.addClass({
      isExported: true,
      name: errorName,
      extends: "Error",
      properties: [
        {
          name: "code",
          initializer: code.toString(),
          isReadonly: true,
          isStatic: true
        },
        {
          name: "code",
          initializer: code.toString(),
          isReadonly: true
        },
        {
          name: "name",
          initializer: `"${errorName}"`,
          isReadonly: true
        },
        {
          name: "msg",
          initializer: `"${message}"`,
          isReadonly: true
        }
      ]
    });
    const ctor = cls.addConstructor({
      parameters: [
        {
          name: "logs",
          isReadonly: true,
          hasQuestionToken: true,
          type: "string[]"
        }
      ]
    });
    ctor.setBodyText(`super("${code}: ${message}")`);
  });
  const fromCodeFn = src.addFunction({
    isExported: true,
    name: "fromCode",
    parameters: [
      {
        name: "code",
        type: "number"
      },
      {
        name: "logs",
        type: "string[]",
        hasQuestionToken: true
      }
    ],
    returnType: "AnchorError | null"
  });
  fromCodeFn.setBodyText((writer) => {
    writer.writeLine("switch (code)").block(() => {
      Object.keys(LangErrorCode).forEach((errorName) => {
        writer.writeLine(`case ${LangErrorCode[errorName]}:`).indent(() => {
          writer.writeLine(`return new ${errorName}(logs);`);
        });
      });
    }).blankLine().writeLine("return null");
  });
}

// src/instructions.ts
import { VariableDeclarationKind as VariableDeclarationKind2 } from "ts-morph";
function genInstructions(project, idl, outPath) {
  if (idl.instructions.length === 0) {
    return;
  }
  genIndexFile2(project, idl, outPath);
  genInstructionFiles(project, idl, outPath);
}
function capitalize(s) {
  return s[0].toUpperCase() + s.slice(1);
}
function argsInterfaceName(ixName) {
  return `${capitalize(ixName)}Args`;
}
function accountsInterfaceName(ixName) {
  return `${capitalize(ixName)}Accounts`;
}
function genIndexFile2(project, idl, outPath) {
  const src = project.createSourceFile(outPath("instructions/index.ts"), "", {
    overwrite: true
  });
  idl.instructions.forEach((ix) => {
    src.addExportDeclaration({
      namedExports: [ix.name],
      moduleSpecifier: `./${ix.name}`
    });
    const typeExports = [];
    if (ix.args.length > 0) {
      typeExports.push(argsInterfaceName(ix.name));
    }
    if (ix.accounts.length > 0) {
      typeExports.push(accountsInterfaceName(ix.name));
    }
    if (typeExports.length > 0) {
      src.addExportDeclaration({
        namedExports: typeExports,
        isTypeOnly: true,
        moduleSpecifier: `./${ix.name}`
      });
    }
  });
}
function genInstructionFiles(project, idl, outPath) {
  idl.instructions.forEach((ix) => {
    const src = project.createSourceFile(
      outPath(`instructions/${ix.name}.ts`),
      "",
      {
        overwrite: true
      }
    );
    src.addStatements([
      `import { TransactionInstruction, PublicKey, AccountMeta } from "@solana/web3.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
      `import BN from "bn.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
      `import * as borsh from "@coral-xyz/borsh" // eslint-disable-line @typescript-eslint/no-unused-vars`,
      ...idl.types && idl.types.length > 0 ? [
        `import * as types from "../types" // eslint-disable-line @typescript-eslint/no-unused-vars`
      ] : [],
      `import { PROGRAM_ID } from "../programId"`
    ]);
    if (ix.args.length > 0) {
      src.addInterface({
        isExported: true,
        name: argsInterfaceName(ix.name),
        properties: ix.args.map((arg) => {
          return {
            name: arg.name,
            type: tsTypeFromIdl(idl, arg.type)
          };
        })
      });
    }
    function genAccIfPropTypeRec(accItem, writer) {
      if (!("accounts" in accItem)) {
        writer.write("PublicKey");
        return;
      }
      writer.block(() => {
        accItem.accounts.forEach((item) => {
          if (item.docs) {
            writer.writeLine(`/** ${item.docs.join(" ")} */`);
          }
          writer.write(`${item.name}: `);
          genAccIfPropTypeRec(item, writer);
          writer.newLine();
        });
      });
    }
    if (ix.accounts.length > 0) {
      src.addInterface({
        isExported: true,
        name: accountsInterfaceName(ix.name),
        properties: ix.accounts.map((acc) => {
          return {
            name: acc.name,
            type: (writer) => {
              genAccIfPropTypeRec(acc, writer);
            },
            docs: acc.docs && [acc.docs.join("\n")]
          };
        })
      });
    }
    if (ix.args.length > 0) {
      src.addVariableStatement({
        isExported: true,
        declarationKind: VariableDeclarationKind2.Const,
        declarations: [
          {
            name: "layout",
            initializer: (writer) => {
              writer.write("borsh.struct([");
              ix.args.forEach((arg) => {
                writer.writeLine(layoutForType(arg.type, arg.name) + ",");
              });
              writer.write("])");
            }
          }
        ]
      });
    }
    const ixFn = src.addFunction({
      isExported: true,
      name: ix.name,
      docs: ix.docs && [ix.docs.join("\n")]
    });
    if (ix.args.length > 0) {
      ixFn.addParameter({
        name: "args",
        type: argsInterfaceName(ix.name)
      });
    }
    if (ix.accounts.length > 0) {
      ixFn.addParameter({
        name: "accounts",
        type: accountsInterfaceName(ix.name)
      });
    }
    ixFn.addParameter({
      name: "programId",
      type: "PublicKey",
      initializer: "PROGRAM_ID"
    });
    ixFn.addVariableStatement({
      declarationKind: VariableDeclarationKind2.Const,
      declarations: [
        {
          name: "keys",
          type: "Array<AccountMeta>",
          initializer: (writer) => {
            writer.write("[");
            function recurseAccounts(accs, nestedNames) {
              accs.forEach((item) => {
                if ("accounts" in item) {
                  recurseAccounts(item.accounts, [...nestedNames, item.name]);
                  return;
                }
                writer.writeLine(
                  `{ pubkey: accounts.${[...nestedNames, item.name].join(
                    "."
                  )}, isSigner: ${item.isSigner}, isWritable: ${item.isMut} },`
                );
              });
            }
            recurseAccounts(ix.accounts, []);
            writer.write("]");
          }
        }
      ]
    });
    ixFn.addVariableStatement({
      declarationKind: VariableDeclarationKind2.Const,
      declarations: [
        {
          name: "identifier",
          initializer: `Buffer.from([${genIxIdentifier(ix.name).toString()}])`
        }
      ]
    });
    if (ix.args.length > 0) {
      ixFn.addVariableStatement({
        declarationKind: VariableDeclarationKind2.Const,
        declarations: [
          {
            name: "buffer",
            initializer: "Buffer.alloc(1000)"
            // TODO: use a tighter buffer.
          }
        ]
      });
      ixFn.addVariableStatement({
        declarationKind: VariableDeclarationKind2.Const,
        declarations: [
          {
            name: "len",
            initializer: (writer) => {
              writer.write("layout.encode({");
              ix.args.forEach((arg) => {
                writer.writeLine(
                  `${arg.name}: ${fieldToEncodable(idl, arg, "args.")},`
                );
              });
              writer.write("}, buffer)");
            }
          }
        ]
      });
      ixFn.addVariableStatement({
        declarationKind: VariableDeclarationKind2.Const,
        declarations: [
          {
            name: "data",
            initializer: "Buffer.concat([identifier, buffer]).slice(0, 8 + len)"
          }
        ]
      });
    } else {
      ixFn.addVariableStatement({
        declarationKind: VariableDeclarationKind2.Const,
        declarations: [
          {
            name: "data",
            initializer: "identifier"
          }
        ]
      });
    }
    ixFn.addVariableStatement({
      declarationKind: VariableDeclarationKind2.Const,
      declarations: [
        {
          name: "ix",
          initializer: "new TransactionInstruction({ keys, programId, data })"
        }
      ]
    });
    ixFn.addStatements("return ix");
  });
}

// src/programId.ts
import { VariableDeclarationKind as VariableDeclarationKind3 } from "ts-morph";
function genProgramId(project, idl, cliProgramId, outPath) {
  var _a, _b;
  let idlProgramId = null;
  if ("metadata" in idl && "address" in idl.metadata) {
    idlProgramId = idl.metadata.address;
  }
  let src = project.addSourceFileAtPathIfExists(outPath("programId.ts"));
  if (src === void 0 && idlProgramId === null && cliProgramId === null) {
    console.warn(
      "\nWARNING: program ID not found in the IDL nor provided with the `--program-id` flag. Edit the generated `programId.ts` file manually to return the correct program ID!\n"
    );
  }
  let programIdValue = (_b = (_a = src == null ? void 0 : src.getVariableDeclaration("PROGRAM_ID")) == null ? void 0 : _a.getInitializer()) == null ? void 0 : _b.getText();
  const programIdDefaultValue = "new PublicKey(/* edit this to return the correct program ID */)";
  if (programIdValue === programIdDefaultValue) {
    programIdValue = void 0;
  }
  if (programIdValue === void 0) {
    programIdValue = programIdDefaultValue;
    if (cliProgramId) {
      programIdValue = "PROGRAM_ID_CLI";
    } else if (idlProgramId) {
      programIdValue = "PROGRAM_ID_IDL";
    }
  }
  const importStatements = src == null ? void 0 : src.getImportDeclarations().map((impt) => impt.getText());
  src = project.createSourceFile(outPath("programId.ts"), "", {
    overwrite: true
  });
  if (importStatements === void 0 || importStatements.length === 0) {
    src.addImportDeclaration({
      namedImports: ["PublicKey"],
      moduleSpecifier: "@solana/web3.js"
    });
  } else {
    src.addStatements(importStatements);
  }
  if (idlProgramId) {
    src.addStatements([
      "\n",
      "// Program ID defined in the provided IDL. Do not edit, it will get overwritten."
    ]);
    src.addVariableStatement({
      declarationKind: VariableDeclarationKind3.Const,
      declarations: [
        {
          name: "PROGRAM_ID_IDL",
          initializer: `new PublicKey("${idlProgramId}")`
        }
      ],
      isExported: true
    });
  }
  if (cliProgramId) {
    src.addStatements([
      "\n",
      "// Program ID passed with the cli --program-id flag when running the code generator. Do not edit, it will get overwritten."
    ]);
    src.addVariableStatement({
      declarationKind: VariableDeclarationKind3.Const,
      declarations: [
        {
          name: "PROGRAM_ID_CLI",
          initializer: `new PublicKey("${cliProgramId}")`
        }
      ],
      isExported: true
    });
  }
  src.addStatements([
    "\n",
    "// This constant will not get overwritten on subsequent code generations and it's safe to modify it's value."
  ]);
  src.addVariableStatement({
    isExported: true,
    declarationKind: VariableDeclarationKind3.Const,
    declarations: [
      {
        name: "PROGRAM_ID",
        type: "PublicKey",
        initializer: programIdValue
      }
    ]
  });
}

// src/types.ts
import camelcase2 from "camelcase";
function genTypes(project, idl, outPath) {
  if (idl.types === void 0 || idl.types.length === 0) {
    return;
  }
  genIndexFile3(project, idl, outPath);
  genTypeFiles(project, idl, outPath);
}
function genIndexFile3(project, idl, outPath) {
  var _a;
  const src = project.createSourceFile(outPath("types/index.ts"), "", {
    overwrite: true
  });
  (_a = idl.types) == null ? void 0 : _a.forEach((ty) => {
    switch (ty.type.kind) {
      case "struct":
        src.addExportDeclaration({
          namedExports: [ty.name],
          moduleSpecifier: `./${ty.name}`
        });
        src.addExportDeclaration({
          namedExports: [
            fieldsInterfaceName(ty.name),
            jsonInterfaceName(ty.name)
          ],
          isTypeOnly: true,
          moduleSpecifier: `./${ty.name}`
        });
        return;
      case "enum":
        src.addImportDeclaration({
          namespaceImport: ty.name,
          moduleSpecifier: `./${ty.name}`
        });
        src.addExportDeclaration({
          namedExports: [ty.name]
        });
        src.addTypeAlias({
          isExported: true,
          name: kindInterfaceName(ty.name),
          type: ty.type.variants.map((variant) => {
            return `${ty.name}.${variant.name}`;
          }).join(" | "),
          docs: ty.docs && [ty.docs.join("\n")]
        });
        src.addTypeAlias({
          isExported: true,
          name: jsonInterfaceName(ty.name),
          type: ty.type.variants.map((variant) => {
            return `${ty.name}.${jsonInterfaceName(variant.name)}`;
          }).join(" | ")
        });
        return;
      default:
        unreachable(ty.type);
    }
  });
}
function genTypeFiles(project, idl, outPath) {
  var _a;
  (_a = idl.types) == null ? void 0 : _a.forEach((ty) => {
    const src = project.createSourceFile(outPath(`types/${ty.name}.ts`), "", {
      overwrite: true
    });
    switch (ty.type.kind) {
      case "struct": {
        genStruct(idl, src, ty.name, ty.type.fields, ty.docs);
        return;
      }
      case "enum": {
        genEnum(idl, src, ty.name, ty.type.variants);
        return;
      }
      default:
        unreachable(ty.type);
    }
  });
}
function genStruct(idl, src, name, fields, docs) {
  src.addStatements([
    `import { PublicKey } from "@solana/web3.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import BN from "bn.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import * as types from "../types" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import * as borsh from "@coral-xyz/borsh"`
  ]);
  src.addInterface({
    isExported: true,
    name: fieldsInterfaceName(name),
    properties: fields.map((field) => {
      return {
        name: field.name,
        type: tsTypeFromIdl(idl, field.type),
        docs: field.docs && [field.docs.join("\n")]
      };
    })
  });
  src.addInterface({
    isExported: true,
    name: jsonInterfaceName(name),
    properties: fields.map((field) => {
      return {
        name: field.name,
        type: idlTypeToJSONType(field.type),
        docs: field.docs && [field.docs.join("\n")]
      };
    })
  });
  const cls = src.addClass({
    isExported: true,
    name,
    properties: fields.map((field) => {
      return {
        isReadonly: true,
        name: field.name,
        type: tsTypeFromIdl(idl, field.type, "types.", false),
        docs: field.docs && [field.docs.join("\n")]
      };
    }),
    docs: docs && [docs.join("\n")]
  });
  cls.addConstructor({
    parameters: [
      {
        name: "fields",
        type: fieldsInterfaceName(name)
      }
    ],
    statements: (writer) => {
      fields.forEach((field) => {
        const initializer = structFieldInitializer(idl, field);
        writer.writeLine(`this.${field.name} = ${initializer}`);
      });
    }
  });
  cls.addMethod({
    isStatic: true,
    name: "layout",
    parameters: [
      {
        name: "property",
        type: "string",
        hasQuestionToken: true
      }
    ],
    statements: [
      (writer) => {
        writer.write("return borsh.struct([");
        fields.forEach((field) => {
          writer.writeLine(layoutForType(field.type, field.name) + ",");
        });
        writer.write("], property)");
      }
    ]
  });
  const fromDecoded = cls.addMethod({
    isStatic: true,
    name: "fromDecoded",
    parameters: [
      {
        name: "obj",
        type: "any"
      }
    ],
    statements: [
      (writer) => {
        writer.write(`return new ${name}({`);
        fields.forEach((field) => {
          const decoded = fieldFromDecoded(idl, field, "obj.");
          writer.writeLine(`${field.name}: ${decoded},`);
        });
        writer.write("})");
      }
    ]
  });
  cls.insertText(
    fromDecoded.getStart(),
    "// eslint-disable-next-line @typescript-eslint/no-explicit-any\n"
  );
  cls.addMethod({
    isStatic: true,
    name: "toEncodable",
    parameters: [
      {
        name: "fields",
        type: fieldsInterfaceName(name)
      }
    ],
    statements: [
      (writer) => {
        writer.write(`return {`);
        fields.forEach((field) => {
          writer.writeLine(
            `${field.name}: ${fieldToEncodable(idl, field, "fields.")},`
          );
        });
        writer.write("}");
      }
    ]
  });
  cls.addMethod({
    name: "toJSON",
    returnType: jsonInterfaceName(name),
    statements: [
      (writer) => {
        writer.write(`return {`);
        fields.forEach((field) => {
          writer.writeLine(
            `${field.name}: ${fieldToJSON(idl, field, "this.")},`
          );
        });
        writer.write("}");
      }
    ]
  });
  cls.addMethod({
    isStatic: true,
    name: "fromJSON",
    returnType: name,
    parameters: [
      {
        name: "obj",
        type: jsonInterfaceName(name)
      }
    ],
    statements: [
      (writer) => {
        writer.write(`return new ${name}({`);
        fields.forEach((field) => {
          writer.writeLine(`${field.name}: ${fieldFromJSON(field)},`);
        });
        writer.write("})");
      }
    ]
  });
  cls.addMethod({
    name: "toEncodable",
    statements: [`return ${name}.toEncodable(this)`]
  });
}
function genEnum(idl, src, name, variants) {
  src.addStatements([
    `import { PublicKey } from "@solana/web3.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import BN from "bn.js" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import * as types from "../types" // eslint-disable-line @typescript-eslint/no-unused-vars`,
    `import * as borsh from "@coral-xyz/borsh"`
  ]);
  variants.forEach((variant, i) => {
    const discriminator = i;
    const fields = variant.fields;
    if (fields && fields.length > 0) {
      let fieldsAliasType;
      let valueAliasType;
      if (typeof fields[0] === "object" && "name" in fields[0]) {
        fieldsAliasType = (writer) => {
          writer.write("{");
          fields.forEach((field) => {
            if (field.docs) {
              writer.writeLine(`/** ${field.docs.join("\n")} */`);
            }
            writer.writeLine(
              `${camelcase2(field.name)}: ${tsTypeFromIdl(idl, field.type)}`
            );
          });
          writer.writeLine("}");
        };
        valueAliasType = (writer) => {
          writer.write("{");
          fields.forEach((field) => {
            if (field.docs) {
              writer.writeLine(`/** ${field.docs.join("\n")} */`);
            }
            writer.writeLine(
              `${camelcase2(field.name)}: ${tsTypeFromIdl(
                idl,
                field.type,
                "types.",
                false
              )}`
            );
          });
          writer.writeLine("}");
        };
      } else {
        fieldsAliasType = (writer) => {
          writer.write("[");
          fields.forEach((field) => {
            writer.writeLine(`${tsTypeFromIdl(idl, field)},`);
          });
          writer.writeLine("]");
        };
        valueAliasType = (writer) => {
          writer.write("[");
          fields.forEach((field) => {
            writer.writeLine(`${tsTypeFromIdl(idl, field, "types.", false)},`);
          });
          writer.writeLine("]");
        };
      }
      src.addTypeAlias({
        isExported: true,
        name: fieldsInterfaceName(variant.name),
        type: fieldsAliasType
      });
      src.addTypeAlias({
        isExported: true,
        name: valueInterfaceName(variant.name),
        type: valueAliasType
      });
    }
    const jsonInterface = src.addInterface({
      isExported: true,
      name: jsonInterfaceName(variant.name),
      properties: [
        {
          name: "kind",
          type: `"${variant.name}"`
        }
      ]
    });
    if (fields !== void 0 && fields.length > 0) {
      const valueTypeWriter = (writer) => {
        if (typeof fields[0] === "object" && "name" in fields[0]) {
          writer.inlineBlock(() => {
            fields.forEach((field) => {
              if (field.docs) {
                writer.writeLine(`/** ${field.docs.join("\n")} */`);
              }
              const name2 = camelcase2(field.name);
              writer.writeLine(`${name2}: ${idlTypeToJSONType(field.type)},`);
            });
          });
        } else {
          writer.write(`[`);
          writer.blankLine();
          fields.forEach((field) => {
            writer.writeLine(`${idlTypeToJSONType(field)},`);
          });
          writer.write("]");
        }
      };
      jsonInterface.addProperty({
        name: "value",
        type: valueTypeWriter
      });
    }
    const cls = src.addClass({
      isExported: true,
      name: variant.name,
      properties: [
        {
          isReadonly: true,
          name: "discriminator",
          initializer: discriminator.toString(),
          isStatic: true
        },
        {
          isReadonly: true,
          name: "kind",
          initializer: `"${variant.name}"`,
          isStatic: true
        },
        {
          isReadonly: true,
          name: "discriminator",
          initializer: discriminator.toString()
        },
        {
          isReadonly: true,
          name: "kind",
          initializer: `"${variant.name}"`
        }
      ]
    });
    if (fields && fields.length > 0) {
      cls.addProperty({
        isReadonly: true,
        name: "value",
        type: valueInterfaceName(variant.name)
      });
    }
    if (fields && fields.length > 0) {
      const cstr = cls.addConstructor({
        parameters: [
          {
            name: "value",
            type: fieldsInterfaceName(variant.name)
          }
        ]
      });
      cstr.setBodyText((writer) => {
        if (typeof fields[0] === "object" && "name" in fields[0]) {
          writer.write("this.value = {");
          fields.forEach((field) => {
            const name2 = camelcase2(field.name);
            writer.writeLine(
              `${name2}: ${structFieldInitializer(
                idl,
                __spreadProps(__spreadValues({}, field), { name: name2 }),
                "value."
              )},`
            );
          });
          writer.writeLine("}");
        } else {
          writer.write("this.value = [");
          fields.forEach((field, i2) => {
            const name2 = `value[${i2}]`;
            writer.writeLine(
              `${structFieldInitializer(idl, { name: name2, type: field }, "")},`
            );
          });
          writer.writeLine("]");
        }
      });
    }
    const toJSONstmt = (writer) => {
      writer.write("return");
      writer.inlineBlock(() => {
        writer.writeLine(`kind: "${variant.name}",`);
        if (fields === void 0 || fields.length === 0) {
          return;
        }
        writer.write("value: ");
        if (typeof fields[0] === "object" && "name" in fields[0]) {
          writer.inlineBlock(() => {
            fields.forEach((field) => {
              const name2 = camelcase2(field.name);
              writer.writeLine(
                `${name2}: ${fieldToJSON(
                  idl,
                  __spreadProps(__spreadValues({}, field), { name: name2 }),
                  "this.value."
                )},`
              );
            });
          });
        } else {
          writer.write(`[`);
          fields.forEach((field, i2) => {
            const name2 = `value[${i2}]`;
            writer.writeLine(
              `${fieldToJSON(idl, { name: name2, type: field }, "this.")},`
            );
          });
          writer.write("]");
        }
      });
    };
    cls.addMethod({
      name: "toJSON",
      returnType: jsonInterfaceName(variant.name),
      statements: [toJSONstmt]
    });
    const toEncodableStmt = (writer) => {
      writer.write(`return`).inlineBlock(() => {
        writer.writeLine(`${variant.name}: {`);
        fields == null ? void 0 : fields.forEach((field, i2) => {
          if (typeof field === "object" && "name" in field) {
            const encodable = fieldToEncodable(
              idl,
              __spreadProps(__spreadValues({}, field), { name: camelcase2(field.name) }),
              "this.value."
            );
            writer.writeLine(`${field.name}: ${encodable},`);
          } else {
            const encodable = fieldToEncodable(
              idl,
              { type: field, name: `[${i2}]` },
              "this.value"
            );
            writer.writeLine(`_${i2}: ${encodable},`);
          }
        });
        writer.writeLine(`}`);
      });
    };
    cls.addMethod({
      name: "toEncodable",
      statements: [toEncodableStmt]
    });
  });
  const fromDecoded = src.addFunction({
    isExported: true,
    name: "fromDecoded",
    parameters: [
      {
        name: "obj",
        type: "any"
      }
    ],
    returnType: `types.${kindInterfaceName(name)}`,
    statements: [
      (writer) => {
        writer.write('if (typeof obj !== "object")').block(() => {
          writer.writeLine('throw new Error("Invalid enum object")');
        });
        writer.blankLine();
        variants.forEach((variant) => {
          writer.write(`if ("${variant.name}" in obj)`).block(() => {
            if (variant.fields && variant.fields.length > 0) {
              writer.writeLine(`const val = obj["${variant.name}"]`);
              if (typeof variant.fields[0] === "object" && "name" in variant.fields[0]) {
                writer.write(`return new ${variant.name}({`);
                variant.fields.forEach((field) => {
                  const decoded = fieldFromDecoded(
                    idl,
                    __spreadProps(__spreadValues({}, field), {
                      name: `val["${field.name}"]`
                    }),
                    ""
                  );
                  writer.writeLine(`${camelcase2(field.name)}: ${decoded},`);
                });
                writer.writeLine(`})`);
              } else {
                writer.write(`return new ${variant.name}([`);
                variant.fields.forEach((field, i) => {
                  const decoded = fieldFromDecoded(
                    idl,
                    {
                      type: field,
                      name: `val["_${i}"]`
                    },
                    ""
                  );
                  writer.writeLine(`${decoded},`);
                });
                writer.writeLine(`])`);
              }
            } else {
              writer.writeLine(`return new ${variant.name}()`);
            }
          });
        });
        writer.blankLine();
        writer.writeLine('throw new Error("Invalid enum object")');
      }
    ]
  });
  src.insertText(
    fromDecoded.getStart(),
    "// eslint-disable-next-line @typescript-eslint/no-explicit-any\n"
  );
  src.addFunction({
    isExported: true,
    name: "fromJSON",
    parameters: [
      {
        name: "obj",
        type: `types.${jsonInterfaceName(name)}`
      }
    ],
    returnType: `types.${kindInterfaceName(name)}`,
    statements: [
      (writer) => {
        writer.write("switch (obj.kind)").block(() => {
          variants.forEach((variant) => {
            writer.write(`case "${variant.name}":`).block(() => {
              if (variant.fields && variant.fields.length > 0) {
                if (typeof variant.fields[0] === "object" && "name" in variant.fields[0]) {
                  writer.write(`return new ${variant.name}({`);
                  variant.fields.forEach((field) => {
                    const jf = fieldFromJSON(
                      __spreadProps(__spreadValues({}, field), { name: camelcase2(field.name) }),
                      "obj.value"
                    );
                    writer.writeLine(`${camelcase2(field.name)}: ${jf},`);
                  });
                  writer.writeLine(`})`);
                } else {
                  writer.write(`return new ${variant.name}([`);
                  variant.fields.forEach((field, i) => {
                    const jf = fieldFromJSON({
                      type: field,
                      name: `value[${i}]`
                    });
                    writer.writeLine(`${jf},`);
                  });
                  writer.writeLine(`])`);
                }
              } else {
                writer.writeLine(`return new ${variant.name}()`);
              }
            });
          });
        });
      }
    ]
  });
  src.addFunction({
    isExported: true,
    name: "layout",
    parameters: [
      {
        name: "property",
        hasQuestionToken: true,
        type: "string"
      }
    ],
    statements: [
      (writer) => {
        writer.write("const ret = borsh.rustEnum([");
        writer.indent(() => {
          variants.forEach((variant) => {
            writer.writeLine("borsh.struct([");
            writer.indent(() => {
              var _a;
              (_a = variant.fields) == null ? void 0 : _a.forEach((field, i) => {
                if (typeof field === "object" && "type" in field) {
                  writer.writeLine(layoutForType(field.type, field.name) + ",");
                } else {
                  writer.writeLine(layoutForType(field, `_${i}`) + ",");
                }
              });
            });
            writer.writeLine(`], "${variant.name}"),`);
          });
        });
        writer.writeLine("])");
        writer.writeLine("if (property !== undefined)").block(() => {
          writer.writeLine("return ret.replicate(property)");
        });
        writer.writeLine("return ret");
      }
    ]
  });
}

// src/main.ts
import { program } from "commander";
import * as prettier from "prettier";
function main() {
  return __async(this, null, function* () {
    program.description(
      "Generate solana web3 client code from the specified anchor IDL."
    ).argument("<idl>", "anchor IDL file path or '-' to read from stdin").argument("<out>", "output directory").option(
      "--program-id <PROGRAM_ID>",
      "optional program ID to be included in the code"
    ).version("anchor-client-gen 0.28.1").parse();
    const idlPath = program.args[0];
    const outBase = program.args[1];
    const programIdOpt = program.opts().programId || null;
    function outPath(filePath) {
      return path.join(outBase, filePath);
    }
    const pathOrStdin = idlPath === "-" ? 0 : idlPath;
    const idl = JSON.parse(fs.readFileSync(pathOrStdin, "utf-8"));
    const project = new Project4();
    console.log("generating programId.ts...");
    genProgramId(project, idl, programIdOpt, outPath);
    console.log("generating errors...");
    genErrors(project, idl, outPath);
    console.log("generating instructions...");
    genInstructions(project, idl, outPath);
    console.log("generating types...");
    genTypes(project, idl, outPath);
    console.log("generating accounts...");
    genAccounts(project, idl, outPath);
    const files = project.getSourceFiles();
    console.log("formatting...");
    yield Promise.all(
      files.map((file) => __async(this, null, function* () {
        let src = file.getFullText();
        src = prettier.format(src, {
          semi: false,
          singleQuote: false,
          parser: "babel-ts"
        });
        file.replaceWithText(src);
      }))
    );
    console.log("writing files...");
    yield project.save();
  });
}
main().catch((e) => {
  console.error(e.message);
  process.exit(1);
});
