"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMSwapExecutor = void 0;
// src/api/swap/evm/evm-swap.ts
const web3_1 = __importDefault(require("web3"));
class EVMSwapExecutor {
    constructor(config, networkConfig) {
        var _a;
        this.config = config;
        this.networkConfig = networkConfig;
        this.DEFAULT_GAS_MULTIPLIER = BigInt(3) / BigInt(2); // 1.5x
        if (!this.config.evm) {
            throw new Error("EVM configuration required");
        }
        this.web3 = new web3_1.default(((_a = this.config.evm.connection) === null || _a === void 0 ? void 0 : _a.rpcUrl) || '');
    }
    async executeSwap(swapData, params) {
        var _a;
        const quoteData = (_a = swapData.data) === null || _a === void 0 ? void 0 : _a[0];
        if (!(quoteData === null || quoteData === void 0 ? void 0 : quoteData.routerResult)) {
            throw new Error("Invalid swap data: missing router result");
        }
        const { routerResult } = quoteData;
        const tx = quoteData.tx;
        if (!tx) {
            throw new Error("Missing transaction data");
        }
        try {
            const result = await this.executeEvmTransaction(tx);
            return this.formatSwapResult(result.transactionHash.toString(), routerResult);
        }
        catch (error) {
            console.error("Swap execution failed:", error);
            throw error;
        }
    }
    async executeEvmTransaction(tx) {
        var _a, _b;
        if (!((_a = this.config.evm) === null || _a === void 0 ? void 0 : _a.privateKey) || !((_b = this.config.evm) === null || _b === void 0 ? void 0 : _b.walletAddress)) {
            throw new Error("EVM private key and wallet address required");
        }
        let retryCount = 0;
        while (retryCount < (this.networkConfig.maxRetries || 3)) {
            try {
                const nonce = await this.web3.eth.getTransactionCount(this.config.evm.walletAddress, 'latest');
                const signTransactionParams = {
                    data: tx.data,
                    gasPrice: BigInt(tx.gasPrice || 0) * this.DEFAULT_GAS_MULTIPLIER,
                    to: tx.to,
                    value: tx.value || '0',
                    gas: BigInt(tx.gas || 0) * this.DEFAULT_GAS_MULTIPLIER,
                    nonce,
                };
                const { rawTransaction } = await this.web3.eth.accounts.signTransaction(signTransactionParams, this.config.evm.privateKey);
                return this.web3.eth.sendSignedTransaction(rawTransaction);
            }
            catch (error) {
                retryCount++;
                if (retryCount === this.networkConfig.maxRetries)
                    throw error;
                await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));
            }
        }
        throw new Error('Max retries exceeded');
    }
    formatSwapResult(txHash, routerResult) {
        const fromDecimals = parseInt(routerResult.fromToken.decimal);
        const toDecimals = parseInt(routerResult.toToken.decimal);
        const displayFromAmount = (Number(routerResult.fromTokenAmount) /
            Math.pow(10, fromDecimals)).toFixed(6);
        const displayToAmount = (Number(routerResult.toTokenAmount) /
            Math.pow(10, toDecimals)).toFixed(6);
        return {
            success: true,
            transactionId: txHash,
            explorerUrl: `${this.networkConfig.explorer}/${txHash}`,
            details: {
                fromToken: {
                    symbol: routerResult.fromToken.tokenSymbol,
                    amount: displayFromAmount,
                    decimal: routerResult.fromToken.decimal,
                },
                toToken: {
                    symbol: routerResult.toToken.tokenSymbol,
                    amount: displayToAmount,
                    decimal: routerResult.toToken.decimal,
                },
                priceImpact: routerResult.priceImpactPercentage,
            },
        };
    }
}
exports.EVMSwapExecutor = EVMSwapExecutor;
