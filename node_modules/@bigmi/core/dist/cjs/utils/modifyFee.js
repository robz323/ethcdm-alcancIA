"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyFee = modifyFee;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
function modifyFee(psbt, newFee, accountAddress) {
    const newPsbt = new bitcoinjs_lib_1.Psbt();
    const inputs = psbt.data.inputs;
    const outputs = psbt.txOutputs;
    for (let i = 0; i < inputs.length; i++) {
        const input = inputs[i];
        const inputData = {
            hash: psbt.txInputs[i].hash,
            index: psbt.txInputs[i].index,
        };
        if (input.nonWitnessUtxo) {
            inputData.nonWitnessUtxo = input.nonWitnessUtxo;
        }
        else if (input.witnessUtxo) {
            inputData.witnessUtxo = input.witnessUtxo;
        }
        if (input.redeemScript) {
            inputData.redeemScript = input.redeemScript;
        }
        if (input.witnessScript) {
            inputData.witnessScript = input.witnessScript;
        }
        newPsbt.addInput(inputData);
    }
    const changeOutputScript = bitcoinjs_lib_1.address.toOutputScript(accountAddress);
    for (const output of outputs) {
        const outputData = {
            script: output.script,
            value: output.value,
        };
        const scriptsAreEqual = output.script.length === changeOutputScript.length &&
            output.script.every((value, index) => value === changeOutputScript[index]);
        if (scriptsAreEqual) {
            outputData.value = output.value - newFee;
            if (outputData.value < 0) {
                throw new Error('Insufficient funds to adjust the fee by the specified amount.');
            }
        }
        newPsbt.addOutput(outputData);
    }
    newPsbt.txInputs.forEach((_, index) => {
        newPsbt.setInputSequence(index, 0xfffffffd);
    });
    return newPsbt;
}
//# sourceMappingURL=modifyFee.js.map