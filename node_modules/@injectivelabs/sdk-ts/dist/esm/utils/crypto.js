// import CryptoEs from 'crypto-es'
import CryptoEs from 'crypto-js';
import { secp256k1 } from '@noble/curves/secp256k1';
import keccak256 from 'keccak256';
import { TypedDataUtils, SignTypedDataVersion, } from '@metamask/eth-sig-util';
export const hashToHex = (data) => {
    return CryptoEs.SHA256(CryptoEs.enc.Base64.parse(data))
        .toString()
        .toUpperCase();
};
export const sha256 = (data) => {
    const wordArray = CryptoEs.lib.WordArray.create(data);
    const hash = CryptoEs.SHA256(wordArray);
    return Uint8Array.from(Buffer.from(hash.toString(), 'hex'));
};
export const ripemd160 = (data) => {
    const wordArray = CryptoEs.lib.WordArray.create(data);
    const hash = CryptoEs.RIPEMD160(wordArray);
    return Uint8Array.from(Buffer.from(hash.toString(), 'hex'));
};
export const privateKeyToPublicKey = (privateKey) => {
    return secp256k1.getPublicKey(privateKey, true);
};
export const privateKeyHashToPublicKey = (privateKeyHash) => {
    const privateKey = privateKeyHash.startsWith('0x')
        ? privateKeyHash.slice(2)
        : privateKeyHash;
    return secp256k1.getPublicKey(Buffer.from(privateKey, 'hex'), true);
};
export const privateKeyToPublicKeyBase64 = (privateKey) => {
    return Buffer.from(privateKeyToPublicKey(privateKey)).toString('base64');
};
export const privateKeyHashToPublicKeyBase64 = (privateKeyHash) => {
    return Buffer.from(privateKeyHashToPublicKey(privateKeyHash)).toString('base64');
};
export const domainHash = (message) => TypedDataUtils.hashStruct('EIP712Domain', message.domain, message.types, SignTypedDataVersion.V4);
export const messageHash = (message) => TypedDataUtils.hashStruct(message.primaryType, message.message, message.types, SignTypedDataVersion.V4);
export function uint8ArrayToHex(arr) {
    return Buffer.from(arr).toString('hex');
}
export function hexToUnit8Array(str) {
    return new Uint8Array(Buffer.from(str, 'hex'));
}
export function decompressPubKey(startsWith02Or03) {
    const testBuffer = Buffer.from(startsWith02Or03, 'hex');
    if (testBuffer.length === 64)
        startsWith02Or03 = '04' + startsWith02Or03;
    const point = secp256k1.ProjectivePoint.fromHex(Buffer.from(testBuffer).toString('hex'));
    const decompressed = point.toHex(false);
    if (!decompressed.startsWith('04'))
        return decompressed;
    return decompressed.slice(2);
}
export const publicKeyToAddress = function (pubKey, sanitize = false) {
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.ProjectivePoint.fromHex(pubKey)
            .toRawBytes(false)
            .slice(1);
    }
    if (pubKey.length !== 64) {
        throw new Error('Expected pubKey to be of length 64');
    }
    return keccak256(Buffer.from(pubKey)).subarray(-20);
};
export const sanitizeTypedData = (data) => {
    switch (Object.prototype.toString.call(data)) {
        case '[object Object]': {
            const entries = Object.keys(data).map((k) => [
                k,
                sanitizeTypedData(data[k]),
            ]);
            return Object.fromEntries(entries);
        }
        case '[object Array]':
            return data.map((v) => sanitizeTypedData(v));
        case '[object BigInt]':
            return data.toString();
        default:
            return data;
    }
};
export const TypedDataUtilsSanitizeData = TypedDataUtils.sanitizeData;
export const TypedDataUtilsHashStruct = TypedDataUtils.hashStruct;
export const SignTypedDataVersionV4 = SignTypedDataVersion.V4;
