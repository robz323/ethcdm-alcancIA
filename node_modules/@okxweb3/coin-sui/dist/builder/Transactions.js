"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = exports.getTransactionType = exports.TransactionType = exports.PublishTransaction = exports.MakeMoveVecTransaction = exports.MergeCoinsTransaction = exports.SplitCoinsTransaction = exports.TransferObjectsTransaction = exports.MoveCallTransaction = exports.PureTransactionArgument = exports.ObjectTransactionArgument = exports.TransactionArgument = exports.TransactionBlockInput = void 0;
const bcs_1 = require("../bcs");
const superstruct_1 = require("superstruct");
const common_1 = require("../types/common");
const utils_1 = require("./utils");
const option = (some) => (0, superstruct_1.union)([(0, superstruct_1.object)({ None: (0, superstruct_1.literal)(null) }), (0, superstruct_1.object)({ Some: some })]);
exports.TransactionBlockInput = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('Input'),
    index: (0, superstruct_1.integer)(),
    value: (0, superstruct_1.optional)((0, superstruct_1.any)()),
    type: (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.literal)('pure'), (0, superstruct_1.literal)('object')])),
});
const TransactionArgumentTypes = [
    exports.TransactionBlockInput,
    (0, superstruct_1.object)({ kind: (0, superstruct_1.literal)('GasCoin') }),
    (0, superstruct_1.object)({ kind: (0, superstruct_1.literal)('Result'), index: (0, superstruct_1.integer)() }),
    (0, superstruct_1.object)({
        kind: (0, superstruct_1.literal)('NestedResult'),
        index: (0, superstruct_1.integer)(),
        resultIndex: (0, superstruct_1.integer)(),
    }),
];
exports.TransactionArgument = (0, superstruct_1.union)([...TransactionArgumentTypes]);
exports.ObjectTransactionArgument = (0, superstruct_1.union)([...TransactionArgumentTypes]);
exports.ObjectTransactionArgument[utils_1.TRANSACTION_TYPE] = {
    kind: 'object',
};
const PureTransactionArgument = (type) => {
    const struct = (0, superstruct_1.union)([...TransactionArgumentTypes]);
    struct[utils_1.TRANSACTION_TYPE] = {
        kind: 'pure',
        type,
    };
    return struct;
};
exports.PureTransactionArgument = PureTransactionArgument;
exports.MoveCallTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('MoveCall'),
    target: (0, superstruct_1.define)('target', (0, superstruct_1.string)().validator),
    typeArguments: (0, superstruct_1.array)((0, superstruct_1.string)()),
    arguments: (0, superstruct_1.array)(exports.TransactionArgument),
});
exports.TransferObjectsTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('TransferObjects'),
    objects: (0, superstruct_1.array)(exports.ObjectTransactionArgument),
    address: (0, exports.PureTransactionArgument)(bcs_1.BCS.ADDRESS),
});
exports.SplitCoinsTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('SplitCoins'),
    coin: exports.ObjectTransactionArgument,
    amounts: (0, superstruct_1.array)((0, exports.PureTransactionArgument)('u64')),
});
exports.MergeCoinsTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('MergeCoins'),
    destination: exports.ObjectTransactionArgument,
    sources: (0, superstruct_1.array)(exports.ObjectTransactionArgument),
});
exports.MakeMoveVecTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('MakeMoveVec'),
    type: (0, superstruct_1.optional)(option((0, superstruct_1.string)())),
    objects: (0, superstruct_1.array)(exports.ObjectTransactionArgument),
});
exports.PublishTransaction = (0, superstruct_1.object)({
    kind: (0, superstruct_1.literal)('Publish'),
    modules: (0, superstruct_1.array)((0, superstruct_1.array)((0, superstruct_1.integer)())),
    dependencies: (0, superstruct_1.array)(common_1.ObjectId),
});
const TransactionTypes = [
    exports.MoveCallTransaction,
    exports.TransferObjectsTransaction,
    exports.SplitCoinsTransaction,
    exports.MergeCoinsTransaction,
    exports.PublishTransaction,
    exports.MakeMoveVecTransaction,
];
exports.TransactionType = (0, superstruct_1.union)([...TransactionTypes]);
function getTransactionType(data) {
    (0, superstruct_1.assert)(data, exports.TransactionType);
    return TransactionTypes.find((schema) => (0, superstruct_1.is)(data, schema));
}
exports.getTransactionType = getTransactionType;
exports.Transactions = {
    MoveCall(input) {
        return (0, utils_1.create)({
            kind: 'MoveCall',
            target: input.target,
            arguments: input.arguments ?? [],
            typeArguments: input.typeArguments ?? [],
        }, exports.MoveCallTransaction);
    },
    TransferObjects(objects, address) {
        return (0, utils_1.create)({ kind: 'TransferObjects', objects, address }, exports.TransferObjectsTransaction);
    },
    SplitCoins(coin, amounts) {
        return (0, utils_1.create)({ kind: 'SplitCoins', coin, amounts }, exports.SplitCoinsTransaction);
    },
    MergeCoins(destination, sources) {
        return (0, utils_1.create)({ kind: 'MergeCoins', destination, sources }, exports.MergeCoinsTransaction);
    },
    Publish(modules, dependencies) {
        return (0, utils_1.create)({ kind: 'Publish', modules, dependencies }, exports.PublishTransaction);
    },
    MakeMoveVec({ type, objects, }) {
        return (0, utils_1.create)({
            kind: 'MakeMoveVec',
            type: type ? { Some: type } : { None: null },
            objects,
        }, exports.MakeMoveVecTransaction);
    },
};
//# sourceMappingURL=Transactions.js.map