"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.PROGRAMMABLE_CALL = exports.ARGUMENT = exports.TRANSACTION = exports.ENUM_KIND = exports.TRANSACTION_INNER = exports.PROGRAMMABLE_CALL_INNER = exports.PROGRAMMABLE_TX_BLOCK = exports.OBJECT_ARG = exports.TYPE_TAG = exports.CALL_ARG = exports.OPTION = exports.VECTOR = exports.ARGUMENT_INNER = void 0;
const bcs_1 = require("../bcs");
const sui_bcs_1 = require("../types/sui-bcs");
const types_1 = require("../types");
const type_tag_serializer_1 = require("../signers/txn-data-serializers/type-tag-serializer");
exports.ARGUMENT_INNER = 'Argument';
exports.VECTOR = 'vector';
exports.OPTION = 'Option';
exports.CALL_ARG = 'CallArg';
exports.TYPE_TAG = 'TypeTag';
exports.OBJECT_ARG = 'ObjectArg';
exports.PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';
exports.PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';
exports.TRANSACTION_INNER = 'Transaction';
exports.ENUM_KIND = 'EnumKind';
exports.TRANSACTION = [exports.ENUM_KIND, exports.TRANSACTION_INNER];
exports.ARGUMENT = [exports.ENUM_KIND, exports.ARGUMENT_INNER];
exports.PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';
exports.builder = new bcs_1.BCS(sui_bcs_1.bcs)
    .registerStructType(exports.PROGRAMMABLE_TX_BLOCK, {
    inputs: [exports.VECTOR, exports.CALL_ARG],
    transactions: [exports.VECTOR, exports.TRANSACTION],
})
    .registerEnumType(exports.ARGUMENT_INNER, {
    GasCoin: null,
    Input: { index: bcs_1.BCS.U16 },
    Result: { index: bcs_1.BCS.U16 },
    NestedResult: { index: bcs_1.BCS.U16, resultIndex: bcs_1.BCS.U16 },
})
    .registerStructType(exports.PROGRAMMABLE_CALL_INNER, {
    package: bcs_1.BCS.ADDRESS,
    module: bcs_1.BCS.STRING,
    function: bcs_1.BCS.STRING,
    type_arguments: [exports.VECTOR, exports.TYPE_TAG],
    arguments: [exports.VECTOR, exports.ARGUMENT],
})
    .registerEnumType(exports.TRANSACTION_INNER, {
    MoveCall: exports.PROGRAMMABLE_CALL,
    TransferObjects: {
        objects: [exports.VECTOR, exports.ARGUMENT],
        address: exports.ARGUMENT,
    },
    SplitCoins: { coin: exports.ARGUMENT, amounts: [exports.VECTOR, exports.ARGUMENT] },
    MergeCoins: { destination: exports.ARGUMENT, sources: [exports.VECTOR, exports.ARGUMENT] },
    Publish: {
        modules: [exports.VECTOR, [exports.VECTOR, bcs_1.BCS.U8]],
        dependencies: [exports.VECTOR, bcs_1.BCS.ADDRESS],
    },
    MakeMoveVec: {
        type: [exports.OPTION, exports.TYPE_TAG],
        objects: [exports.VECTOR, exports.ARGUMENT],
    },
});
exports.builder.registerType([exports.ENUM_KIND, 'T'], function encode(writer, data, typeParams, typeMap) {
    const kind = data.kind;
    const invariant = { [kind]: data };
    const [enumType] = typeParams;
    return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);
}, function decode(reader, typeParams, typeMap) {
    const [enumType] = typeParams;
    const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);
    const kind = Object.keys(data)[0];
    return { kind, ...data[kind] };
}, (data) => {
    if (typeof data !== 'object' && !('kind' in data)) {
        throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(data)}`);
    }
    return true;
});
exports.builder.registerType(exports.PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {
    const [pkg, module, fun] = data.target.split('::');
    const type_arguments = data.typeArguments.map((tag) => type_tag_serializer_1.TypeTagSerializer.parseFromStr(tag, true));
    return this.getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {
        package: (0, types_1.normalizeSuiAddress)(pkg),
        module,
        function: fun,
        type_arguments,
        arguments: data.arguments,
    }, typeParams, typeMap);
}, function decodeProgrammableTx(reader, typeParams, typeMap) {
    let data = exports.builder
        .getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)
        ._decodeRaw.call(this, reader, typeParams, typeMap);
    return {
        target: [data.package, data.module, data.function].join('::'),
        arguments: data.arguments,
        typeArguments: data.type_arguments.map(type_tag_serializer_1.TypeTagSerializer.tagToString),
    };
}, (data) => {
    return data.target.split('::').length === 3;
});
//# sourceMappingURL=bcs.js.map