"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TransactionBlock_instances, _TransactionBlock_blockData, _TransactionBlock_input, _TransactionBlock_prepare;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBlock = void 0;
const bcs_1 = require("../bcs");
const superstruct_1 = require("superstruct");
const types_1 = require("../types");
const Transactions_1 = require("./Transactions");
const Inputs_1 = require("./Inputs");
const TransactionBlockData_1 = require("./TransactionBlockData");
const utils_1 = require("./utils");
function createTransactionResult(index) {
    const baseResult = { kind: 'Result', index };
    const nestedResults = [];
    const nestedResultFor = (resultIndex) => (nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
        kind: 'NestedResult',
        index,
        resultIndex,
    }));
    return new Proxy(baseResult, {
        set() {
            throw new Error('The transaction result is a proxy, and does not support setting properties directly');
        },
        get(target, property) {
            if (property in target) {
                return Reflect.get(target, property);
            }
            if (property === Symbol.iterator) {
                return function* () {
                    let i = 0;
                    while (true) {
                        yield nestedResultFor(i);
                        i++;
                    }
                };
            }
            if (typeof property === 'symbol')
                return;
            const resultIndex = parseInt(property, 10);
            if (Number.isNaN(resultIndex) || resultIndex < 0)
                return;
            return nestedResultFor(resultIndex);
        },
    });
}
const TRANSACTION_BRAND = Symbol.for('../transaction');
const MAX_GAS_OBJECTS = 256;
const MAX_GAS = 1000000000;
const GAS_OVERHEAD_PER_COIN = 10n;
class TransactionBlock {
    static is(obj) {
        return (!!obj &&
            typeof obj === 'object' &&
            obj[TRANSACTION_BRAND] === true);
    }
    static fromKind(serialized) {
        const tx = new TransactionBlock();
        __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionBlockData_1.TransactionBlockDataBuilder.fromKindBytes(typeof serialized === 'string' ? (0, bcs_1.fromB64)(serialized) : serialized), "f");
        return tx;
    }
    static from(serialized) {
        const tx = new TransactionBlock();
        if (typeof serialized !== 'string' || !serialized.startsWith('{')) {
            __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionBlockData_1.TransactionBlockDataBuilder.fromBytes(typeof serialized === 'string' ? (0, bcs_1.fromB64)(serialized) : serialized), "f");
        }
        else {
            __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionBlockData_1.TransactionBlockDataBuilder.restore(JSON.parse(serialized)), "f");
        }
        return tx;
    }
    static get Transactions() {
        return Transactions_1.Transactions;
    }
    static get Inputs() {
        return Inputs_1.Inputs;
    }
    setSender(sender) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender = sender;
    }
    setSenderIfNotSet(sender) {
        if (!__classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender) {
            __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender = sender;
        }
    }
    setExpiration(expiration) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").expiration = expiration;
    }
    setGasPrice(price) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.price = String(price);
    }
    setGasBudget(budget) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.budget = String(budget);
    }
    setGasOwner(owner) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.owner = owner;
    }
    setGasPayment(payments) {
        if (payments.length >= MAX_GAS_OBJECTS) {
            throw new Error(`Payment objects exceed maximum amount ${MAX_GAS_OBJECTS}`);
        }
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.payment = payments.map((payment) => (0, superstruct_1.mask)(payment, types_1.SuiObjectRef));
    }
    get blockData() {
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").snapshot();
    }
    get [(_TransactionBlock_blockData = new WeakMap(), _TransactionBlock_instances = new WeakSet(), TRANSACTION_BRAND)]() {
        return true;
    }
    constructor(transaction) {
        _TransactionBlock_instances.add(this);
        _TransactionBlock_blockData.set(this, void 0);
        __classPrivateFieldSet(this, _TransactionBlock_blockData, new TransactionBlockData_1.TransactionBlockDataBuilder(transaction ? __classPrivateFieldGet(transaction, _TransactionBlock_blockData, "f") : undefined), "f");
    }
    get gas() {
        return { kind: 'GasCoin' };
    }
    object(value) {
        const id = (0, Inputs_1.getIdFromCallArg)(value);
        const inserted = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.find((i) => i.type === 'object' && id === (0, Inputs_1.getIdFromCallArg)(i.value));
        return inserted ?? __classPrivateFieldGet(this, _TransactionBlock_instances, "m", _TransactionBlock_input).call(this, 'object', value);
    }
    pure(value, type) {
        return __classPrivateFieldGet(this, _TransactionBlock_instances, "m", _TransactionBlock_input).call(this, 'pure', value instanceof Uint8Array
            ? Inputs_1.Inputs.Pure(value)
            : type
                ? Inputs_1.Inputs.Pure(value, type)
                : value);
    }
    add(transaction) {
        const index = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").transactions.push(transaction);
        return createTransactionResult(index - 1);
    }
    splitCoins(...args) {
        return this.add(Transactions_1.Transactions.SplitCoins(...args));
    }
    mergeCoins(...args) {
        return this.add(Transactions_1.Transactions.MergeCoins(...args));
    }
    publish(...args) {
        return this.add(Transactions_1.Transactions.Publish(...args));
    }
    moveCall(...args) {
        return this.add(Transactions_1.Transactions.MoveCall(...args));
    }
    transferObjects(...args) {
        return this.add(Transactions_1.Transactions.TransferObjects(...args));
    }
    makeMoveVec(...args) {
        return this.add(Transactions_1.Transactions.MakeMoveVec(...args));
    }
    serialize() {
        return JSON.stringify(__classPrivateFieldGet(this, _TransactionBlock_blockData, "f").snapshot());
    }
    async build({ onlyTransactionKind, } = {}) {
        await __classPrivateFieldGet(this, _TransactionBlock_instances, "m", _TransactionBlock_prepare).call(this, { onlyTransactionKind });
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").build({ onlyTransactionKind });
    }
    async getDigest({} = {}) {
        await __classPrivateFieldGet(this, _TransactionBlock_instances, "m", _TransactionBlock_prepare).call(this, {});
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").getDigest();
    }
}
exports.TransactionBlock = TransactionBlock;
_TransactionBlock_input = function _TransactionBlock_input(type, value) {
    const index = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.length;
    const input = (0, utils_1.create)({
        kind: 'Input',
        value: typeof value === 'bigint' ? String(value) : value,
        index,
        type,
    }, Transactions_1.TransactionBlockInput);
    __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.push(input);
    return input;
}, _TransactionBlock_prepare = async function _TransactionBlock_prepare({ onlyTransactionKind }) {
    if (!onlyTransactionKind && !__classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender) {
        throw new Error('Missing transaction sender');
    }
    const { inputs, transactions } = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f");
    const moveModulesToResolve = [];
    const objectsToResolve = [];
    transactions.forEach((transaction) => {
        if (transaction.kind === 'MoveCall') {
            const needsResolution = transaction.arguments.some((arg) => arg.kind === 'Input' &&
                !(0, superstruct_1.is)(inputs[arg.index].value, Inputs_1.BuilderCallArg));
            if (needsResolution) {
                moveModulesToResolve.push(transaction);
            }
            return;
        }
        const transactionType = (0, Transactions_1.getTransactionType)(transaction);
        if (!transactionType.schema)
            return;
        Object.entries(transaction).forEach(([key, value]) => {
            if (key === 'kind')
                return;
            const keySchema = transactionType.schema[key];
            const isArray = keySchema.type === 'array';
            const wellKnownEncoding = isArray
                ? keySchema.schema[utils_1.TRANSACTION_TYPE]
                : keySchema[utils_1.TRANSACTION_TYPE];
            if (!wellKnownEncoding)
                return;
            const encodeInput = (index) => {
                const input = inputs[index];
                if (!input) {
                    throw new Error(`Missing input ${value.index}`);
                }
                if ((0, superstruct_1.is)(input.value, Inputs_1.BuilderCallArg))
                    return;
                if (wellKnownEncoding.kind === 'object' &&
                    typeof input.value === 'string') {
                    objectsToResolve.push({ id: input.value, input });
                }
                else if (wellKnownEncoding.kind === 'pure') {
                    input.value = Inputs_1.Inputs.Pure(input.value, wellKnownEncoding.type);
                }
                else {
                    throw new Error('Unexpected input format.');
                }
            };
            if (isArray) {
                value.forEach((arrayItem) => {
                    if (arrayItem.kind !== 'Input')
                        return;
                    encodeInput(arrayItem.index);
                });
            }
            else {
                if (value.kind !== 'Input')
                    return;
                encodeInput(value.index);
            }
        });
    });
    if (moveModulesToResolve.length) {
        throw new Error(`No provider passed to Transaction#build, but transaction data has move modules to resolve.`);
    }
    if (objectsToResolve.length) {
        throw new Error(`No provider passed to Transaction#build, but transaction data has objects to resolve.`);
    }
};
//# sourceMappingURL=TransactionBlock.js.map