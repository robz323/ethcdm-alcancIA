"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519Keypair = exports.DEFAULT_ED25519_DERIVATION_PATH = void 0;
const ed25519_publickey_1 = require("./ed25519-publickey");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
exports.DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
class Ed25519Keypair {
    constructor(keypair) {
        this.keypair = keypair;
    }
    getKeyScheme() {
        return 'ED25519';
    }
    static fromSecretKey(secretKey, options) {
        const secretKeyLength = secretKey.length;
        if (secretKeyLength != 64) {
            if (secretKeyLength == 32) {
                throw new Error('Wrong secretKey size. Expected 64 bytes, got 32. Similar function exists: fromSeed(seed: Uint8Array)');
            }
            throw new Error(`Wrong secretKey size. Expected 64 bytes, got ${secretKeyLength}.`);
        }
        const obj = crypto_lib_1.signUtil.ed25519.fromSecret(secretKey);
        if (!options || !options.skipValidation) {
            const encoder = new TextEncoder();
            const signData = encoder.encode('sui validation');
            const signature = crypto_lib_1.signUtil.ed25519.sign(signData, obj.secretKey);
            if (!crypto_lib_1.signUtil.ed25519.verify(signData, signature, obj.publicKey)) {
                throw new Error('provided secretKey is invalid');
            }
        }
        return new Ed25519Keypair(obj);
    }
    static fromSeed(seed) {
        const seedLength = seed.length;
        if (seedLength != 32) {
            throw new Error(`Wrong seed size. Expected 32 bytes, got ${seedLength}.`);
        }
        return new Ed25519Keypair(crypto_lib_1.signUtil.ed25519.fromSeed(seed));
    }
    getPublicKey() {
        return new ed25519_publickey_1.Ed25519PublicKey(this.keypair.publicKey);
    }
    signData(data) {
        return crypto_lib_1.signUtil.ed25519.sign(data, this.keypair.secretKey);
    }
}
exports.Ed25519Keypair = Ed25519Keypair;
//# sourceMappingURL=ed25519-keypair.js.map