"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuiMoveConfig = exports.getRustConfig = exports.registerPrimitives = exports.decodeStr = exports.encodeStr = exports.BCS = exports.BcsWriter = exports.BcsReader = exports.toHEX = exports.fromHEX = exports.fromB64 = exports.toB64 = exports.fromB58 = exports.toB58 = void 0;
const b64_1 = require("./b64");
Object.defineProperty(exports, "toB64", { enumerable: true, get: function () { return b64_1.toB64; } });
Object.defineProperty(exports, "fromB64", { enumerable: true, get: function () { return b64_1.fromB64; } });
const hex_1 = require("./hex");
Object.defineProperty(exports, "toHEX", { enumerable: true, get: function () { return hex_1.toHEX; } });
Object.defineProperty(exports, "fromHEX", { enumerable: true, get: function () { return hex_1.fromHEX; } });
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const SUI_ADDRESS_LENGTH = 32;
function toLittleEndian(bigint, size) {
    let result = new Uint8Array(size);
    let i = 0;
    while (bigint > 0) {
        result[i] = Number(bigint % BigInt(256));
        bigint = bigint / BigInt(256);
        i += 1;
    }
    return result;
}
const toB58 = (buffer) => crypto_lib_1.base.toBase58(buffer);
exports.toB58 = toB58;
const fromB58 = (str) => crypto_lib_1.base.fromBase58(str);
exports.fromB58 = fromB58;
class BcsReader {
    constructor(data) {
        this.bytePosition = 0;
        this.dataView = new DataView(data.buffer);
    }
    shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    read8() {
        let value = this.dataView.getUint8(this.bytePosition);
        this.shift(1);
        return value;
    }
    read16() {
        let value = this.dataView.getUint16(this.bytePosition, true);
        this.shift(2);
        return value;
    }
    read32() {
        let value = this.dataView.getUint32(this.bytePosition, true);
        this.shift(4);
        return value;
    }
    read64() {
        let value1 = this.read32();
        let value2 = this.read32();
        let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
    }
    read128() {
        let value1 = BigInt(this.read64());
        let value2 = BigInt(this.read64());
        let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
        return BigInt("0x" + result).toString(10);
    }
    read256() {
        let value1 = BigInt(this.read128());
        let value2 = BigInt(this.read128());
        let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
        return BigInt("0x" + result).toString(10);
    }
    readBytes(num) {
        let start = this.bytePosition + this.dataView.byteOffset;
        let value = new Uint8Array(this.dataView.buffer, start, num);
        this.shift(num);
        return value;
    }
    readULEB() {
        let start = this.bytePosition + this.dataView.byteOffset;
        let buffer = new Uint8Array(this.dataView.buffer, start);
        let { value, length } = ulebDecode(buffer);
        this.shift(length);
        return value;
    }
    readVec(cb) {
        let length = this.readULEB();
        let result = [];
        for (let i = 0; i < length; i++) {
            result.push(cb(this, i, length));
        }
        return result;
    }
}
exports.BcsReader = BcsReader;
class BcsWriter {
    constructor({ size = 1024, maxSize, allocateSize = 1024, } = {}) {
        this.bytePosition = 0;
        this.size = size;
        this.maxSize = maxSize || size;
        this.allocateSize = allocateSize;
        this.dataView = new DataView(new ArrayBuffer(size));
    }
    ensureSizeOrGrow(bytes) {
        const requiredSize = this.bytePosition + bytes;
        if (requiredSize > this.size) {
            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
            if (requiredSize > nextSize) {
                throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);
            }
            this.size = nextSize;
            const nextBuffer = new ArrayBuffer(this.size);
            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
            this.dataView = new DataView(nextBuffer);
        }
    }
    shift(bytes) {
        this.bytePosition += bytes;
        return this;
    }
    write8(value) {
        this.ensureSizeOrGrow(1);
        this.dataView.setUint8(this.bytePosition, Number(value));
        return this.shift(1);
    }
    write16(value) {
        this.ensureSizeOrGrow(2);
        this.dataView.setUint16(this.bytePosition, Number(value), true);
        return this.shift(2);
    }
    write32(value) {
        this.ensureSizeOrGrow(4);
        this.dataView.setUint32(this.bytePosition, Number(value), true);
        return this.shift(4);
    }
    write64(value) {
        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
        return this;
    }
    write128(value) {
        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
        return this;
    }
    write256(value) {
        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
        return this;
    }
    writeULEB(value) {
        ulebEncode(value).forEach((el) => this.write8(el));
        return this;
    }
    writeVec(vector, cb) {
        this.writeULEB(vector.length);
        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));
        return this;
    }
    *[Symbol.iterator]() {
        for (let i = 0; i < this.bytePosition; i++) {
            yield this.dataView.getUint8(i);
        }
        return this.toBytes();
    }
    toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
    }
    toString(encoding) {
        return encodeStr(this.toBytes(), encoding);
    }
}
exports.BcsWriter = BcsWriter;
function ulebEncode(num) {
    let arr = [];
    let len = 0;
    if (num === 0) {
        return [0];
    }
    while (num > 0) {
        arr[len] = num & 0x7f;
        if ((num >>= 7)) {
            arr[len] |= 0x80;
        }
        len += 1;
    }
    return arr;
}
function ulebDecode(arr) {
    let total = 0;
    let shift = 0;
    let len = 0;
    while (true) {
        let byte = arr[len];
        len += 1;
        total |= (byte & 0x7f) << shift;
        if ((byte & 0x80) === 0) {
            break;
        }
        shift += 7;
    }
    return {
        value: total,
        length: len,
    };
}
class BCS {
    tempKey() {
        return `bcs-struct-${++this.counter}`;
    }
    constructor(schema) {
        this.types = new Map();
        this.counter = 0;
        if (schema instanceof BCS) {
            this.schema = schema.schema;
            this.types = new Map(schema.types);
            return;
        }
        this.schema = schema;
        this.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);
        this.registerVectorType(schema.vectorType);
        if (schema.types && schema.types.structs) {
            for (let name of Object.keys(schema.types.structs)) {
                this.registerStructType(name, schema.types.structs[name]);
            }
        }
        if (schema.types && schema.types.enums) {
            for (let name of Object.keys(schema.types.enums)) {
                this.registerEnumType(name, schema.types.enums[name]);
            }
        }
        if (schema.types && schema.types.aliases) {
            for (let name of Object.keys(schema.types.aliases)) {
                this.registerAlias(name, schema.types.aliases[name]);
            }
        }
        if (schema.withPrimitives !== false) {
            registerPrimitives(this);
        }
    }
    ser(type, data, options) {
        if (typeof type === "string" || Array.isArray(type)) {
            const { name, params } = this.parseTypeName(type);
            return this.getTypeInterface(name).encode(this, data, options, params);
        }
        if (typeof type === "object") {
            const key = this.tempKey();
            const temp = new BCS(this);
            return temp.registerStructType(key, type).ser(key, data, options);
        }
        throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);
    }
    de(type, data, encoding) {
        if (typeof data === "string") {
            if (encoding) {
                data = decodeStr(data, encoding);
            }
            else {
                throw new Error("To pass a string to `bcs.de`, specify encoding");
            }
        }
        if (typeof type === "string" || Array.isArray(type)) {
            const { name, params } = this.parseTypeName(type);
            return this.getTypeInterface(name).decode(this, data, params);
        }
        if (typeof type === "object") {
            const temp = new BCS(this);
            const key = this.tempKey();
            return temp.registerStructType(key, type).de(key, data, encoding);
        }
        throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);
    }
    hasType(type) {
        return this.types.has(type);
    }
    registerAlias(name, forType) {
        this.types.set(name, forType);
        return this;
    }
    registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
        const { name, params: generics } = this.parseTypeName(typeName);
        this.types.set(name, {
            encode(self, data, options, typeParams) {
                const typeMap = generics.reduce((acc, value, index) => {
                    return Object.assign(acc, { [value]: typeParams[index] });
                }, {});
                return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);
            },
            decode(self, data, typeParams) {
                const typeMap = generics.reduce((acc, value, index) => {
                    return Object.assign(acc, { [value]: typeParams[index] });
                }, {});
                return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);
            },
            _encodeRaw(writer, data, typeParams, typeMap) {
                if (validateCb(data)) {
                    return encodeCb.call(this, writer, data, typeParams, typeMap);
                }
                else {
                    throw new Error(`Validation failed for type ${name}, data: ${data}`);
                }
            },
            _decodeRaw(reader, typeParams, typeMap) {
                return decodeCb.call(this, reader, typeParams, typeMap);
            },
        });
        return this;
    }
    registerAddressType(name, length, encoding = "hex") {
        switch (encoding) {
            case "base64":
                return this.registerType(name, function encodeAddress(writer, data) {
                    return (0, b64_1.fromB64)(data).reduce((writer, el) => writer.write8(el), writer);
                }, function decodeAddress(reader) {
                    return (0, b64_1.toB64)(reader.readBytes(length));
                });
            case "hex":
                return this.registerType(name, function encodeAddress(writer, data) {
                    return (0, hex_1.fromHEX)(data).reduce((writer, el) => writer.write8(el), writer);
                }, function decodeAddress(reader) {
                    return (0, hex_1.toHEX)(reader.readBytes(length));
                });
            default:
                throw new Error("Unsupported encoding! Use either hex or base64");
        }
    }
    registerVectorType(typeName) {
        let { name, params } = this.parseTypeName(typeName);
        if (params.length > 1) {
            throw new Error("Vector can have only one type parameter; got " + name);
        }
        return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {
            return writer.writeVec(data, (writer, el) => {
                let elementType = typeParams[0];
                if (!elementType) {
                    throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);
                }
                let { name, params } = this.parseTypeName(elementType);
                if (this.hasType(name)) {
                    return this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);
                }
                if (!(name in typeMap)) {
                    throw new Error(`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`);
                }
                let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
                return this.getTypeInterface(innerName)._encodeRaw.call(this, writer, el, innerParams, typeMap);
            });
        }, function decodeVector(reader, typeParams, typeMap) {
            return reader.readVec((reader) => {
                let elementType = typeParams[0];
                if (!elementType) {
                    throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);
                }
                let { name, params } = this.parseTypeName(elementType);
                if (this.hasType(name)) {
                    return this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);
                }
                if (!(name in typeMap)) {
                    throw new Error(`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`);
                }
                let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
                this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);
            });
        });
    }
    registerStructType(typeName, fields) {
        for (let key in fields) {
            let internalName = this.tempKey();
            let value = fields[key];
            if (!Array.isArray(value) && typeof value !== "string") {
                fields[key] = internalName;
                this.registerStructType(internalName, value);
            }
        }
        let struct = Object.freeze(fields);
        let canonicalOrder = Object.keys(struct);
        let { name: structName, params: generics } = this.parseTypeName(typeName);
        return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {
            if (!data || data.constructor !== Object) {
                throw new Error(`Expected ${structName} to be an Object, got: ${data}`);
            }
            if (typeParams.length !== generics.length) {
                throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);
            }
            for (let key of canonicalOrder) {
                if (!(key in data)) {
                    throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);
                }
                const { name: fieldType, params: fieldParams } = this.parseTypeName(struct[key]);
                if (!generics.includes(fieldType)) {
                    this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);
                }
                else {
                    const paramIdx = generics.indexOf(fieldType);
                    let { name, params } = this.parseTypeName(typeParams[paramIdx]);
                    if (this.hasType(name)) {
                        this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);
                        continue;
                    }
                    if (!(name in typeMap)) {
                        throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);
                    }
                    let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
                    this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);
                }
            }
            return writer;
        }, function decodeStruct(reader, typeParams, typeMap) {
            if (typeParams.length !== generics.length) {
                throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);
            }
            let result = {};
            for (let key of canonicalOrder) {
                const { name: fieldName, params: fieldParams } = this.parseTypeName(struct[key]);
                if (!generics.includes(fieldName)) {
                    result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);
                }
                else {
                    const paramIdx = generics.indexOf(fieldName);
                    let { name, params } = this.parseTypeName(typeParams[paramIdx]);
                    if (this.hasType(name)) {
                        result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);
                        continue;
                    }
                    if (!(name in typeMap)) {
                        throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);
                    }
                    let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);
                    result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);
                }
            }
            return result;
        });
    }
    registerEnumType(typeName, variants) {
        for (let key in variants) {
            let internalName = this.tempKey();
            let value = variants[key];
            if (value !== null &&
                !Array.isArray(value) &&
                typeof value !== "string") {
                variants[key] = internalName;
                this.registerStructType(internalName, value);
            }
        }
        let struct = Object.freeze(variants);
        let canonicalOrder = Object.keys(struct);
        let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);
        return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {
            if (!data) {
                throw new Error(`Unable to write enum "${name}", missing data.\nReceived: "${data}"`);
            }
            if (typeof data !== "object") {
                throw new Error(`Incorrect data passed into enum "${name}", expected object with properties: "${canonicalOrder.join(" | ")}".\nReceived: "${JSON.stringify(data)}"`);
            }
            let key = Object.keys(data)[0];
            if (key === undefined) {
                throw new Error(`Empty object passed as invariant of the enum "${name}"`);
            }
            let orderByte = canonicalOrder.indexOf(key);
            if (orderByte === -1) {
                throw new Error(`Unknown invariant of the enum "${name}", allowed values: "${canonicalOrder.join(" | ")}"; received "${key}"`);
            }
            let invariant = canonicalOrder[orderByte];
            let invariantType = struct[invariant];
            writer.write8(orderByte);
            if (invariantType === null) {
                return writer;
            }
            let paramIndex = canonicalTypeParams.indexOf(invariantType);
            let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
            {
                let { name, params } = this.parseTypeName(typeOrParam);
                return this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);
            }
        }, function decodeEnum(reader, typeParams, typeMap) {
            let orderByte = reader.readULEB();
            let invariant = canonicalOrder[orderByte];
            let invariantType = struct[invariant];
            if (orderByte === -1) {
                throw new Error(`Decoding type mismatch, expected enum "${name}" invariant index, received "${orderByte}"`);
            }
            if (invariantType === null) {
                return { [invariant]: true };
            }
            let paramIndex = canonicalTypeParams.indexOf(invariantType);
            let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
            {
                let { name, params } = this.parseTypeName(typeOrParam);
                return {
                    [invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),
                };
            }
        });
    }
    getTypeInterface(type) {
        let typeInterface = this.types.get(type);
        if (typeof typeInterface === "string") {
            let chain = [];
            while (typeof typeInterface === "string") {
                if (chain.includes(typeInterface)) {
                    throw new Error(`Recursive definition found: ${chain.join(" -> ")} -> ${typeInterface}`);
                }
                chain.push(typeInterface);
                typeInterface = this.types.get(typeInterface);
            }
        }
        if (typeInterface === undefined) {
            throw new Error(`Type ${type} is not registered`);
        }
        return typeInterface;
    }
    parseTypeName(name) {
        if (Array.isArray(name)) {
            let [typeName, ...params] = name;
            return { name: typeName, params };
        }
        if (typeof name !== "string") {
            throw new Error(`Illegal type passed as a name of the type: ${name}`);
        }
        let [left, right] = this.schema.genericSeparators || ["<", ">"];
        let l_bound = name.indexOf(left);
        let r_bound = Array.from(name).reverse().indexOf(right);
        if (l_bound === -1 && r_bound === -1) {
            return { name: name, params: [] };
        }
        if (l_bound === -1 || r_bound === -1) {
            throw new Error(`Unclosed generic in name '${name}'`);
        }
        let typeName = name.slice(0, l_bound);
        let params = name
            .slice(l_bound + 1, name.length - r_bound - 1)
            .split(",")
            .map((e) => e.trim());
        return { name: typeName, params };
    }
}
exports.BCS = BCS;
BCS.U8 = "u8";
BCS.U16 = "u16";
BCS.U32 = "u32";
BCS.U64 = "u64";
BCS.U128 = "u128";
BCS.U256 = "u256";
BCS.BOOL = "bool";
BCS.VECTOR = "vector";
BCS.ADDRESS = "address";
BCS.STRING = "string";
BCS.HEX = "hex-string";
BCS.BASE58 = "base58-string";
BCS.BASE64 = "base64-string";
function encodeStr(data, encoding) {
    switch (encoding) {
        case "base58":
            return toB58(data);
        case "base64":
            return (0, b64_1.toB64)(data);
        case "hex":
            return (0, hex_1.toHEX)(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
exports.encodeStr = encodeStr;
function decodeStr(data, encoding) {
    switch (encoding) {
        case "base58":
            return fromB58(data);
        case "base64":
            return (0, b64_1.fromB64)(data);
        case "hex":
            return (0, hex_1.fromHEX)(data);
        default:
            throw new Error("Unsupported encoding, supported values are: base64, hex");
    }
}
exports.decodeStr = decodeStr;
function registerPrimitives(bcs) {
    bcs.registerType(BCS.U8, function (writer, data) {
        return writer.write8(data);
    }, function (reader) {
        return reader.read8();
    }, (u8) => u8 < 256);
    bcs.registerType(BCS.U16, function (writer, data) {
        return writer.write16(data);
    }, function (reader) {
        return reader.read16();
    }, (u16) => u16 < 65536);
    bcs.registerType(BCS.U32, function (writer, data) {
        return writer.write32(data);
    }, function (reader) {
        return reader.read32();
    }, (u32) => u32 <= 4294967296n);
    bcs.registerType(BCS.U64, function (writer, data) {
        return writer.write64(data);
    }, function (reader) {
        return reader.read64();
    });
    bcs.registerType(BCS.U128, function (writer, data) {
        return writer.write128(data);
    }, function (reader) {
        return reader.read128();
    });
    bcs.registerType(BCS.U256, function (writer, data) {
        return writer.write256(data);
    }, function (reader) {
        return reader.read256();
    });
    bcs.registerType(BCS.BOOL, function (writer, data) {
        return writer.write8(data);
    }, function (reader) {
        return reader.read8().toString(10) === "1";
    });
    bcs.registerType(BCS.STRING, function (writer, data) {
        return writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));
    }, function (reader) {
        return reader
            .readVec((reader) => reader.read8())
            .map((el) => String.fromCharCode(Number(el)))
            .join("");
    }, (_str) => true);
    bcs.registerType(BCS.HEX, function (writer, data) {
        return writer.writeVec(Array.from((0, hex_1.fromHEX)(data)), (writer, el) => writer.write8(el));
    }, function (reader) {
        let bytes = reader.readVec((reader) => reader.read8());
        return (0, hex_1.toHEX)(new Uint8Array(bytes));
    });
    bcs.registerType(BCS.BASE58, function (writer, data) {
        return writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));
    }, function (reader) {
        let bytes = reader.readVec((reader) => reader.read8());
        return toB58(new Uint8Array(bytes));
    });
    bcs.registerType(BCS.BASE64, function (writer, data) {
        return writer.writeVec(Array.from((0, b64_1.fromB64)(data)), (writer, el) => writer.write8(el));
    }, function (reader) {
        let bytes = reader.readVec((reader) => reader.read8());
        return (0, b64_1.toB64)(new Uint8Array(bytes));
    });
}
exports.registerPrimitives = registerPrimitives;
function getRustConfig() {
    return {
        genericSeparators: ["<", ">"],
        vectorType: "Vec",
        addressLength: SUI_ADDRESS_LENGTH,
        addressEncoding: "hex",
    };
}
exports.getRustConfig = getRustConfig;
function getSuiMoveConfig() {
    return {
        genericSeparators: ["<", ">"],
        vectorType: "vector",
        addressLength: SUI_ADDRESS_LENGTH,
        addressEncoding: "hex",
    };
}
exports.getSuiMoveConfig = getSuiMoveConfig;
//# sourceMappingURL=index.js.map