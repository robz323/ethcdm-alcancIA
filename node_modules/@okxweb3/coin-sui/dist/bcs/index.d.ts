import { toB64, fromB64 } from "./b64";
import { toHEX, fromHEX } from "./hex";
declare const toB58: (buffer: Uint8Array) => string;
declare const fromB58: (str: string) => Uint8Array;
export { toB58, fromB58, toB64, fromB64, fromHEX, toHEX };
export type Encoding = "base58" | "base64" | "hex";
export type TypeName = string | [string, ...(TypeName | string)[]];
export declare class BcsReader {
    private dataView;
    private bytePosition;
    constructor(data: Uint8Array);
    shift(bytes: number): this;
    read8(): number;
    read16(): number;
    read32(): number;
    read64(): string;
    read128(): string;
    read256(): string;
    readBytes(num: number): Uint8Array;
    readULEB(): number;
    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[];
}
interface BcsWriterOptions {
    size?: number;
    maxSize?: number;
    allocateSize?: number;
}
export declare class BcsWriter {
    private dataView;
    private bytePosition;
    private size;
    private maxSize;
    private allocateSize;
    constructor({ size, maxSize, allocateSize, }?: BcsWriterOptions);
    private ensureSizeOrGrow;
    shift(bytes: number): this;
    write8(value: number | bigint): this;
    write16(value: number | bigint): this;
    write32(value: number | bigint): this;
    write64(value: number | bigint): this;
    write128(value: number | bigint): this;
    write256(value: number | bigint): this;
    writeULEB(value: number): this;
    writeVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => {}): this;
    [Symbol.iterator](): Iterator<number, Iterable<number>>;
    toBytes(): Uint8Array;
    toString(encoding: Encoding): string;
}
export interface TypeInterface {
    encode: (self: BCS, data: any, options: BcsWriterOptions | undefined, typeParams: TypeName[]) => BcsWriter;
    decode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;
    _encodeRaw: (writer: BcsWriter, data: any, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => BcsWriter;
    _decodeRaw: (reader: BcsReader, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => any;
}
export type StructTypeDefinition = {
    [key: string]: TypeName | StructTypeDefinition;
};
export type EnumTypeDefinition = {
    [key: string]: TypeName | StructTypeDefinition | null;
};
export type BcsConfig = {
    vectorType: string;
    addressLength: number;
    addressEncoding?: "hex" | "base64";
    genericSeparators?: [string, string];
    types?: {
        structs?: {
            [key: string]: StructTypeDefinition;
        };
        enums?: {
            [key: string]: EnumTypeDefinition;
        };
        aliases?: {
            [key: string]: string;
        };
    };
    withPrimitives?: boolean;
};
export declare class BCS {
    static readonly U8: string;
    static readonly U16: string;
    static readonly U32: string;
    static readonly U64: string;
    static readonly U128: string;
    static readonly U256: string;
    static readonly BOOL: string;
    static readonly VECTOR: string;
    static readonly ADDRESS: string;
    static readonly STRING: string;
    static readonly HEX: string;
    static readonly BASE58: string;
    static readonly BASE64: string;
    types: Map<string, TypeInterface | string>;
    protected schema: BcsConfig;
    protected counter: number;
    private tempKey;
    constructor(schema: BcsConfig | BCS);
    ser(type: TypeName | StructTypeDefinition, data: any, options?: BcsWriterOptions): BcsWriter;
    de(type: TypeName | StructTypeDefinition, data: Uint8Array | string, encoding?: Encoding): any;
    hasType(type: string): boolean;
    registerAlias(name: string, forType: string): BCS;
    registerType(typeName: TypeName, encodeCb: (writer: BcsWriter, data: any, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => BcsWriter, decodeCb: (reader: BcsReader, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => any, validateCb?: (data: any) => boolean): BCS;
    registerAddressType(name: string, length: number, encoding?: Encoding | void): BCS;
    private registerVectorType;
    registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS;
    registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS;
    getTypeInterface(type: string): TypeInterface;
    parseTypeName(name: TypeName): {
        name: string;
        params: TypeName[];
    };
}
export declare function encodeStr(data: Uint8Array, encoding: Encoding): string;
export declare function decodeStr(data: string, encoding: Encoding): Uint8Array;
export declare function registerPrimitives(bcs: BCS): void;
export declare function getRustConfig(): BcsConfig;
export declare function getSuiMoveConfig(): BcsConfig;
