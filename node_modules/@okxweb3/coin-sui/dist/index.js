"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryDecodeSuiPrivateKey = exports.encodeSuiPrivateKey = exports.getAddressFromPublic = exports.getAddressFromPrivate = exports.assert = exports.is = exports.toB64 = exports.fromB64 = void 0;
const ed25519_keypair_1 = require("./cryptography/ed25519-keypair");
__exportStar(require("./cryptography/ed25519-keypair"), exports);
__exportStar(require("./cryptography/keypair"), exports);
__exportStar(require("./cryptography/ed25519-publickey"), exports);
__exportStar(require("./cryptography/publickey"), exports);
__exportStar(require("./cryptography/signature"), exports);
__exportStar(require("./signers/txn-data-serializers/type-tag-serializer"), exports);
__exportStar(require("./signers/signer"), exports);
__exportStar(require("./signers/raw-signer"), exports);
__exportStar(require("./signers/types"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils/format"), exports);
__exportStar(require("./utils/intent"), exports);
__exportStar(require("./framework"), exports);
__exportStar(require("./builder"), exports);
var bcs_1 = require("./bcs");
Object.defineProperty(exports, "fromB64", { enumerable: true, get: function () { return bcs_1.fromB64; } });
Object.defineProperty(exports, "toB64", { enumerable: true, get: function () { return bcs_1.toB64; } });
var superstruct_1 = require("superstruct");
Object.defineProperty(exports, "is", { enumerable: true, get: function () { return superstruct_1.is; } });
Object.defineProperty(exports, "assert", { enumerable: true, get: function () { return superstruct_1.assert; } });
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const ed25519_publickey_1 = require("./cryptography/ed25519-publickey");
const keypair_1 = require("./cryptography/keypair");
const SuiWallet_1 = require("./SuiWallet");
__exportStar(require("./signers/raw-signer"), exports);
__exportStar(require("./signers/signer-with-provider"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./SuiWallet"), exports);
function getAddressFromPrivate(privateKey) {
    if (!crypto_lib_1.base.validateHexString(privateKey)) {
        throw new Error('invalid key');
    }
    const pk = crypto_lib_1.base.fromHex(privateKey.toLowerCase());
    const kp = ed25519_keypair_1.Ed25519Keypair.fromSeed(pk);
    return { address: kp.getPublicKey().toSuiAddress(), publicKey: crypto_lib_1.base.toBase64(kp.getPublicKey().toBytes()) };
}
exports.getAddressFromPrivate = getAddressFromPrivate;
function getAddressFromPublic(publicKey) {
    const pk = crypto_lib_1.base.fromBase64(publicKey);
    const p = new ed25519_publickey_1.Ed25519PublicKey(pk);
    return p.toSuiAddress();
}
exports.getAddressFromPublic = getAddressFromPublic;
function encodeSuiPrivateKey(prv) {
    if (prv == undefined || null || prv.length == 0) {
        throw new Error('Invalid bytes length');
    }
    if (prv.startsWith(SuiWallet_1.SUI_PRIVATE_KEY_PREFIX)) {
        const [prefix, words] = crypto_lib_1.base.fromBech32(prv);
        if (prefix !== SuiWallet_1.SUI_PRIVATE_KEY_PREFIX) {
            throw new Error('invalid private key prefix');
        }
        if (words[0] != 0x00) {
            throw new Error('invalid private key prefix');
        }
        if (words.length !== keypair_1.PRIVATE_KEY_SIZE + 1) {
            throw new Error('invalid key');
        }
        return prv;
    }
    if (!crypto_lib_1.base.validateHexString(prv)) {
        throw new Error('invalid key');
    }
    let bytes = crypto_lib_1.base.fromHex(prv.toLowerCase());
    if (bytes.length !== keypair_1.PRIVATE_KEY_SIZE) {
        throw new Error('invalid key');
    }
    const privKeyBytes = new Uint8Array(bytes.length + 1);
    privKeyBytes.set([0x00]);
    privKeyBytes.set(bytes, 1);
    return crypto_lib_1.base.toBech32(SuiWallet_1.SUI_PRIVATE_KEY_PREFIX, privKeyBytes);
}
exports.encodeSuiPrivateKey = encodeSuiPrivateKey;
function tryDecodeSuiPrivateKey(value) {
    if (value == undefined || null || value.length == 0) {
        throw new Error('invalid private key prefix');
    }
    if (!value.startsWith(SuiWallet_1.SUI_PRIVATE_KEY_PREFIX)) {
        if (!crypto_lib_1.base.validateHexString(value)) {
            throw new Error('invalid key');
        }
        const keyBytes = crypto_lib_1.base.fromHex(value.toLowerCase());
        if (keyBytes.length !== keypair_1.PRIVATE_KEY_SIZE || keyBytes.every(byte => byte === 0)) {
            throw new Error('invalid key');
        }
        return value;
    }
    const [prefix, words] = crypto_lib_1.base.fromBech32(value);
    if (prefix !== SuiWallet_1.SUI_PRIVATE_KEY_PREFIX) {
        throw new Error('invalid private key prefix');
    }
    if (words[0] != 0x00) {
        throw new Error('invalid private key prefix');
    }
    if (words.length !== keypair_1.PRIVATE_KEY_SIZE + 1) {
        throw new Error('invalid key');
    }
    return crypto_lib_1.base.toHex(words.slice(1), true);
}
exports.tryDecodeSuiPrivateKey = tryDecodeSuiPrivateKey;
//# sourceMappingURL=index.js.map