"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiWallet = exports.SUI_PRIVATE_KEY_PREFIX = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const index_1 = require("./index");
exports.SUI_PRIVATE_KEY_PREFIX = 'suiprivkey';
class SuiWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/784'/0'/0'/${param.index}'`;
    }
    async getRandomPrivateKey() {
        try {
            const privateKeyHex = crypto_lib_1.signUtil.ed25519.ed25519_getRandomPrivateKey(false, "hex");
            return Promise.resolve((0, index_1.encodeSuiPrivateKey)(privateKeyHex));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    async getDerivedPrivateKey(param) {
        try {
            const privateKeyHex = await crypto_lib_1.signUtil.ed25519.ed25519_getDerivedPrivateKey(param.mnemonic, param.hdPath, false, "hex");
            return Promise.resolve((0, index_1.encodeSuiPrivateKey)(privateKeyHex));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    getNewAddress(param) {
        try {
            const address = (0, index_1.getAddressFromPrivate)((0, index_1.tryDecodeSuiPrivateKey)(param.privateKey));
            let data = {
                address: address.address,
                publicKey: address.publicKey
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    async validPrivateKey(param) {
        let isValid = true;
        try {
            (0, index_1.tryDecodeSuiPrivateKey)(param.privateKey);
        }
        catch (e) {
            isValid = false;
        }
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async signCommonMsg(params) {
        const pri = (0, index_1.tryDecodeSuiPrivateKey)(params.privateKey);
        return super.signCommonMsg({ privateKey: params.privateKey, privateKeyHex: pri,
            message: params.message, signType: coin_base_1.SignType.ED25519, chainName: "sui" });
    }
    async signMessage(param) {
        try {
            if (!(param.data instanceof Uint8Array)) {
                return Promise.reject(coin_base_1.SignMsgError);
            }
            const message = param.data;
            const keyPair = index_1.Ed25519Keypair.fromSeed(crypto_lib_1.base.fromHex((0, index_1.tryDecodeSuiPrivateKey)(param.privateKey)));
            const signer = new index_1.RawSigner(keyPair);
            return Promise.resolve(signer.signMessage({ message: message }));
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    signTransaction(param) {
        try {
            const data = param.data;
            const keyPair = index_1.Ed25519Keypair.fromSeed(crypto_lib_1.base.fromHex((0, index_1.tryDecodeSuiPrivateKey)(param.privateKey)));
            const signer = new index_1.RawSigner(keyPair);
            if (data.type == 'raw') {
                const s = data.data;
                const d = crypto_lib_1.base.fromBase64(s);
                const signedTransaction = signer.signTransactionBlock({
                    transactionBlock: d,
                });
                return Promise.resolve(signedTransaction);
            }
            else if (data.type == 'paySUI') {
                const tx = new index_1.TransactionBlock();
                const s = data.data;
                if (s.inputCoins == undefined || s.inputCoins.length == 0) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                tx.setGasPrice(BigInt(s.gasPrice));
                tx.setGasBudget(BigInt(s.gasBudget));
                if (s.epoch) {
                    tx.setExpiration({ Epoch: s.epoch });
                }
                tx.setGasPayment(s.inputCoins);
                return signer.getAddress().then((sender) => {
                    tx.setSender(sender);
                    const coin = tx.splitCoins(tx.gas, [tx.pure(BigInt(s.amount))]);
                    tx.transferObjects([coin], tx.pure(s.recipient));
                    return tx.build().then(transactionBlock => {
                        const signedTransaction = signer.signTransactionBlock({
                            transactionBlock: transactionBlock,
                        });
                        return Promise.resolve(signedTransaction);
                    }).catch(err => Promise.reject(err));
                }).catch(err => Promise.reject(err));
            }
            return Promise.reject(coin_base_1.SignTxError);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    validAddress(param) {
        let isValid;
        try {
            const array = crypto_lib_1.base.fromHex(param.address);
            isValid = (array.length == 32);
        }
        catch (e) {
            isValid = false;
        }
        let data = {
            isValid: isValid,
            address: param.address,
        };
        return Promise.resolve(data);
    }
    async calcTxHash(param) {
        try {
            const hash = index_1.TransactionBlockDataBuilder.getDigestFromBytes(crypto_lib_1.base.fromBase64(param.data));
            return Promise.resolve(hash);
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
}
exports.SuiWallet = SuiWallet;
//# sourceMappingURL=SuiWallet.js.map