"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleWallet = exports.BaseWallet = exports.ecdsaSign = exports.fromSigned = exports.padWithZeroes = exports.toUnsigned = exports.intToHex = exports.makeSignature = exports.secp256k1SignTest = void 0;
const error_1 = require("./error");
const common_1 = require("./common");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const basic_1 = require("./basic");
function secp256k1SignTest(privateKey) {
    const msgHash = crypto_lib_1.base.sha256("secp256k1-test");
    const publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey, false);
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(msgHash), privateKey);
    return crypto_lib_1.signUtil.secp256k1.verify(msgHash, signature, recovery, publicKey);
}
exports.secp256k1SignTest = secp256k1SignTest;
function makeSignature(v, r, s) {
    const rSig = (0, exports.fromSigned)(r);
    const sSig = (0, exports.fromSigned)(s);
    const vSig = v;
    const rStr = padWithZeroes((0, exports.toUnsigned)(rSig).toString('hex'), 64);
    const sStr = padWithZeroes((0, exports.toUnsigned)(sSig).toString('hex'), 64);
    const vStr = crypto_lib_1.base.stripHexPrefix(intToHex(vSig));
    return vStr.concat(rStr, sStr);
}
exports.makeSignature = makeSignature;
function intToHex(i) {
    const hex = i.toString(16);
    return `0x${hex}`;
}
exports.intToHex = intToHex;
const toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
exports.toUnsigned = toUnsigned;
function padWithZeroes(hexString, targetLength) {
    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, '0');
}
exports.padWithZeroes = padWithZeroes;
const fromSigned = function (num) {
    return new crypto_lib_1.BN(num).fromTwos(256);
};
exports.fromSigned = fromSigned;
function ecdsaSign(msgHash, privateKey, chainId) {
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(msgHash, privateKey);
    const r = Buffer.from(signature.slice(0, 32));
    const s = Buffer.from(signature.slice(32, 64));
    if (chainId && !Number.isSafeInteger(chainId)) {
        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
    }
    const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
    return { v, r, s };
}
exports.ecdsaSign = ecdsaSign;
class BaseWallet {
    getRandomPrivateKey() {
        try {
            while (true) {
                const privateKey = crypto_lib_1.base.randomBytes(32);
                if (secp256k1SignTest(privateKey)) {
                    return Promise.resolve(crypto_lib_1.base.toHex(privateKey, true));
                }
            }
        }
        catch (e) {
        }
        return Promise.reject(error_1.GenPrivateKeyError);
    }
    getDerivedPrivateKey(param) {
        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)
            .then((masterSeed) => {
            let childKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath(param.hdPath);
            if (childKey.privateKey) {
                let privateKey = crypto_lib_1.base.toHex(childKey.privateKey);
                return Promise.resolve("0x" + privateKey);
            }
            else {
                return Promise.reject(error_1.GenPrivateKeyError);
            }
        }).catch((e) => {
            return Promise.reject(error_1.GenPrivateKeyError);
        });
    }
    getDerivedPath(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    validPrivateKey(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    signMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    async signCommonMsg(params) {
        if (!params.signType) {
            params.signType = common_1.SignType.Secp256k1;
        }
        let data;
        if (params.message.text) {
            data = params.message.text;
        }
        else {
            let publicKey;
            if (params.publicKey) {
                publicKey = params.publicKey;
            }
            else {
                let addr = await this.getNewAddress({
                    privateKey: params.privateKey,
                    addressType: params.addressType,
                    hrp: params.hrp,
                    version: params.version
                });
                publicKey = addr.publicKey;
            }
            if (params.chainName && params.chainName == "sui") {
                if ((0, common_1.isHexStr)(publicKey)) {
                    if (publicKey.startsWith("0x")) {
                        publicKey = publicKey.substring(2);
                    }
                }
            }
            else {
                if (publicKey.startsWith("0x")) {
                    publicKey = publicKey.substring(2);
                }
            }
            if (!params.message.walletId) {
                return Promise.reject("invalid walletId");
            }
            data = (0, basic_1.buildCommonSignMsg)(publicKey, params.message.walletId);
        }
        let hash = crypto_lib_1.base.magicHash(data);
        const privateKeyStr = params.privateKeyHex ? params.privateKeyHex : params.privateKey;
        const privateKey = crypto_lib_1.base.fromHex(privateKeyStr);
        var sig;
        switch (params.signType) {
            case common_1.SignType.Secp256k1:
                const { v, r, s } = ecdsaSign(Buffer.from(hash), privateKey);
                return Promise.resolve(makeSignature(v, r, s));
            case common_1.SignType.ECDSA_P256:
                sig = crypto_lib_1.signUtil.p256.sign(Buffer.from(hash), privateKey).signature;
                return Promise.resolve(crypto_lib_1.base.toHex(sig));
            case common_1.SignType.ED25519:
                sig = crypto_lib_1.signUtil.ed25519.sign(hash, privateKey);
                return Promise.resolve(crypto_lib_1.base.toHex(sig));
            case common_1.SignType.StarknetSignType:
                sig = crypto_lib_1.signUtil.schnorr.stark.sign(hash, privateKey).toCompactRawBytes();
                return Promise.resolve(crypto_lib_1.base.toHex(sig));
            case common_1.SignType.TezosSignType:
                return Promise.reject("not support");
        }
    }
    verifyMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    ecRecover(message, signature) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getAddressByPublicKey(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCRawMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCSignedMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareSignedTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareMessageHash(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    calcTxHash(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    validSignedTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    estimateFee(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
}
exports.BaseWallet = BaseWallet;
class SimpleWallet extends BaseWallet {
    mockData(mockAddress, mockPublicKey) {
        this.mockAddress = mockAddress;
        this.mockPublicKey = mockPublicKey;
    }
    getNewAddress(param) {
        return Promise.resolve({ address: this.mockAddress, publicKey: this.mockPublicKey });
    }
    validAddress(param) {
        throw new Error("Method not implemented.");
    }
    signTransaction(param) {
        throw new Error("Method not implemented.");
    }
}
exports.SimpleWallet = SimpleWallet;
//# sourceMappingURL=wallet.js.map