"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationLists = exports.AccessLists = void 0;
const ethereumjs_util_1 = require("../ethereumjs-util");
const types_1 = require("./types");
class AccessLists {
    static getAccessListData(accessList) {
        let AccessListJSON;
        let bufferAccessList;
        if (accessList && (0, types_1.isAccessList)(accessList)) {
            AccessListJSON = accessList;
            const newAccessList = [];
            for (let i = 0; i < accessList.length; i++) {
                const item = accessList[i];
                const addressBuffer = (0, ethereumjs_util_1.toBuffer)(item.address);
                const storageItems = [];
                for (let index = 0; index < item.storageKeys.length; index++) {
                    storageItems.push((0, ethereumjs_util_1.toBuffer)(item.storageKeys[index]));
                }
                newAccessList.push([addressBuffer, storageItems]);
            }
            bufferAccessList = newAccessList;
        }
        else {
            bufferAccessList = accessList ?? [];
            const json = [];
            for (let i = 0; i < bufferAccessList.length; i++) {
                const data = bufferAccessList[i];
                const address = (0, ethereumjs_util_1.bufferToHex)(data[0]);
                const storageKeys = [];
                for (let item = 0; item < data[1].length; item++) {
                    storageKeys.push((0, ethereumjs_util_1.bufferToHex)(data[1][item]));
                }
                const jsonItem = {
                    address,
                    storageKeys,
                };
                json.push(jsonItem);
            }
            AccessListJSON = json;
        }
        return {
            AccessListJSON,
            accessList: bufferAccessList,
        };
    }
    static verifyAccessList(accessList) {
        for (let key = 0; key < accessList.length; key++) {
            const accessListItem = accessList[key];
            const address = accessListItem[0];
            const storageSlots = accessListItem[1];
            if (accessListItem[2] !== undefined) {
                throw new Error('Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.');
            }
            if (address.length != 20) {
                throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes');
            }
            for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
                if (storageSlots[storageSlot].length != 32) {
                    throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes');
                }
            }
        }
    }
    static getAccessListJSON(accessList) {
        const accessListJSON = [];
        for (let index = 0; index < accessList.length; index++) {
            const item = accessList[index];
            const JSONItem = {
                address: '0x' + (0, ethereumjs_util_1.setLengthLeft)(item[0], 20).toString('hex'),
                storageKeys: [],
            };
            const storageSlots = item[1];
            for (let slot = 0; slot < storageSlots.length; slot++) {
                const storageSlot = storageSlots[slot];
                JSONItem.storageKeys.push('0x' + (0, ethereumjs_util_1.setLengthLeft)(storageSlot, 32).toString('hex'));
            }
            accessListJSON.push(JSONItem);
        }
        return accessListJSON;
    }
}
exports.AccessLists = AccessLists;
class AuthorizationLists {
    static getAuthorizationListData(authorizationList) {
        let AuthorizationListJSON;
        let bufferAuthorizationList;
        if ((0, types_1.isAuthorizationList)(authorizationList)) {
            AuthorizationListJSON = authorizationList;
            const newAuthorizationList = [];
            const jsonItems = ['chainId', 'address', 'nonce', 'yParity', 'r', 's'];
            for (let i = 0; i < authorizationList.length; i++) {
                const item = authorizationList[i];
                for (const key of jsonItems) {
                    if (item[key] === undefined) {
                        throw new Error(`EIP-7702 authorization list invalid: ${key} is not defined`);
                    }
                }
                const chainId = (0, ethereumjs_util_1.hexToBytes)(item.chainId);
                const addressBytes = (0, ethereumjs_util_1.hexToBytes)(item.address);
                const nonce = (0, ethereumjs_util_1.hexToBytes)(item.nonce);
                const yParity = (0, ethereumjs_util_1.hexToBytes)(item.yParity);
                const r = (0, ethereumjs_util_1.hexToBytes)(item.r);
                const s = (0, ethereumjs_util_1.hexToBytes)(item.s);
                newAuthorizationList.push([chainId, addressBytes, nonce, yParity, r, s]);
            }
            bufferAuthorizationList = newAuthorizationList;
        }
        else {
            bufferAuthorizationList = authorizationList ?? [];
            const json = [];
            for (let i = 0; i < bufferAuthorizationList.length; i++) {
                const data = bufferAuthorizationList[i];
                const chainId = (0, ethereumjs_util_1.bytesToHex)(data[0]);
                const address = (0, ethereumjs_util_1.bytesToHex)(data[1]);
                const nonce = (0, ethereumjs_util_1.bytesToHex)(data[2]);
                const yParity = (0, ethereumjs_util_1.bytesToHex)(data[3]);
                const r = (0, ethereumjs_util_1.bytesToHex)(data[4]);
                const s = (0, ethereumjs_util_1.bytesToHex)(data[5]);
                const jsonItem = {
                    chainId,
                    address,
                    nonce,
                    yParity,
                    r,
                    s,
                };
                json.push(jsonItem);
            }
            AuthorizationListJSON = json;
        }
        return {
            AuthorizationListJSON,
            authorizationList: bufferAuthorizationList,
        };
    }
    static verifyAuthorizationList(authorizationList) {
        if (authorizationList.length === 0) {
            throw new Error('Invalid EIP-7702 transaction: authorization list is empty');
        }
        for (let key = 0; key < authorizationList.length; key++) {
            const authorizationListItem = authorizationList[key];
            const chainId = authorizationListItem[0];
            const address = authorizationListItem[1];
            const nonce = authorizationListItem[2];
            const yParity = authorizationListItem[3];
            const r = authorizationListItem[4];
            const s = authorizationListItem[5];
            (0, ethereumjs_util_1.validateNoLeadingZeroes)({ yParity, r, s, nonce, chainId });
            if (address.length !== 20) {
                throw new Error('Invalid EIP-7702 transaction: address length should be 20 bytes');
            }
            if ((0, ethereumjs_util_1.bytesToBigInt)(chainId) > ethereumjs_util_1.MAX_INTEGER_BI) {
                throw new Error('Invalid EIP-7702 transaction: chainId exceeds 2^256 - 1');
            }
            if ((0, ethereumjs_util_1.bytesToBigInt)(nonce) > ethereumjs_util_1.MAX_UINT64_BI) {
                throw new Error('Invalid EIP-7702 transaction: nonce exceeds 2^64 - 1');
            }
            const yParityBigInt = (0, ethereumjs_util_1.bytesToBigInt)(yParity);
            if (yParityBigInt >= BigInt(2 ** 8)) {
                throw new Error('Invalid EIP-7702 transaction: yParity should be fit within 1 byte (0 - 255)');
            }
            if ((0, ethereumjs_util_1.bytesToBigInt)(r) > ethereumjs_util_1.MAX_INTEGER_BI) {
                throw new Error('Invalid EIP-7702 transaction: r exceeds 2^256 - 1');
            }
            if ((0, ethereumjs_util_1.bytesToBigInt)(s) > ethereumjs_util_1.MAX_INTEGER_BI) {
                throw new Error('Invalid EIP-7702 transaction: s exceeds 2^256 - 1');
            }
        }
    }
}
exports.AuthorizationLists = AuthorizationLists;
//# sourceMappingURL=util.js.map