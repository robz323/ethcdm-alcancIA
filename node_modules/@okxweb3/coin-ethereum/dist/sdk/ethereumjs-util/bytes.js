"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToBigInt = exports.validateNoLeadingZeroes = exports.concatBytes = exports.unpadBytes = exports.bytesToHex = exports.hexToBytes = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.toBuffer = exports.unpadArray = exports.unpadBuffer = exports.stripZeros = exports.setLengthLeft = exports.zeros = exports.bytesToUnprefixedHex = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const crypto_lib_2 = require("@okxweb3/crypto-lib");
const util_1 = require("./util");
const helpers_1 = require("./helpers");
const utils_js_1 = require("ethereum-cryptography/utils.js");
const constants_1 = require("./constants");
exports.bytesToUnprefixedHex = utils_js_1.bytesToHex;
const zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
exports.zeros = zeros;
const setLength = function (msg, length, right) {
    const buf = (0, exports.zeros)(length);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
const setLengthU8A = (msg, length, right) => {
    if (right) {
        if (msg.length < length) {
            return new Uint8Array([...msg, ...new Uint8Array(length - msg.length)]);
        }
        return msg.subarray(0, length);
    }
    else {
        if (msg.length < length) {
            return new Uint8Array([...new Uint8Array(length - msg.length), ...msg]);
        }
        return msg.subarray(-length);
    }
};
const setLengthLeft = function (msg, length) {
    (0, helpers_1.assertIsBuffer)(msg);
    return setLength(msg, length, false);
};
exports.setLengthLeft = setLengthLeft;
const stripZeros = function (a) {
    let first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = stripZeros;
const unpadBuffer = function (a) {
    (0, helpers_1.assertIsBuffer)(a);
    return (0, exports.stripZeros)(a);
};
exports.unpadBuffer = unpadBuffer;
const unpadArray = function (a) {
    (0, helpers_1.assertIsArray)(a);
    return (0, exports.stripZeros)(a);
};
exports.unpadArray = unpadArray;
const toBuffer = function (v) {
    if (v === null || v === undefined) {
        return Buffer.allocUnsafe(0);
    }
    if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
    }
    if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
    }
    if (typeof v === 'string') {
        if (!(0, util_1.isHexString)(v)) {
            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, util_1.padToEven)(crypto_lib_2.base.stripHexPrefix(v)), 'hex');
    }
    if (typeof v === 'number') {
        return (0, util_1.intToBuffer)(v);
    }
    if (crypto_lib_1.BN.isBN(v)) {
        return v.toArrayLike(Buffer);
    }
    if (v.toArray) {
        return Buffer.from(v.toArray());
    }
    if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
    }
    throw new Error('invalid type');
};
exports.toBuffer = toBuffer;
const bufferToHex = function (buf) {
    buf = (0, exports.toBuffer)(buf);
    return '0x' + buf.toString('hex');
};
exports.bufferToHex = bufferToHex;
const fromSigned = function (num) {
    return new crypto_lib_1.BN(num).fromTwos(256);
};
exports.fromSigned = fromSigned;
const toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
exports.toUnsigned = toUnsigned;
const addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return crypto_lib_2.base.isHexPrefixed(str) ? str : '0x' + str;
};
exports.addHexPrefix = addHexPrefix;
const hexToBytes = (hex) => {
    if (!hex.startsWith('0x'))
        throw new Error('input string must be 0x prefixed');
    return (0, utils_js_1.hexToBytes)((0, util_1.padToEven)(crypto_lib_2.base.stripHexPrefix(hex)));
};
exports.hexToBytes = hexToBytes;
const bytesToHex = (bytes) => {
    if (bytes === undefined || bytes.length === 0)
        return '0x';
    const unprefixedHex = (0, exports.bytesToUnprefixedHex)(bytes);
    return ('0x' + unprefixedHex);
};
exports.bytesToHex = bytesToHex;
const unpadBytes = (a) => {
    (0, helpers_1.assertIsBytes)(a);
    return (0, exports.stripZeros)(a);
};
exports.unpadBytes = unpadBytes;
const concatBytes = (...arrays) => {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
};
exports.concatBytes = concatBytes;
const validateNoLeadingZeroes = (values) => {
    for (const [k, v] of Object.entries(values)) {
        if (v !== undefined && v.length > 0 && v[0] === 0) {
            throw new Error(`${k} cannot have leading zeroes, received: ${(0, exports.bytesToHex)(v)}`);
        }
    }
};
exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
const BIGINT_CACHE = [];
for (let i = 0; i <= 256 * 256 - 1; i++) {
    BIGINT_CACHE[i] = BigInt(i);
}
const bytesToBigInt = (bytes, littleEndian = false) => {
    if (littleEndian) {
        bytes.reverse();
    }
    const hex = (0, exports.bytesToHex)(bytes);
    if (hex === '0x') {
        return constants_1.BIGINT_0;
    }
    if (hex.length === 4) {
        return BIGINT_CACHE[bytes[0]];
    }
    if (hex.length === 6) {
        return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];
    }
    return BigInt(hex);
};
exports.bytesToBigInt = bytesToBigInt;
//# sourceMappingURL=bytes.js.map