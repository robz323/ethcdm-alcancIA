// src/alpha-vault/index.ts
import { AnchorProvider, BN as BN3, Program } from "@coral-xyz/anchor";
import { NATIVE_MINT as NATIVE_MINT2, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2 } from "@solana/spl-token";
import {
  SystemProgram as SystemProgram2,
  Transaction as Transaction2
} from "@solana/web3.js";

// src/alpha-vault/constant.ts
import { PublicKey } from "@solana/web3.js";
var PROGRAM_ID = Object.freeze({
  devnet: "vaU6kP7iNEGkbmPkLmZfGwiGxd4Mob24QQCie5R9kd2",
  "mainnet-beta": "vaU6kP7iNEGkbmPkLmZfGwiGxd4Mob24QQCie5R9kd2",
  "localhost": "SNPmGgnywBvvrAKMLundzG6StojyHTHDLu7T4sdhP4k"
});
var SEED = Object.freeze({
  escrow: "escrow",
  vault: "vault",
  merkleRoot: "merkle_root",
  crankFeeWhitelist: "crank_fee_whitelist"
});
var ALPHA_VAULT_TREASURY_ID = new PublicKey(
  "BJQbRiRWhJCyTYZcAuAL3ngDCx3AyFQGKDq8zhiZAKUw"
);
var VAULT_PROGRAM_ID = new PublicKey(
  "24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"
);
var DYNAMIC_AMM_PROGRAM_ID = new PublicKey(
  "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
);
var DLMM_PROGRAM_ID = new PublicKey(
  "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"
);
var MERKLE_PROOF_API = Object.freeze({
  devnet: "https://worker-dev.meteora.ag/merkle-root-config-proof",
  "mainnet-beta": "https://worker.meteora.ag/merkle-root-config-proof"
});
var Permissionless = 0;
var PermissionWithMerkleProof = 1;
var PermissionWithAuthority = 2;

// src/alpha-vault/helper/index.ts
import {
  ComputeBudgetProgram,
  PublicKey as PublicKey2,
  SystemProgram,
  TransactionInstruction
} from "@solana/web3.js";

// src/alpha-vault/type.ts
var VaultMode = /* @__PURE__ */ ((VaultMode2) => {
  VaultMode2[VaultMode2["PRORATA"] = 0] = "PRORATA";
  VaultMode2[VaultMode2["FCFS"] = 1] = "FCFS";
  return VaultMode2;
})(VaultMode || {});
var PoolType = /* @__PURE__ */ ((PoolType2) => {
  PoolType2[PoolType2["DLMM"] = 0] = "DLMM";
  PoolType2[PoolType2["DYNAMIC"] = 1] = "DYNAMIC";
  return PoolType2;
})(PoolType || {});
var ActivationType = /* @__PURE__ */ ((ActivationType2) => {
  ActivationType2[ActivationType2["SLOT"] = 0] = "SLOT";
  ActivationType2[ActivationType2["TIMESTAMP"] = 1] = "TIMESTAMP";
  return ActivationType2;
})(ActivationType || {});

// src/alpha-vault/helper/index.ts
import {
  createAssociatedTokenAccountInstruction,
  createCloseAccountInstruction,
  getAccount,
  getAssociatedTokenAddressSync,
  NATIVE_MINT,
  TOKEN_PROGRAM_ID,
  TokenAccountNotFoundError,
  TokenInvalidAccountOwnerError
} from "@solana/spl-token";
import DynamicAmm from "@mercurial-finance/dynamic-amm-sdk";
import { Transaction } from "@solana/web3.js";
import DLMM, { DlmmSdkError } from "@meteora-ag/dlmm";
import BN from "bn.js";
function deriveCrankFeeWhitelist(cranker, programId) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from(SEED.crankFeeWhitelist),
      cranker.toBuffer()
    ],
    programId
  );
}
function deriveMerkleRootConfig(alphaVault, version, programId) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from(SEED.merkleRoot),
      alphaVault.toBuffer(),
      new Uint8Array(version.toArrayLike(Buffer, "le", 8))
    ],
    programId
  );
}
function deriveEscrow(alphaVault, owner, programId) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from(SEED.escrow), alphaVault.toBuffer(), owner.toBuffer()],
    programId
  );
}
function deriveAlphaVault(base, lbPair, programId) {
  return PublicKey2.findProgramAddressSync(
    [Buffer.from(SEED.vault), base.toBuffer(), lbPair.toBuffer()],
    programId
  );
}
var getOrCreateATAInstruction = async (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true) => {
  const toAccount = getAssociatedTokenAddressSync(
    tokenMint,
    owner,
    allowOwnerOffCurve
  );
  try {
    await getAccount(connection, toAccount);
    return { ataPubKey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof TokenAccountNotFoundError || e instanceof TokenInvalidAccountOwnerError) {
      const ix = createAssociatedTokenAccountInstruction(
        payer,
        toAccount,
        owner,
        tokenMint
      );
      return { ataPubKey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
};
var wrapSOLInstruction = (from, to, amount) => {
  return [
    SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = (owner) => {
  const wSolATAAccount = getAssociatedTokenAddressSync(
    NATIVE_MINT,
    owner,
    true
  );
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      owner,
      owner
    );
    return closedWrappedSolInstruction;
  }
  return null;
};
var fillDlmmTransaction = async (program, vaultKey, vault, payer) => {
  const connection = program.provider.connection;
  const pair = await DLMM.create(connection, vault.pool);
  const [crankFeeWhitelist] = deriveCrankFeeWhitelist(payer, program.programId);
  const crankFeeWhitelistAccount = await connection.getAccountInfo(crankFeeWhitelist);
  const preInstructions = [
    ComputeBudgetProgram.setComputeUnitLimit({
      units: 14e5
    })
  ];
  const { ataPubKey: tokenOutVault, ix: createTokenOutVaultIx } = await getOrCreateATAInstruction(
    connection,
    vault.baseMint,
    vaultKey,
    payer
  );
  createTokenOutVaultIx && preInstructions.push(createTokenOutVaultIx);
  const inAmountCap = vault.vaultMode == 1 /* FCFS */ ? vault.totalDeposit : vault.totalDeposit.lt(vault.maxBuyingCap) ? vault.totalDeposit : vault.maxBuyingCap;
  const remainingInAmount = inAmountCap.sub(vault.swappedAmount);
  const swapForY = pair.lbPair.tokenXMint.equals(vault.quoteMint);
  const binArrays = await pair.getBinArrayForSwap(swapForY, 3);
  let quoteResult;
  try {
    quoteResult = pair.swapQuote(
      remainingInAmount,
      swapForY,
      new BN(0),
      binArrays,
      true
    );
  } catch (error) {
    if (error instanceof DlmmSdkError) {
      if (error.name == "SWAP_QUOTE_INSUFFICIENT_LIQUIDITY") {
        return null;
      }
    }
    throw error;
  }
  const { consumedInAmount, binArraysPubkey } = quoteResult;
  const [dlmmEventAuthority] = PublicKey2.findProgramAddressSync(
    [Buffer.from("__event_authority")],
    DLMM_PROGRAM_ID
  );
  const fillDlmmTransaction2 = await program.methods.fillDlmm(consumedInAmount).accounts({
    vault: vaultKey,
    tokenVault: vault.tokenVault,
    tokenOutVault,
    ammProgram: DLMM_PROGRAM_ID,
    pool: vault.pool,
    binArrayBitmapExtension: pair.binArrayBitmapExtension ? pair.binArrayBitmapExtension.publicKey : pair.program.programId,
    reserveX: pair.lbPair.reserveX,
    reserveY: pair.lbPair.reserveY,
    tokenXMint: pair.lbPair.tokenXMint,
    tokenYMint: pair.lbPair.tokenYMint,
    oracle: pair.lbPair.oracle,
    tokenXProgram: TOKEN_PROGRAM_ID,
    tokenYProgram: TOKEN_PROGRAM_ID,
    dlmmEventAuthority,
    cranker: payer,
    crankFeeReceiver: crankFeeWhitelistAccount ? program.programId : ALPHA_VAULT_TREASURY_ID,
    crankFeeWhitelist: crankFeeWhitelistAccount ? crankFeeWhitelist : program.programId,
    systemProgram: SystemProgram.programId
  }).preInstructions(preInstructions).remainingAccounts(
    binArraysPubkey.map((x) => ({
      pubkey: x,
      isSigner: false,
      isWritable: true
    }))
  ).transaction();
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
  return new Transaction({
    blockhash,
    lastValidBlockHeight,
    feePayer: payer
  }).add(fillDlmmTransaction2);
};
var fillDynamicAmmTransaction = async (program, vaultKey, vault, payer) => {
  const connection = program.provider.connection;
  const pool = await DynamicAmm.create(connection, vault.pool);
  const [crankFeeWhitelist] = deriveCrankFeeWhitelist(payer, program.programId);
  const crankFeeWhitelistAccount = await connection.getAccountInfo(crankFeeWhitelist);
  const preInstructions = [];
  const { ataPubKey: tokenOutVault, ix: createTokenOutVaultIx } = await getOrCreateATAInstruction(
    connection,
    vault.baseMint,
    vaultKey,
    payer
  );
  createTokenOutVaultIx && preInstructions.push(createTokenOutVaultIx);
  const adminTokenFee = vault.quoteMint.equals(pool.poolState.tokenBMint) ? pool.poolState.protocolTokenBFee : pool.poolState.protocolTokenAFee;
  const fillAmmTransaction = await program.methods.fillDynamicAmm(vault.maxBuyingCap).accounts({
    vault: vaultKey,
    tokenVault: vault.tokenVault,
    tokenOutVault,
    ammProgram: DYNAMIC_AMM_PROGRAM_ID,
    pool: vault.pool,
    aVault: pool.vaultA.vaultPda,
    bVault: pool.vaultB.vaultPda,
    aTokenVault: pool.vaultA.tokenVaultPda,
    bTokenVault: pool.vaultB.tokenVaultPda,
    aVaultLp: pool.poolState.aVaultLp,
    bVaultLp: pool.poolState.bVaultLp,
    aVaultLpMint: pool.vaultA.tokenLpMint.address,
    bVaultLpMint: pool.vaultB.tokenLpMint.address,
    adminTokenFee,
    vaultProgram: VAULT_PROGRAM_ID,
    tokenProgram: TOKEN_PROGRAM_ID,
    cranker: payer,
    crankFeeReceiver: crankFeeWhitelistAccount ? program.programId : ALPHA_VAULT_TREASURY_ID,
    crankFeeWhitelist: crankFeeWhitelistAccount ? crankFeeWhitelist : program.programId,
    systemProgram: SystemProgram.programId
  }).preInstructions(preInstructions).transaction();
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
  return new Transaction({
    blockhash,
    lastValidBlockHeight,
    feePayer: payer
  }).add(fillAmmTransaction);
};

// src/alpha-vault/idl.ts
var IDL = {
  "version": "0.3.2",
  "name": "alpha_vault",
  "instructions": [
    {
      "name": "transferVaultAuthority",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultAuthority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "newAuthority",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "initializeProrataVault",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "InitializeProrataVaultParams"
          }
        }
      ]
    },
    {
      "name": "initializeVaultWithProrataConfig",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "quoteMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "InitializeVaultWithConfigParams"
          }
        }
      ]
    },
    {
      "name": "updateProrataVaultParameters",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "UpdateProrataVaultParams"
          }
        }
      ]
    },
    {
      "name": "createProrataConfig",
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "configParameters",
          "type": {
            "defined": "ProrataConfigParameters"
          }
        }
      ]
    },
    {
      "name": "closeProrataConfig",
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "initializeFcfsVault",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "InitializeFcfsVaultParams"
          }
        }
      ]
    },
    {
      "name": "initializeVaultWithFcfsConfig",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "quoteMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "InitializeVaultWithConfigParams"
          }
        }
      ]
    },
    {
      "name": "updateFcfsVaultParameters",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "UpdateFcfsVaultParams"
          }
        }
      ]
    },
    {
      "name": "createFcfsConfig",
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "configParameters",
          "type": {
            "defined": "FcfsConfigParameters"
          }
        }
      ]
    },
    {
      "name": "closeFcfsConfig",
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "createMerkleRootConfig",
      "accounts": [
        {
          "name": "vault",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "merkleRootConfig",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "CreateMerkleRootConfigParams"
          }
        }
      ]
    },
    {
      "name": "createNewEscrow",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "escrowFeeReceiver",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "createPermissionedEscrow",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "merkleRootConfig",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "merkle_root_config"
          ]
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "escrowFeeReceiver",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxCap",
          "type": "u64"
        },
        {
          "name": "proof",
          "type": {
            "vec": {
              "array": [
                "u8",
                32
              ]
            }
          }
        }
      ]
    },
    {
      "name": "createPermissionedEscrowWithAuthority",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxCap",
          "type": "u64"
        }
      ]
    },
    {
      "name": "closeEscrow",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "deposit",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sourceToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdraw",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "destinationToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdrawRemainingQuote",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "destinationToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "claimToken",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "escrow",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenOutVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "destinationToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "fillDlmm",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenOutVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "dlmmEventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "crankFeeWhitelist",
          "isMut": false,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "crankFeeReceiver",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "cranker",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "fillDynamicAmm",
      "accounts": [
        {
          "name": "vault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenOutVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ammProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "pool",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bTokenVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLpMint",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "aVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "bVaultLp",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "adminTokenFee",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "vaultProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "crankFeeWhitelist",
          "isMut": false,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "crankFeeReceiver",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "cranker",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "maxAmount",
          "type": "u64"
        }
      ]
    },
    {
      "name": "createCrankFeeWhitelist",
      "accounts": [
        {
          "name": "crankFeeWhitelist",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "cranker",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "closeCrankFeeWhitelist",
      "accounts": [
        {
          "name": "crankFeeWhitelist",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "crankFeeWhitelist",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "owner",
            "type": "publicKey"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u128",
                5
              ]
            }
          }
        ]
      }
    },
    {
      "name": "escrow",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "vault",
            "docs": [
              "vault address"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "owner"
            ],
            "type": "publicKey"
          },
          {
            "name": "totalDeposit",
            "docs": [
              "total deposited quote token"
            ],
            "type": "u64"
          },
          {
            "name": "claimedToken",
            "docs": [
              "Total token that escrow has claimed"
            ],
            "type": "u64"
          },
          {
            "name": "lastClaimedPoint",
            "docs": [
              "Last claimed timestamp"
            ],
            "type": "u64"
          },
          {
            "name": "refunded",
            "docs": [
              "Whether owner has claimed for remaining quote token"
            ],
            "type": "u8"
          },
          {
            "name": "padding1",
            "docs": [
              "padding 1"
            ],
            "type": {
              "array": [
                "u8",
                7
              ]
            }
          },
          {
            "name": "maxCap",
            "docs": [
              "Only has meaning in permissioned vault"
            ],
            "type": "u64"
          },
          {
            "name": "padding2",
            "docs": [
              "padding 2"
            ],
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u128",
                1
              ]
            }
          }
        ]
      }
    },
    {
      "name": "merkleRootConfig",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "root",
            "docs": [
              "The 256-bit merkle root."
            ],
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "vault",
            "docs": [
              "vault pubkey that config is belong"
            ],
            "type": "publicKey"
          },
          {
            "name": "version",
            "docs": [
              "version"
            ],
            "type": "u64"
          },
          {
            "name": "padding",
            "docs": [
              "padding for further use"
            ],
            "type": {
              "array": [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      "name": "prorataVaultConfig",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxBuyingCap",
            "type": "u64"
          },
          {
            "name": "startVestingDuration",
            "type": "u64"
          },
          {
            "name": "endVestingDuration",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "activationType",
            "type": "u8"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u8",
                191
              ]
            }
          }
        ]
      }
    },
    {
      "name": "fcfsVaultConfig",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxDepositingCap",
            "type": "u64"
          },
          {
            "name": "startVestingDuration",
            "type": "u64"
          },
          {
            "name": "endVestingDuration",
            "type": "u64"
          },
          {
            "name": "depositingDurationUntilLastJoinPoint",
            "type": "u64"
          },
          {
            "name": "individualDepositingCap",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "activationType",
            "type": "u8"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u8",
                175
              ]
            }
          }
        ]
      }
    },
    {
      "name": "vault",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "pool",
            "docs": [
              "pool"
            ],
            "type": "publicKey"
          },
          {
            "name": "tokenVault",
            "docs": [
              "reserve quote token"
            ],
            "type": "publicKey"
          },
          {
            "name": "tokenOutVault",
            "docs": [
              "reserve base token"
            ],
            "type": "publicKey"
          },
          {
            "name": "quoteMint",
            "docs": [
              "quote token"
            ],
            "type": "publicKey"
          },
          {
            "name": "baseMint",
            "docs": [
              "base token"
            ],
            "type": "publicKey"
          },
          {
            "name": "base",
            "docs": [
              "base key"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "owner key, deprecated field, can re-use in the future"
            ],
            "type": "publicKey"
          },
          {
            "name": "maxBuyingCap",
            "docs": [
              "max buying cap"
            ],
            "type": "u64"
          },
          {
            "name": "totalDeposit",
            "docs": [
              "total deposited quote token"
            ],
            "type": "u64"
          },
          {
            "name": "totalEscrow",
            "docs": [
              "total user deposit"
            ],
            "type": "u64"
          },
          {
            "name": "swappedAmount",
            "docs": [
              "swapped_amount"
            ],
            "type": "u64"
          },
          {
            "name": "boughtToken",
            "docs": [
              "total bought token"
            ],
            "type": "u64"
          },
          {
            "name": "totalRefund",
            "docs": [
              "Total quote refund"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedToken",
            "docs": [
              "Total claimed_token"
            ],
            "type": "u64"
          },
          {
            "name": "startVestingPoint",
            "docs": [
              "Start vesting ts"
            ],
            "type": "u64"
          },
          {
            "name": "endVestingPoint",
            "docs": [
              "End vesting ts"
            ],
            "type": "u64"
          },
          {
            "name": "bump",
            "docs": [
              "bump"
            ],
            "type": "u8"
          },
          {
            "name": "poolType",
            "docs": [
              "pool type"
            ],
            "type": "u8"
          },
          {
            "name": "vaultMode",
            "docs": [
              "vault mode"
            ],
            "type": "u8"
          },
          {
            "name": "padding0",
            "docs": [
              "padding 0"
            ],
            "type": {
              "array": [
                "u8",
                5
              ]
            }
          },
          {
            "name": "maxDepositingCap",
            "docs": [
              "max depositing cap"
            ],
            "type": "u64"
          },
          {
            "name": "individualDepositingCap",
            "docs": [
              "individual depositing cap"
            ],
            "type": "u64"
          },
          {
            "name": "depositingPoint",
            "docs": [
              "depositing point"
            ],
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "docs": [
              "flat fee when user open an escrow"
            ],
            "type": "u64"
          },
          {
            "name": "totalEscrowFee",
            "docs": [
              "total escrow fee just for statistic"
            ],
            "type": "u64"
          },
          {
            "name": "whitelistMode",
            "docs": [
              "deposit whitelist mode"
            ],
            "type": "u8"
          },
          {
            "name": "activationType",
            "docs": [
              "activation type"
            ],
            "type": "u8"
          },
          {
            "name": "padding1",
            "docs": [
              "padding 1"
            ],
            "type": {
              "array": [
                "u8",
                6
              ]
            }
          },
          {
            "name": "vaultAuthority",
            "docs": [
              "vault authority normally is vault creator, will be able to create merkle root config"
            ],
            "type": "publicKey"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u128",
                5
              ]
            }
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "CreateMerkleRootConfigParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "root",
            "docs": [
              "The 256-bit merkle root."
            ],
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "version",
            "docs": [
              "version"
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "FcfsConfigParameters",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxDepositingCap",
            "type": "u64"
          },
          {
            "name": "startVestingDuration",
            "type": "u64"
          },
          {
            "name": "endVestingDuration",
            "type": "u64"
          },
          {
            "name": "depositingDurationUntilLastJoinPoint",
            "type": "u64"
          },
          {
            "name": "individualDepositingCap",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "activationType",
            "type": "u8"
          },
          {
            "name": "index",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "InitializeFcfsVaultParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "poolType",
            "type": "u8"
          },
          {
            "name": "quoteMint",
            "type": "publicKey"
          },
          {
            "name": "baseMint",
            "type": "publicKey"
          },
          {
            "name": "depositingPoint",
            "type": "u64"
          },
          {
            "name": "startVestingPoint",
            "type": "u64"
          },
          {
            "name": "endVestingPoint",
            "type": "u64"
          },
          {
            "name": "maxDepositingCap",
            "type": "u64"
          },
          {
            "name": "individualDepositingCap",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "whitelistMode",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "UpdateFcfsVaultParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxDepositingCap",
            "type": "u64"
          },
          {
            "name": "depositingPoint",
            "type": "u64"
          },
          {
            "name": "individualDepositingCap",
            "type": "u64"
          },
          {
            "name": "startVestingPoint",
            "type": "u64"
          },
          {
            "name": "endVestingPoint",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "ProrataConfigParameters",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxBuyingCap",
            "type": "u64"
          },
          {
            "name": "startVestingDuration",
            "type": "u64"
          },
          {
            "name": "endVestingDuration",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "activationType",
            "type": "u8"
          },
          {
            "name": "index",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "InitializeProrataVaultParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "poolType",
            "type": "u8"
          },
          {
            "name": "quoteMint",
            "type": "publicKey"
          },
          {
            "name": "baseMint",
            "type": "publicKey"
          },
          {
            "name": "depositingPoint",
            "type": "u64"
          },
          {
            "name": "startVestingPoint",
            "type": "u64"
          },
          {
            "name": "endVestingPoint",
            "type": "u64"
          },
          {
            "name": "maxBuyingCap",
            "type": "u64"
          },
          {
            "name": "escrowFee",
            "type": "u64"
          },
          {
            "name": "whitelistMode",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "InitializeVaultWithConfigParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "poolType",
            "type": "u8"
          },
          {
            "name": "quoteMint",
            "type": "publicKey"
          },
          {
            "name": "baseMint",
            "type": "publicKey"
          },
          {
            "name": "whitelistMode",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "UpdateProrataVaultParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "maxBuyingCap",
            "type": "u64"
          },
          {
            "name": "startVestingPoint",
            "type": "u64"
          },
          {
            "name": "endVestingPoint",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "ActivationType",
      "docs": [
        "Type of the activation"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Slot"
          },
          {
            "name": "Timestamp"
          }
        ]
      }
    },
    {
      "name": "PoolType",
      "docs": [
        "Type of the Pair. 0 = Permissionless, 1 = Permission. Putting 0 as permissionless for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Dlmm"
          },
          {
            "name": "DynamicPool"
          }
        ]
      }
    },
    {
      "name": "VaultMode",
      "docs": [
        "Vault Mode. 0 = Prorata, 1 = FirstComeFirstServe. Putting 0 as Prorata for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Prorata"
          },
          {
            "name": "Fcfs"
          }
        ]
      }
    },
    {
      "name": "WhitelistMode",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Permissionless"
          },
          {
            "name": "PermissionWithMerkleProof"
          },
          {
            "name": "PermissionWithAuthority"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "ProrataVaultCreated",
      "fields": [
        {
          "name": "baseMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "quoteMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "startVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "endVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "maxBuyingCap",
          "type": "u64",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "poolType",
          "type": "u8",
          "index": false
        },
        {
          "name": "escrowFee",
          "type": "u64",
          "index": false
        },
        {
          "name": "activationType",
          "type": "u8",
          "index": false
        }
      ]
    },
    {
      "name": "FcfsVaultCreated",
      "fields": [
        {
          "name": "baseMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "quoteMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "startVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "endVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "maxDepositingCap",
          "type": "u64",
          "index": false
        },
        {
          "name": "pool",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "poolType",
          "type": "u8",
          "index": false
        },
        {
          "name": "depositingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "individualDepositingCap",
          "type": "u64",
          "index": false
        },
        {
          "name": "escrowFee",
          "type": "u64",
          "index": false
        },
        {
          "name": "activationType",
          "type": "u8",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowCreated",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vaultTotalEscrow",
          "type": "u64",
          "index": false
        },
        {
          "name": "escrowFee",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "MerkleRootConfigCreated",
      "fields": [
        {
          "name": "admin",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "config",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "version",
          "type": "u64",
          "index": false
        },
        {
          "name": "root",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        }
      ]
    },
    {
      "name": "ProrataVaultParametersUpdated",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "maxBuyingCap",
          "type": "u64",
          "index": false
        },
        {
          "name": "startVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "endVestingPoint",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "FcfsVaultParametersUpdated",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "maxDepositingCap",
          "type": "u64",
          "index": false
        },
        {
          "name": "startVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "endVestingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "depositingPoint",
          "type": "u64",
          "index": false
        },
        {
          "name": "individualDepositingCap",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowRemainingWithdraw",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "vaultRemainingDeposit",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowWithdraw",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "vaultTotalDeposit",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "SwapFill",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "pair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "fillAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "purchasedAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "unfilledAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowDeposit",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "vaultTotalDeposit",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowClosed",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "vaultTotalEscrow",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "EscrowClaimToken",
      "fields": [
        {
          "name": "vault",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "escrow",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        },
        {
          "name": "vaultTotalClaimedToken",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "CrankFeeWhitelistCreated",
      "fields": [
        {
          "name": "cranker",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "CrankFeeWhitelistClosed",
      "fields": [
        {
          "name": "cranker",
          "type": "publicKey",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "TimePointNotInFuture",
      "msg": "Time point is not in future"
    },
    {
      "code": 6001,
      "name": "IncorrectTokenMint",
      "msg": "Token mint is incorrect"
    },
    {
      "code": 6002,
      "name": "IncorrectPairType",
      "msg": "Pair is not permissioned"
    },
    {
      "code": 6003,
      "name": "PoolHasStarted",
      "msg": "Pool has started"
    },
    {
      "code": 6004,
      "name": "NotPermitThisActionInThisTimePoint",
      "msg": "This action is not permitted in this time point"
    },
    {
      "code": 6005,
      "name": "TheSaleIsOngoing",
      "msg": "The sale is on going, cannot withdraw"
    },
    {
      "code": 6006,
      "name": "EscrowIsNotClosable",
      "msg": "Escrow is not closable"
    },
    {
      "code": 6007,
      "name": "TimePointOrdersAreIncorrect",
      "msg": "Time point orders are incorrect"
    },
    {
      "code": 6008,
      "name": "EscrowHasRefuned",
      "msg": "Escrow has refunded"
    },
    {
      "code": 6009,
      "name": "MathOverflow",
      "msg": "Math operation overflow"
    },
    {
      "code": 6010,
      "name": "MaxBuyingCapIsZero",
      "msg": "Max buying cap is zero"
    },
    {
      "code": 6011,
      "name": "MaxAmountIsTooSmall",
      "msg": "Max amount is too small"
    },
    {
      "code": 6012,
      "name": "PoolTypeIsNotSupported",
      "msg": "Pool type is not supported"
    },
    {
      "code": 6013,
      "name": "InvalidAdmin",
      "msg": "Invalid admin"
    },
    {
      "code": 6014,
      "name": "VaultModeIsIncorrect",
      "msg": "Vault mode is incorrect"
    },
    {
      "code": 6015,
      "name": "MaxDepositingCapIsInValid",
      "msg": "Max depositing cap is invalid"
    },
    {
      "code": 6016,
      "name": "VestingDurationIsInValid",
      "msg": "Vesting duration is invalid"
    },
    {
      "code": 6017,
      "name": "DepositAmountIsZero",
      "msg": "Deposit amount is zero"
    },
    {
      "code": 6018,
      "name": "PoolOwnerIsMismatched",
      "msg": "Pool owner is mismatched"
    },
    {
      "code": 6019,
      "name": "RefundAmountIsZero",
      "msg": "Refund amount is zero"
    },
    {
      "code": 6020,
      "name": "DepositingDurationIsInvalid",
      "msg": "Depositing duration is invalid"
    },
    {
      "code": 6021,
      "name": "DepositingTimePointIsInvalid",
      "msg": "Depositing time point is invalid"
    },
    {
      "code": 6022,
      "name": "IndividualDepositingCapIsZero",
      "msg": "Individual depositing cap is zero"
    },
    {
      "code": 6023,
      "name": "InvalidFeeReceiverAccount",
      "msg": "Invalid fee receiver account"
    },
    {
      "code": 6024,
      "name": "NotPermissionedVault",
      "msg": "Not permissioned vault"
    },
    {
      "code": 6025,
      "name": "NotPermitToDoThisAction",
      "msg": "Not permit to do this action"
    },
    {
      "code": 6026,
      "name": "InvalidProof",
      "msg": "Invalid Merkle proof"
    },
    {
      "code": 6027,
      "name": "InvalidActivationType",
      "msg": "Invalid activation type"
    },
    {
      "code": 6028,
      "name": "ActivationTypeIsMismatched",
      "msg": "Activation type is mismatched"
    },
    {
      "code": 6029,
      "name": "InvalidPool",
      "msg": "Pool is not connected to the alpha vault"
    },
    {
      "code": 6030,
      "name": "InvalidCreator",
      "msg": "Invalid creator"
    },
    {
      "code": 6031,
      "name": "PermissionedVaultCannotChargeEscrowFee",
      "msg": "Permissioned vault cannot charge escrow fee"
    },
    {
      "code": 6032,
      "name": "EscrowFeeTooHigh",
      "msg": "Escrow fee too high"
    },
    {
      "code": 6033,
      "name": "LockDurationInvalid",
      "msg": "Lock duration is invalid"
    },
    {
      "code": 6034,
      "name": "MaxBuyingCapIsTooSmall",
      "msg": "Max buying cap is too small"
    },
    {
      "code": 6035,
      "name": "MaxDepositingCapIsTooSmall",
      "msg": "Max depositing cap is too small"
    },
    {
      "code": 6036,
      "name": "InvalidWhitelistWalletMode",
      "msg": "Invalid whitelist wallet mode"
    },
    {
      "code": 6037,
      "name": "InvalidCrankFeeWhitelist",
      "msg": "Invalid crank fee whitelist"
    },
    {
      "code": 6038,
      "name": "MissingFeeReceiver",
      "msg": "Missing fee receiver"
    }
  ]
};

// src/alpha-vault/merkle_tree/balance-tree.ts
import { BN as BN2 } from "@coral-xyz/anchor";
import { sha256 as sha2562 } from "js-sha256";

// src/alpha-vault/merkle_tree/merkle-tree.ts
import { sha256 } from "js-sha256";
import invariant from "tiny-invariant";

// src/alpha-vault/index.ts
var AlphaVault = class {
  constructor(program, pubkey, vault, mode) {
    this.program = program;
    this.pubkey = pubkey;
    this.vault = vault;
    this.mode = mode;
  }
  /**
   * Creates an AlphaVault instance from a given vault address.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {PublicKey} vaultAddress - The address of the vault to create an instance for.
   * @param {Opt} [opt] - Optional configuration options.
   * @return {Promise<AlphaVault>} A promise resolving to the created AlphaVault instance.
   */
  static async create(connection, vaultAddress, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    const vault = await program.account.vault.fetch(vaultAddress);
    const vaultMode = vault.vaultMode === 0 ? 0 /* PRORATA */ : 1 /* FCFS */;
    return new AlphaVault(program, vaultAddress, vault, vaultMode);
  }
  /**
   * Creates a customizable FCFS vault
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {CustomizableFcfsVaultParams} vaultParam - The parameters for creating the vault.
   * @param {PublicKey} owner - The owner of the vault.
   * @param {Opt} [opt] - Optional configuration options.
   * @return {Promise<Transaction>} The transaction for creating the vault.
   */
  static async createCustomizableFcfsVault(connection, vaultParam, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    const {
      poolAddress,
      poolType,
      baseMint,
      quoteMint,
      depositingPoint,
      startVestingPoint,
      endVestingPoint,
      maxDepositingCap,
      individualDepositingCap,
      escrowFee,
      whitelistMode
    } = vaultParam;
    const [alphaVault] = deriveAlphaVault(
      owner,
      poolAddress,
      program.programId
    );
    const createTx = await program.methods.initializeFcfsVault({
      poolType,
      baseMint,
      quoteMint,
      depositingPoint,
      startVestingPoint,
      endVestingPoint,
      maxDepositingCap,
      individualDepositingCap,
      escrowFee,
      whitelistMode
    }).accounts({
      base: owner,
      vault: alphaVault,
      pool: poolAddress,
      funder: owner,
      program: program.programId,
      systemProgram: SystemProgram2.programId
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(createTx);
  }
  /**
   * Creates a customizable Prorata vault.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {CustomizableProrataVaultParams} vaultParam - The parameters for creating the vault.
   * @param {PublicKey} owner - The owner of the vault.
   * @param {Opt} [opt] - Optional configuration options.
   * @return {Promise<Transaction>} The transaction for creating the vault.
   */
  static async createCustomizableProrataVault(connection, vaultParam, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    const {
      poolAddress,
      poolType,
      baseMint,
      quoteMint,
      depositingPoint,
      startVestingPoint,
      endVestingPoint,
      maxBuyingCap,
      escrowFee,
      whitelistMode
    } = vaultParam;
    const [alphaVault] = deriveAlphaVault(
      owner,
      poolAddress,
      program.programId
    );
    const createTx = await program.methods.initializeProrataVault({
      poolType,
      baseMint,
      quoteMint,
      depositingPoint,
      startVestingPoint,
      endVestingPoint,
      maxBuyingCap,
      escrowFee,
      whitelistMode
    }).accounts({
      base: owner,
      vault: alphaVault,
      pool: poolAddress,
      funder: owner,
      program: program.programId,
      systemProgram: SystemProgram2.programId
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(createTx);
  }
  /**
   * Creates a permissionless vault for dynamic amm / dlmm pool.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {VaultParam} params - The vault parameters.
   * @param {PublicKey} owner - The public key of the vault owner.
   * @param {Opt} [opt] - Optional parameters.
   * @return {Promise<Transaction>} The transaction creating the vault.
   */
  static async createPermissionlessVault(connection, vaultParam, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return AlphaVault.createVault(program, vaultParam, owner, Permissionless);
  }
  /**
   * Creates a permissioned vault for dynamic amm / dlmm pool. Vault created with this function will require merkle proof to be passed along when create stake escrow.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {VaultParam} params - The vault parameters.
   * @param {PublicKey} owner - The public key of the vault owner.
   * @param {Opt} [opt] - Optional parameters.
   * @return {Promise<Transaction>} The transaction creating the vault.
   */
  static async createPermissionedVaultWithMerkleProof(connection, vaultParam, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return AlphaVault.createVault(
      program,
      vaultParam,
      owner,
      PermissionWithMerkleProof
    );
  }
  /**
   * Creates a permissioned vault for dynamic amm / dlmm pool. Vault created with this function will require vault creator to create stake escrow for each users.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {VaultParam} params - The vault parameters.
   * @param {PublicKey} owner - The public key of the vault owner.
   * @param {Opt} [opt] - Optional parameters.
   * @return {Promise<Transaction>} The transaction creating the vault.
   */
  static async createPermissionedVaultWithAuthorityFund(connection, vaultParam, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return AlphaVault.createVault(
      program,
      vaultParam,
      owner,
      PermissionWithAuthority
    );
  }
  /**
   * Retrieves a list of all FCFS vault configurations.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {Opt} [opt] - Optional parameters (e.g., cluster).
   * @return {Promise<fcfsVaultConfig[]>} A promise containing a list of FCFS vault configurations.
   */
  static async getFcfsConfigs(connection, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return program.account.fcfsVaultConfig.all();
  }
  /**
   * Retrieves a list of all prorata vault configurations.
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {Opt} [opt] - Optional configuration options.
   * @return {Promise<prorataVaultConfig[]>} A promise containing a list of prorata vault configurations.
   */
  static async getProrataConfigs(connection, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return program.account.prorataVaultConfig.all();
  }
  /**
   * Refreshes the state of the Alpha Vault by fetching the latest vault data.
   *
   * @return {void} No return value, updates the internal state of the Alpha Vault.
   */
  async refreshState() {
    this.vault = await this.program.account.vault.fetch(this.pubkey);
  }
  /**
   * Retrieves the escrow account associated with the given owner.
   *
   * @param {PublicKey} owner - The public key of the owner.
   * @return {Promise<Escrow | null>} A promise containing the escrow account, or null if not found.
   */
  async getEscrow(owner) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const escrowAccount = await this.program.account.escrow.fetchNullable(escrow);
    return escrowAccount;
  }
  /**
   * Creates a stake escrow account by vault authority. Only applicable with PermissionWithAuthority whitelist mode
   *
   * @param {BN} maxAmount - The maximum amount for the escrow.
   * @param {PublicKey} owner - The public key of the owner.
   * @param {PublicKey} vaultAuthority - The public key of the vault authority.
   * @return {Promise<Transaction>} A promise that resolves to the transaction for creating a stake escrow.
   */
  async createStakeEscrowByAuthority(maxAmount, owner, vaultAuthority) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const createStakeEscrowIx = await this.program.methods.createPermissionedEscrowWithAuthority(maxAmount).accounts({
      vault: this.pubkey,
      pool: this.vault.pool,
      escrow,
      owner,
      payer: vaultAuthority
    }).instruction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: vaultAuthority
    }).add(createStakeEscrowIx);
  }
  /**
   * Creates a stake escrow account by vault authority. Only applicable with PermissionWithAuthority whitelist mode
   *
   * @param {BN} maxAmount - The maximum amount for the escrow.
   * @param {PublicKey[]} owners - The public key of the owners.
   * @param {PublicKey} vaultAuthority - The public key of the vault authority.
   * @return {Promise<Transaction>} A promise that resolves to the transaction for creating a stake escrow.
   */
  async createMultipleStakeEscrowByAuthorityInstructions(walletDepositCap, vaultAuthority) {
    return Promise.all(
      walletDepositCap.map((individualCap) => {
        const owner = individualCap.address;
        const maxAmount = individualCap.maxAmount;
        const [escrow] = deriveEscrow(
          this.pubkey,
          owner,
          this.program.programId
        );
        return this.program.methods.createPermissionedEscrowWithAuthority(maxAmount).accounts({
          vault: this.pubkey,
          pool: this.vault.pool,
          escrow,
          owner,
          payer: vaultAuthority
        }).instruction();
      })
    );
  }
  /**
   * Deposits a specified amount of tokens into the vault.
   *
   * @param {BN} maxAmount - The maximum amount of tokens to deposit.
   * @param {PublicKey} owner - The public key of the owner's wallet.
   * @param {DepositWithProofParams} [depositProof] - The deposit proof parameters. Required for permisisoned vault.
   * @return {Promise<Transaction>} A promise that resolves to the deposit transaction.
   */
  async deposit(maxAmount, owner, depositProof) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const escrowAccount = await this.program.account.escrow.fetchNullable(escrow);
    const preInstructions = [];
    if (!escrowAccount) {
      if (this.vault.whitelistMode === PermissionWithMerkleProof) {
        const { merkleRootConfig, maxCap, proof } = depositProof;
        const createEscrowTx = await this.program.methods.createPermissionedEscrow(maxCap, proof).accounts({
          merkleRootConfig,
          vault: this.pubkey,
          pool: this.vault.pool,
          escrow,
          owner,
          payer: owner,
          systemProgram: SystemProgram2.programId,
          escrowFeeReceiver: ALPHA_VAULT_TREASURY_ID
        }).instruction();
        preInstructions.push(createEscrowTx);
      } else if (this.vault.whitelistMode === Permissionless) {
        const createEscrowTx = await this.program.methods.createNewEscrow().accounts({
          vault: this.pubkey,
          escrow,
          owner,
          payer: owner,
          systemProgram: SystemProgram2.programId,
          pool: this.vault.pool,
          escrowFeeReceiver: ALPHA_VAULT_TREASURY_ID
        }).instruction();
        preInstructions.push(createEscrowTx);
      }
    }
    const [
      { ataPubKey: sourceToken, ix: createSourceTokenIx },
      { ix: createBaseTokenIx },
      { ix: createTokenVaultIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.vault.quoteMint,
        owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.vault.baseMint,
        owner
      ),
      getOrCreateATAInstruction(
        this.program.provider.connection,
        this.vault.quoteMint,
        this.pubkey,
        owner
      )
    ]);
    createSourceTokenIx && preInstructions.push(createSourceTokenIx);
    createBaseTokenIx && preInstructions.push(createBaseTokenIx);
    createTokenVaultIx && preInstructions.push(createTokenVaultIx);
    const postInstructions = [];
    if (this.vault.quoteMint.equals(NATIVE_MINT2)) {
      preInstructions.push(
        ...wrapSOLInstruction(owner, sourceToken, BigInt(maxAmount.toString()))
      );
      postInstructions.push(unwrapSOLInstruction(owner));
    }
    const depositTx = await this.program.methods.deposit(maxAmount).accounts({
      vault: this.pubkey,
      escrow,
      sourceToken,
      tokenVault: this.vault.tokenVault,
      tokenMint: this.vault.quoteMint,
      pool: this.vault.pool,
      owner
    }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(depositTx);
  }
  /**
   * Withdraws a specified amount of tokens from the vault.
   *
   * @param {BN} amount - The amount of tokens to withdraw.
   * @param {PublicKey} owner - The public key of the owner's wallet.
   * @return {Promise<Transaction>} A promise that resolves to the withdraw transaction.
   */
  async withdraw(amount, owner) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const preInstructions = [];
    const { ataPubKey: destinationToken, ix: createDestinationTokenIx } = await getOrCreateATAInstruction(
      this.program.provider.connection,
      this.vault.quoteMint,
      owner
    );
    createDestinationTokenIx && preInstructions.push(createDestinationTokenIx);
    const withdrawTx = await this.program.methods.withdraw(amount).accounts({
      vault: this.pubkey,
      destinationToken,
      escrow,
      owner,
      pool: this.vault.pool,
      tokenVault: this.vault.tokenVault,
      tokenMint: this.vault.quoteMint,
      tokenProgram: TOKEN_PROGRAM_ID2
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(withdrawTx);
  }
  /**
   * Withdraws the remaining quote from the vault.
   *
   * @param {PublicKey} owner - The public key of the owner's wallet.
   * @return {Promise<Transaction>} A promise that resolves to the withdraw transaction.
   */
  async withdrawRemainingQuote(owner) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const preInstructions = [];
    const { ataPubKey: destinationToken, ix: createDestinationTokenIx } = await getOrCreateATAInstruction(
      this.program.provider.connection,
      this.vault.quoteMint,
      owner
    );
    createDestinationTokenIx && preInstructions.push(createDestinationTokenIx);
    const withdrawRemainingTx = await this.program.methods.withdrawRemainingQuote().accounts({
      vault: this.pubkey,
      escrow,
      owner,
      destinationToken,
      pool: this.vault.pool,
      tokenVault: this.vault.tokenVault,
      tokenMint: this.vault.quoteMint,
      tokenProgram: TOKEN_PROGRAM_ID2
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(withdrawRemainingTx);
  }
  /**
   * Claims bought token from the vault.
   *
   * @param {PublicKey} owner - The public key of the owner's wallet.
   * @return {Promise<Transaction>} A promise that resolves to the claim transaction.
   */
  async claimToken(owner) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const preInstructions = [];
    const { ataPubKey: destinationToken, ix: createDestinationTokenIx } = await getOrCreateATAInstruction(
      this.program.provider.connection,
      this.vault.baseMint,
      owner
    );
    createDestinationTokenIx && preInstructions.push(createDestinationTokenIx);
    const claimTokenTx = await this.program.methods.claimToken().accounts({
      vault: this.pubkey,
      escrow,
      owner,
      destinationToken,
      tokenOutVault: this.vault.tokenOutVault,
      tokenMint: this.vault.baseMint,
      tokenProgram: TOKEN_PROGRAM_ID2
    }).preInstructions(preInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(claimTokenTx);
  }
  /**
   * Crank the vault to buy tokens from the pool.
   *
   * @param {PublicKey} payer - The public key of the payer's wallet.
   *
   * @returns {Promise<Transaction | null>} A promise that resolves to the fill vault transaction or null if it's DLMM pool and out of liquidity.
   */
  async fillVault(payer) {
    const poolType = this.vault.poolType;
    if (poolType === 1 /* DYNAMIC */) {
      return fillDynamicAmmTransaction(
        this.program,
        this.pubkey,
        this.vault,
        payer
      );
    } else {
      return fillDlmmTransaction(this.program, this.pubkey, this.vault, payer);
    }
  }
  /**
   * Creates a Merkle root configuration for the vault.
   *
   * @param {Buffer} root - The Merkle root to be configured.
   * @param {BN} version - The version of the Merkle root configuration.
   * @return {Transaction} A transaction to create the Merkle root configuration.
   */
  async createMerkleRootConfig(root, version, vaultCreator) {
    const [merkleRootConfig] = deriveMerkleRootConfig(
      this.pubkey,
      version,
      this.program.programId
    );
    return this.program.methods.createMerkleRootConfig({
      root: Array.from(new Uint8Array(root)),
      version
    }).accounts({
      merkleRootConfig,
      vault: this.pubkey,
      admin: vaultCreator,
      systemProgram: SystemProgram2.programId
    }).transaction();
  }
  /**
   * Close the escrow account.
   *
   * @param {PublicKey} owner - The public key of the owner's wallet.
   * @return {Promise<Transaction>} A promise that resolves to the close escrow transaction.
   */
  async closeEscrow(owner) {
    const [escrow] = deriveEscrow(this.pubkey, owner, this.program.programId);
    const closeEscrowTx = await this.program.methods.closeEscrow().accounts({
      vault: this.pubkey,
      escrow,
      owner,
      rentReceiver: owner
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(closeEscrowTx);
  }
  /**
   * Retrieves deposit information for the given escrow account.
   *
   * @param {Escrow | null} escrowAccount - The escrow account to retrieve deposit information for.
   * @return {Promise<DepositInfo>} A promise that resolves to the deposit information, including total deposit, total filled, and total returned.
   */
  async getDepositInfo(escrowAccount) {
    if (!escrowAccount) {
      return {
        totalDeposit: new BN3(0),
        totalFilled: new BN3(0),
        totalReturned: new BN3(0)
      };
    }
    const remainingAmount = this.vault.totalDeposit.sub(this.vault.swappedAmount);
    const totalReturned = remainingAmount.mul(escrowAccount.totalDeposit).div(this.vault.totalDeposit);
    const totalFilled = escrowAccount.totalDeposit.sub(totalReturned);
    return {
      totalDeposit: escrowAccount.totalDeposit,
      totalFilled,
      totalReturned
    };
  }
  static async createVault(program, {
    quoteMint,
    baseMint,
    poolType,
    vaultMode,
    poolAddress,
    config
  }, owner, whitelistMode) {
    const [alphaVault] = deriveAlphaVault(
      config,
      poolAddress,
      program.programId
    );
    const method = vaultMode === 0 /* PRORATA */ ? program.methods.initializeVaultWithProrataConfig : program.methods.initializeVaultWithFcfsConfig;
    const createTx = await method({
      poolType,
      baseMint,
      quoteMint,
      whitelistMode
    }).accounts({
      vault: alphaVault,
      pool: poolAddress,
      funder: owner,
      config,
      quoteMint,
      program: program.programId,
      systemProgram: SystemProgram2.programId
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction2({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(createTx);
  }
  /**
   * Retrieves a list of all escrows by owner
   *
   * @param {Connection} connection - The Solana connection to use.
   * @param {PublicKey} owner - The owner of escrows.
   * @param {Opt} [opt] - Optional configuration options.
   * @return {Promise<Esrow[]>} A promise containing a list of escrow
   */
  static async getEscrowByOwner(connection, owner, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return program.account.escrow.all([
      {
        memcmp: {
          bytes: owner.toBase58(),
          offset: 40
        }
      }
    ]);
  }
  static async getVault(connection, vaultAddress, opt) {
    const provider = new AnchorProvider(
      connection,
      {},
      AnchorProvider.defaultOptions()
    );
    const program = new Program(
      IDL,
      PROGRAM_ID[opt?.cluster || "mainnet-beta"],
      provider
    );
    return program.account.vault.fetch(vaultAddress);
  }
};

// src/index.ts
var src_default = AlphaVault;
export {
  ALPHA_VAULT_TREASURY_ID,
  ActivationType,
  DLMM_PROGRAM_ID,
  DYNAMIC_AMM_PROGRAM_ID,
  IDL,
  MERKLE_PROOF_API,
  PROGRAM_ID,
  PermissionWithAuthority,
  PermissionWithMerkleProof,
  Permissionless,
  PoolType,
  SEED,
  VAULT_PROGRAM_ID,
  VaultMode,
  src_default as default
};
//# sourceMappingURL=index.mjs.map