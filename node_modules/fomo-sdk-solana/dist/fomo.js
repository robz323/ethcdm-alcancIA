"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fomo = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const bytes_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
const fomo_idl_devnet_json_1 = __importDefault(require("./idl/fomo.idl.devnet.json"));
const fomo_idl_devnet_json_2 = __importDefault(require("./idl/fomo.idl.devnet.json"));
const pda_1 = require("./pda");
const constants_1 = require("./constants");
const transaction_1 = require("./transaction");
const events_1 = require("./events");
const raydium_1 = require("./raydium");
const spl_token_1 = require("@solana/spl-token");
const token_1 = require("coral-xyz3/dist/cjs/utils/token");
class Fomo {
    constructor(connection, cluster, authority) {
        this.SCALE_FACTOR = 1.70583785146;
        this.TOTAL_SUPPLY = 1000000000000000;
        this.program = new anchor_1.Program((cluster === "devnet" ? fomo_idl_devnet_json_1.default : fomo_idl_devnet_json_2.default), new anchor_1.AnchorProvider(connection, {}));
        this.authority = authority;
        this.connection = connection;
        this.events = new events_1.FomoEvents(this.program);
        this.raydium = new raydium_1.FomoRaydium(this.connection, cluster, this.program, authority);
    }
    async buyToken(wallet, tokenMint, amount, slippage, priorityFee, purchaseCurrency) {
        const instructions = [
            web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: priorityFee * web3_js_1.LAMPORTS_PER_SOL,
            }),
        ];
        const global = await this.getGlobalData();
        const bondingCurve = await this.getBondingCurve(tokenMint);
        let [buyAmount, slippageAmount] = this.calculateTradePrice(bondingCurve, amount, purchaseCurrency, "buy", slippage);
        if (buyAmount > bondingCurve.realTokenReserve.toNumber() / constants_1.DENOMINATOR) {
            buyAmount = bondingCurve.realTokenReserve.toNumber() / constants_1.DENOMINATOR;
        }
        const buyIx = await this.program.methods
            .buy(new anchor_1.BN(buyAmount * constants_1.DENOMINATOR), new anchor_1.BN(slippageAmount * web3_js_1.LAMPORTS_PER_SOL))
            .accounts({
            feeWallet: global.feeWallet,
            payer: wallet,
            mint: tokenMint,
        })
            .instruction();
        instructions.push(buyIx);
        return await (0, transaction_1.createTransaction)(this.connection, wallet, instructions);
    }
    async calculateTokenAmountForSol(solAmount, mint, action) {
        const curve = await this.getBondingCurve(mint);
        const [buyAmount] = this.calculateTradePrice(curve, solAmount, "sol", action, 10);
        return buyAmount;
    }
    async sellToken(wallet, tokenMint, amount, slippage, priorityFee, sellCurrency) {
        const instructions = [
            web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: priorityFee * web3_js_1.LAMPORTS_PER_SOL,
            }),
        ];
        const global = await this.getGlobalData();
        const bondingCurve = await this.getBondingCurve(tokenMint);
        const [tokenAmount, slippageAmount] = this.calculateTradePrice(bondingCurve, amount, sellCurrency, "sell", slippage);
        const ix = await this.program.methods
            .sell(new anchor_1.BN(tokenAmount * constants_1.DENOMINATOR), new anchor_1.BN(slippageAmount * web3_js_1.LAMPORTS_PER_SOL))
            .accounts({
            feeWallet: global.feeWallet,
            mint: tokenMint,
            payer: wallet,
        })
            .instruction();
        instructions.push(ix);
        return await (0, transaction_1.createTransaction)(this.connection, wallet, instructions);
    }
    async createToken(wallet, name, symbol, uri, priorityFee, mintKeypair, requiredLiquidity = 85, initialBuy) {
        const instructions = [
            web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: priorityFee * web3_js_1.LAMPORTS_PER_SOL,
            }),
        ];
        const global = await this.getGlobalData();
        const mint = web3_js_1.Keypair.fromSecretKey(bytes_1.bs58.decode(mintKeypair));
        const createMintAccount = web3_js_1.SystemProgram.createAccount({
            fromPubkey: wallet,
            lamports: await this.connection.getMinimumBalanceForRentExemption(spl_token_1.MintLayout.span),
            newAccountPubkey: mint.publicKey,
            programId: spl_token_1.TOKEN_PROGRAM_ID,
            space: spl_token_1.MintLayout.span,
        });
        const bc = (0, pda_1.getBondingPda)(mint.publicKey, this.program.programId);
        instructions.push(createMintAccount);
        instructions.push((0, spl_token_1.createInitializeMintInstruction)(mint.publicKey, 6, bc, null));
        const bondingAta = (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, bc, true);
        const createBondingAta = (0, spl_token_1.createAssociatedTokenAccountInstruction)(wallet, bondingAta, bc, mint.publicKey, spl_token_1.TOKEN_PROGRAM_ID);
        instructions.push(createBondingAta);
        const treasuryAta = (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, global.treasuryWallet, true, spl_token_1.TOKEN_PROGRAM_ID);
        const createTreasuryAta = (0, spl_token_1.createAssociatedTokenAccountInstruction)(wallet, treasuryAta, global.treasuryWallet, mint.publicKey);
        instructions.push(createTreasuryAta);
        const [metadata] = web3_js_1.PublicKey.findProgramAddressSync([
            constants_1.metadataSeed,
            constants_1.TOKEN_METADATA_PROGRAM_ID.toBuffer(),
            mint.publicKey.toBuffer(),
        ], constants_1.TOKEN_METADATA_PROGRAM_ID);
        const [edition] = web3_js_1.PublicKey.findProgramAddressSync([
            constants_1.metadataSeed,
            constants_1.TOKEN_METADATA_PROGRAM_ID.toBuffer(),
            mint.publicKey.toBuffer(),
            constants_1.editionSeed,
        ], constants_1.TOKEN_METADATA_PROGRAM_ID);
        const ix = await this.program.methods
            .create(name, symbol, uri, new anchor_1.BN(requiredLiquidity * web3_js_1.LAMPORTS_PER_SOL))
            .accounts({
            sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            masterEdition: edition,
            metadata,
            treasury: global.treasuryWallet,
            mint: mint.publicKey,
            payer: wallet,
            treasuryAta,
            bondingAta,
            createSolFeeDest: global.createSolDestination,
        })
            .instruction();
        instructions.push(ix);
        let tokenAm;
        if (initialBuy) {
            const vsol = new anchor_1.BN(requiredLiquidity * web3_js_1.LAMPORTS_PER_SOL * (this.SCALE_FACTOR - 1) +
                initialBuy * web3_js_1.LAMPORTS_PER_SOL);
            const realTok = new anchor_1.BN(this.TOTAL_SUPPLY * 0.8);
            const rsol = new anchor_1.BN(initialBuy * web3_js_1.LAMPORTS_PER_SOL);
            const vrs = new anchor_1.BN(realTok.toNumber() * this.SCALE_FACTOR);
            const price = this.calculatePrice(vsol, vrs, rsol, realTok);
            const tokenAmount = initialBuy / price;
            const tok = new anchor_1.BN(tokenAmount * constants_1.DENOMINATOR);
            tokenAm = tokenAmount;
            const buyIx = await this.program.methods
                .buy(tok, new anchor_1.BN((initialBuy + 1) * web3_js_1.LAMPORTS_PER_SOL))
                .accountsPartial({
                feeWallet: global.feeWallet,
                mint: mint.publicKey,
                payer: wallet,
                associatedTokenProgram: token_1.ASSOCIATED_PROGRAM_ID,
                global: (0, pda_1.getGlobalPda)(this.program.programId),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                systemProgram: web3_js_1.SystemProgram.programId,
                bondingCurve: (0, pda_1.getBondingPda)(mint.publicKey, this.program.programId),
                bondingAta: (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, (0, pda_1.getBondingPda)(mint.publicKey, this.program.programId), true),
                userAta: (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, wallet),
                creatorData: web3_js_1.PublicKey.findProgramAddressSync([
                    Buffer.from("creator"),
                    wallet.toBuffer(),
                    mint.publicKey.toBuffer(),
                ], this.program.programId)[0],
            })
                .instruction();
            instructions.push(buyIx);
        }
        return {
            tokenAmount: tokenAm,
            transaction: await (0, transaction_1.createTransaction)(this.connection, wallet, instructions),
        };
    }
    async getGlobalData() {
        const global = (0, pda_1.getGlobalPda)(this.program.programId);
        return this.program.account.globalData.fetch(global);
    }
    async getBondingCurve(tokenMint) {
        const pda = (0, pda_1.getBondingPda)(tokenMint, this.program.programId);
        const bondingCurve = await this.program.account.bondingCurve.fetch(pda);
        return bondingCurve;
    }
    calculatePrice(virtualSolReserve, virtualTokenReserve, realSolReserve, realTokenReserve) {
        const totalSolReserves = virtualSolReserve.add(realSolReserve).toNumber();
        const solInDecimal = totalSolReserves / web3_js_1.LAMPORTS_PER_SOL;
        const totalTokenReserves = virtualTokenReserve
            .add(realTokenReserve)
            .toNumber();
        const tokenInDecimal = totalTokenReserves / constants_1.DENOMINATOR;
        return solInDecimal / tokenInDecimal;
    }
    calculateSlippage(solAmount, slippage, tradeType) {
        const sl = solAmount * (slippage / 100);
        if (tradeType === "buy") {
            return solAmount + sl;
        }
        return solAmount - sl;
    }
    calculateTradePrice(bondingCurve, purchaseAmount, purchaseCurrency, tradeType, slippage) {
        let virtualTokenReserve = bondingCurve.virtualTokenReserve;
        let virtualSolReserve = bondingCurve.virtualSolReserve;
        let realSolReserve = bondingCurve.realSolReserve;
        let realTokenReserve = bondingCurve.realTokenReserve;
        switch (purchaseCurrency) {
            case "sol": {
                switch (tradeType) {
                    case "buy": {
                        virtualSolReserve = virtualSolReserve.add(new anchor_1.BN(purchaseAmount * web3_js_1.LAMPORTS_PER_SOL));
                        realSolReserve = realSolReserve.add(new anchor_1.BN(purchaseAmount * web3_js_1.LAMPORTS_PER_SOL));
                        const price = this.calculatePrice(virtualSolReserve, virtualTokenReserve, realSolReserve, realTokenReserve);
                        const calculatedSlippage = this.calculateSlippage(purchaseAmount, slippage, "buy");
                        let tokenAmount = purchaseAmount / price;
                        if (tokenAmount > realTokenReserve.toNumber() / constants_1.DENOMINATOR) {
                            tokenAmount = realTokenReserve.toNumber() / constants_1.DENOMINATOR;
                        }
                        return [tokenAmount, calculatedSlippage];
                    }
                    case "sell": {
                        virtualSolReserve = virtualSolReserve.sub(new anchor_1.BN(purchaseAmount * web3_js_1.LAMPORTS_PER_SOL));
                        realSolReserve = realSolReserve.sub(new anchor_1.BN(purchaseAmount * web3_js_1.LAMPORTS_PER_SOL));
                        const price = this.calculatePrice(virtualSolReserve, virtualTokenReserve, realSolReserve, realTokenReserve);
                        const calculatedSlippage = this.calculateSlippage(purchaseAmount, slippage, "sell");
                        const tokenAmount = purchaseAmount / price;
                        return [tokenAmount, calculatedSlippage];
                    }
                }
            }
            case "token": {
                switch (tradeType) {
                    case "buy": {
                        virtualTokenReserve = virtualTokenReserve.sub(new anchor_1.BN(purchaseAmount * constants_1.DENOMINATOR));
                        realTokenReserve = realTokenReserve.sub(new anchor_1.BN(purchaseAmount * constants_1.DENOMINATOR));
                        let price = this.calculatePrice(virtualSolReserve, virtualTokenReserve, realSolReserve, realTokenReserve);
                        let solTransfer = price * purchaseAmount;
                        const calculatedSlippage = this.calculateSlippage(solTransfer, slippage, "buy");
                        return [purchaseAmount, calculatedSlippage];
                    }
                    case "sell": {
                        virtualTokenReserve = virtualTokenReserve.add(new anchor_1.BN(purchaseAmount * constants_1.DENOMINATOR));
                        realTokenReserve = realTokenReserve.add(new anchor_1.BN(purchaseAmount * constants_1.DENOMINATOR));
                        let price = this.calculatePrice(virtualSolReserve, virtualTokenReserve, realSolReserve, realTokenReserve);
                        let solTransfer = price * purchaseAmount;
                        const calculatedSlippage = this.calculateSlippage(solTransfer, slippage, "sell");
                        return [purchaseAmount, calculatedSlippage];
                    }
                }
            }
        }
    }
}
exports.Fomo = Fomo;
