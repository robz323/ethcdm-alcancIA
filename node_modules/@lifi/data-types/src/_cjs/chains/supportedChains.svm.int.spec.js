"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const vitest_1 = require("vitest");
const supportedChains_svm_js_1 = require("./supportedChains.svm.js");
const TokenProgramAddress = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
const WalletAddress = '6AUWsSCRFSCbrHKH9s84wfzJXtD6mNzAHs11x6pGEcmJ';
vitest_1.describe.concurrent('SVM chains RPC check', () => {
    const rpcUrls = supportedChains_svm_js_1.supportedSolanaChains.flatMap((chain) => chain.metamask.rpcUrls.map((rpcUrl) => ({
        rpcUrl: rpcUrl,
        chainId: chain.id,
        chainName: chain.name,
    })));
    vitest_1.test.for(rpcUrls)(`should successfully get chain ID from $chainName - $chainId RPC: $rpcUrl`, { timeout: 10_000, retry: 3 }, async ({ rpcUrl }) => {
        const connection = new web3_js_1.Connection(rpcUrl);
        const accountPublicKey = new web3_js_1.PublicKey(WalletAddress);
        const tokenProgramPublicKey = new web3_js_1.PublicKey(TokenProgramAddress);
        const [blockHeight, slot, balance, tokenAccountsByOwner] = await Promise.allSettled([
            connection.getBlockHeight(),
            connection.getSlot(),
            connection.getBalance(accountPublicKey),
            connection.getParsedTokenAccountsByOwner(accountPublicKey, {
                programId: tokenProgramPublicKey,
            }),
        ]);
        (0, vitest_1.expect)(blockHeight.status).toBe('fulfilled');
        (0, vitest_1.expect)(slot.status).toBe('fulfilled');
        (0, vitest_1.expect)(balance.status).toBe('fulfilled');
        (0, vitest_1.expect)(tokenAccountsByOwner.status).toBe('fulfilled');
    });
});
vitest_1.describe.concurrent('SVM chains block explorer check', () => {
    const blockExplorerUrls = supportedChains_svm_js_1.supportedSolanaChains.flatMap((chain) => chain.metamask.blockExplorerUrls.map((blockExplorerUrl) => ({
        blockExplorerUrl: blockExplorerUrl,
        chainId: chain.id,
        chainName: chain.name,
    })));
    vitest_1.test.for(blockExplorerUrls)(`block explorer should be alive $chainName - $chainId - $blockExplorerUrl`, { timeout: 10_000, retry: 3 }, async ({ blockExplorerUrl }) => {
        const response = await fetch(blockExplorerUrl);
        (0, vitest_1.expect)(response.url).toBe(blockExplorerUrl);
        (0, vitest_1.expect)(response.ok).toBe(true);
        (0, vitest_1.expect)(response.status).toBe(200);
    });
});
//# sourceMappingURL=supportedChains.svm.int.spec.js.map