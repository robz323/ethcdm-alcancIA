"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@lifi/types");
const vitest_1 = require("vitest");
const index_js_1 = require("../coins/index.js");
const supportedChains_js_1 = require("./supportedChains.js");
const supportedChains_evm_js_1 = require("./supportedChains.evm.js");
const utils_js_1 = require("./utils.js");
(0, vitest_1.test)('getChainById', () => {
    (0, vitest_1.expect)((0, supportedChains_js_1.getChainById)(types_1.ChainId.ETH)).toBeDefined();
});
(0, vitest_1.test)('getChainByKey', () => {
    (0, vitest_1.expect)((0, supportedChains_js_1.getChainByKey)(types_1.ChainKey.ETH)).toBeDefined();
});
(0, vitest_1.test)('native token defined for all chains', () => {
    const ignoredChainsForNativeToken = [types_1.ChainId.FSN, types_1.ChainId.TLO, types_1.ChainId.RSK];
    const ignoredChainsForWrappedToken = [
        ...ignoredChainsForNativeToken,
        types_1.ChainId.BTC,
        types_1.ChainId.BCH,
        types_1.ChainId.LTC,
        types_1.ChainId.DGE,
    ];
    for (const chain of supportedChains_js_1.supportedChains) {
        if (ignoredChainsForNativeToken.includes(chain.id)) {
            continue;
        }
        try {
            const gasToken = (0, index_js_1.findDefaultToken)(chain.coin, chain.id);
            (0, vitest_1.expect)(gasToken).toBeDefined();
        }
        catch (e) {
            throw new Error(`Failed to load gas token for ${chain.name}(${chain.id})`);
        }
    }
    for (const chain of supportedChains_js_1.supportedChains) {
        if (ignoredChainsForWrappedToken.includes(chain.id)) {
            continue;
        }
        try {
            const wrappedGasToken = (0, index_js_1.findWrappedGasOnChain)(chain.id);
            (0, vitest_1.expect)(wrappedGasToken).toBeDefined();
        }
        catch (e) {
            throw new Error(`Failed to load wrapped gas token for ${chain.name}(${chain.id})`);
        }
    }
});
(0, vitest_1.describe)('findTokenByChainIdAndAddress', () => {
    (0, vitest_1.describe)('token has no name override', () => {
        (0, vitest_1.it)('returns a token with the coin name', () => {
            (0, vitest_1.expect)((0, index_js_1.findTokenByChainIdAndAddress)(types_1.ChainId.LNA, '0xa219439258ca9da29e9cc4ce5596924745e12b93').name).toEqual(types_1.CoinKey.USDT);
        });
    });
    (0, vitest_1.describe)('token has a name override', () => {
        (0, vitest_1.it)('returns a token with the overrode name', () => {
            (0, vitest_1.expect)((0, index_js_1.findTokenByChainIdAndAddress)(types_1.ChainId.SOL, '33fsBLA8djQm82RpHmE3SuVrPGtZBWNYExsEUeKX1HXX').name).toEqual('Binance USD (Wormhole from Ethereum)');
        });
    });
});
(0, vitest_1.describe)('validate chains', () => {
    supportedChains_evm_js_1.supportedEVMChains.forEach((chain) => {
        (0, vitest_1.it)(`validate chain ${chain.name}`, () => {
            (0, vitest_1.expect)(chain.metamask.blockExplorerUrls.length).toBeGreaterThan(0);
            chain.metamask.blockExplorerUrls.forEach((blockExplorerUrl) => {
                (0, vitest_1.expect)(blockExplorerUrl.startsWith('https://')).toBeTruthy();
                (0, vitest_1.expect)(blockExplorerUrl.endsWith('/')).toBeTruthy();
            });
            const chainId = (0, utils_js_1.prefixChainId)(chain.id);
            (0, vitest_1.expect)(chainId).toEqual(chain.metamask.chainId);
            (0, vitest_1.expect)(chain.metamask.rpcUrls.length).toBeGreaterThan(0);
        });
    });
});
//# sourceMappingURL=supportedChains.unit.spec.js.map