import type { Route } from '@lifi/types';
import type { ExecutionOptions, RouteExtended } from './types.js';
/**
 * Execute a route.
 * @param route - The route that should be executed. Cannot be an active route.
 * @param executionOptions - An object containing settings and callbacks.
 * @returns The executed route.
 * @throws {LiFiError} Throws a LiFiError if the execution fails.
 */
export declare const executeRoute: (route: Route, executionOptions?: ExecutionOptions) => Promise<RouteExtended>;
/**
 * Resume the execution of a route that has been stopped or had an error while executing.
 * @param route - The route that is to be executed. Cannot be an active route.
 * @param executionOptions - An object containing settings and callbacks.
 * @returns The executed route.
 * @throws {LiFiError} Throws a LiFiError if the execution fails.
 */
export declare const resumeRoute: (route: Route, executionOptions?: ExecutionOptions) => Promise<RouteExtended>;
/**
 * Updates route execution to background or foreground state.
 * @param route - A route that is currently in execution.
 * @param options - An object with execution settings.
 */
export declare const updateRouteExecution: (route: Route, options: ExecutionOptions) => void;
/**
 * Stops the execution of an active route.
 * @param route - A route that is currently in execution.
 * @returns The stopped route.
 */
export declare const stopRouteExecution: (route: Route) => Route;
/**
 * Get the list of active routes.
 * @returns A list of routes.
 */
export declare const getActiveRoutes: () => RouteExtended[];
/**
 * Return the current route information for given route. The route has to be active.
 * @param routeId - A route id.
 * @returns The updated route.
 */
export declare const getActiveRoute: (routeId: string) => RouteExtended | undefined;
//# sourceMappingURL=execution.d.ts.map