"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUTXOAPIPublicClient = void 0;
const core_1 = require("@bigmi/core");
const core_2 = require("@bigmi/core");
const viem_1 = require("viem");
const config_js_1 = require("../../config.js");
const publicAPIClients = {};
const getUTXOAPIPublicClient = async (chainId) => {
    if (!publicAPIClients[chainId]) {
        const _chain = await config_js_1.config.getChainById(chainId);
        const chain = {
            ..._chain,
            ..._chain.metamask,
            name: _chain.metamask.chainName,
            rpcUrls: {
                default: { http: _chain.metamask.rpcUrls },
                public: { http: _chain.metamask.rpcUrls },
            },
        };
        const client = (0, viem_1.createClient)({
            chain,
            rpcSchema: (0, viem_1.rpcSchema)(),
            transport: (0, viem_1.fallback)([
                (0, core_2.utxo)('https://api.blockchair.com', {
                    key: 'blockchair',
                    includeChainToURL: true,
                }),
                (0, core_2.utxo)('https://rpc.ankr.com/http/btc_blockbook/api/v2', {
                    key: 'ankr',
                }),
                (0, core_2.utxo)('https://api.blockcypher.com/v1/btc/main', {
                    key: 'blockcypher',
                }),
                (0, core_2.utxo)('https://mempool.space/api', {
                    key: 'mempool',
                }),
            ]),
        }).extend(core_1.UTXOAPIActions);
        publicAPIClients[chainId] = client;
    }
    if (!publicAPIClients[chainId]) {
        throw new Error(`Unable to configure provider for chain ${chainId}`);
    }
    return publicAPIClients[chainId];
};
exports.getUTXOAPIPublicClient = getUTXOAPIPublicClient;
//# sourceMappingURL=getUTXOAPIPublicClient.js.map