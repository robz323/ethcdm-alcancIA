"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUTXOErrors = void 0;
const SDKError_js_1 = require("../../errors/SDKError.js");
const baseError_js_1 = require("../../errors/baseError.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const parseUTXOErrors = async (e, step, process) => {
    if (e instanceof SDKError_js_1.SDKError) {
        e.step = e.step ?? step;
        e.process = e.process ?? process;
        return e;
    }
    const baseError = handleSpecificErrors(e);
    return new SDKError_js_1.SDKError(baseError, step, process);
};
exports.parseUTXOErrors = parseUTXOErrors;
const handleSpecificErrors = (e) => {
    if (e.details?.includes?.('conflict') ||
        e.cause?.message?.includes?.('conflict')) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionConflict, 'Your transaction conflicts with another transaction already in the mempool. One or more inputs have been spent by another transaction.', e);
    }
    if (e.code === 4001 || e.code === -32000 || e.cause?.includes?.('rejected')) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.SignatureRejected, e.message, e);
    }
    if (e.code === -5 || e.code === -32700 || e.code === -32064) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.NotFound, e.message, e);
    }
    if (e instanceof baseError_js_1.BaseError) {
        return e;
    }
    return new errors_js_1.UnknownError(e.message || constants_js_1.ErrorMessage.UnknownError, e);
};
//# sourceMappingURL=parseUTXOErrors.js.map