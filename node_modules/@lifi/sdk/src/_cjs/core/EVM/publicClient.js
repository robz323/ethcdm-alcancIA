"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicClient = void 0;
const types_1 = require("@lifi/types");
const viem_1 = require("viem");
const chains_1 = require("viem/chains");
const config_js_1 = require("../../config.js");
const rpc_js_1 = require("../rpc.js");
const publicClients = {};
const getPublicClient = async (chainId) => {
    if (!publicClients[chainId]) {
        const urls = await (0, rpc_js_1.getRpcUrls)(chainId);
        const fallbackTransports = urls.map((url) => url.startsWith('wss')
            ? (0, viem_1.webSocket)(url)
            : (0, viem_1.http)(url, {
                batch: {
                    batchSize: 64,
                },
            }));
        const _chain = await config_js_1.config.getChainById(chainId);
        const chain = {
            ..._chain,
            ..._chain.metamask,
            name: _chain.metamask.chainName,
            rpcUrls: {
                default: { http: _chain.metamask.rpcUrls },
                public: { http: _chain.metamask.rpcUrls },
            },
        };
        if (chain.id === types_1.ChainId.ETH) {
            chain.contracts = {
                ...chains_1.mainnet.contracts,
                ...chain.contracts,
            };
        }
        publicClients[chainId] = (0, viem_1.createClient)({
            chain: chain,
            transport: (0, viem_1.fallback)(fallbackTransports),
            batch: {
                multicall: true,
            },
        });
    }
    if (!publicClients[chainId]) {
        throw new Error(`Unable to configure provider for chain ${chainId}`);
    }
    return publicClients[chainId];
};
exports.getPublicClient = getPublicClient;
//# sourceMappingURL=publicClient.js.map