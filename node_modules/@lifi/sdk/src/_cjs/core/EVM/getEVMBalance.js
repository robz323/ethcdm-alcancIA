"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEVMBalance = void 0;
const actions_1 = require("viem/actions");
const isZeroAddress_js_1 = require("../../utils/isZeroAddress.js");
const abi_js_1 = require("./abi.js");
const publicClient_js_1 = require("./publicClient.js");
const utils_js_1 = require("./utils.js");
const getEVMBalance = async (walletAddress, tokens) => {
    if (tokens.length === 0) {
        return [];
    }
    const { chainId } = tokens[0];
    for (const token of tokens) {
        if (token.chainId !== chainId) {
            console.warn('Requested tokens have to be on the same chain.');
        }
    }
    const multicallAddress = await (0, utils_js_1.getMulticallAddress)(chainId);
    if (multicallAddress && tokens.length > 1) {
        return getEVMBalanceMulticall(chainId, tokens, walletAddress, multicallAddress);
    }
    return getEVMBalanceDefault(chainId, tokens, walletAddress);
};
exports.getEVMBalance = getEVMBalance;
const getEVMBalanceMulticall = async (chainId, tokens, walletAddress, multicallAddress) => {
    const client = await (0, publicClient_js_1.getPublicClient)(chainId);
    const contracts = tokens.map((token) => {
        if ((0, isZeroAddress_js_1.isZeroAddress)(token.address)) {
            return {
                address: multicallAddress,
                abi: abi_js_1.getEthBalanceAbi,
                functionName: 'getEthBalance',
                args: [walletAddress],
            };
        }
        return {
            address: token.address,
            abi: abi_js_1.balanceOfAbi,
            functionName: 'balanceOf',
            args: [walletAddress],
        };
    });
    const blockNumber = await (0, actions_1.getBlockNumber)(client);
    const results = await (0, actions_1.multicall)(client, {
        contracts,
        multicallAddress: multicallAddress,
        blockNumber,
    });
    if (!results.length) {
        return [];
    }
    return tokens.map((token, i) => {
        return {
            ...token,
            amount: results[i].result,
            blockNumber,
        };
    });
};
const getEVMBalanceDefault = async (chainId, tokens, walletAddress) => {
    const client = await (0, publicClient_js_1.getPublicClient)(chainId);
    const blockNumber = await (0, actions_1.getBlockNumber)(client);
    const queue = tokens.map((token) => {
        if ((0, isZeroAddress_js_1.isZeroAddress)(token.address)) {
            return (0, actions_1.getBalance)(client, {
                address: walletAddress,
            });
        }
        return (0, actions_1.readContract)(client, {
            address: token.address,
            abi: abi_js_1.balanceOfAbi,
            functionName: 'balanceOf',
            args: [walletAddress],
        });
    });
    const results = await Promise.allSettled(queue);
    const tokenAmounts = tokens.map((token, index) => {
        const result = results[index];
        if (result.status === 'rejected') {
            return {
                ...token,
                blockNumber,
            };
        }
        return {
            ...token,
            amount: result.value,
            blockNumber,
        };
    });
    return tokenAmounts;
};
//# sourceMappingURL=getEVMBalance.js.map