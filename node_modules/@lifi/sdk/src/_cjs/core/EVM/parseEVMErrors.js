"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEVMErrors = void 0;
const SDKError_js_1 = require("../../errors/SDKError.js");
const baseError_js_1 = require("../../errors/baseError.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const helpers_js_1 = require("../../helpers.js");
const parseEVMErrors = async (e, step, process) => {
    if (e instanceof SDKError_js_1.SDKError) {
        e.step = e.step ?? step;
        e.process = e.process ?? process;
        return e;
    }
    const baseError = await handleSpecificErrors(e, step, process);
    return new SDKError_js_1.SDKError(baseError, step, process);
};
exports.parseEVMErrors = parseEVMErrors;
const handleSpecificErrors = async (e, step, process) => {
    if (e.cause?.name === 'UserRejectedRequestError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.SignatureRejected, e.message, e);
    }
    if (step &&
        process?.txHash &&
        e.code === constants_js_1.LiFiErrorCode.TransactionFailed &&
        e.message === constants_js_1.ErrorMessage.TransactionReverted) {
        const response = await (0, helpers_js_1.fetchTxErrorDetails)(process.txHash, step.action.fromChainId);
        const errorMessage = response?.error_message;
        if (errorMessage?.toLowerCase().includes('out of gas')) {
            return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.GasLimitError, constants_js_1.ErrorMessage.GasLimitLow, e);
        }
    }
    if (e instanceof baseError_js_1.BaseError) {
        return e;
    }
    return new errors_js_1.UnknownError(e.message || constants_js_1.ErrorMessage.UnknownError, e);
};
//# sourceMappingURL=parseEVMErrors.js.map