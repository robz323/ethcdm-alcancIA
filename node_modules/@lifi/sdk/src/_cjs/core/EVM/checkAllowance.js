"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAllowance = void 0;
const getAllowance_js_1 = require("./getAllowance.js");
const parseEVMErrors_js_1 = require("./parseEVMErrors.js");
const setAllowance_js_1 = require("./setAllowance.js");
const waitForTransactionReceipt_js_1 = require("./waitForTransactionReceipt.js");
const checkAllowance = async (client, chain, step, statusManager, settings, allowUserInteraction = false, shouldBatchTransactions = false) => {
    let allowanceProcess = statusManager.findOrCreateProcess({
        step,
        type: 'TOKEN_ALLOWANCE',
        chainId: step.action.fromChainId,
    });
    try {
        if (allowanceProcess.txHash && allowanceProcess.status !== 'DONE') {
            await waitForApprovalTransaction(client, allowanceProcess.txHash, allowanceProcess.type, step, chain, statusManager);
        }
        else {
            allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'STARTED');
            const approved = await (0, getAllowance_js_1.getAllowance)(chain.id, step.action.fromToken.address, client.account.address, step.estimate.approvalAddress);
            const fromAmount = BigInt(step.action.fromAmount);
            if (fromAmount > approved) {
                if (!allowUserInteraction) {
                    return;
                }
                if (shouldBatchTransactions) {
                    const approveTxHash = await (0, setAllowance_js_1.setAllowance)(client, step.action.fromToken.address, step.estimate.approvalAddress, fromAmount, settings, true);
                    allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'DONE');
                    return approveTxHash;
                }
                const approveTxHash = await (0, setAllowance_js_1.setAllowance)(client, step.action.fromToken.address, step.estimate.approvalAddress, fromAmount);
                await waitForApprovalTransaction(client, approveTxHash, allowanceProcess.type, step, chain, statusManager);
            }
            else {
                allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'DONE');
            }
        }
    }
    catch (e) {
        const error = await (0, parseEVMErrors_js_1.parseEVMErrors)(e, step, allowanceProcess);
        allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'FAILED', {
            error: {
                message: error.cause.message,
                code: error.code,
            },
        });
        statusManager.updateExecution(step, 'FAILED');
        throw error;
    }
};
exports.checkAllowance = checkAllowance;
const waitForApprovalTransaction = async (client, txHash, processType, step, chain, statusManager) => {
    statusManager.updateProcess(step, processType, 'PENDING', {
        txHash,
        txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${txHash}`,
    });
    const transactionReceipt = await (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)({
        client: client,
        chainId: chain.id,
        txHash: txHash,
        onReplaced(response) {
            statusManager.updateProcess(step, processType, 'PENDING', {
                txHash: response.transaction.hash,
                txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${response.transaction.hash}`,
            });
        },
    });
    const transactionHash = transactionReceipt?.transactionHash || txHash;
    statusManager.updateProcess(step, processType, 'DONE', {
        txHash: transactionHash,
        txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${transactionHash}`,
    });
};
//# sourceMappingURL=checkAllowance.js.map