"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForTransactionReceipt = waitForTransactionReceipt;
const actions_1 = require("viem/actions");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const publicClient_js_1 = require("./publicClient.js");
const utils_js_1 = require("./utils.js");
async function waitForTransactionReceipt({ client, chainId, txHash, onReplaced, }) {
    let { transactionReceipt, replacementReason } = await waitForReceipt(client, txHash, onReplaced);
    if (!transactionReceipt?.status) {
        const publicClient = await (0, publicClient_js_1.getPublicClient)(chainId);
        const result = await waitForReceipt(publicClient, txHash, onReplaced);
        transactionReceipt = result.transactionReceipt;
        replacementReason = result.replacementReason;
    }
    if (transactionReceipt?.status === 'reverted') {
        throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionFailed, 'Transaction was reverted.');
    }
    if (replacementReason === 'cancelled') {
        throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionCanceled, 'User canceled transaction.');
    }
    return transactionReceipt;
}
async function waitForReceipt(client, txHash, onReplaced) {
    let replacementReason;
    let transactionReceipt;
    try {
        transactionReceipt = await (0, actions_1.waitForTransactionReceipt)(client, {
            hash: txHash,
            onReplaced: (response) => {
                replacementReason = response.reason;
                onReplaced?.(response);
            },
            retryCount: utils_js_1.retryCount,
            retryDelay: utils_js_1.retryDelay,
        });
    }
    catch {
    }
    return { transactionReceipt, replacementReason };
}
//# sourceMappingURL=waitForTransactionReceipt.js.map