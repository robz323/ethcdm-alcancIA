"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusManager = void 0;
const executionState_js_1 = require("./executionState.js");
const processMessages_js_1 = require("./processMessages.js");
class StatusManager {
    constructor(routeId) {
        Object.defineProperty(this, "routeId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shouldUpdate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "initExecutionObject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (step) => {
                if (!step.execution) {
                    step.execution = {
                        status: 'PENDING',
                        process: [],
                    };
                    this.updateStepInRoute(step);
                }
                if (step.execution.status === 'FAILED') {
                    step.execution.status = 'PENDING';
                    this.updateStepInRoute(step);
                }
                return step.execution;
            }
        });
        Object.defineProperty(this, "findOrCreateProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ({ step, type, chainId, status, }) => {
                if (!step.execution?.process) {
                    throw new Error("Execution hasn't been initialized.");
                }
                const process = step.execution.process.find((p) => p.type === type);
                if (process) {
                    if (status && process.status !== status) {
                        process.status = status;
                        this.updateStepInRoute(step);
                    }
                    return process;
                }
                const newProcess = {
                    type: type,
                    startedAt: Date.now(),
                    message: (0, processMessages_js_1.getProcessMessage)(type, status ?? 'STARTED'),
                    status: status ?? 'STARTED',
                    chainId: chainId,
                };
                step.execution.process.push(newProcess);
                this.updateStepInRoute(step);
                return newProcess;
            }
        });
        Object.defineProperty(this, "updateProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (step, type, status, params) => {
                if (!step.execution) {
                    throw new Error("Can't update an empty step execution.");
                }
                const currentProcess = step?.execution?.process.find((p) => p.type === type);
                if (!currentProcess) {
                    throw new Error("Can't find a process for the given type.");
                }
                switch (status) {
                    case 'CANCELLED':
                        currentProcess.doneAt = Date.now();
                        break;
                    case 'FAILED':
                        currentProcess.doneAt = Date.now();
                        step.execution.status = 'FAILED';
                        break;
                    case 'DONE':
                        currentProcess.doneAt = Date.now();
                        break;
                    case 'PENDING':
                        step.execution.status = 'PENDING';
                        break;
                    case 'ACTION_REQUIRED':
                        step.execution.status = 'ACTION_REQUIRED';
                        break;
                    default:
                        break;
                }
                currentProcess.status = status;
                currentProcess.message = (0, processMessages_js_1.getProcessMessage)(type, status);
                if (params) {
                    for (const [key, value] of Object.entries(params)) {
                        currentProcess[key] = value;
                    }
                }
                step.execution.process = [
                    ...step.execution.process.filter((process) => process.status === 'DONE'),
                    ...step.execution.process.filter((process) => process.status !== 'DONE'),
                ];
                this.updateStepInRoute(step);
                return currentProcess;
            }
        });
        Object.defineProperty(this, "removeProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (step, type) => {
                if (!step.execution) {
                    throw new Error("Execution hasn't been initialized.");
                }
                const index = step.execution.process.findIndex((p) => p.type === type);
                step.execution.process.splice(index, 1);
                this.updateStepInRoute(step);
            }
        });
        Object.defineProperty(this, "updateStepInRoute", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (step) => {
                if (!this.shouldUpdate) {
                    return step;
                }
                const data = executionState_js_1.executionState.get(this.routeId);
                if (!data) {
                    throw new Error('Execution data not found.');
                }
                const stepIndex = data.route.steps.findIndex((routeStep) => routeStep.id === step.id);
                if (stepIndex === -1) {
                    throw new Error("Couldn't find a step to update.");
                }
                data.route.steps[stepIndex] = { ...data.route.steps[stepIndex], ...step };
                data.executionOptions?.updateRouteHook?.(data.route);
                return data.route.steps[stepIndex];
            }
        });
        this.routeId = routeId;
    }
    updateExecution(step, status, execution) {
        if (!step.execution) {
            throw Error("Can't update empty execution.");
        }
        step.execution.status = status;
        if (execution) {
            step.execution = {
                ...step.execution,
                ...execution,
            };
        }
        this.updateStepInRoute(step);
        return step;
    }
    allowUpdates(value) {
        this.shouldUpdate = value;
    }
}
exports.StatusManager = StatusManager;
//# sourceMappingURL=StatusManager.js.map