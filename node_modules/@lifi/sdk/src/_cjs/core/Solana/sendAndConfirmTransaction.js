"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
const bs58_1 = require("bs58");
const sleep_js_1 = require("../../utils/sleep.js");
const connection_js_1 = require("./connection.js");
async function sendAndConfirmTransaction(signedTx) {
    const connections = await (0, connection_js_1.getSolanaConnections)();
    const signedTxSerialized = signedTx.serialize();
    const txSignature = bs58_1.default.encode(signedTx.signatures[0]);
    if (!txSignature) {
        throw new Error('Transaction signature is missing.');
    }
    const rawTransactionOptions = {
        skipPreflight: true,
        maxRetries: 0,
        preflightCommitment: 'confirmed',
    };
    for (const connection of connections) {
        connection
            .sendRawTransaction(signedTxSerialized, rawTransactionOptions)
            .catch();
    }
    const abortControllers = [];
    const confirmPromises = connections.map(async (connection) => {
        const abortController = new AbortController();
        abortControllers.push(abortController);
        try {
            const blockhashResult = await connection.getLatestBlockhash('confirmed');
            const confirmTransactionPromise = connection
                .confirmTransaction({
                signature: txSignature,
                blockhash: blockhashResult.blockhash,
                lastValidBlockHeight: blockhashResult.lastValidBlockHeight,
                abortSignal: abortController.signal,
            }, 'confirmed')
                .then((result) => result.value);
            let signatureResult = null;
            let blockHeight = await connection.getBlockHeight('confirmed');
            while (!signatureResult &&
                blockHeight < blockhashResult.lastValidBlockHeight) {
                await connection.sendRawTransaction(signedTxSerialized, rawTransactionOptions);
                signatureResult = await Promise.race([
                    confirmTransactionPromise,
                    (0, sleep_js_1.sleep)(1000),
                ]);
                if (signatureResult || abortController.signal.aborted) {
                    break;
                }
                blockHeight = await connection.getBlockHeight('confirmed');
            }
            abortController.abort();
            return signatureResult;
        }
        catch (error) {
            if (abortController.signal.aborted) {
                return Promise.reject(new Error('Confirmation aborted.'));
            }
            throw error;
        }
    });
    const signatureResult = await Promise.any(confirmPromises).catch(() => null);
    for (const abortController of abortControllers) {
        abortController.abort();
    }
    return { signatureResult, txSignature };
}
//# sourceMappingURL=sendAndConfirmTransaction.js.map