"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSolanaErrors = void 0;
const SDKError_js_1 = require("../../errors/SDKError.js");
const baseError_js_1 = require("../../errors/baseError.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const parseSolanaErrors = async (e, step, process) => {
    if (e instanceof SDKError_js_1.SDKError) {
        e.step = e.step ?? step;
        e.process = e.process ?? process;
        return e;
    }
    const baseError = handleSpecificErrors(e);
    return new SDKError_js_1.SDKError(baseError, step, process);
};
exports.parseSolanaErrors = parseSolanaErrors;
const handleSpecificErrors = (e) => {
    if (e.name === 'WalletSignTransactionError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.SignatureRejected, e.message, e);
    }
    if (e.name === 'SendTransactionError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionFailed, e.message, e);
    }
    if (e.name === 'TransactionExpiredBlockheightExceededError') {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionExpired, e.message, e);
    }
    if (e.message?.includes('simulate')) {
        return new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionSimulationFailed, e.message, e);
    }
    if (e instanceof baseError_js_1.BaseError) {
        return e;
    }
    return new errors_js_1.UnknownError(e.message || constants_js_1.ErrorMessage.UnknownError, e);
};
//# sourceMappingURL=parseSolanaErrors.js.map