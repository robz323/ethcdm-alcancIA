"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveRoute = exports.getActiveRoutes = exports.stopRouteExecution = exports.updateRouteExecution = exports.resumeRoute = exports.executeRoute = void 0;
const config_js_1 = require("../config.js");
const executionState_js_1 = require("./executionState.js");
const prepareRestart_js_1 = require("./prepareRestart.js");
const executeRoute = async (route, executionOptions) => {
    const clonedRoute = structuredClone(route);
    let executionPromise = executionState_js_1.executionState.get(clonedRoute.id)?.promise;
    if (executionPromise) {
        return executionPromise;
    }
    executionState_js_1.executionState.create({ route: clonedRoute, executionOptions });
    executionPromise = executeSteps(clonedRoute);
    executionState_js_1.executionState.update({
        route: clonedRoute,
        promise: executionPromise,
    });
    return executionPromise;
};
exports.executeRoute = executeRoute;
const resumeRoute = async (route, executionOptions) => {
    const execution = executionState_js_1.executionState.get(route.id);
    if (execution) {
        const executionHalted = execution.executors.some((executor) => !executor.allowExecution);
        if (!executionHalted) {
            (0, exports.updateRouteExecution)(route, {
                executeInBackground: executionOptions?.executeInBackground,
            });
            if (!execution.promise) {
                throw new Error('Route execution promise not found.');
            }
            return execution.promise;
        }
    }
    await (0, prepareRestart_js_1.prepareRestart)(route);
    return (0, exports.executeRoute)(route, executionOptions);
};
exports.resumeRoute = resumeRoute;
const executeSteps = async (route) => {
    for (let index = 0; index < route.steps.length; index++) {
        const execution = executionState_js_1.executionState.get(route.id);
        if (!execution) {
            break;
        }
        const step = route.steps[index];
        const previousStep = route.steps[index - 1];
        if (step.execution?.status === 'DONE') {
            continue;
        }
        if (previousStep?.execution?.toAmount) {
            step.action.fromAmount = previousStep.execution.toAmount;
            if (step.includedSteps?.length) {
                step.includedSteps[0].action.fromAmount =
                    previousStep.execution.toAmount;
            }
        }
        try {
            const fromAddress = step.action.fromAddress;
            if (!fromAddress) {
                throw new Error('Action fromAddress is not specified.');
            }
            const provider = config_js_1.config
                .get()
                .providers.find((provider) => provider.isAddress(fromAddress));
            if (!provider) {
                throw new Error('SDK Execution Provider not found.');
            }
            const stepExecutor = await provider.getStepExecutor({
                routeId: route.id,
                executionOptions: execution.executionOptions,
            });
            execution.executors.push(stepExecutor);
            if (execution.executionOptions) {
                (0, exports.updateRouteExecution)(route, execution.executionOptions);
            }
            const executedStep = await stepExecutor.executeStep(step);
            if (executedStep.execution?.status !== 'DONE') {
                (0, exports.stopRouteExecution)(route);
            }
            if (!stepExecutor.allowExecution) {
                return route;
            }
        }
        catch (e) {
            (0, exports.stopRouteExecution)(route);
            throw e;
        }
    }
    executionState_js_1.executionState.delete(route.id);
    return route;
};
const updateRouteExecution = (route, options) => {
    const execution = executionState_js_1.executionState.get(route.id);
    if (!execution) {
        return;
    }
    if ('executeInBackground' in options) {
        for (const executor of execution.executors) {
            executor.setInteraction({
                allowInteraction: !options?.executeInBackground,
                allowUpdates: true,
            });
        }
    }
    execution.executionOptions = {
        ...execution.executionOptions,
        ...options,
    };
};
exports.updateRouteExecution = updateRouteExecution;
const stopRouteExecution = (route) => {
    const execution = executionState_js_1.executionState.get(route.id);
    if (!execution) {
        return route;
    }
    for (const executor of execution.executors) {
        executor.setInteraction({
            allowInteraction: false,
            allowUpdates: false,
            allowExecution: false,
        });
    }
    executionState_js_1.executionState.delete(route.id);
    return execution.route;
};
exports.stopRouteExecution = stopRouteExecution;
const getActiveRoutes = () => {
    return Object.values(executionState_js_1.executionState.state)
        .map((dict) => dict?.route)
        .filter(Boolean);
};
exports.getActiveRoutes = getActiveRoutes;
const getActiveRoute = (routeId) => {
    return executionState_js_1.executionState.get(routeId)?.route;
};
exports.getActiveRoute = getActiveRoute;
//# sourceMappingURL=execution.js.map