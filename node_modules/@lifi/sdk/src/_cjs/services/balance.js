"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenBalancesByChain = exports.getTokenBalances = exports.getTokenBalance = void 0;
const types_1 = require("@lifi/types");
const config_js_1 = require("../config.js");
const errors_js_1 = require("../errors/errors.js");
const typeguards_js_1 = require("../typeguards.js");
const getTokenBalance = async (walletAddress, token) => {
    const tokenAmounts = await (0, exports.getTokenBalances)(walletAddress, [token]);
    return tokenAmounts.length ? tokenAmounts[0] : null;
};
exports.getTokenBalance = getTokenBalance;
const getTokenBalances = async (walletAddress, tokens) => {
    const tokensByChain = tokens.reduce((tokens, token) => {
        if (!tokens[token.chainId]) {
            tokens[token.chainId] = [];
        }
        tokens[token.chainId].push(token);
        return tokens;
    }, {});
    const tokenAmountsByChain = await (0, exports.getTokenBalancesByChain)(walletAddress, tokensByChain);
    return Object.values(tokenAmountsByChain).flat();
};
exports.getTokenBalances = getTokenBalances;
const getTokenBalancesByChain = async (walletAddress, tokensByChain) => {
    if (!walletAddress) {
        throw new errors_js_1.ValidationError('Missing walletAddress.');
    }
    const tokenList = Object.values(tokensByChain).flat();
    const invalidTokens = tokenList.filter((token) => !(0, typeguards_js_1.isToken)(token));
    if (invalidTokens.length) {
        throw new errors_js_1.ValidationError('Invalid tokens passed.');
    }
    const tokenAmountsByChain = {};
    const tokenAmountsSettled = await Promise.allSettled(Object.keys(tokensByChain).map(async (chainIdStr) => {
        const chainId = Number.parseInt(chainIdStr);
        const chain = await config_js_1.config.getChainById(chainId);
        const tokenAddress = tokensByChain[chainId][0].address;
        const provider = config_js_1.config
            .get()
            .providers.find((provider) => chain.chainType === types_1.ChainType.UTXO
            ? provider.isAddress(walletAddress)
            : provider.isAddress(tokenAddress));
        if (!provider) {
            throw new Error(`SDK Token Provider for ${chain.chainType} is not found.`);
        }
        const tokenAmounts = await provider.getBalance(walletAddress, tokensByChain[chainId]);
        tokenAmountsByChain[chainId] = tokenAmounts;
    }));
    if (config_js_1.config.get().debug) {
        for (const result of tokenAmountsSettled) {
            if (result.status === 'rejected') {
                console.warn("Couldn't fetch token balance.", result.reason);
            }
        }
    }
    return tokenAmountsByChain;
};
exports.getTokenBalancesByChain = getTokenBalancesByChain;
//# sourceMappingURL=balance.js.map