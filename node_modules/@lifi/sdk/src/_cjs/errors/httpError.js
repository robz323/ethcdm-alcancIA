"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPError = void 0;
const baseError_js_1 = require("./baseError.js");
const constants_js_1 = require("./constants.js");
const constants_js_2 = require("./constants.js");
const statusCodeToErrorClassificationMap = new Map([
    [
        400,
        { type: constants_js_2.ErrorName.ValidationError, code: constants_js_1.LiFiErrorCode.ValidationError },
    ],
    [404, { type: constants_js_2.ErrorName.NotFoundError, code: constants_js_1.LiFiErrorCode.NotFound }],
    [
        409,
        {
            type: constants_js_2.ErrorName.SlippageError,
            code: constants_js_1.LiFiErrorCode.SlippageError,
            message: constants_js_2.ErrorMessage.SlippageError,
        },
    ],
    [500, { type: constants_js_2.ErrorName.ServerError, code: constants_js_1.LiFiErrorCode.InternalError }],
]);
const getErrorClassificationFromStatusCode = (code) => statusCodeToErrorClassificationMap.get(code) ?? {
    type: constants_js_2.ErrorName.ServerError,
    code: constants_js_1.LiFiErrorCode.InternalError,
};
const createInitialMessage = (response) => {
    const statusCode = response.status || response.status === 0 ? response.status : '';
    const title = response.statusText || '';
    const status = `${statusCode} ${title}`.trim();
    const reason = status ? `status code ${status}` : 'an unknown error';
    return `Request failed with ${reason}`;
};
class HTTPError extends baseError_js_1.BaseError {
    constructor(response, url, options) {
        const errorClassification = getErrorClassificationFromStatusCode(response.status);
        const additionalMessage = errorClassification?.message
            ? `\n${errorClassification.message}`
            : '';
        const message = createInitialMessage(response) + additionalMessage;
        super(constants_js_2.ErrorName.HTTPError, errorClassification.code, message);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetchOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.type = errorClassification.type;
        this.response = response;
        this.status = response.status;
        this.message = message;
        this.url = url;
        this.fetchOptions = options;
    }
    async buildAdditionalDetails() {
        if (this.type) {
            this.message = `[${this.type}] ${this.message}`;
        }
        try {
            this.responseBody = await this.response.json();
            if (this.responseBody) {
                this.message += this.message.endsWith('.')
                    ? ` ${this.responseBody?.message.toString()}`
                    : `. ${this.responseBody?.message.toString()}`;
            }
        }
        catch { }
        return this;
    }
}
exports.HTTPError = HTTPError;
//# sourceMappingURL=httpError.js.map