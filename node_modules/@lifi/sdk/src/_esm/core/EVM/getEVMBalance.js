import { getBalance, getBlockNumber, multicall, readContract, } from 'viem/actions';
import { isZeroAddress } from '../../utils/isZeroAddress.js';
import { balanceOfAbi, getEthBalanceAbi } from './abi.js';
import { getPublicClient } from './publicClient.js';
import { getMulticallAddress } from './utils.js';
export const getEVMBalance = async (walletAddress, tokens) => {
    if (tokens.length === 0) {
        return [];
    }
    const { chainId } = tokens[0];
    for (const token of tokens) {
        if (token.chainId !== chainId) {
            console.warn('Requested tokens have to be on the same chain.');
        }
    }
    const multicallAddress = await getMulticallAddress(chainId);
    if (multicallAddress && tokens.length > 1) {
        return getEVMBalanceMulticall(chainId, tokens, walletAddress, multicallAddress);
    }
    return getEVMBalanceDefault(chainId, tokens, walletAddress);
};
const getEVMBalanceMulticall = async (chainId, tokens, walletAddress, multicallAddress) => {
    const client = await getPublicClient(chainId);
    const contracts = tokens.map((token) => {
        if (isZeroAddress(token.address)) {
            return {
                address: multicallAddress,
                abi: getEthBalanceAbi,
                functionName: 'getEthBalance',
                args: [walletAddress],
            };
        }
        return {
            address: token.address,
            abi: balanceOfAbi,
            functionName: 'balanceOf',
            args: [walletAddress],
        };
    });
    const blockNumber = await getBlockNumber(client);
    const results = await multicall(client, {
        contracts,
        multicallAddress: multicallAddress,
        blockNumber,
    });
    if (!results.length) {
        return [];
    }
    return tokens.map((token, i) => {
        return {
            ...token,
            amount: results[i].result,
            blockNumber,
        };
    });
};
const getEVMBalanceDefault = async (chainId, tokens, walletAddress) => {
    const client = await getPublicClient(chainId);
    const blockNumber = await getBlockNumber(client);
    const queue = tokens.map((token) => {
        if (isZeroAddress(token.address)) {
            return getBalance(client, {
                address: walletAddress,
            });
        }
        return readContract(client, {
            address: token.address,
            abi: balanceOfAbi,
            functionName: 'balanceOf',
            args: [walletAddress],
        });
    });
    const results = await Promise.allSettled(queue);
    const tokenAmounts = tokens.map((token, index) => {
        const result = results[index];
        if (result.status === 'rejected') {
            return {
                ...token,
                blockNumber,
            };
        }
        return {
            ...token,
            amount: result.value,
            blockNumber,
        };
    });
    return tokenAmounts;
};
//# sourceMappingURL=getEVMBalance.js.map