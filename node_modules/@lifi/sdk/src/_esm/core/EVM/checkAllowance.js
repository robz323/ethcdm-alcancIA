import { getAllowance } from './getAllowance.js';
import { parseEVMErrors } from './parseEVMErrors.js';
import { setAllowance } from './setAllowance.js';
import { waitForTransactionReceipt } from './waitForTransactionReceipt.js';
export const checkAllowance = async (client, chain, step, statusManager, settings, allowUserInteraction = false, shouldBatchTransactions = false) => {
    // Ask the user to set an allowance
    let allowanceProcess = statusManager.findOrCreateProcess({
        step,
        type: 'TOKEN_ALLOWANCE',
        chainId: step.action.fromChainId,
    });
    // Check allowance
    try {
        if (allowanceProcess.txHash && allowanceProcess.status !== 'DONE') {
            await waitForApprovalTransaction(client, allowanceProcess.txHash, allowanceProcess.type, step, chain, statusManager);
        }
        else {
            allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'STARTED');
            const approved = await getAllowance(chain.id, step.action.fromToken.address, client.account.address, step.estimate.approvalAddress);
            const fromAmount = BigInt(step.action.fromAmount);
            if (fromAmount > approved) {
                if (!allowUserInteraction) {
                    return;
                }
                if (shouldBatchTransactions) {
                    const approveTxHash = await setAllowance(client, step.action.fromToken.address, step.estimate.approvalAddress, fromAmount, settings, true);
                    allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'DONE');
                    return approveTxHash;
                }
                const approveTxHash = await setAllowance(client, step.action.fromToken.address, step.estimate.approvalAddress, fromAmount);
                await waitForApprovalTransaction(client, approveTxHash, allowanceProcess.type, step, chain, statusManager);
            }
            else {
                allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'DONE');
            }
        }
    }
    catch (e) {
        const error = await parseEVMErrors(e, step, allowanceProcess);
        allowanceProcess = statusManager.updateProcess(step, allowanceProcess.type, 'FAILED', {
            error: {
                message: error.cause.message,
                code: error.code,
            },
        });
        statusManager.updateExecution(step, 'FAILED');
        throw error;
    }
};
const waitForApprovalTransaction = async (client, txHash, processType, step, chain, statusManager) => {
    statusManager.updateProcess(step, processType, 'PENDING', {
        txHash,
        txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${txHash}`,
    });
    const transactionReceipt = await waitForTransactionReceipt({
        client: client,
        chainId: chain.id,
        txHash: txHash,
        onReplaced(response) {
            statusManager.updateProcess(step, processType, 'PENDING', {
                txHash: response.transaction.hash,
                txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${response.transaction.hash}`,
            });
        },
    });
    const transactionHash = transactionReceipt?.transactionHash || txHash;
    statusManager.updateProcess(step, processType, 'DONE', {
        txHash: transactionHash,
        txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${transactionHash}`,
    });
};
//# sourceMappingURL=checkAllowance.js.map