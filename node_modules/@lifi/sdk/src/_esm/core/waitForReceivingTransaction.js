import { ServerError } from '../errors/errors.js';
import { getStatus } from '../services/api.js';
import { waitForResult } from '../utils/waitForResult.js';
import { getSubstatusMessage } from './processMessages.js';
const TRANSACTION_HASH_OBSERVERS = {};
export async function waitForReceivingTransaction(txHash, statusManager, processType, step, interval = 5_000) {
    const _getStatus = () => {
        return getStatus({
            fromChain: step.action.fromChainId,
            toChain: step.action.toChainId,
            txHash,
            ...(step.tool !== 'custom' && { bridge: step.tool }),
        })
            .then((statusResponse) => {
            switch (statusResponse.status) {
                case 'DONE':
                    return statusResponse;
                case 'PENDING':
                    statusManager?.updateProcess(step, processType, 'PENDING', {
                        substatus: statusResponse.substatus,
                        substatusMessage: statusResponse.substatusMessage ||
                            getSubstatusMessage(statusResponse.status, statusResponse.substatus),
                        txLink: statusResponse.bridgeExplorerLink,
                    });
                    return undefined;
                case 'NOT_FOUND':
                    return undefined;
                default:
                    return Promise.reject();
            }
        })
            .catch((e) => {
            console.debug('Fetching status from backend failed.', e);
            return undefined;
        });
    };
    let status = TRANSACTION_HASH_OBSERVERS[txHash];
    if (!status) {
        status = waitForResult(_getStatus, interval);
        TRANSACTION_HASH_OBSERVERS[txHash] = status;
    }
    const resolvedStatus = await status;
    if (!('receiving' in resolvedStatus)) {
        throw new ServerError("Status doesn't contain receiving information.");
    }
    return resolvedStatus;
}
//# sourceMappingURL=waitForReceivingTransaction.js.map