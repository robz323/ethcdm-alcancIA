import { BaseError } from './baseError.js';
import { LiFiErrorCode } from './constants.js';
import { ErrorMessage, ErrorName } from './constants.js';
const statusCodeToErrorClassificationMap = new Map([
    [
        400,
        { type: ErrorName.ValidationError, code: LiFiErrorCode.ValidationError },
    ],
    [404, { type: ErrorName.NotFoundError, code: LiFiErrorCode.NotFound }],
    [
        409,
        {
            type: ErrorName.SlippageError,
            code: LiFiErrorCode.SlippageError,
            message: ErrorMessage.SlippageError,
        },
    ],
    [500, { type: ErrorName.ServerError, code: LiFiErrorCode.InternalError }],
]);
const getErrorClassificationFromStatusCode = (code) => statusCodeToErrorClassificationMap.get(code) ?? {
    type: ErrorName.ServerError,
    code: LiFiErrorCode.InternalError,
};
const createInitialMessage = (response) => {
    const statusCode = response.status || response.status === 0 ? response.status : '';
    const title = response.statusText || '';
    const status = `${statusCode} ${title}`.trim();
    const reason = status ? `status code ${status}` : 'an unknown error';
    return `Request failed with ${reason}`;
};
export class HTTPError extends BaseError {
    constructor(response, url, options) {
        const errorClassification = getErrorClassificationFromStatusCode(response.status);
        const additionalMessage = errorClassification?.message
            ? `\n${errorClassification.message}`
            : '';
        const message = createInitialMessage(response) + additionalMessage;
        super(ErrorName.HTTPError, errorClassification.code, message);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetchOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.type = errorClassification.type;
        this.response = response;
        this.status = response.status;
        this.message = message;
        this.url = url;
        this.fetchOptions = options;
    }
    async buildAdditionalDetails() {
        if (this.type) {
            this.message = `[${this.type}] ${this.message}`;
        }
        try {
            this.responseBody = await this.response.json();
            if (this.responseBody) {
                this.message += this.message.endsWith('.')
                    ? ` ${this.responseBody?.message.toString()}`
                    : `. ${this.responseBody?.message.toString()}`;
            }
        }
        catch { }
        return this;
    }
}
//# sourceMappingURL=httpError.js.map