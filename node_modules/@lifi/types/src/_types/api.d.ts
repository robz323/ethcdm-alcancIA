import type { BridgeDefinition } from './bridges.js';
import type { Chain, ChainId, ChainKey, ChainType } from './chains/index.js';
import type { ExchangeDefinition } from './exchanges.js';
import type { Action, FeeCost, LiFiStep, StepToolDetails } from './step.js';
import type { Token } from './tokens/index.js';
/**
 * Used as a bigint replacement for TransactionRequest because bigint is not serializable
 */
export type BigIntish = string;
/**
 * Pagination options for the API
 */
export interface PaginationQuery {
    limit?: number;
    next?: string;
    previous?: string;
}
/**
 * API response for paginated requests
 */
export interface PaginatedResponse<T> {
    hasNext?: boolean;
    hasPrevious?: boolean;
    next?: string;
    previous?: string;
    total?: number;
    data: T[];
}
export type TransactionRequest = {
    to?: string;
    from?: string;
    nonce?: number;
    gasLimit?: BigIntish;
    gasPrice?: BigIntish;
    data?: string;
    value?: BigIntish;
    chainId?: number;
    type?: number;
    accessList?: {
        address: string;
        storageKeys: string[];
    }[];
    maxPriorityFeePerGas?: BigIntish;
    maxFeePerGas?: BigIntish;
    customData?: Record<string, any>;
    ccipReadEnabled?: boolean;
};
/**
 * Timing options
 */
export interface TimingStrategyMinWaitTime {
    strategy: 'minWaitTime';
    minWaitTimeMs: number;
    startingExpectedResults: number;
    reduceEveryMs: number;
}
export type TimingStrategyMinWaitTimeString = `minWaitTime-${number}-${number}-${number}`;
export type TimingStrategy = TimingStrategyMinWaitTime;
export type TimingStrategyString = TimingStrategyMinWaitTimeString;
export interface Timing {
    swapStepTimingStrategies?: TimingStrategy[];
    routeTimingStrategies?: TimingStrategy[];
}
export interface TimingStrings {
    swapStepTimingStrategies?: TimingStrategyString[];
    routeTimingStrategies?: TimingStrategyString[];
}
/**
 * RECOMMENDED and SAFEST are deprecated as of 28.06.24
 * https://lifi.atlassian.net/browse/LF-8826
 */
export declare const Orders: readonly ["RECOMMENDED", "FASTEST", "CHEAPEST", "SAFEST"];
export type Order = (typeof Orders)[number];
export interface RoutesRequest {
    fromChainId: number;
    fromAmount: string;
    fromTokenAddress: string;
    fromAddress?: string;
    toChainId: number;
    toTokenAddress: string;
    toAddress?: string;
    options?: RouteOptions;
    fromAmountForGas?: string;
}
export interface RouteOptions {
    integrator?: string;
    fee?: number;
    maxPriceImpact?: number;
    order?: Order;
    slippage?: number;
    referrer?: string;
    allowSwitchChain?: boolean;
    allowDestinationCall?: boolean;
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    timing?: Timing;
    /**
     * @deprecated This property is deprecated and will be removed in future versions.
     */
    insurance?: boolean;
}
export type ToolsResponse = {
    exchanges: {
        key: string;
        name: string;
        logoURI: string;
        supportedChains: ChainId[];
    }[];
    bridges: {
        key: string;
        name: string;
        logoURI: string;
        supportedChains: {
            fromChainId: ChainId;
            toChainId: ChainId;
        }[];
    }[];
};
export interface AllowDenyPrefer {
    allow?: string[];
    deny?: string[];
    prefer?: string[];
}
/**
 * @deprecated _InsuranceState is deprecated and will be removed in future versions.
 */
export declare const _InsuranceState: readonly ["INSURED", "INSURABLE", "NOT_INSURABLE"];
/**
 * @deprecated InsuranceState is deprecated and will be removed in future versions.
 */
export type InsuranceState = (typeof _InsuranceState)[number];
/**
 * @deprecated InsuranceState is deprecated and will be removed in future versions.
 */
export interface Insurance {
    state: InsuranceState;
    feeAmountUsd: string;
}
export interface Route {
    id: string;
    insurance: Insurance;
    fromChainId: number;
    fromAmountUSD: string;
    fromAmount: string;
    fromToken: Token;
    fromAddress?: string;
    toChainId: number;
    toAmountUSD: string;
    toAmount: string;
    toAmountMin: string;
    toToken: Token;
    toAddress?: string;
    gasCostUSD?: string;
    containsSwitchChain?: boolean;
    steps: LiFiStep[];
    tags?: Order[];
}
export type ToolErrorType = 'NO_QUOTE';
export interface ToolError {
    errorType: ToolErrorType;
    code: string;
    action: Action;
    tool: string;
    message: string;
}
export type ErroredPaths = {
    [subpath: string]: ToolError[];
};
export type ErroredRoute = {
    overallPath: string;
    subpaths: ErroredPaths;
};
export type FilteredResult = {
    overallPath: string;
    reason: string;
};
export type UnavailableRoutes = {
    filteredOut: FilteredResult[];
    failed: ErroredRoute[];
};
export interface RoutesResponse {
    routes: Route[];
    unavailableRoutes: UnavailableRoutes;
}
export type PossibilityTopic = 'chains' | 'tokens' | 'bridges' | 'exchanges';
/**
 * We don't want to support this endpoint anymore in the future. /chains, /tools, /connections, and /tokens should be used instead
 * @deprecated
 */
export interface PossibilitiesRequest {
    chains?: number[];
    bridges?: AllowDenyPrefer;
    exchanges?: AllowDenyPrefer;
    include?: PossibilityTopic[];
}
/**
 * Should not be accessed via the types package anymore
 * @deprecated
 */
export interface PossibilitiesResponse {
    chains?: Chain[];
    tokens?: Token[];
    bridges?: BridgeDefinition[];
    exchanges?: ExchangeDefinition[];
}
export interface GetTokenRequest {
    chain: number | string;
    token: string;
}
export declare enum TokenHistoricGranularity {
    THIRTY_MIN = "30min",
    HOUR = "hour",
    DAY = "day",
    OVER_DAY = ">day"
}
export interface GetTokenHistoricRequest {
    chain: number | string;
    token: string;
    timestamp: number;
    granularity?: TokenHistoricGranularity;
}
export interface TokenPriceHistoricResponse {
    chainId: number;
    tokenAddress: string;
    isNativeToken: boolean;
    priceUSD: number;
    timestamp: number;
    granularity: TokenHistoricGranularity;
}
export interface ToolConfiguration {
    allowBridges?: string[];
    denyBridges?: string[];
    preferBridges?: string[];
    allowExchanges?: string[];
    denyExchanges?: string[];
    preferExchanges?: string[];
}
export interface QuoteRequest extends ToolConfiguration, TimingStrings {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    fromAmount: string;
    toChain: number | string;
    toToken: string;
    toAddress?: string;
    order?: Order;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
    allowDestinationCall?: boolean;
    fromAmountForGas?: string;
    maxPriceImpact?: number;
    skipSimulation?: boolean;
    /**
     * @deprecated This property is deprecated and will be removed in future versions.
     */
    insurance?: boolean;
}
export interface QuoteToAmountRequest extends Omit<QuoteRequest, 'fromAmount' | 'fromAmountForGas' | 'insurance'> {
    toAmount: string;
}
export interface ContractCall {
    fromAmount: string;
    fromTokenAddress: string;
    toContractAddress: string;
    toContractCallData: string;
    toContractGasLimit: string;
    toApprovalAddress?: string;
    toTokenAddress?: string;
}
type PartialContractCallsQuoteRequest = ToolConfiguration & {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toToken: string;
    toFallbackAddress?: string;
    contractOutputsToken?: string;
    contractCalls: ContractCall[];
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
    allowDestinationCall?: boolean;
};
export type ContractCallsQuoteRequestToAmount = PartialContractCallsQuoteRequest & {
    toAmount: string;
};
export type ContractCallsQuoteRequestFromAmount = PartialContractCallsQuoteRequest & {
    fromAmount: string;
};
export type ContractCallsQuoteRequest = ContractCallsQuoteRequestFromAmount | ContractCallsQuoteRequestToAmount;
export declare const isContractCallsRequestWithFromAmount: (r: ContractCallsQuoteRequestFromAmount | ContractCallsQuoteRequestToAmount) => r is ContractCallsQuoteRequestFromAmount;
export declare const isContractCallsRequestWithToAmount: (r: ContractCallsQuoteRequestFromAmount | ContractCallsQuoteRequestToAmount) => r is ContractCallsQuoteRequestToAmount;
export interface ContractCallQuoteRequest extends ToolConfiguration {
    fromChain: number | string;
    fromToken: string;
    fromAddress: string;
    toChain: number | string;
    toToken: string;
    toAmount: string;
    toContractAddress: string;
    toContractCallData: string;
    toContractGasLimit: string;
    toApprovalAddress?: string;
    toFallbackAddress?: string;
    contractOutputsToken?: string;
    slippage?: number | string;
    integrator?: string;
    referrer?: string;
    fee?: number | string;
    allowDestinationCall?: boolean;
}
export interface ConnectionsRequest extends ToolConfiguration {
    fromChain?: number | string;
    fromToken?: string;
    toChain?: number | string;
    toToken?: string;
    allowSwitchChain?: boolean;
    allowDestinationCall?: boolean;
    chainTypes?: ChainType[];
}
export interface Connection {
    fromChainId: number;
    toChainId: number;
    fromTokens: Token[];
    toTokens: Token[];
}
export interface ConnectionsResponse {
    connections: Connection[];
}
export interface GetStatusRequest {
    txHash: string;
    bridge?: string;
    fromChain?: number | string;
    toChain?: number | string;
}
export interface BaseTransactionInfo {
    txHash: string;
    chainId: ChainId;
    txLink: string;
}
export interface ExtendedTransactionInfo extends BaseTransactionInfo {
    amount?: string;
    amountUSD?: string;
    token?: Token;
    gasPrice: string;
    gasUsed: string;
    gasToken: Token;
    gasAmount: string;
    gasAmountUSD: string;
    timestamp?: number;
    value?: string;
    includedSteps?: IncludedStep[];
}
export interface PendingReceivingInfo {
    chainId: ChainId;
}
declare const _StatusMessage: readonly ["NOT_FOUND", "INVALID", "PENDING", "DONE", "FAILED"];
export type StatusMessage = (typeof _StatusMessage)[number];
declare const _SubstatusPending: readonly ["WAIT_SOURCE_CONFIRMATIONS", "WAIT_DESTINATION_TRANSACTION", "BRIDGE_NOT_AVAILABLE", "CHAIN_NOT_AVAILABLE", "REFUND_IN_PROGRESS", "UNKNOWN_ERROR"];
export type SubstatusPending = (typeof _SubstatusPending)[number];
declare const _SubstatusDone: readonly ["COMPLETED", "PARTIAL", "REFUNDED"];
export type SubstatusDone = (typeof _SubstatusDone)[number];
declare const _SubstatusFailed: readonly ["INSUFFICIENT_ALLOWANCE", "INSUFFICIENT_BALANCE", "OUT_OF_GAS", "EXPIRED", "SLIPPAGE_EXCEEDED", "UNKNOWN_FAILED_ERROR"];
export type SubstatusFailed = (typeof _SubstatusFailed)[number];
export type Substatus = SubstatusPending | SubstatusDone | SubstatusFailed;
export declare const isSubstatusPending: (substatus: Substatus) => substatus is SubstatusPending;
export declare const isSubstatusDone: (substatus: Substatus) => substatus is SubstatusDone;
export declare const isSubstatusFailed: (substatus: Substatus) => substatus is SubstatusFailed;
export interface BaseStatusData {
    status: StatusMessage;
    substatus?: Substatus;
    substatusMessage?: string;
}
export interface StatusData extends BaseStatusData {
    tool: string;
    sending: BaseTransactionInfo;
    receiving: PendingReceivingInfo;
}
export interface FailedStatusData extends BaseStatusData {
    status: 'FAILED';
    sending: BaseTransactionInfo;
}
export type StatusResponse = FullStatusData | StatusData | FailedStatusData;
interface TransferMetadata {
    integrator: string;
}
export type IncludedStep = {
    fromAmount: string;
    fromToken: Token;
    toAmount: string;
    toToken: Token;
    bridgedAmount?: string;
    tool: string;
    toolDetails: StepToolDetails;
};
export interface FullStatusData extends StatusData {
    transactionId: string;
    sending: ExtendedTransactionInfo;
    receiving: PendingReceivingInfo | ExtendedTransactionInfo;
    feeCosts: FeeCost[];
    lifiExplorerLink: string;
    fromAddress: string;
    toAddress: string;
    metadata: TransferMetadata;
    bridgeExplorerLink?: string;
}
export interface ExtendedChain extends Chain {
    nativeToken: Token;
    diamondAddress: string;
    permit2?: string;
    permit2Proxy?: string;
}
export interface ChainsResponse {
    chains: ExtendedChain[];
}
export interface ChainsRequest {
    chainTypes?: ChainType[];
}
export interface ToolsRequest {
    chains?: (ChainKey | ChainId)[];
}
export type TokensRequest = {
    chains?: (ChainId | ChainKey)[];
    chainTypes?: ChainType[];
    minPriceUSD?: number;
};
export type TokensResponse = {
    tokens: {
        [chainId: number]: Token[];
    };
};
export type RequestOptions = {
    signal?: AbortSignal;
};
export interface Integrator {
    integratorId: string;
    feeBalances: FeeBalance[];
}
export type FeeBalance = {
    chainId: ChainId;
    tokenBalances: TokenBalance[];
};
export type TokenBalance = {
    token: Token;
    amount: string;
    amountUsd: string;
};
export interface IntegratorWithdrawalRequest {
    integratorId: string;
    chainId: ChainId;
    tokens?: string[];
}
export interface IntegratorWithdrawalTransactionResponse {
    transactionRequest: TransactionRequest;
}
declare const _LIFuelState: readonly ["PENDING", "DONE", "NOT_FOUND"];
type LIFuelState = (typeof _LIFuelState)[number];
export type LIFuelStatusResponse = {
    status: LIFuelState;
    sending?: ExtendedTransactionInfo;
    receiving?: PendingReceivingInfo | ExtendedTransactionInfo;
};
export type GasRecommendationRequest = {
    chainId: ChainId;
    fromChain?: ChainId;
    fromToken?: string;
};
export type RefetchSourceLIFuelRequest = {
    txHash: string;
    chainId: ChainId;
};
export type LIFuelStatusRequest = {
    txHash: string;
};
export type RefetchLIFuelRequest = {
    txHash: string;
    chainId: ChainId;
};
export type GasRecommendationResponse = {
    available: boolean;
    message?: string;
    recommended?: TokenBalance;
    limit?: TokenBalance;
    serviceFee?: TokenBalance;
    fromToken?: Token;
    fromAmount?: string;
};
export interface TransactionAnalyticsResponse {
    transfers: StatusResponse[];
}
export type TransactionAnalyticsStatus = Exclude<StatusMessage, 'NOT_FOUND' | 'INVALID'> | 'ALL';
export interface TransactionAnalyticsRequest {
    wallet: string;
    fromTimestamp?: number;
    toTimestamp?: number;
    status?: TransactionAnalyticsStatus;
}
export interface CreateIntegratorRequest {
    name: string;
    integratorId: string;
    fee?: number;
    feeType?: IntegratorFeeType;
    defaultWallet?: string;
    chainWallets?: ChainWalletConfiguration;
}
export interface UpdateIntegratorRequest {
    name?: string;
    fee?: number;
    feeType?: IntegratorFeeType;
    defaultWallet?: string;
    chainWallets?: ChainWalletConfiguration;
}
export type IntegratorResult = {
    name: string;
    integratorId: string;
    fee: number;
    feeType: IntegratorFeeType;
    defaultWallet?: string;
    chainWallets?: ChainWalletConfiguration;
};
export type ChainWalletConfiguration = {
    [key in ChainId]?: string;
};
export declare enum IntegratorFeeType {
    FIXED = "FIXED",
    SHARED = "SHARED"
}
export type TransferSummary = {
    id: {
        toAddress: string;
        sendingChainId?: number;
    };
    totalReceivedAmount: number;
};
export interface TransferSummariesResponse extends PaginatedResponse<TransferSummary> {
}
export {};
//# sourceMappingURL=api.d.ts.map