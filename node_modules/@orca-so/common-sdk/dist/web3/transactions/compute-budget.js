"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLockWritableAccounts = exports.getPriorityFeeInLamports = exports.estimateComputeBudgetLimit = exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = exports.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = exports.DEFAULT_PRIORITY_FEE_PERCENTILE = exports.MICROLAMPORTS_PER_LAMPORT = void 0;
const web3_js_1 = require("@solana/web3.js");
exports.MICROLAMPORTS_PER_LAMPORT = 1000000;
exports.DEFAULT_PRIORITY_FEE_PERCENTILE = 0.9;
exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = 1000000; // 0.001 SOL
exports.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = 0; // 0 SOL
exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = 1400000;
async function estimateComputeBudgetLimit(connection, instructions, lookupTableAccounts, payer, margin) {
    try {
        const txMainInstructions = instructions.flatMap((instruction) => instruction.instructions);
        const txCleanupInstruction = instructions.flatMap((instruction) => instruction.cleanupInstructions);
        const txMessage = new web3_js_1.TransactionMessage({
            recentBlockhash: web3_js_1.PublicKey.default.toBase58(),
            payerKey: payer,
            instructions: [...txMainInstructions, ...txCleanupInstruction],
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(txMessage);
        const simulation = await connection.simulateTransaction(tx, { sigVerify: false, replaceRecentBlockhash: true });
        if (!simulation.value.unitsConsumed) {
            return exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
        }
        const marginUnits = Math.max(100000, margin * simulation.value.unitsConsumed);
        const estimatedUnits = Math.ceil(simulation.value.unitsConsumed + marginUnits);
        return Math.min(exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT, estimatedUnits);
    }
    catch {
        return exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
    }
}
exports.estimateComputeBudgetLimit = estimateComputeBudgetLimit;
async function getPriorityFeeInLamports(connection, computeBudgetLimit, lockedWritableAccounts, percentile = exports.DEFAULT_PRIORITY_FEE_PERCENTILE, getRecentPrioritizationFees) {
    const recentPriorityFees = await (getRecentPrioritizationFees ? getRecentPrioritizationFees(lockedWritableAccounts) : connection.getRecentPrioritizationFees({
        lockedWritableAccounts,
    }));
    const priorityFee = getPriorityFeeSuggestion(recentPriorityFees, percentile);
    return (priorityFee * computeBudgetLimit) / exports.MICROLAMPORTS_PER_LAMPORT;
}
exports.getPriorityFeeInLamports = getPriorityFeeInLamports;
function getPriorityFeeSuggestion(recentPriorityFees, percentile) {
    // Take the Xth percentile of all the slots returned
    const sortedPriorityFees = recentPriorityFees
        .sort((a, b) => a.prioritizationFee - b.prioritizationFee);
    const percentileIndex = Math.min(Math.max(Math.floor(sortedPriorityFees.length * percentile), 0), sortedPriorityFees.length - 1);
    return sortedPriorityFees[percentileIndex].prioritizationFee;
}
function getLockWritableAccounts(instructions) {
    return instructions
        .flatMap((instruction) => [...instruction.instructions, ...instruction.cleanupInstructions])
        .flatMap((instruction) => instruction.keys)
        .filter((key) => key.isWritable)
        .map((key) => key.pubkey);
}
exports.getLockWritableAccounts = getLockWritableAccounts;
