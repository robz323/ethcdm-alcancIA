"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  tavily: () => tavily
});
module.exports = __toCommonJS(src_exports);

// src/utils.ts
var import_axios = __toESM(require("axios"));
var import_js_tiktoken = require("js-tiktoken");
var BASE_URL = "https://api.tavily.com";
var DEFAULT_MODEL_ENCODING = "gpt-3.5-turbo";
var DEFAULT_MAX_TOKENS = 4e3;
function post(endpoint, body) {
  return __async(this, null, function* () {
    const url = `${BASE_URL}/${endpoint}`;
    return import_axios.default.post(url, body);
  });
}
function getTotalTokensFromString(str, encodingName = DEFAULT_MODEL_ENCODING) {
  const encoding = (0, import_js_tiktoken.encodingForModel)(encodingName);
  return encoding.encode(str).length;
}
function getMaxTokensFromList(data, maxTokens = DEFAULT_MAX_TOKENS) {
  var result = [];
  let currentTokens = 0;
  for (let item of data) {
    let itemString = JSON.stringify(item);
    let newTotalTokens = currentTokens + getTotalTokensFromString(itemString);
    if (newTotalTokens > maxTokens) {
      break;
    }
    result.push(item);
    currentTokens = newTotalTokens;
  }
  return JSON.stringify(result);
}

// src/search.ts
function _search(apiKey) {
  return function search(_0) {
    return __async(this, arguments, function* (query, options = {
      searchDepth: "basic",
      topic: "general",
      days: 3,
      maxResults: 5,
      includeImages: false,
      includeImageDescriptions: false,
      includeAnswer: false,
      includeRawContent: false,
      includeDomains: void 0,
      excludeDomains: void 0,
      maxTokens: void 0
    }) {
      const response = yield post("search", {
        api_key: apiKey,
        query,
        search_depth: options.searchDepth,
        topic: options.topic,
        days: options.days,
        max_results: options.maxResults,
        include_images: options.includeImages,
        include_image_descriptions: options.includeImageDescriptions,
        include_answer: options.includeAnswer,
        include_raw_content: options.includeRawContent,
        include_domains: options.includeDomains,
        exclude_domains: options.excludeDomains
      });
      return {
        query,
        responseTime: response.data.response_time,
        images: response.data.images.map((image) => {
          return {
            url: (image == null ? void 0 : image.url) || image,
            description: image.description
          };
        }),
        results: response.data.results.map((result) => {
          return {
            title: result.title,
            url: result.url,
            content: result.content,
            rawContent: result.raw_content,
            score: result.score,
            publishedDate: result.published_date
          };
        }),
        answer: response.data.answer
      };
    });
  };
}
function _searchQNA(apiKey) {
  return function searchQNA(_0) {
    return __async(this, arguments, function* (query, options = {
      searchDepth: "advanced",
      topic: "general",
      days: 3,
      maxResults: 5,
      includeImages: false,
      includeImageDescriptions: false,
      includeAnswer: false,
      includeRawContent: false,
      includeDomains: void 0,
      excludeDomains: void 0,
      maxTokens: void 0
    }) {
      const response = yield post("search", {
        api_key: apiKey,
        query,
        search_depth: options.searchDepth,
        topic: options.topic,
        days: options.days,
        max_results: options.maxResults,
        include_images: false,
        include_image_descriptions: false,
        include_answer: true,
        include_raw_content: false,
        include_domains: options.includeDomains,
        exclude_domains: options.excludeDomains
      });
      const answer = response.data.answer;
      return answer;
    });
  };
}
function _searchContext(apiKey) {
  return function searchContext(_0) {
    return __async(this, arguments, function* (query, options = {
      searchDepth: "basic",
      topic: "general",
      days: 3,
      maxResults: 5,
      includeImages: false,
      includeImageDescriptions: false,
      includeAnswer: false,
      includeRawContent: false,
      includeDomains: void 0,
      excludeDomains: void 0,
      maxTokens: DEFAULT_MAX_TOKENS
    }) {
      var _a;
      const response = yield post("search", {
        api_key: apiKey,
        query,
        search_depth: options.searchDepth,
        topic: options.topic,
        days: options.days,
        max_results: options.maxResults,
        include_images: false,
        include_image_descriptions: false,
        include_answer: false,
        include_raw_content: false,
        include_domains: options.includeDomains,
        exclude_domains: options.excludeDomains,
        max_tokens: options.maxTokens
      });
      const sources = ((_a = response.data) == null ? void 0 : _a.results) || [];
      const context = sources.map((source) => {
        return {
          url: source.url,
          content: source.content
        };
      });
      return JSON.stringify(getMaxTokensFromList(context, options.maxTokens));
    });
  };
}

// src/extract.ts
function _extract(apiKey) {
  return function extract(urls) {
    return __async(this, null, function* () {
      const response = yield post("extract", {
        api_key: apiKey,
        urls
      });
      return {
        responseTime: response.data.response_time,
        results: response.data.results.map((result) => {
          return {
            url: result.url,
            rawContent: result.raw_content
          };
        }),
        failedResults: response.data.failed_results.map((result) => {
          return {
            url: result.url,
            error: result.error
          };
        })
      };
    });
  };
}

// src/client.ts
function tavily(options) {
  const apiKey = (options == null ? void 0 : options.apiKey) || process.env.TAVILY_API_KEY;
  if (!apiKey) {
    throw new Error("No API key provided");
  }
  return {
    search: _search(apiKey),
    extract: _extract(apiKey),
    searchQNA: _searchQNA(apiKey),
    searchContext: _searchContext(apiKey)
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  tavily
});
//# sourceMappingURL=index.js.map