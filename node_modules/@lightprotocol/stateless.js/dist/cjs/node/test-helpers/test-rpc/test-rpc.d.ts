import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
import { AddressWithTree, CompressedMintTokenHolders, CompressedTransaction, GetCompressedAccountsByOwnerConfig, PaginatedOptions, HashWithTree, LatestNonVotingSignatures, LatestNonVotingSignaturesPaginated, SignatureWithMetadata, WithContext, WithCursor } from '../../rpc-interface';
import { CompressedProofWithContext, CompressionApiInterface, GetCompressedTokenAccountsByOwnerOrDelegateOptions, ParsedTokenAccount, TokenBalance } from '../../rpc-interface';
import { BN254, CompressedAccountWithMerkleContext, MerkleContextWithMerkleProof } from '../../state';
import { MerkleContextWithNewAddressProof } from '../../rpc';
export interface TestRpcConfig {
    /**
     * Address of the state tree to index. Default: public default test state
     * tree.
     */
    merkleTreeAddress?: PublicKey;
    /**
     * Nullifier queue associated with merkleTreeAddress
     */
    nullifierQueueAddress?: PublicKey;
    /**
     * Depth of state tree. Defaults to the public default test state tree depth
     */
    depth?: number;
    /**
     * Log proof generation time
     */
    log?: boolean;
    /**
     * Address of the address tree to index. Default: public default test
     * address tree.
     */
    addressTreeAddress?: PublicKey;
    /**
     * Address queue associated with addressTreeAddress
     */
    addressQueueAddress?: PublicKey;
}
export interface LightWasm {
    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;
    poseidonHash(input: string[] | BN[]): Uint8Array;
    poseidonHashString(input: string[] | BN[]): string;
    poseidonHashBN(input: string[] | BN[]): BN;
}
/**
 * Returns a mock RPC instance for use in unit tests.
 *
 * @param lightWasm               Wasm hasher instance.
 * @param endpoint                RPC endpoint URL. Defaults to
 *                                'http://127.0.0.1:8899'.
 * @param proverEndpoint          Prover server endpoint URL. Defaults to
 *                                'http://localhost:3001'.
 * @param merkleTreeAddress       Address of the merkle tree to index. Defaults
 *                                to the public default test state tree.
 * @param nullifierQueueAddress   Optional address of the associated nullifier
 *                                queue.
 * @param depth                   Depth of the merkle tree.
 * @param log                     Log proof generation time.
 */
export declare function getTestRpc(lightWasm: LightWasm, endpoint?: string, compressionApiEndpoint?: string, proverEndpoint?: string, merkleTreeAddress?: PublicKey, nullifierQueueAddress?: PublicKey, depth?: number, log?: boolean): Promise<TestRpc>;
/**
 * Simple mock rpc for unit tests that simulates the compression rpc interface.
 * Fetches, parses events and builds merkletree on-demand, i.e. it does not persist state.
 * Constraints:
 * - Can only index 1 merkletree
 * - Can only index up to 1000 transactions
 *
 * For advanced testing use photon: https://github.com/helius-labs/photon
 */
export declare class TestRpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    merkleTreeAddress: PublicKey;
    nullifierQueueAddress: PublicKey;
    addressTreeAddress: PublicKey;
    addressQueueAddress: PublicKey;
    lightWasm: LightWasm;
    depth: number;
    log: boolean;
    /**
     * Establish a Compression-compatible JSON RPC mock-connection
     *
     * @param endpoint                  endpoint to the solana cluster (use for
     *                                  localnet only)
     * @param hasher                    light wasm hasher instance
     * @param compressionApiEndpoint    Endpoint to the compression server.
     * @param proverEndpoint            Endpoint to the prover server. defaults
     *                                  to endpoint
     * @param connectionConfig          Optional connection config
     * @param testRpcConfig             Config for the mock rpc
     */
    constructor(endpoint: string, hasher: LightWasm, compressionApiEndpoint: string, proverEndpoint: string, connectionConfig?: ConnectionConfig, testRpcConfig?: TestRpcConfig);
    /**
     * Fetch the compressed account for the specified account hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(_slot: number): Promise<boolean>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, _config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(_cursor?: string, _limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch the latest non-voting signatures on the cluster. Results are
     * not paginated.
     */
    getLatestNonVotingSignatures(_limit?: number): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint.
     */
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<{
        balance: BN;
        mint: PublicKey;
    }[]>>;
    /**
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Uses context.
     */
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(_hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(_signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed
     * block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(_address: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    getCompressedMintTokenHolders(_mint: PublicKey, _options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Note: Use RPC class for forested trees. TestRpc is only for custom
     * testing purposes.
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * @deprecated This method is not available for TestRpc. Please use
     * {@link getValidityProof} instead.
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
}
