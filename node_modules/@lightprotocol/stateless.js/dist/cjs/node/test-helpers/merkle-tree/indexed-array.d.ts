import { LightWasm } from '../test-rpc/test-rpc';
import { BN } from '@coral-xyz/anchor';
export declare class IndexedElement {
    index: number;
    value: BN;
    nextIndex: number;
    constructor(index: number, value: BN, nextIndex: number);
    equals(other: IndexedElement): boolean;
    compareTo(other: IndexedElement): number;
    hash(lightWasm: LightWasm, nextValue: BN): Uint8Array;
}
export declare class IndexedElementBundle {
    newLowElement: IndexedElement;
    newElement: IndexedElement;
    newElementNextValue: BN;
    constructor(newLowElement: IndexedElement, newElement: IndexedElement, newElementNextValue: BN);
}
/**
 * This indexed array implementation mirrors the rust implementation of the
 * indexed merkle tree. It stores the elements of the indexed merkle tree.
 */
export declare class IndexedArray {
    elements: Array<IndexedElement>;
    currentNodeIndex: number;
    highestElementIndex: number;
    constructor(elements: Array<IndexedElement>, currentNodeIndex: number, highestElementIndex: number);
    static default(): IndexedArray;
    get(index: number): IndexedElement | undefined;
    length(): number;
    isEmpty(): boolean;
    findElement(value: BN): IndexedElement | undefined;
    init(): IndexedElementBundle;
    /**
     * Finds the index of the low element for the given `value` which should not be part of the array.
     * Low element is the greatest element which still has a lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElementIndex(value: BN): number | undefined;
    /**
     * Returns the low element for the given value and the next value for that low element.
     * Low element is the greatest element which still has lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElement(value: BN): [IndexedElement | undefined, BN | undefined];
    /**
     * Returns the hash of the given element. That hash consists of:
     * - The value of the given element.
     * - The `nextIndex` of the given element.
     * - The value of the element pointed by `nextIndex`.
     */
    hashElement(lightWasm: LightWasm, index: number): Uint8Array | undefined;
    /**
     * Appends a new element with the given value to the indexed array.
     * It finds the low element index and uses it to append the new element correctly.
     * @param value The value of the new element to append.
     * @returns The new element and its low element after insertion.
     */
    append(value: BN): IndexedElementBundle;
    /**
     * Appends a new element with the given value to the indexed array using a specific low element index.
     * This method ensures the new element is placed correctly relative to the low element.
     * @param lowElementIndex The index of the low element.
     * @param value The value of the new element to append.
     * @returns The new element and its updated low element.
     */
    appendWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Finds the lowest element in the array.
     * @returns The lowest element or undefined if the array is empty.
     */
    lowest(): IndexedElement | undefined;
    /**
     * Creates a new element with the specified value and updates the low element index accordingly.
     * @param lowElementIndex The index of the low element.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElementWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Creates a new element with the specified value by first finding the appropriate low element index.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElement(value: BN): IndexedElementBundle;
}
