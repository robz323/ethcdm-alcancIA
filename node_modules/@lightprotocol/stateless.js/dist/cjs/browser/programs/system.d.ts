import { Program, BN } from '@coral-xyz/anchor';
import { PublicKey, TransactionInstruction } from '@solana/web3.js';
import { LightSystemProgram as LightSystemProgramIDL } from '../idls/light_system_program';
import { CompressedAccount, CompressedAccountWithMerkleContext, CompressedProof } from '../state';
import { NewAddressParams } from '../utils';
export declare const sumUpLamports: (accounts: CompressedAccountWithMerkleContext[]) => BN;
/**
 * Create compressed account system transaction params
 */
type CreateAccountWithSeedParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * Address params for the new compressed account
     */
    newAddressParams: NewAddressParams;
    newAddress: number[];
    /**
     * Recent validity proof proving that there's no existing compressed account
     * registered with newAccountAddress
     */
    recentValidityProof: CompressedProof;
    /**
     * State tree pubkey. Defaults to a public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Public key of the program to assign as the owner of the created account
     */
    programId?: PublicKey;
    /**
     * Optional input accounts to transfer lamports from into the new compressed
     * account.
     */
    inputCompressedAccounts?: CompressedAccountWithMerkleContext[];
    /**
     * Optional input state root indices of 'inputCompressedAccounts'. The
     * expiry is tied to the 'recentValidityProof'.
     */
    inputStateRootIndices?: number[];
    /**
     * Optional lamports to transfer into the new compressed account.
     */
    lamports?: number | BN;
};
/**
 * Defines the parameters for the transfer method
 */
type TransferParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to transfer.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type CompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * address that the lamports are attached to. also defaults to the recipient owner
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to compress.
     */
    lamports: number | BN;
    /**
     * The state tree that the tx output should be inserted into. Defaults to a
     * public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type DecompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address of uncompressed lamports
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to decompress.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTree?: PublicKey;
};
export declare class LightSystemProgram {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    private static _program;
    static get program(): Program<LightSystemProgramIDL>;
    /**
     * @internal
     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY
     *
     */
    static deriveCompressedSolPda(): PublicKey;
    /**
     * Initializes the program statically if not already initialized.
     */
    private static initializeProgram;
    static createTransferOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], toAddress: PublicKey, lamports: number | BN): CompressedAccount[];
    static createDecompressOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], lamports: number | BN): CompressedAccount[];
    /**
     * No data by default
     */
    static createNewAddressOutputState(address: number[], owner: PublicKey, lamports?: BN | number, inputCompressedAccounts?: CompressedAccountWithMerkleContext[]): CompressedAccount[];
    /**
     * Creates instruction to create compressed account with PDA.
     * Cannot write data.
     *
     * TODO: support transfer of lamports to the new account.
     */
    static createAccount({ payer, newAddressParams, newAddress, recentValidityProof, outputStateTree, inputCompressedAccounts, inputStateRootIndices, lamports, }: CreateAccountWithSeedParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static transfer({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTrees, }: TransferParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static compress({ payer, toAddress, lamports, outputStateTree, }: CompressParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static decompress({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTree, }: DecompressParams): Promise<TransactionInstruction>;
}
/**
 * Selects the minimal number of compressed SOL accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
export declare function selectMinCompressedSolAccountsForTransfer(accounts: CompressedAccountWithMerkleContext[], transferLamports: BN | number): [selectedAccounts: CompressedAccountWithMerkleContext[], total: BN];
export {};
