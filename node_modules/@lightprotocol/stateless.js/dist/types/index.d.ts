import * as _solana_web3_js from '@solana/web3.js';
import { PublicKey, Connection, Commitment, Keypair, TransactionInstruction, AddressLookupTableAccount, VersionedTransaction, ConfirmOptions, TransactionSignature, RpcResponseAndContext, SignatureResult, Signer, DataSlice, MemcmpFilter, ConnectionConfig, AccountMeta, ParsedTransactionWithMeta } from '@solana/web3.js';
import { Buffer as Buffer$1 } from 'buffer';
import { Struct } from 'superstruct';
import { BN, Program } from '@coral-xyz/anchor';

/**
 * bignumber with <254-bit max size. Anchor serialization doesn't support native
 * bigint yet, so we wrap BN. This wrapper has simple base10 encoding which is
 * needed for zk circuit compat, in addition to the base58 encoding that users
 * are used to from working with the web3.js PublicKey type.
 */
type BN254 = BN;
declare const bn: (number: string | number | BN | Buffer$1 | Uint8Array | number[], base?: number | "hex" | undefined, endian?: BN.Endianness | undefined) => BN;
/** Create a bigint instance with <254-bit max size and base58 capabilities */
declare const createBN254: (number: string | number | BN | Buffer$1 | Uint8Array | number[], base?: number | "hex" | "base58" | undefined) => BN254;
/** Convert <254-bit bigint to Base58 string.  */
declare function encodeBN254toBase58(bigintNumber: BN): string;

declare function deriveAddressSeed(seeds: Uint8Array[], programId: PublicKey): Uint8Array;
/**
 * Derive an address for a compressed account from a seed and an address Merkle
 * tree public key.
 *
 * @param seed                     Seed to derive the address from
 * @param addressMerkleTreePubkey  Merkle tree public key. Defaults to
 *                                 defaultTestStateTreeAccounts().addressTree
 * @returns                        Derived address
 */
declare function deriveAddress(seed: Uint8Array, addressMerkleTreePubkey?: PublicKey): PublicKey;
interface NewAddressParams {
    /**
     * Seed for the compressed account. Must be seed used to derive
     * newAccountAddress
     */
    seed: Uint8Array;
    /**
     * Recent state root index of the address tree. The expiry is tied to the
     * validity proof.
     */
    addressMerkleTreeRootIndex: number;
    /**
     * Address tree pubkey. Must be base pubkey used to derive new address
     */
    addressMerkleTreePubkey: PublicKey;
    /**
     * Address space queue pubkey. Associated with the state tree.
     */
    addressQueuePubkey: PublicKey;
}
interface NewAddressParamsPacked {
    /**
     * Seed for the compressed account. Must be seed used to derive
     * newAccountAddress
     */
    seed: number[];
    /**
     * Recent state root index of the address tree. The expiry is tied to the
     * validity proof.
     */
    addressMerkleTreeRootIndex: number;
    /**
     * Index of the address merkle tree account in the remaining accounts array
     */
    addressMerkleTreeAccountIndex: number;
    /**
     * Index of the address queue account in the remaining accounts array
     */
    addressQueueAccountIndex: number;
}
/**
 * Packs new address params for instruction data in TypeScript clients
 *
 * @param newAddressParams      New address params
 * @param remainingAccounts     Remaining accounts
 * @returns                     Packed new address params
 */
declare function packNewAddressParams(newAddressParams: NewAddressParams[], remainingAccounts: PublicKey[]): {
    newAddressParamsPacked: NewAddressParamsPacked[];
    remainingAccounts: PublicKey[];
};

declare function airdropSol({ connection, lamports, recipientPublicKey, }: {
    connection: Connection;
    lamports: number;
    recipientPublicKey: PublicKey;
}): Promise<string>;
declare function confirmTransaction(connection: Connection, signature: string, confirmation?: Commitment): Promise<_solana_web3_js.RpcResponseAndContext<_solana_web3_js.SignatureResult>>;

declare function byteArrayToKeypair(byteArray: number[]): Keypair;
/**
 * @internal
 * convert BN to hex with '0x' prefix
 */
declare function toHex(bn: BN): string;
declare const toArray: <T>(value: T | T[]) => T[];
declare const bufToDecStr: (buf: Buffer$1) => string;
/**
 * Hash the provided `bytes` with Keccak256 and ensure the result fits in the
 * BN254 prime field by repeatedly hashing the inputs with various "bump seeds"
 * and truncating the resulting hash to 31 bytes.
 *
 * @deprecated Use `hashvToBn254FieldSizeBe` instead.
 */
declare function hashToBn254FieldSizeBe(bytes: Buffer$1): [Buffer$1, number] | null;
/**
 * Hash the provided `bytes` with Keccak256 and ensure that the result fits in
 * the BN254 prime field by truncating the resulting hash to 31 bytes.
 *
 * @param bytes Input bytes
 *
 * @returns     Hash digest
 */
declare function hashvToBn254FieldSizeBe(bytes: Uint8Array[]): Uint8Array;
/** Mutates array in place */
declare function pushUniqueItems<T>(items: T[], map: T[]): void;
declare function toCamelCase(obj: Array<any> | unknown | any): Array<any> | unknown | any;

interface GnarkProofJson {
    ar: string[];
    bs: string[][];
    krs: string[];
}
type ProofABC = {
    a: Uint8Array;
    b: Uint8Array;
    c: Uint8Array;
};
declare const placeholderValidityProof: () => {
    a: number[];
    b: number[];
    c: number[];
};
declare const checkValidityProofShape: (proof: CompressedProof) => void;
declare function proofFromJsonStruct(json: GnarkProofJson): ProofABC;
declare function negateAndCompressProof(proof: ProofABC): CompressedProof;

/** pipe function */
declare function pipe<T, R>(initialFunction: (arg: T) => R, ...functions: ((arg: R) => R)[]): (initialValue: T) => R;

/**
 * Builds a versioned Transaction from instructions.
 *
 * @param instructions          instructions to include
 * @param payerPublicKey        fee payer public key
 * @param blockhash             blockhash to use
 * @param lookupTableAccounts   lookup table accounts to include
 *
 * @return VersionedTransaction
 */
declare function buildTx(instructions: TransactionInstruction[], payerPublicKey: PublicKey, blockhash: string, lookupTableAccounts?: AddressLookupTableAccount[]): VersionedTransaction;
/**
 * Sends a versioned transaction and confirms it.
 *
 * @param rpc               connection to use
 * @param tx                versioned transaction to send
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 *
 * @return TransactionSignature
 */
declare function sendAndConfirmTx(rpc: Rpc, tx: VersionedTransaction, confirmOptions?: ConfirmOptions, blockHashCtx?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<TransactionSignature>;
/**
 * Confirms a transaction with a given txId.
 *
 * @param rpc               connection to use
 * @param txId              transaction signature to confirm
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 * @return SignatureResult
 */
declare function confirmTx(rpc: Rpc, txId: string, confirmOptions?: ConfirmOptions, blockHashCtx?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<RpcResponseAndContext<SignatureResult>>;
/**
 * Builds a versioned Transaction from instructions and signs it.
 *
 * @param instructions          instructions to include in the transaction
 * @param payer                 payer of the transaction
 * @param blockhash             recent blockhash to use in the transaction
 * @param additionalSigners     non-feepayer signers to include in the
 *                              transaction
 * @param lookupTableAccounts   lookup table accounts to include in the
 *                              transaction
 */
declare function buildAndSignTx(instructions: TransactionInstruction[], payer: Signer, blockhash: string, additionalSigners?: Signer[], lookupTableAccounts?: AddressLookupTableAccount[]): VersionedTransaction;

declare function sleep(ms: number): Promise<void>;

declare const ALICE: Keypair;
declare const BOB: Keypair;
declare const CHARLIE: Keypair;
declare const DAVE: Keypair;
/**
 * Create a new account and airdrop lamports to it
 *
 * @param rpc       connection to use
 * @param lamports  amount of lamports to airdrop
 * @param counter   counter to use for generating the keypair.
 *                  If undefined or >255, generates random keypair.
 */
declare function newAccountWithLamports(rpc: Rpc, lamports?: number, counter?: number | undefined): Promise<Signer>;
declare function getConnection(): Connection;
/**
 * For use in tests.
 * Generate a unique keypair by passing in a counter <255. If no counter
 * is supplied, it uses and increments a global counter.
 * if counter > 255, generates random keypair
 */
declare function getTestKeypair(counter?: number | undefined): Keypair;

declare const validateSufficientBalance: (balance: BN) => void;
declare const validateSameOwner: (compressedAccounts: CompressedAccount[] | CompressedAccountWithMerkleContext[]) => void;

/**
 * @param targetLamports - Target priority fee in lamports
 * @param computeUnits - Expected compute units used by the transaction
 * @returns microLamports per compute unit (use in
 * `ComputeBudgetProgram.setComputeUnitPrice`)
 */
declare function calculateComputeUnitPrice(targetLamports: number, computeUnits: number): number;

interface PackedCompressedAccountWithMerkleContext {
    compressedAccount: CompressedAccount;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    readOnly: boolean;
}
interface PackedMerkleContext {
    merkleTreePubkeyIndex: number;
    nullifierQueuePubkeyIndex: number;
    leafIndex: number;
    queueIndex: null | QueueIndex;
}
interface QueueIndex {
    queueId: number;
    index: number;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
interface CompressedAccount {
    /** Public key of program or user that owns the account */
    owner: PublicKey;
    /** Lamports attached to the account */
    lamports: BN;
    /**
     * TODO: use PublicKey. Optional unique account ID that is persistent across
     * transactions.
     */
    address: number[] | null;
    /** Optional data attached to the account */
    data: CompressedAccountData | null;
}
/**
 * Describe the generic compressed account details applicable to every
 * compressed account.
 * */
interface OutputCompressedAccountWithPackedContext {
    compressedAccount: CompressedAccount;
    merkleTreeIndex: number;
}
interface CompressedAccountData {
    discriminator: number[];
    data: Buffer$1;
    dataHash: number[];
}
interface PublicTransactionEvent {
    inputCompressedAccountHashes: number[][];
    outputCompressedAccountHashes: number[][];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    outputLeafIndices: number[];
    relayFee: BN | null;
    isCompress: boolean;
    compressOrDecompressLamports: BN | null;
    pubkeyArray: PublicKey[];
    message: Uint8Array | null;
}
interface InstructionDataInvoke {
    proof: CompressedProof | null;
    inputCompressedAccountsWithMerkleContext: PackedCompressedAccountWithMerkleContext[];
    outputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    relayFee: BN | null;
    newAddressParams: NewAddressParamsPacked[];
    compressOrDecompressLamports: BN | null;
    isCompress: boolean;
}
interface CompressedProof {
    a: number[];
    b: number[];
    c: number[];
}
/**
 * Compressed-token types
 *
 * TODO: Token-related code should ideally not have to go into stateless.js.
 * Find a better altnerative way to extend the RPC.
 *
 */
type TokenTransferOutputData = {
    owner: PublicKey;
    amount: BN;
    lamports: BN | null;
    tlv: Buffer$1 | null;
};
type CompressedTokenInstructionDataTransfer = {
    proof: CompressedProof | null;
    mint: PublicKey;
    delegatedTransfer: null;
    inputTokenDataWithContext: InputTokenDataWithContext[];
    outputCompressedAccounts: TokenTransferOutputData[];
    isCompress: boolean;
    compressOrDecompressAmount: BN | null;
    cpiContext: null;
    lamportsChangeAccountMerkleTreeIndex: number | null;
};
interface InputTokenDataWithContext {
    amount: BN;
    delegateIndex: number | null;
    merkleContext: PackedMerkleContext;
    rootIndex: number;
    lamports: BN | null;
    tlv: Buffer$1 | null;
}
type TokenData$1 = {
    mint: PublicKey;
    owner: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: number;
    tlv: Buffer$1 | null;
};

type CompressedAccountWithMerkleContext = CompressedAccount & MerkleContext & {
    readOnly: boolean;
};
/**
 * Context for compressed account inserted into a state Merkle tree
 * */
type MerkleContext = {
    /** State Merkle tree */
    merkleTree: PublicKey;
    /** The state nullfier queue belonging to merkleTree */
    nullifierQueue: PublicKey;
    /** Poseidon hash of the utxo preimage. Is a leaf in state merkle tree  */
    hash: number[];
    /** 'hash' position within the Merkle tree */
    leafIndex: number;
};
type MerkleContextWithMerkleProof = MerkleContext & {
    /** Recent valid 'hash' proof path, expires after n slots */
    merkleProof: BN254[];
    /** Index of state root the merkleproof is valid for, expires after n slots */
    rootIndex: number;
    /** Current root */
    root: BN254;
};
declare const createCompressedAccount: (owner: PublicKey, lamports?: BN, data?: CompressedAccountData, address?: number[]) => CompressedAccount;
declare const createCompressedAccountWithMerkleContext: (merkleContext: MerkleContext, owner: PublicKey, lamports?: BN, data?: CompressedAccountData, address?: number[]) => CompressedAccountWithMerkleContext;
declare const createMerkleContext: (merkleTree: PublicKey, nullifierQueue: PublicKey, hash: number[], leafIndex: number) => MerkleContext;

interface LatestNonVotingSignatures {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
            error: string | null;
        }[];
    };
}
interface GetCompressedAccountsByOwnerConfig {
    filters?: GetCompressedAccountsFilter[];
    dataSlice?: DataSlice;
    cursor?: string;
    limit?: BN;
}
interface CompressedMintTokenHolders {
    balance: BN;
    owner: PublicKey;
}
interface LatestNonVotingSignaturesPaginated {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
        }[];
        cursor: string | null;
    };
}
interface SignatureWithMetadata {
    blockTime: number;
    signature: string;
    slot: number;
}
interface HashWithTree {
    hash: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
interface AddressWithTree {
    address: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
interface CompressedTransaction {
    compressionInfo: {
        closedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData$1 | null;
        }[];
        openedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData$1 | null;
        }[];
        preTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
        postTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
    };
    transaction: any;
}
interface HexBatchInputsForProver {
    'input-compressed-accounts': HexInputsForProver[];
}
interface HexInputsForProver {
    root: string;
    pathIndex: number;
    pathElements: string[];
    leaf: string;
}
type CompressedProofWithContext = {
    compressedProof: CompressedProof;
    roots: BN[];
    rootIndices: number[];
    leafIndices: number[];
    leaves: BN[];
    merkleTrees: PublicKey[];
    nullifierQueues: PublicKey[];
};
interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {
    mint?: PublicKey;
    cursor?: string;
    limit?: BN;
}
type TokenBalance = {
    balance: BN;
    mint: PublicKey;
};
/**
 * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.
 *
 * **Limit** is the maximum number of results to return per page.
 */
interface PaginatedOptions {
    cursor?: string;
    limit?: BN;
}
/**
 * Note, DataSizeFilter is currently not available.
 */
type GetCompressedAccountsFilter = MemcmpFilter;
type GetCompressedAccountConfig = {
    encoding?: string;
};
type GetCompressedAccountsConfig = {
    dataSlice: DataSlice;
    filters?: GetCompressedAccountsFilter[];
};
interface ParsedTokenAccount {
    compressedAccount: CompressedAccountWithMerkleContext;
    parsed: TokenData$1;
}
type WithContext<T> = {
    /** context */
    context: {
        slot: number;
    };
    /** response value */
    value: T;
};
type WithCursor<T> = {
    /** context */
    cursor: string | null;
    /** response value */
    items: T;
};
/**
 * @internal
 */
declare function createRpcResult<T, U>(result: Struct<T, U>): Struct<RpcResult<T>, null>;
/**
 * @internal
 */
declare function jsonRpcResult<T, U>(schema: Struct<T, U>): Struct<RpcResult<T>, null>;
type WithRpcContext<T> = {
    context: {
        slot: number;
    };
    value: T;
};
/**
 * @internal
 */
declare function jsonRpcResultAndContext<T, U>(value: Struct<T, U>): Struct<RpcResult<WithRpcContext<T>>, null>;
/**
 * @internal
 */
declare const CompressedAccountResult: Struct<{
    owner: PublicKey;
    lamports: BN;
    address: number[] | null;
    data: {
        data: string;
        discriminator: BN;
        dataHash: BN;
    } | null;
    leafIndex: number;
    seq: BN | null;
    hash: BN;
    tree: PublicKey;
    slotCreated: BN;
}, {
    address: Struct<number[] | null, null>;
    hash: Struct<BN, null>;
    data: Struct<{
        data: string;
        discriminator: BN;
        dataHash: BN;
    } | null, {
        data: Struct<string, null>;
        dataHash: Struct<BN, null>;
        discriminator: Struct<BN, null>;
    }>;
    lamports: Struct<BN, null>;
    owner: Struct<PublicKey, null>;
    leafIndex: Struct<number, null>;
    tree: Struct<PublicKey, null>;
    seq: Struct<BN | null, null>;
    slotCreated: Struct<BN, null>;
}>;
declare const TokenDataResult: Struct<{
    owner: PublicKey;
    mint: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: string;
}, {
    mint: Struct<PublicKey, null>;
    owner: Struct<PublicKey, null>;
    amount: Struct<BN, null>;
    delegate: Struct<PublicKey | null, null>;
    state: Struct<string, null>;
}>;
/**
 * @internal
 */
declare const CompressedTokenAccountResult: Struct<{
    tokenData: {
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    };
    account: {
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    };
}, {
    tokenData: Struct<{
        owner: PublicKey;
        mint: PublicKey;
        amount: BN;
        delegate: PublicKey | null;
        state: string;
    }, {
        mint: Struct<PublicKey, null>;
        owner: Struct<PublicKey, null>;
        amount: Struct<BN, null>;
        delegate: Struct<PublicKey | null, null>;
        state: Struct<string, null>;
    }>;
    account: Struct<{
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>;
}>;
/**
 * @internal
 */
declare const MultipleCompressedAccountsResult: Struct<{
    items: {
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[];
}, {
    items: Struct<{
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[], Struct<{
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
}>;
/**
 * @internal
 */
declare const CompressedAccountsByOwnerResult: Struct<{
    items: {
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[], Struct<{
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const CompressedTokenAccountsByOwnerOrDelegateResult: Struct<{
    items: {
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
    }[], Struct<{
        tokenData: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        };
        account: {
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
    }, {
        tokenData: Struct<{
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
            delegate: PublicKey | null;
            state: string;
        }, {
            mint: Struct<PublicKey, null>;
            owner: Struct<PublicKey, null>;
            amount: Struct<BN, null>;
            delegate: Struct<PublicKey | null, null>;
            state: Struct<string, null>;
        }>;
        account: Struct<{
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        }, {
            address: Struct<number[] | null, null>;
            hash: Struct<BN, null>;
            data: Struct<{
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null, {
                data: Struct<string, null>;
                dataHash: Struct<BN, null>;
                discriminator: Struct<BN, null>;
            }>;
            lamports: Struct<BN, null>;
            owner: Struct<PublicKey, null>;
            leafIndex: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            seq: Struct<BN | null, null>;
            slotCreated: Struct<BN, null>;
        }>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const SlotResult: Struct<number, null>;
/**
 * @internal
 */
declare const HealthResult: Struct<string, null>;
/**
 * @internal
 */
declare const LatestNonVotingSignaturesResult: Struct<{
    items: {
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }[];
}, {
    items: Struct<{
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        error: string | null;
        slot: number;
        blockTime: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
        error: Struct<string | null, null>;
    }>>;
}>;
/**
 * @internal
 */
declare const LatestNonVotingSignaturesResultPaginated: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
declare const MerkeProofResult: Struct<{
    proof: BN[];
    leafIndex: number;
    root: BN;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>;
/**
 * @internal
 */
declare const NewAddressProofResult: Struct<{
    proof: BN[];
    address: BN;
    root: BN;
    merkleTree: PublicKey;
    rootSeq: number;
    nextIndex: number;
    lowerRangeAddress: BN;
    higherRangeAddress: BN;
    lowElementLeafIndex: number;
}, {
    address: Struct<BN, null>;
    nextIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
    lowerRangeAddress: Struct<BN, null>;
    higherRangeAddress: Struct<BN, null>;
    lowElementLeafIndex: Struct<number, null>;
}>;
/**
 * @internal
 */
declare const ValidityProofResult: Struct<{
    compressedProof: {
        a: number[];
        b: number[];
        c: number[];
    };
    leafIndices: number[];
    leaves: BN[];
    rootIndices: number[];
    roots: BN[];
    merkleTrees: PublicKey[];
}, {
    compressedProof: Struct<{
        a: number[];
        b: number[];
        c: number[];
    }, {
        a: Struct<number[], Struct<number, null>>;
        b: Struct<number[], Struct<number, null>>;
        c: Struct<number[], Struct<number, null>>;
    }>;
    leafIndices: Struct<number[], Struct<number, null>>;
    leaves: Struct<BN[], Struct<BN, null>>;
    rootIndices: Struct<number[], Struct<number, null>>;
    roots: Struct<BN[], Struct<BN, null>>;
    merkleTrees: Struct<PublicKey[], Struct<PublicKey, null>>;
}>;
/**
 * @internal
 */
declare const MultipleMerkleProofsResult: Struct<{
    proof: BN[];
    leafIndex: number;
    root: BN;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}[], Struct<{
    proof: BN[];
    leafIndex: number;
    root: BN;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>>;
/**
 * @internal
 */
declare const BalanceResult: Struct<{
    amount: BN;
}, {
    amount: Struct<BN, null>;
}>;
declare const NativeBalanceResult: Struct<BN, null>;
declare const TokenBalanceResult: Struct<{
    mint: PublicKey;
    balance: BN;
}, {
    balance: Struct<BN, null>;
    mint: Struct<PublicKey, null>;
}>;
declare const TokenBalanceListResult: Struct<{
    cursor: string | null;
    tokenBalances: {
        mint: PublicKey;
        balance: BN;
    }[];
}, {
    tokenBalances: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const TokenBalanceListResultV2: Struct<{
    items: {
        mint: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const CompressedMintTokenHoldersResult: Struct<{
    items: {
        owner: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    cursor: Struct<string | null, null>;
    items: Struct<{
        owner: PublicKey;
        balance: BN;
    }[], Struct<{
        owner: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
    }>>;
}>;
declare const AccountProofResult: Struct<{
    proof: number[][];
    root: number[];
    hash: number[];
}, {
    hash: Struct<number[], Struct<number, null>>;
    root: Struct<number[], Struct<number, null>>;
    proof: Struct<number[][], Struct<number[], Struct<number, null>>>;
}>;
declare const toUnixTimestamp: (blockTime: string) => number;
declare const SignatureListResult: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
}>;
declare const SignatureListWithCursorResult: Struct<{
    items: {
        signature: string;
        slot: number;
        blockTime: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }[], Struct<{
        signature: string;
        slot: number;
        blockTime: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
declare const CompressedTransactionResult: Struct<{
    compressionInfo: {
        closedAccounts: {
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    };
    transaction?: any;
}, {
    compressionInfo: Struct<{
        closedAccounts: {
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
        openedAccounts: {
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[];
    }, {
        closedAccounts: Struct<{
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
        openedAccounts: Struct<{
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }[], Struct<{
            account: {
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null;
        }, {
            account: Struct<{
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                owner: PublicKey;
                mint: PublicKey;
                amount: BN;
                delegate: PublicKey | null;
                state: string;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
    }>;
    transaction: Struct<any, null>;
}>;
interface CompressionApiInterface {
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    getValidityProof(hashes: BN254[], newAddresses: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<CompressedProofWithContext>;
    getValidityProofAndRpcContext(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    getCompressedTokenAccountsByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    getIndexerHealth(): Promise<string>;
    getIndexerSlot(): Promise<number>;
}
type RpcResultSuccess<T> = {
    jsonrpc: '2.0';
    id: string;
    result: T;
};
type RpcResultError = {
    jsonrpc: '2.0';
    id: string;
    error: {
        code: unknown;
        message: string;
        data?: any;
    };
};
type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;

/** @internal */
declare function parseAccountData({ discriminator, data, dataHash, }: {
    discriminator: BN;
    data: string;
    dataHash: BN;
}): {
    discriminator: number[];
    data: Buffer$1;
    dataHash: number[];
};
/**
 * Establish a Compression-compatible JSON RPC connection
 *
 * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or
 *                                      Connection object
 * @param compressionApiEndpoint        Endpoint to the compression server
 * @param proverEndpoint                Endpoint to the prover server. defaults
 *                                      to endpoint
 * @param connectionConfig              Optional connection config
 */
declare function createRpc(endpointOrWeb3JsConnection?: string | Connection, compressionApiEndpoint?: string, proverEndpoint?: string, config?: ConnectionConfig): Rpc;
/** @internal */
declare const rpcRequest: (rpcEndpoint: string, method: string, params?: any, convertToCamelCase?: boolean, debug?: boolean) => Promise<any>;
/** @internal */
declare const proverRequest: (proverEndpoint: string, method: "inclusion" | "new-address" | "combined", params?: any, log?: boolean) => Promise<CompressedProof>;
type NonInclusionMerkleProofInputs = {
    root: BN;
    value: BN;
    leaf_lower_range_value: BN;
    leaf_higher_range_value: BN;
    nextIndex: BN;
    merkle_proof_hashed_indexed_element_leaf: BN[];
    index_hashed_indexed_element_leaf: BN;
};
type MerkleContextWithNewAddressProof = {
    root: BN;
    rootIndex: number;
    value: BN;
    leafLowerRangeValue: BN;
    leafHigherRangeValue: BN;
    nextIndex: BN;
    merkleProofHashedIndexedElementLeaf: BN[];
    indexHashedIndexedElementLeaf: BN;
    merkleTree: PublicKey;
    nullifierQueue: PublicKey;
};
type NonInclusionJsonStruct = {
    root: string;
    value: string;
    pathIndex: number;
    pathElements: string[];
    leafLowerRangeValue: string;
    leafHigherRangeValue: string;
    nextIndex: number;
};
declare function convertMerkleProofsWithContextToHex(merkleProofsWithContext: MerkleContextWithMerkleProof[]): HexInputsForProver[];
declare function convertNonInclusionMerkleProofInputsToHex(nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[]): NonInclusionJsonStruct[];
/**
 *
 */
declare class Rpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    /**
     * Establish a Compression-compatible JSON RPC connection
     *
     * @param endpoint                      Endpoint to the solana cluster
     * @param compressionApiEndpoint        Endpoint to the compression server
     * @param proverEndpoint                Endpoint to the prover server.
     * @param connectionConfig              Optional connection config
     */
    constructor(endpoint: string, compressionApiEndpoint: string, proverEndpoint: string, config?: ConnectionConfig);
    /**
     * Fetch the compressed account for the specified account address or hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account address or hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig | undefined): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.
     *
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Returns without context.
     */
    getCompressedTokenBalancesByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    /**
     * Fetch the compressed token balances owned by the specified public
     * key. Paginated. Can filter by mint. Returns with context.
     */
    getCompressedTokenBalancesByOwnerV2(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed compression signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(slot: number): Promise<boolean>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch all the compressed token holders for a given mint. Paginated.
     */
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch all non-voting signatures
     */
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in
     * respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.
     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.
     * @returns             validity proof with context
     */
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses. Returns with context slot.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses. Optionally specify the
     *                      tree and queue for each address. Default to public
     *                      state tree/queue.
     * @returns             validity proof with context
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
}

/**
 * Compress lamports to a solana address
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
declare function compress(rpc: Rpc, payer: Signer, lamports: number | BN, toAddress: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Create compressed account with address
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
declare function createAccount(rpc: Rpc, payer: Signer, seeds: Uint8Array[], programId: PublicKey, addressTree?: PublicKey, addressQueue?: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
/**
 * Create compressed account with address and lamports
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param lamports          Number of compressed lamports to initialize the
 *                          account with
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
declare function createAccountWithLamports(rpc: Rpc, payer: Signer, seeds: Uint8Array[], lamports: number | BN, programId: PublicKey, addressTree?: PublicKey, addressQueue?: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Decompress lamports into a solana account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
declare function decompress(rpc: Rpc, payer: Signer, lamports: number | BN, recipient: PublicKey, outputStateTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/** @internal remove signer from signers if part of signers */
declare function dedupeSigner(signer: Signer, signers: Signer[]): Signer[];

/**
 * Transfer compressed lamports from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of transaction fees
 * @param lamports       Number of lamports to transfer
 * @param owner          Owner of the compressed lamports
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed lamports should be
 *                       inserted into. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 * @param config         Configuration for fetching compressed accounts
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function transfer(rpc: Rpc, payer: Signer, lamports: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

type AccountCompression = {
    version: '1.2.0';
    name: 'account_compression';
    constants: [
        {
            name: 'CPI_AUTHORITY_PDA_SEED';
            type: 'bytes';
            value: '[99, 112, 105, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]';
        },
        {
            name: 'GROUP_AUTHORITY_SEED';
            type: 'bytes';
            value: '[103, 114, 111, 117, 112, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]';
        },
        {
            name: 'STATE_MERKLE_TREE_HEIGHT';
            type: 'u64';
            value: '26';
        },
        {
            name: 'STATE_MERKLE_TREE_CHANGELOG';
            type: 'u64';
            value: '1400';
        },
        {
            name: 'STATE_MERKLE_TREE_ROOTS';
            type: 'u64';
            value: '2400';
        },
        {
            name: 'STATE_MERKLE_TREE_CANOPY_DEPTH';
            type: 'u64';
            value: '10';
        },
        {
            name: 'STATE_NULLIFIER_QUEUE_VALUES';
            type: 'u16';
            value: '28_807';
        },
        {
            name: 'STATE_NULLIFIER_QUEUE_SEQUENCE_THRESHOLD';
            type: 'u64';
            value: '2400';
        },
        {
            name: 'ADDRESS_MERKLE_TREE_HEIGHT';
            type: 'u64';
            value: '26';
        },
        {
            name: 'ADDRESS_MERKLE_TREE_CHANGELOG';
            type: 'u64';
            value: '1400';
        },
        {
            name: 'ADDRESS_MERKLE_TREE_ROOTS';
            type: 'u64';
            value: '2400';
        },
        {
            name: 'ADDRESS_MERKLE_TREE_CANOPY_DEPTH';
            type: 'u64';
            value: '10';
        },
        {
            name: 'ADDRESS_MERKLE_TREE_INDEXED_CHANGELOG';
            type: 'u64';
            value: '1400';
        },
        {
            name: 'ADDRESS_QUEUE_VALUES';
            type: 'u16';
            value: '28_807';
        },
        {
            name: 'ADDRESS_QUEUE_SEQUENCE_THRESHOLD';
            type: 'u64';
            value: '2400';
        },
        {
            name: 'NOOP_PUBKEY';
            type: {
                array: ['u8', 32];
            };
            value: '[11 , 188 , 15 , 192 , 187 , 71 , 202 , 47 , 116 , 196 , 17 , 46 , 148 , 171 , 19 , 207 , 163 , 198 , 52 , 229 , 220 , 23 , 234 , 203 , 3 , 205 , 26 , 35 , 205 , 126 , 120 , 124 ,]';
        }
    ];
    instructions: [
        {
            name: 'initializeAddressMerkleTreeAndQueue';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'queue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'index';
                    type: 'u64';
                },
                {
                    name: 'programOwner';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'forester';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'addressMerkleTreeConfig';
                    type: {
                        defined: 'AddressMerkleTreeConfig';
                    };
                },
                {
                    name: 'addressQueueConfig';
                    type: {
                        defined: 'AddressQueueConfig';
                    };
                }
            ];
        },
        {
            name: 'insertAddresses';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['Fee payer pays rollover fee.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'addresses';
                    type: {
                        vec: {
                            array: ['u8', 32];
                        };
                    };
                }
            ];
        },
        {
            name: 'updateAddressMerkleTree';
            docs: ['Updates the address Merkle tree with a new address.'];
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'queue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'logWrapper';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'changelogIndex';
                    type: 'u16';
                },
                {
                    name: 'indexedChangelogIndex';
                    type: 'u16';
                },
                {
                    name: 'value';
                    type: 'u16';
                },
                {
                    name: 'lowAddressIndex';
                    type: 'u64';
                },
                {
                    name: 'lowAddressValue';
                    type: {
                        array: ['u8', 32];
                    };
                },
                {
                    name: 'lowAddressNextIndex';
                    type: 'u64';
                },
                {
                    name: 'lowAddressNextValue';
                    type: {
                        array: ['u8', 32];
                    };
                },
                {
                    name: 'lowAddressProof';
                    type: {
                        array: [
                            {
                                array: ['u8', 32];
                            },
                            16
                        ];
                    };
                }
            ];
        },
        {
            name: 'rolloverAddressMerkleTreeAndQueue';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Signer used to receive rollover accounts rentexemption reimbursement.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'newAddressMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldAddressMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldQueue';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'initializeGroupAuthority';
            docs: [
                'initialize group (a group can be used to give multiple programs access',
                'to the same Merkle trees by registering the programs to the group)'
            ];
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'seed';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Seed public key used to derive the group authority.'
                    ];
                },
                {
                    name: 'groupAuthority';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'authority';
                    type: 'publicKey';
                }
            ];
        },
        {
            name: 'updateGroupAuthority';
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'groupAuthority';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'authority';
                    type: 'publicKey';
                }
            ];
        },
        {
            name: 'registerProgramToGroup';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'programToBeRegistered';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'groupAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'deregisterProgram';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'groupAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'closeRecipient';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'initializeStateMerkleTreeAndNullifierQueue';
            docs: [
                'Initializes a new Merkle tree from config bytes.',
                'Index is an optional identifier and not checked by the program.'
            ];
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'nullifierQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'index';
                    type: 'u64';
                },
                {
                    name: 'programOwner';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'forester';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'stateMerkleTreeConfig';
                    type: {
                        defined: 'StateMerkleTreeConfig';
                    };
                },
                {
                    name: 'nullifierQueueConfig';
                    type: {
                        defined: 'NullifierQueueConfig';
                    };
                },
                {
                    name: 'additionalBytes';
                    type: 'u64';
                }
            ];
        },
        {
            name: 'appendLeavesToMerkleTrees';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['Fee payer pays rollover fee.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Checked whether instruction is accessed by a registered program or owner = authority.'
                    ];
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Some assumes that the Merkle trees are accessed by a registered program.',
                        'None assumes that the Merkle trees are accessed by its owner.'
                    ];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'leaves';
                    type: {
                        vec: {
                            defined: '(u8,[u8;32])';
                        };
                    };
                }
            ];
        },
        {
            name: 'nullifyLeaves';
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'logWrapper';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'nullifierQueue';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'changeLogIndices';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'leavesQueueIndices';
                    type: {
                        vec: 'u16';
                    };
                },
                {
                    name: 'leafIndices';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'proofs';
                    type: {
                        vec: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    };
                }
            ];
        },
        {
            name: 'insertIntoNullifierQueues';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['Fee payer pays rollover fee.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'nullifiers';
                    type: {
                        vec: {
                            array: ['u8', 32];
                        };
                    };
                }
            ];
        },
        {
            name: 'rolloverStateMerkleTreeAndNullifierQueue';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Signer used to receive rollover accounts rentexemption reimbursement.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'newStateMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newNullifierQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldStateMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldNullifierQueue';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [];
        }
    ];
    accounts: [
        {
            name: 'registeredProgram';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'registeredProgramId';
                        type: 'publicKey';
                    },
                    {
                        name: 'groupAuthorityPda';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'accessMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        docs: ['Owner of the Merkle tree.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'programOwner';
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.'
                        ];
                        type: 'publicKey';
                    },
                    {
                        name: 'forester';
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.'
                        ];
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'addressMerkleTreeAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'metadata';
                        type: {
                            defined: 'MerkleTreeMetadata';
                        };
                    }
                ];
            };
        },
        {
            name: 'groupAuthority';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'authority';
                        type: 'publicKey';
                    },
                    {
                        name: 'seed';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'merkleTreeMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'accessMetadata';
                        type: {
                            defined: 'AccessMetadata';
                        };
                    },
                    {
                        name: 'rolloverMetadata';
                        type: {
                            defined: 'RolloverMetadata';
                        };
                    },
                    {
                        name: 'associatedQueue';
                        type: 'publicKey';
                    },
                    {
                        name: 'nextMerkleTree';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'stateMerkleTreeAccount';
            docs: [
                'Concurrent state Merkle tree used for public compressed transactions.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'metadata';
                        type: {
                            defined: 'MerkleTreeMetadata';
                        };
                    }
                ];
            };
        },
        {
            name: 'queueMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'accessMetadata';
                        type: {
                            defined: 'AccessMetadata';
                        };
                    },
                    {
                        name: 'rolloverMetadata';
                        type: {
                            defined: 'RolloverMetadata';
                        };
                    },
                    {
                        name: 'associatedMerkleTree';
                        type: 'publicKey';
                    },
                    {
                        name: 'nextQueue';
                        type: 'publicKey';
                    },
                    {
                        name: 'queueType';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'queueAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'metadata';
                        type: {
                            defined: 'QueueMetadata';
                        };
                    }
                ];
            };
        },
        {
            name: 'rolloverMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'index';
                        docs: ['Unique index.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverFee';
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverThreshold';
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        docs: ['Tip for maintaining the account.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolledoverSlot';
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'closeThreshold';
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'additionalBytes';
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.'
                        ];
                        type: 'u64';
                    }
                ];
            };
        }
    ];
    types: [
        {
            name: 'AddressMerkleTreeConfig';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'height';
                        type: 'u32';
                    },
                    {
                        name: 'changelogSize';
                        type: 'u64';
                    },
                    {
                        name: 'rootsSize';
                        type: 'u64';
                    },
                    {
                        name: 'canopyDepth';
                        type: 'u64';
                    },
                    {
                        name: 'addressChangelogSize';
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'rolloverThreshold';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'closeThreshold';
                        type: {
                            option: 'u64';
                        };
                    }
                ];
            };
        },
        {
            name: 'StateMerkleTreeConfig';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'height';
                        type: 'u32';
                    },
                    {
                        name: 'changelogSize';
                        type: 'u64';
                    },
                    {
                        name: 'rootsSize';
                        type: 'u64';
                    },
                    {
                        name: 'canopyDepth';
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'rolloverThreshold';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'closeThreshold';
                        type: {
                            option: 'u64';
                        };
                    }
                ];
            };
        },
        {
            name: 'NullifierQueueConfig';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'capacity';
                        type: 'u16';
                    },
                    {
                        name: 'sequenceThreshold';
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        type: {
                            option: 'u64';
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueType';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'NullifierQueue';
                    },
                    {
                        name: 'AddressQueue';
                    }
                ];
            };
        },
        {
            name: 'AddressQueueConfig';
            type: {
                kind: 'alias';
                value: {
                    defined: 'NullifierQueueConfig';
                };
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'IntegerOverflow';
            msg: 'Integer overflow';
        },
        {
            code: 6001;
            name: 'InvalidAuthority';
            msg: 'InvalidAuthority';
        },
        {
            code: 6002;
            name: 'NumberOfLeavesMismatch';
            msg: 'Leaves <> remaining accounts mismatch. The number of remaining accounts must match the number of leaves.';
        },
        {
            code: 6003;
            name: 'InvalidNoopPubkey';
            msg: 'Provided noop program public key is invalid';
        },
        {
            code: 6004;
            name: 'NumberOfChangeLogIndicesMismatch';
            msg: 'Number of change log indices mismatch';
        },
        {
            code: 6005;
            name: 'NumberOfIndicesMismatch';
            msg: 'Number of indices mismatch';
        },
        {
            code: 6006;
            name: 'NumberOfProofsMismatch';
            msg: 'NumberOfProofsMismatch';
        },
        {
            code: 6007;
            name: 'InvalidMerkleProof';
            msg: 'InvalidMerkleProof';
        },
        {
            code: 6008;
            name: 'LeafNotFound';
            msg: 'Could not find the leaf in the queue';
        },
        {
            code: 6009;
            name: 'MerkleTreeAndQueueNotAssociated';
            msg: 'MerkleTreeAndQueueNotAssociated';
        },
        {
            code: 6010;
            name: 'MerkleTreeAlreadyRolledOver';
            msg: 'MerkleTreeAlreadyRolledOver';
        },
        {
            code: 6011;
            name: 'NotReadyForRollover';
            msg: 'NotReadyForRollover';
        },
        {
            code: 6012;
            name: 'RolloverNotConfigured';
            msg: 'RolloverNotConfigured';
        },
        {
            code: 6013;
            name: 'NotAllLeavesProcessed';
            msg: 'NotAllLeavesProcessed';
        },
        {
            code: 6014;
            name: 'InvalidQueueType';
            msg: 'InvalidQueueType';
        },
        {
            code: 6015;
            name: 'InputElementsEmpty';
            msg: 'InputElementsEmpty';
        },
        {
            code: 6016;
            name: 'NoLeavesForMerkleTree';
            msg: 'NoLeavesForMerkleTree';
        },
        {
            code: 6017;
            name: 'InvalidAccountSize';
            msg: 'InvalidAccountSize';
        },
        {
            code: 6018;
            name: 'InsufficientRolloverFee';
            msg: 'InsufficientRolloverFee';
        },
        {
            code: 6019;
            name: 'UnsupportedHeight';
            msg: 'Unsupported Merkle tree height';
        },
        {
            code: 6020;
            name: 'UnsupportedCanopyDepth';
            msg: 'Unsupported canopy depth';
        },
        {
            code: 6021;
            name: 'InvalidSequenceThreshold';
            msg: 'Invalid sequence threshold';
        },
        {
            code: 6022;
            name: 'UnsupportedCloseThreshold';
            msg: 'Unsupported close threshold';
        },
        {
            code: 6023;
            name: 'InvalidAccountBalance';
            msg: 'InvalidAccountBalance';
        },
        {
            code: 6024;
            name: 'UnsupportedAdditionalBytes';
        },
        {
            code: 6025;
            name: 'InvalidGroup';
        },
        {
            code: 6026;
            name: 'ProofLengthMismatch';
        }
    ];
};
declare const IDL$3: AccountCompression;

type LightRegistry = {
    version: '1.2.0';
    name: 'light_registry';
    constants: [
        {
            name: 'FORESTER_SEED';
            type: 'bytes';
            value: '[102, 111, 114, 101, 115, 116, 101, 114]';
        },
        {
            name: 'FORESTER_EPOCH_SEED';
            type: 'bytes';
            value: '[102, 111, 114, 101, 115, 116, 101, 114, 95, 101, 112, 111, 99, 104]';
        },
        {
            name: 'PROTOCOL_CONFIG_PDA_SEED';
            type: 'bytes';
            value: '[97, 117, 116, 104, 111, 114, 105, 116, 121]';
        }
    ];
    instructions: [
        {
            name: 'initializeProtocolConfig';
            docs: [
                'Initializes the protocol config pda. Can only be called once by the',
                'program account keypair.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'protocolConfig';
                    type: {
                        defined: 'ProtocolConfig';
                    };
                }
            ];
        },
        {
            name: 'updateProtocolConfig';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newAuthority';
                    isMut: false;
                    isSigner: true;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'protocolConfig';
                    type: {
                        option: {
                            defined: 'ProtocolConfig';
                        };
                    };
                }
            ];
        },
        {
            name: 'registerSystemProgram';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthority';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'groupPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'programToBeRegistered';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        '- is signer so that only the program deployer can register a program.'
                    ];
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                }
            ];
        },
        {
            name: 'deregisterSystemProgram';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthority';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'groupPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                }
            ];
        },
        {
            name: 'registerForester';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'foresterPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'authority';
                    type: 'publicKey';
                },
                {
                    name: 'config';
                    type: {
                        defined: 'ForesterConfig';
                    };
                },
                {
                    name: 'weight';
                    type: {
                        option: 'u64';
                    };
                }
            ];
        },
        {
            name: 'updateForesterPda';
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'foresterPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newAuthority';
                    isMut: false;
                    isSigner: true;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'config';
                    type: {
                        option: {
                            defined: 'ForesterConfig';
                        };
                    };
                }
            ];
        },
        {
            name: 'updateForesterPdaWeight';
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'foresterPda';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'newWeight';
                    type: 'u64';
                }
            ];
        },
        {
            name: 'registerForesterEpoch';
            docs: [
                'Registers the forester for the epoch.',
                '1. Only the forester can register herself for the epoch.',
                '2. Protocol config is copied.',
                '3. Epoch account is created if needed.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'foresterPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'foresterEpochPda';
                    isMut: true;
                    isSigner: false;
                    docs: [
                        'Instruction checks that current_epoch is the the current epoch and that',
                        'the epoch is in registration phase.'
                    ];
                },
                {
                    name: 'protocolConfig';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'epochPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'epoch';
                    type: 'u64';
                }
            ];
        },
        {
            name: 'finalizeRegistration';
            docs: [
                'This transaction can be included as additional instruction in the first',
                'work instructions during the active phase.',
                'Registration Period must be over.'
            ];
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'foresterEpochPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'epochPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'reportWork';
            accounts: [
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'foresterEpochPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'epochPda';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'initializeAddressMerkleTree';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Anyone can create new trees just the fees cannot be set arbitrarily.'
                    ];
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'queue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthority';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'programOwner';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'forester';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'merkleTreeConfig';
                    type: {
                        defined: 'AddressMerkleTreeConfig';
                    };
                },
                {
                    name: 'queueConfig';
                    type: {
                        defined: 'AddressQueueConfig';
                    };
                }
            ];
        },
        {
            name: 'initializeStateMerkleTree';
            accounts: [
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Anyone can create new trees just the fees cannot be set arbitrarily.'
                    ];
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'queue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthority';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'programOwner';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'forester';
                    type: {
                        option: 'publicKey';
                    };
                },
                {
                    name: 'merkleTreeConfig';
                    type: {
                        defined: 'StateMerkleTreeConfig';
                    };
                },
                {
                    name: 'queueConfig';
                    type: {
                        defined: 'NullifierQueueConfig';
                    };
                }
            ];
        },
        {
            name: 'nullify';
            accounts: [
                {
                    name: 'registeredForesterPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'logWrapper';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'nullifierQueue';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'changeLogIndices';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'leavesQueueIndices';
                    type: {
                        vec: 'u16';
                    };
                },
                {
                    name: 'indices';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'proofs';
                    type: {
                        vec: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    };
                }
            ];
        },
        {
            name: 'updateAddressMerkleTree';
            accounts: [
                {
                    name: 'registeredForesterPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'queue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'logWrapper';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                },
                {
                    name: 'changelogIndex';
                    type: 'u16';
                },
                {
                    name: 'indexedChangelogIndex';
                    type: 'u16';
                },
                {
                    name: 'value';
                    type: 'u16';
                },
                {
                    name: 'lowAddressIndex';
                    type: 'u64';
                },
                {
                    name: 'lowAddressValue';
                    type: {
                        array: ['u8', 32];
                    };
                },
                {
                    name: 'lowAddressNextIndex';
                    type: 'u64';
                },
                {
                    name: 'lowAddressNextValue';
                    type: {
                        array: ['u8', 32];
                    };
                },
                {
                    name: 'lowAddressProof';
                    type: {
                        array: [
                            {
                                array: ['u8', 32];
                            },
                            16
                        ];
                    };
                }
            ];
        },
        {
            name: 'rolloverAddressMerkleTreeAndQueue';
            accounts: [
                {
                    name: 'registeredForesterPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'newMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldQueue';
                    isMut: true;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                }
            ];
        },
        {
            name: 'rolloverStateMerkleTreeAndQueue';
            accounts: [
                {
                    name: 'registeredForesterPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'authority';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'newMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'newQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldMerkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'oldQueue';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'protocolConfigPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'bump';
                    type: 'u8';
                }
            ];
        }
    ];
    accounts: [
        {
            name: 'epochPda';
            docs: ['Is used for tallying and rewards calculation'];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'epoch';
                        type: 'u64';
                    },
                    {
                        name: 'protocolConfig';
                        type: {
                            defined: 'ProtocolConfig';
                        };
                    },
                    {
                        name: 'totalWork';
                        type: 'u64';
                    },
                    {
                        name: 'registeredWeight';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'foresterEpochPda';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'authority';
                        type: 'publicKey';
                    },
                    {
                        name: 'config';
                        type: {
                            defined: 'ForesterConfig';
                        };
                    },
                    {
                        name: 'epoch';
                        type: 'u64';
                    },
                    {
                        name: 'weight';
                        type: 'u64';
                    },
                    {
                        name: 'workCounter';
                        type: 'u64';
                    },
                    {
                        name: 'hasReportedWork';
                        docs: [
                            'Work can be reported in an extra round to earn extra performance based',
                            'rewards.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'foresterIndex';
                        docs: [
                            'Start index of the range that determines when the forester is eligible to perform work.',
                            'End index is forester_start_index + weight'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'epochActivePhaseStartSlot';
                        type: 'u64';
                    },
                    {
                        name: 'totalEpochWeight';
                        docs: [
                            'Total epoch weight is registered weight of the epoch account after',
                            'registration is concluded and active epoch period starts.'
                        ];
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'protocolConfig';
                        type: {
                            defined: 'ProtocolConfig';
                        };
                    },
                    {
                        name: 'finalizeCounter';
                        docs: [
                            'Incremented every time finalize registration is called.'
                        ];
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'protocolConfigPda';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'authority';
                        type: 'publicKey';
                    },
                    {
                        name: 'bump';
                        type: 'u8';
                    },
                    {
                        name: 'config';
                        type: {
                            defined: 'ProtocolConfig';
                        };
                    }
                ];
            };
        },
        {
            name: 'foresterPda';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'authority';
                        type: 'publicKey';
                    },
                    {
                        name: 'config';
                        type: {
                            defined: 'ForesterConfig';
                        };
                    },
                    {
                        name: 'activeWeight';
                        type: 'u64';
                    },
                    {
                        name: 'pendingWeight';
                        docs: [
                            'Pending weight which will get active once the next epoch starts.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'currentEpoch';
                        type: 'u64';
                    },
                    {
                        name: 'lastCompressedForesterEpochPdaHash';
                        docs: [
                            'Link to previous compressed forester epoch account hash.'
                        ];
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'lastRegisteredEpoch';
                        type: 'u64';
                    }
                ];
            };
        }
    ];
    types: [
        {
            name: 'ProtocolConfig';
            docs: [
                'Epoch Phases:',
                '1. Registration',
                '2. Active',
                '3. Report Work',
                '4. Post (Epoch has ended, and rewards can be claimed.)',
                '- There is always an active phase in progress, registration and report work',
                'phases run in parallel to a currently active phase.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'genesisSlot';
                        docs: [
                            'Solana slot when the protocol starts operating.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'minWeight';
                        docs: [
                            'Minimum weight required for a forester to register to an epoch.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'slotLength';
                        docs: ['Light protocol slot length.'];
                        type: 'u64';
                    },
                    {
                        name: 'registrationPhaseLength';
                        docs: ['Foresters can register for this phase.'];
                        type: 'u64';
                    },
                    {
                        name: 'activePhaseLength';
                        docs: ['Foresters can perform work in this phase.'];
                        type: 'u64';
                    },
                    {
                        name: 'reportWorkPhaseLength';
                        docs: [
                            'Foresters can report work to receive performance based rewards in this',
                            'phase.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        type: 'u64';
                    },
                    {
                        name: 'cpiContextSize';
                        type: 'u64';
                    },
                    {
                        name: 'finalizeCounterLimit';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolder';
                        docs: ['Placeholder for future protocol updates.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'placeHolderA';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolderB';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolderC';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolderD';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolderE';
                        type: 'u64';
                    },
                    {
                        name: 'placeHolderF';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'ForesterConfig';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'fee';
                        docs: ['Fee in percentage points.'];
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'EpochState';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'Registration';
                    },
                    {
                        name: 'Active';
                    },
                    {
                        name: 'ReportWork';
                    },
                    {
                        name: 'Post';
                    },
                    {
                        name: 'Pre';
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'InvalidForester';
            msg: 'InvalidForester';
        },
        {
            code: 6001;
            name: 'NotInReportWorkPhase';
        },
        {
            code: 6002;
            name: 'StakeAccountAlreadySynced';
        },
        {
            code: 6003;
            name: 'EpochEnded';
        },
        {
            code: 6004;
            name: 'ForesterNotEligible';
        },
        {
            code: 6005;
            name: 'NotInRegistrationPeriod';
        },
        {
            code: 6006;
            name: 'WeightInsuffient';
        },
        {
            code: 6007;
            name: 'ForesterAlreadyRegistered';
        },
        {
            code: 6008;
            name: 'InvalidEpochAccount';
        },
        {
            code: 6009;
            name: 'InvalidEpoch';
        },
        {
            code: 6010;
            name: 'EpochStillInProgress';
        },
        {
            code: 6011;
            name: 'NotInActivePhase';
        },
        {
            code: 6012;
            name: 'ForesterAlreadyReportedWork';
        },
        {
            code: 6013;
            name: 'InvalidNetworkFee';
        },
        {
            code: 6014;
            name: 'FinalizeCounterExceeded';
        },
        {
            code: 6015;
            name: 'CpiContextAccountMissing';
        },
        {
            code: 6016;
            name: 'ArithmeticUnderflow';
        },
        {
            code: 6017;
            name: 'RegistrationNotFinalized';
        },
        {
            code: 6018;
            name: 'CpiContextAccountInvalidDataLen';
        },
        {
            code: 6019;
            name: 'InvalidConfigUpdate';
        },
        {
            code: 6020;
            name: 'InvalidSigner';
        },
        {
            code: 6021;
            name: 'GetLatestRegisterEpochFailed';
        },
        {
            code: 6022;
            name: 'GetCurrentActiveEpochFailed';
        },
        {
            code: 6023;
            name: 'ForesterUndefined';
        },
        {
            code: 6024;
            name: 'ForesterDefined';
        }
    ];
};
declare const IDL$2: LightRegistry;

type LightSystemProgram$1 = {
    version: '1.2.0';
    name: 'light_system_program';
    constants: [
        {
            name: 'SOL_POOL_PDA_SEED';
            type: 'bytes';
            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]';
        }
    ];
    instructions: [
        {
            name: 'initCpiContextAccount';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'associatedMerkleTree';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'invoke';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                    docs: [
                        'This pda is used to invoke the account compression program.'
                    ];
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['Merkle trees.'];
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol."
                    ];
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.'
                    ];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'invokeCpi';
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'invokingProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiContextAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.'
                    ];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                    docs: [
                        'This pda is used to invoke the account compression program.'
                    ];
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['Merkle trees.'];
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol."
                    ];
                },
                {
                    name: 'decompressionRecipient';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.'
                    ];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'InstructionDataInvoke';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'InstructionDataInvokeCpi';
                    };
                },
                {
                    name: 'inputs3';
                    type: {
                        defined: 'PublicTransactionEvent';
                    };
                }
            ];
        }
    ];
    accounts: [
        {
            name: 'stateMerkleTreeAccount';
            docs: [
                'Concurrent state Merkle tree used for public compressed transactions.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'metadata';
                        type: {
                            defined: 'MerkleTreeMetadata';
                        };
                    }
                ];
            };
        },
        {
            name: 'cpiContextAccount';
            docs: [
                'Collects instruction data without executing a compressed transaction.',
                'Signer checks are performed on instruction data.',
                'Collected instruction data is combined with the instruction data of the executing cpi,',
                'and executed as a single transaction.',
                'This enables to use input compressed accounts that are owned by multiple programs,',
                'with one zero-knowledge proof.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'feePayer';
                        type: 'publicKey';
                    },
                    {
                        name: 'associatedMerkleTree';
                        type: 'publicKey';
                    },
                    {
                        name: 'context';
                        type: {
                            vec: {
                                defined: 'InstructionDataInvokeCpi';
                            };
                        };
                    }
                ];
            };
        }
    ];
    types: [
        {
            name: 'AccessMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        docs: ['Owner of the Merkle tree.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'programOwner';
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.'
                        ];
                        type: 'publicKey';
                    },
                    {
                        name: 'forester';
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.'
                        ];
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'accessMetadata';
                        type: {
                            defined: 'AccessMetadata';
                        };
                    },
                    {
                        name: 'rolloverMetadata';
                        type: {
                            defined: 'RolloverMetadata';
                        };
                    },
                    {
                        name: 'associatedQueue';
                        type: 'publicKey';
                    },
                    {
                        name: 'nextMerkleTree';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'RolloverMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'index';
                        docs: ['Unique index.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverFee';
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverThreshold';
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        docs: ['Tip for maintaining the account.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolledoverSlot';
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'closeThreshold';
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'additionalBytes';
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.'
                        ];
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'queueIndex';
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.'
                        ];
                        type: {
                            option: {
                                defined: 'QueueIndex';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'SumCheckFailed';
            msg: 'Sum check failed';
        },
        {
            code: 6001;
            name: 'SignerCheckFailed';
            msg: 'Signer check failed';
        },
        {
            code: 6002;
            name: 'CpiSignerCheckFailed';
            msg: 'Cpi signer check failed';
        },
        {
            code: 6003;
            name: 'ComputeInputSumFailed';
            msg: 'Computing input sum failed.';
        },
        {
            code: 6004;
            name: 'ComputeOutputSumFailed';
            msg: 'Computing output sum failed.';
        },
        {
            code: 6005;
            name: 'ComputeRpcSumFailed';
            msg: 'Computing rpc sum failed.';
        },
        {
            code: 6006;
            name: 'InvalidAddress';
            msg: 'InvalidAddress';
        },
        {
            code: 6007;
            name: 'DeriveAddressError';
            msg: 'DeriveAddressError';
        },
        {
            code: 6008;
            name: 'CompressedSolPdaUndefinedForCompressSol';
            msg: 'CompressedSolPdaUndefinedForCompressSol';
        },
        {
            code: 6009;
            name: 'DeCompressLamportsUndefinedForCompressSol';
            msg: 'DeCompressLamportsUndefinedForCompressSol';
        },
        {
            code: 6010;
            name: 'CompressedSolPdaUndefinedForDecompressSol';
            msg: 'CompressedSolPdaUndefinedForDecompressSol';
        },
        {
            code: 6011;
            name: 'DeCompressLamportsUndefinedForDecompressSol';
            msg: 'DeCompressLamportsUndefinedForDecompressSol';
        },
        {
            code: 6012;
            name: 'DecompressRecipientUndefinedForDecompressSol';
            msg: 'DecompressRecipientUndefinedForDecompressSol';
        },
        {
            code: 6013;
            name: 'WriteAccessCheckFailed';
            msg: 'WriteAccessCheckFailed';
        },
        {
            code: 6014;
            name: 'InvokingProgramNotProvided';
            msg: 'InvokingProgramNotProvided';
        },
        {
            code: 6015;
            name: 'InvalidCapacity';
            msg: 'InvalidCapacity';
        },
        {
            code: 6016;
            name: 'InvalidMerkleTreeOwner';
            msg: 'InvalidMerkleTreeOwner';
        },
        {
            code: 6017;
            name: 'ProofIsNone';
            msg: 'ProofIsNone';
        },
        {
            code: 6018;
            name: 'ProofIsSome';
            msg: 'Proof is some but no input compressed accounts or new addresses provided.';
        },
        {
            code: 6019;
            name: 'EmptyInputs';
            msg: 'EmptyInputs';
        },
        {
            code: 6020;
            name: 'CpiContextAccountUndefined';
            msg: 'CpiContextAccountUndefined';
        },
        {
            code: 6021;
            name: 'CpiContextEmpty';
            msg: 'CpiContextEmpty';
        },
        {
            code: 6022;
            name: 'CpiContextMissing';
            msg: 'CpiContextMissing';
        },
        {
            code: 6023;
            name: 'DecompressionRecipientDefined';
            msg: 'DecompressionRecipientDefined';
        },
        {
            code: 6024;
            name: 'SolPoolPdaDefined';
            msg: 'SolPoolPdaDefined';
        },
        {
            code: 6025;
            name: 'AppendStateFailed';
            msg: 'AppendStateFailed';
        },
        {
            code: 6026;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6027;
            name: 'CpiContextFeePayerMismatch';
            msg: 'CpiContextFeePayerMismatch';
        },
        {
            code: 6028;
            name: 'CpiContextAssociatedMerkleTreeMismatch';
            msg: 'CpiContextAssociatedMerkleTreeMismatch';
        },
        {
            code: 6029;
            name: 'NoInputs';
            msg: 'NoInputs';
        },
        {
            code: 6030;
            name: 'InputMerkleTreeIndicesNotInOrder';
            msg: 'Input merkle tree indices are not in ascending order.';
        },
        {
            code: 6031;
            name: 'OutputMerkleTreeIndicesNotInOrder';
            msg: 'Output merkle tree indices are not in ascending order.';
        },
        {
            code: 6032;
            name: 'OutputMerkleTreeNotUnique';
        },
        {
            code: 6033;
            name: 'DataFieldUndefined';
        }
    ];
};
declare const IDL$1: LightSystemProgram$1;

type LightCompressedToken = {
    version: '1.2.0';
    name: 'light_compressed_token';
    instructions: [
        {
            name: 'createTokenPool';
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'mintTo';
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['programs'];
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'publicKeys';
                    type: {
                        vec: 'publicKey';
                    };
                },
                {
                    name: 'amounts';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'lamports';
                    type: {
                        option: 'u64';
                    };
                }
            ];
        },
        {
            name: 'compressSplTokenAccount';
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'owner';
                    type: 'publicKey';
                },
                {
                    name: 'remainingAmount';
                    type: {
                        option: 'u64';
                    };
                },
                {
                    name: 'cpiContext';
                    type: {
                        option: {
                            defined: 'CompressedCpiContext';
                        };
                    };
                }
            ];
        },
        {
            name: 'transfer';
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'approve';
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'revoke';
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'freeze';
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'thaw';
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'burn';
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'TokenData';
                    };
                }
            ];
        }
    ];
    types: [
        {
            name: 'AccessMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        docs: ['Owner of the Merkle tree.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'programOwner';
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.'
                        ];
                        type: 'publicKey';
                    },
                    {
                        name: 'forester';
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.'
                        ];
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'AccountState';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'Initialized';
                    },
                    {
                        name: 'Frozen';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataTransfer';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegatedTransfer';
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.'
                        ];
                        type: {
                            option: {
                                defined: 'DelegatedTransfer';
                            };
                        };
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData';
                            };
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressAmount';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex';
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'DelegatedTransfer';
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegateChangeAccountIndex';
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.'
                        ];
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'InputTokenDataWithContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'delegateIndex';
                        type: {
                            option: 'u8';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        type: 'u16';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'accessMetadata';
                        type: {
                            defined: 'AccessMetadata';
                        };
                    },
                    {
                        name: 'rolloverMetadata';
                        type: {
                            defined: 'RolloverMetadata';
                        };
                    },
                    {
                        name: 'associatedQueue';
                        type: 'publicKey';
                    },
                    {
                        name: 'nextMerkleTree';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'queueIndex';
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.'
                        ];
                        type: {
                            option: {
                                defined: 'QueueIndex';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'PackedTokenTransferOutputData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'RolloverMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'index';
                        docs: ['Unique index.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverFee';
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverThreshold';
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        docs: ['Tip for maintaining the account.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolledoverSlot';
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'closeThreshold';
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'additionalBytes';
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.'
                        ];
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'TokenData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'mint';
                        docs: ['The mint associated with this account'];
                        type: 'publicKey';
                    },
                    {
                        name: 'owner';
                        docs: ['The owner of this account.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        docs: ['The amount of tokens this account holds.'];
                        type: 'u64';
                    },
                    {
                        name: 'delegate';
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate'
                        ];
                        type: {
                            option: 'publicKey';
                        };
                    },
                    {
                        name: 'state';
                        docs: ["The account's state"];
                        type: {
                            defined: 'AccountState';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'PublicKeyAmountMissmatch';
            msg: 'public keys and amounts must be of same length';
        },
        {
            code: 6001;
            name: 'ComputeInputSumFailed';
            msg: 'ComputeInputSumFailed';
        },
        {
            code: 6002;
            name: 'ComputeOutputSumFailed';
            msg: 'ComputeOutputSumFailed';
        },
        {
            code: 6003;
            name: 'ComputeCompressSumFailed';
            msg: 'ComputeCompressSumFailed';
        },
        {
            code: 6004;
            name: 'ComputeDecompressSumFailed';
            msg: 'ComputeDecompressSumFailed';
        },
        {
            code: 6005;
            name: 'SumCheckFailed';
            msg: 'SumCheckFailed';
        },
        {
            code: 6006;
            name: 'DecompressRecipientUndefinedForDecompress';
            msg: 'DecompressRecipientUndefinedForDecompress';
        },
        {
            code: 6007;
            name: 'CompressedPdaUndefinedForDecompress';
            msg: 'CompressedPdaUndefinedForDecompress';
        },
        {
            code: 6008;
            name: 'DeCompressAmountUndefinedForDecompress';
            msg: 'DeCompressAmountUndefinedForDecompress';
        },
        {
            code: 6009;
            name: 'CompressedPdaUndefinedForCompress';
            msg: 'CompressedPdaUndefinedForCompress';
        },
        {
            code: 6010;
            name: 'DeCompressAmountUndefinedForCompress';
            msg: 'DeCompressAmountUndefinedForCompress';
        },
        {
            code: 6011;
            name: 'DelegateSignerCheckFailed';
            msg: 'DelegateSignerCheckFailed';
        },
        {
            code: 6012;
            name: 'MintTooLarge';
            msg: 'Minted amount greater than u64::MAX';
        },
        {
            code: 6013;
            name: 'SplTokenSupplyMismatch';
            msg: 'SplTokenSupplyMismatch';
        },
        {
            code: 6014;
            name: 'HeapMemoryCheckFailed';
            msg: 'HeapMemoryCheckFailed';
        },
        {
            code: 6015;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6016;
            name: 'ArithmeticUnderflow';
            msg: 'ArithmeticUnderflow';
        },
        {
            code: 6017;
            name: 'HashToFieldError';
            msg: 'HashToFieldError';
        },
        {
            code: 6018;
            name: 'InvalidAuthorityMint';
            msg: 'Expected the authority to be also a mint authority';
        },
        {
            code: 6019;
            name: 'InvalidFreezeAuthority';
            msg: 'Provided authority is not the freeze authority';
        },
        {
            code: 6020;
            name: 'InvalidDelegateIndex';
        },
        {
            code: 6021;
            name: 'TokenPoolPdaUndefined';
        },
        {
            code: 6022;
            name: 'IsTokenPoolPda';
            msg: 'Compress or decompress recipient is the same account as the token pool pda.';
        },
        {
            code: 6023;
            name: 'InvalidTokenPoolPda';
        },
        {
            code: 6024;
            name: 'NoInputTokenAccountsProvided';
        },
        {
            code: 6025;
            name: 'NoInputsProvided';
        },
        {
            code: 6026;
            name: 'MintHasNoFreezeAuthority';
        },
        {
            code: 6027;
            name: 'MintWithInvalidExtension';
        },
        {
            code: 6028;
            name: 'InsufficientTokenAccountBalance';
            msg: 'The token account balance is less than the remaining amount.';
        }
    ];
};
declare const IDL: LightCompressedToken;

/**
 * @internal Finds the index of a PublicKey in an array, or adds it if not
 * present
 * */
declare function getIndexOrAdd(accountsArray: PublicKey[], key: PublicKey): number;
/** @internal */
declare function padOutputStateMerkleTrees(outputStateMerkleTrees: PublicKey[] | PublicKey | undefined, numberOfOutputCompressedAccounts: number, inputCompressedAccountsWithMerkleContext: CompressedAccountWithMerkleContext[]): PublicKey[];
declare function toAccountMetas(remainingAccounts: PublicKey[]): AccountMeta[];
/**
 * Packs Compressed Accounts.
 *
 * Replaces PublicKey with index pointer to remaining accounts.
 *
 * @param inputCompressedAccounts           Ix input state to be consumed
 * @param inputStateRootIndices             The recent state root indices of the
 *                                          input state. The expiry is tied to
 *                                          the proof.
 * @param outputCompressedAccounts          Ix output state to be created
 * @param outputStateMerkleTrees            Optional output state trees to be
 *                                          inserted into the output state.
 *                                          Defaults to the 0th state tree of
 *                                          the input state. Gets padded to the
 *                                          length of outputCompressedAccounts.
 *
 * @param remainingAccounts                 Optional existing array of accounts
 *                                          to append to.
 **/
declare function packCompressedAccounts(inputCompressedAccounts: CompressedAccountWithMerkleContext[], inputStateRootIndices: number[], outputCompressedAccounts: CompressedAccount[], outputStateMerkleTrees?: PublicKey[] | PublicKey, remainingAccounts?: PublicKey[]): {
    packedInputCompressedAccounts: PackedCompressedAccountWithMerkleContext[];
    packedOutputCompressedAccounts: OutputCompressedAccountWithPackedContext[];
    remainingAccounts: PublicKey[];
};

declare const sumUpLamports: (accounts: CompressedAccountWithMerkleContext[]) => BN;
/**
 * Create compressed account system transaction params
 */
type CreateAccountWithSeedParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * Address params for the new compressed account
     */
    newAddressParams: NewAddressParams;
    newAddress: number[];
    /**
     * Recent validity proof proving that there's no existing compressed account
     * registered with newAccountAddress
     */
    recentValidityProof: CompressedProof;
    /**
     * State tree pubkey. Defaults to a public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Public key of the program to assign as the owner of the created account
     */
    programId?: PublicKey;
    /**
     * Optional input accounts to transfer lamports from into the new compressed
     * account.
     */
    inputCompressedAccounts?: CompressedAccountWithMerkleContext[];
    /**
     * Optional input state root indices of 'inputCompressedAccounts'. The
     * expiry is tied to the 'recentValidityProof'.
     */
    inputStateRootIndices?: number[];
    /**
     * Optional lamports to transfer into the new compressed account.
     */
    lamports?: number | BN;
};
/**
 * Defines the parameters for the transfer method
 */
type TransferParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to transfer.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type CompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * address that the lamports are attached to. also defaults to the recipient owner
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to compress.
     */
    lamports: number | BN;
    /**
     * The state tree that the tx output should be inserted into. Defaults to a
     * public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
};
/**
 * Defines the parameters for the transfer method
 */
type DecompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The input state to be consumed.
     */
    inputCompressedAccounts: CompressedAccountWithMerkleContext[];
    /**
     * Recipient address of uncompressed lamports
     */
    toAddress: PublicKey;
    /**
     * amount of lamports to decompress.
     */
    lamports: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     *
     * TODO: Add support for passing recent-values after instruction creation.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTree?: PublicKey;
};
declare class LightSystemProgram {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    private static _program;
    static get program(): Program<LightSystemProgram$1>;
    /**
     * @internal
     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY
     *
     */
    static deriveCompressedSolPda(): PublicKey;
    /**
     * Initializes the program statically if not already initialized.
     */
    private static initializeProgram;
    static createTransferOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], toAddress: PublicKey, lamports: number | BN): CompressedAccount[];
    static createDecompressOutputState(inputCompressedAccounts: CompressedAccountWithMerkleContext[], lamports: number | BN): CompressedAccount[];
    /**
     * No data by default
     */
    static createNewAddressOutputState(address: number[], owner: PublicKey, lamports?: BN | number, inputCompressedAccounts?: CompressedAccountWithMerkleContext[]): CompressedAccount[];
    /**
     * Creates instruction to create compressed account with PDA.
     * Cannot write data.
     *
     * TODO: support transfer of lamports to the new account.
     */
    static createAccount({ payer, newAddressParams, newAddress, recentValidityProof, outputStateTree, inputCompressedAccounts, inputStateRootIndices, lamports, }: CreateAccountWithSeedParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static transfer({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTrees, }: TransferParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static compress({ payer, toAddress, lamports, outputStateTree, }: CompressParams): Promise<TransactionInstruction>;
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static decompress({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTree, }: DecompressParams): Promise<TransactionInstruction>;
}
/**
 * Selects the minimal number of compressed SOL accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
declare function selectMinCompressedSolAccountsForTransfer(accounts: CompressedAccountWithMerkleContext[], transferLamports: BN | number): [selectedAccounts: CompressedAccountWithMerkleContext[], total: BN];

declare const useWallet: (keypair: Keypair, url?: string, commitment?: Commitment) => {
    publicKey: _solana_web3_js.PublicKey;
    sendAndConfirmTransaction: (transaction: _solana_web3_js.Transaction, signers?: never[]) => Promise<any>;
    signMessage: (message: Uint8Array) => Promise<Uint8Array>;
    signTransaction: (tx: any) => Promise<any>;
    signAllTransactions: <T extends _solana_web3_js.Transaction | _solana_web3_js.VersionedTransaction>(transactions: T[]) => Promise<T[]>;
    sendTransaction: (transaction: _solana_web3_js.VersionedTransaction) => Promise<string>;
};

declare const FIELD_SIZE: BN;
declare const HIGHEST_ADDRESS_PLUS_ONE: BN;
declare const noopProgram = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
declare const lightProgram = "SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7";
declare const accountCompressionProgram = "compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq";
declare const getRegisteredProgramPda: () => PublicKey;
declare const getAccountCompressionAuthority: () => PublicKey;
declare const defaultStaticAccounts: () => PublicKey[];
declare const defaultStaticAccountsStruct: () => {
    registeredProgramPda: PublicKey;
    noopProgram: PublicKey;
    accountCompressionProgram: PublicKey;
    accountCompressionAuthority: PublicKey;
    cpiSignatureAccount: null;
};
declare const defaultTestStateTreeAccounts: () => {
    nullifierQueue: PublicKey;
    merkleTree: PublicKey;
    merkleTreeHeight: number;
    addressTree: PublicKey;
    addressQueue: PublicKey;
};
declare const nullifierQueuePubkey = "nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148";
declare const merkletreePubkey = "smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT";
declare const addressTree = "amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2";
declare const addressQueue = "aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F";
declare const confirmConfig: ConfirmOptions;
declare const DEFAULT_MERKLE_TREE_HEIGHT = 26;
declare const DEFAULT_MERKLE_TREE_ROOTS = 2800;
/** Threshold (per asset) at which new in-UTXOs get merged, in order to reduce UTXO pool size */
declare const UTXO_MERGE_THRESHOLD = 20;
declare const UTXO_MERGE_MAXIMUM = 10;
/**
 * Treshold after which the currently used transaction Merkle tree is switched
 * to the next one
 */
declare const TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD: BN;
/**
 * Fee to provide continous funding for the state Merkle tree.
 * Once the state Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next state Merkle tree with the same parameters.
 *
 * Is charged per output compressed account.
 */
declare const STATE_MERKLE_TREE_ROLLOVER_FEE: BN;
/**
 * Fee to provide continous funding for the address queue and address Merkle tree.
 * Once the address Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next address queue and address tree with the same parameters.
 *
 * Is charged per newly created address.
 */
declare const ADDRESS_QUEUE_ROLLOVER_FEE: BN;
/**
 * Is charged if the transaction nullifies at least one compressed account.
 */
declare const STATE_MERKLE_TREE_NETWORK_FEE: BN;
/**
 * Is charged if the transaction creates at least one address.
 */
declare const ADDRESS_TREE_NETWORK_FEE: BN;

declare enum UtxoErrorCode {
    NEGATIVE_LAMPORTS = "NEGATIVE_LAMPORTS",
    NOT_U64 = "NOT_U64",
    BLINDING_EXCEEDS_FIELD_SIZE = "BLINDING_EXCEEDS_FIELD_SIZE"
}
declare enum SelectInUtxosErrorCode {
    FAILED_TO_FIND_UTXO_COMBINATION = "FAILED_TO_FIND_UTXO_COMBINATION",
    INVALID_NUMBER_OF_IN_UTXOS = "INVALID_NUMBER_OF_IN_UTXOS"
}
declare enum CreateUtxoErrorCode {
    OWNER_UNDEFINED = "OWNER_UNDEFINED",
    INVALID_OUTPUT_UTXO_LENGTH = "INVALID_OUTPUT_UTXO_LENGTH",
    UTXO_DATA_UNDEFINED = "UTXO_DATA_UNDEFINED"
}
declare enum RpcErrorCode {
    CONNECTION_UNDEFINED = "CONNECTION_UNDEFINED",
    RPC_PUBKEY_UNDEFINED = "RPC_PUBKEY_UNDEFINED",
    RPC_METHOD_NOT_IMPLEMENTED = "RPC_METHOD_NOT_IMPLEMENTED",
    RPC_INVALID = "RPC_INVALID"
}
declare enum LookupTableErrorCode {
    LOOK_UP_TABLE_UNDEFINED = "LOOK_UP_TABLE_UNDEFINED",
    LOOK_UP_TABLE_NOT_INITIALIZED = "LOOK_UP_TABLE_NOT_INITIALIZED"
}
declare enum HashErrorCode {
    NO_POSEIDON_HASHER_PROVIDED = "NO_POSEIDON_HASHER_PROVIDED"
}
declare enum ProofErrorCode {
    INVALID_PROOF = "INVALID_PROOF",
    PROOF_INPUT_UNDEFINED = "PROOF_INPUT_UNDEFINED",
    PROOF_GENERATION_FAILED = "PROOF_GENERATION_FAILED"
}
declare enum MerkleTreeErrorCode {
    MERKLE_TREE_NOT_INITIALIZED = "MERKLE_TREE_NOT_INITIALIZED",
    SOL_MERKLE_TREE_UNDEFINED = "SOL_MERKLE_TREE_UNDEFINED",
    MERKLE_TREE_UNDEFINED = "MERKLE_TREE_UNDEFINED",
    INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE = "INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE",
    MERKLE_TREE_INDEX_UNDEFINED = "MERKLE_TREE_INDEX_UNDEFINED",
    MERKLE_TREE_SET_SPACE_UNDEFINED = "MERKLE_TREE_SET_SPACE_UNDEFINED"
}
declare enum UtilsErrorCode {
    ACCOUNT_NAME_UNDEFINED_IN_IDL = "ACCOUNT_NAME_UNDEFINED_IN_IDL",
    PROPERTY_UNDEFINED = "PROPERTY_UNDEFINED",
    LOOK_UP_TABLE_CREATION_FAILED = "LOOK_UP_TABLE_CREATION_FAILED",
    UNSUPPORTED_ARCHITECTURE = "UNSUPPORTED_ARCHITECTURE",
    UNSUPPORTED_PLATFORM = "UNSUPPORTED_PLATFORM",
    ACCOUNTS_UNDEFINED = "ACCOUNTS_UNDEFINED",
    INVALID_NUMBER = "INVALID_NUMBER"
}
declare class MetaError extends Error {
    code: string;
    functionName: string;
    codeMessage?: string;
    constructor(code: string, functionName: string, codeMessage?: string);
}
declare class UtxoError extends MetaError {
}
declare class SelectInUtxosError extends MetaError {
}
declare class CreateUtxoError extends MetaError {
}
declare class RpcError extends MetaError {
}
declare class LookupTableError extends MetaError {
}
declare class HashError extends MetaError {
}
declare class ProofError extends MetaError {
}
declare class MerkleTreeError extends MetaError {
}
declare class UtilsError extends MetaError {
}

interface TestRpcConfig {
    /**
     * Address of the state tree to index. Default: public default test state
     * tree.
     */
    merkleTreeAddress?: PublicKey;
    /**
     * Nullifier queue associated with merkleTreeAddress
     */
    nullifierQueueAddress?: PublicKey;
    /**
     * Depth of state tree. Defaults to the public default test state tree depth
     */
    depth?: number;
    /**
     * Log proof generation time
     */
    log?: boolean;
    /**
     * Address of the address tree to index. Default: public default test
     * address tree.
     */
    addressTreeAddress?: PublicKey;
    /**
     * Address queue associated with addressTreeAddress
     */
    addressQueueAddress?: PublicKey;
}
interface LightWasm {
    blakeHash(input: string | Uint8Array, hashLength: number): Uint8Array;
    poseidonHash(input: string[] | BN[]): Uint8Array;
    poseidonHashString(input: string[] | BN[]): string;
    poseidonHashBN(input: string[] | BN[]): BN;
}
/**
 * Returns a mock RPC instance for use in unit tests.
 *
 * @param lightWasm               Wasm hasher instance.
 * @param endpoint                RPC endpoint URL. Defaults to
 *                                'http://127.0.0.1:8899'.
 * @param proverEndpoint          Prover server endpoint URL. Defaults to
 *                                'http://localhost:3001'.
 * @param merkleTreeAddress       Address of the merkle tree to index. Defaults
 *                                to the public default test state tree.
 * @param nullifierQueueAddress   Optional address of the associated nullifier
 *                                queue.
 * @param depth                   Depth of the merkle tree.
 * @param log                     Log proof generation time.
 */
declare function getTestRpc(lightWasm: LightWasm, endpoint?: string, compressionApiEndpoint?: string, proverEndpoint?: string, merkleTreeAddress?: PublicKey, nullifierQueueAddress?: PublicKey, depth?: number, log?: boolean): Promise<TestRpc>;
/**
 * Simple mock rpc for unit tests that simulates the compression rpc interface.
 * Fetches, parses events and builds merkletree on-demand, i.e. it does not persist state.
 * Constraints:
 * - Can only index 1 merkletree
 * - Can only index up to 1000 transactions
 *
 * For advanced testing use photon: https://github.com/helius-labs/photon
 */
declare class TestRpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    merkleTreeAddress: PublicKey;
    nullifierQueueAddress: PublicKey;
    addressTreeAddress: PublicKey;
    addressQueueAddress: PublicKey;
    lightWasm: LightWasm;
    depth: number;
    log: boolean;
    /**
     * Establish a Compression-compatible JSON RPC mock-connection
     *
     * @param endpoint                  endpoint to the solana cluster (use for
     *                                  localnet only)
     * @param hasher                    light wasm hasher instance
     * @param compressionApiEndpoint    Endpoint to the compression server.
     * @param proverEndpoint            Endpoint to the prover server. defaults
     *                                  to endpoint
     * @param connectionConfig          Optional connection config
     * @param testRpcConfig             Config for the mock rpc
     */
    constructor(endpoint: string, hasher: LightWasm, compressionApiEndpoint: string, proverEndpoint: string, connectionConfig?: ConnectionConfig, testRpcConfig?: TestRpcConfig);
    /**
     * Fetch the compressed account for the specified account hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(_slot: number): Promise<boolean>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, _config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(_cursor?: string, _limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch the latest non-voting signatures on the cluster. Results are
     * not paginated.
     */
    getLatestNonVotingSignatures(_limit?: number): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint.
     */
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<{
        balance: BN;
        mint: PublicKey;
    }[]>>;
    /**
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Uses context.
     */
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(_hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(_signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed
     * block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(_address: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(_owner: PublicKey, _options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    getCompressedMintTokenHolders(_mint: PublicKey, _options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Note: Use RPC class for forested trees. TestRpc is only for custom
     * testing purposes.
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * @deprecated This method is not available for TestRpc. Please use
     * {@link getValidityProof} instead.
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
}

declare class IndexedElement {
    index: number;
    value: BN;
    nextIndex: number;
    constructor(index: number, value: BN, nextIndex: number);
    equals(other: IndexedElement): boolean;
    compareTo(other: IndexedElement): number;
    hash(lightWasm: LightWasm, nextValue: BN): Uint8Array;
}
declare class IndexedElementBundle {
    newLowElement: IndexedElement;
    newElement: IndexedElement;
    newElementNextValue: BN;
    constructor(newLowElement: IndexedElement, newElement: IndexedElement, newElementNextValue: BN);
}
/**
 * This indexed array implementation mirrors the rust implementation of the
 * indexed merkle tree. It stores the elements of the indexed merkle tree.
 */
declare class IndexedArray {
    elements: Array<IndexedElement>;
    currentNodeIndex: number;
    highestElementIndex: number;
    constructor(elements: Array<IndexedElement>, currentNodeIndex: number, highestElementIndex: number);
    static default(): IndexedArray;
    get(index: number): IndexedElement | undefined;
    length(): number;
    isEmpty(): boolean;
    findElement(value: BN): IndexedElement | undefined;
    init(): IndexedElementBundle;
    /**
     * Finds the index of the low element for the given `value` which should not be part of the array.
     * Low element is the greatest element which still has a lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElementIndex(value: BN): number | undefined;
    /**
     * Returns the low element for the given value and the next value for that low element.
     * Low element is the greatest element which still has lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElement(value: BN): [IndexedElement | undefined, BN | undefined];
    /**
     * Returns the hash of the given element. That hash consists of:
     * - The value of the given element.
     * - The `nextIndex` of the given element.
     * - The value of the element pointed by `nextIndex`.
     */
    hashElement(lightWasm: LightWasm, index: number): Uint8Array | undefined;
    /**
     * Appends a new element with the given value to the indexed array.
     * It finds the low element index and uses it to append the new element correctly.
     * @param value The value of the new element to append.
     * @returns The new element and its low element after insertion.
     */
    append(value: BN): IndexedElementBundle;
    /**
     * Appends a new element with the given value to the indexed array using a specific low element index.
     * This method ensures the new element is placed correctly relative to the low element.
     * @param lowElementIndex The index of the low element.
     * @param value The value of the new element to append.
     * @returns The new element and its updated low element.
     */
    appendWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Finds the lowest element in the array.
     * @returns The lowest element or undefined if the array is empty.
     */
    lowest(): IndexedElement | undefined;
    /**
     * Creates a new element with the specified value and updates the low element index accordingly.
     * @param lowElementIndex The index of the low element.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElementWithLowElementIndex(lowElementIndex: number, value: BN): IndexedElementBundle;
    /**
     * Creates a new element with the specified value by first finding the appropriate low element index.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElement(value: BN): IndexedElementBundle;
}

declare const DEFAULT_ZERO = "0";
/**
 * @callback hashFunction
 * @param left Left leaf
 * @param right Right leaf
 */
/**
 * Merkle tree
 */
declare class MerkleTree {
    /**
     * Constructor
     * @param {number} levels Number of levels in the tree
     * @param {Array} [elements] Initial elements
     * @param {Object} options
     * @param {hashFunction} [options.hashFunction] Function used to hash 2 leaves
     * @param [options.zeroElement] Value for non-existent leaves
     */
    levels: number;
    capacity: number;
    zeroElement: string;
    _zeros: string[];
    _layers: string[][];
    _lightWasm: LightWasm;
    constructor(levels: number, lightWasm: LightWasm, elements?: string[], { zeroElement }?: {
        zeroElement?: string | undefined;
    });
    _rebuild(): void;
    /**
     * Get tree root
     * @returns {*}
     */
    root(): string;
    /**
     * Insert new element into the tree
     * @param element Element to insert
     */
    insert(element: string): void;
    /**
     * Insert multiple elements into the tree. Tree will be fully rebuilt during this operation.
     * @param {Array} elements Elements to insert
     */
    bulkInsert(elements: string[]): void;
    /**
     * Change an element in the tree
     * @param {number} index Index of element to change
     * @param element Updated element value
     */
    update(index: number, element: string): void;
    /**
     * Get merkle path to a leaf
     * @param {number} index Leaf index to generate path for
     * @returns {{pathElements: number[], pathIndex: number[]}} An object containing adjacent elements and left-right index
     */
    path(index: number): {
        pathElements: string[];
        pathIndices: number[];
    };
    /**
     * Find an element in the tree
     * @param element An element to find
     * @param comparator A function that checks leaf value equality
     * @returns {number} Index if element is found, otherwise -1
     */
    indexOf(element: string, comparator?: ((element: string, el: string) => boolean) | null): number;
    /**
     * Returns a copy of non-zero tree elements
     * @returns {Object[]}
     */
    elements(): string[];
    /**
     * Serialize entire tree state including intermediate layers into a plain object
     * Deserializing it back will not require to recompute any hashes
     * Elements are not converted to a plain type, this is responsibility of the caller
     */
    serialize(): {
        levels: number;
        _zeros: string[];
        _layers: string[][];
    };
    /**
     * Deserialize data into a MerkleTree instance
     * Make sure to provide the same hashFunction as was used in the source tree,
     * otherwise the tree state will be invalid
     *
     * @param data
     * @param hashFunction
     * @returns {MerkleTree}
     */
    static deserialize(data: any, hashFunction: (left: string, right: string) => string): any;
}

type Deserializer<T> = (data: Buffer, tx: ParsedTransactionWithMeta) => T;
/**
 * @internal
 * Returns newest first.
 *
 * */
declare function getParsedEvents(rpc: Rpc): Promise<PublicTransactionEvent[]>;
declare const parseEvents: <T>(indexerEventsTransactions: (ParsedTransactionWithMeta | null)[], deserializeFn: Deserializer<T>) => NonNullable<T>[];
declare const parsePublicTransactionEventWithIdl: (data: Buffer) => PublicTransactionEvent | null;

type TokenData = {
    mint: PublicKey;
    owner: PublicKey;
    amount: BN;
    delegate: PublicKey | null;
    state: number;
    tlv: Buffer | null;
};
type EventWithParsedTokenTlvData = {
    inputCompressedAccountHashes: number[][];
    outputCompressedAccounts: ParsedTokenAccount[];
};
/**
 * Manually parse the compressed token layout for a given compressed account.
 * @param compressedAccount - The compressed account
 * @returns The parsed token data
 */
declare function parseTokenLayoutWithIdl(compressedAccount: CompressedAccount, programId?: PublicKey): TokenData | null;
/**
 * Retrieves all compressed token accounts for a given mint and owner.
 *
 * Note: This function is intended for testing purposes only. For production, use rpc.getCompressedTokenAccounts.
 *
 * @param events    Public transaction events
 * @param owner     PublicKey of the token owner
 * @param mint      PublicKey of the token mint
 */
declare function getCompressedTokenAccounts(events: PublicTransactionEvent[]): Promise<ParsedTokenAccount[]>;
/** @internal */
declare function getCompressedTokenAccountsByOwnerTest(rpc: Rpc, owner: PublicKey, mint: PublicKey): Promise<WithCursor<ParsedTokenAccount[]>>;
declare function getCompressedTokenAccountsByDelegateTest(rpc: Rpc, delegate: PublicKey, mint: PublicKey): Promise<WithCursor<ParsedTokenAccount[]>>;
declare function getCompressedTokenAccountByHashTest(rpc: Rpc, hash: BN): Promise<ParsedTokenAccount>;

export { ADDRESS_QUEUE_ROLLOVER_FEE, ADDRESS_TREE_NETWORK_FEE, ALICE, type AccountCompression, IDL$3 as AccountCompressionIDL, AccountProofResult, type AddressWithTree, type BN254, BOB, BalanceResult, CHARLIE, type CompressedAccount, type CompressedAccountData, CompressedAccountResult, type CompressedAccountWithMerkleContext, CompressedAccountsByOwnerResult, type CompressedMintTokenHolders, CompressedMintTokenHoldersResult, type CompressedProof, type CompressedProofWithContext, CompressedTokenAccountResult, CompressedTokenAccountsByOwnerOrDelegateResult, type CompressedTokenInstructionDataTransfer, type CompressedTransaction, CompressedTransactionResult, type CompressionApiInterface, CreateUtxoError, CreateUtxoErrorCode, DAVE, DEFAULT_MERKLE_TREE_HEIGHT, DEFAULT_MERKLE_TREE_ROOTS, DEFAULT_ZERO, type EventWithParsedTokenTlvData, FIELD_SIZE, type GetCompressedAccountConfig, type GetCompressedAccountsByOwnerConfig, type GetCompressedAccountsConfig, type GetCompressedAccountsFilter, type GetCompressedTokenAccountsByOwnerOrDelegateOptions, HIGHEST_ADDRESS_PLUS_ONE, HashError, HashErrorCode, type HashWithTree, HealthResult, type HexBatchInputsForProver, type HexInputsForProver, IndexedArray, IndexedElement, IndexedElementBundle, type InputTokenDataWithContext, type InstructionDataInvoke, type LatestNonVotingSignatures, type LatestNonVotingSignaturesPaginated, LatestNonVotingSignaturesResult, LatestNonVotingSignaturesResultPaginated, type LightCompressedToken, IDL as LightCompressedTokenIDL, type LightRegistry, IDL$2 as LightRegistryIDL, type LightSystemProgram$1 as LightSystem, IDL$1 as LightSystemIDL, LightSystemProgram, type LightWasm, LookupTableError, LookupTableErrorCode, MerkeProofResult, type MerkleContext, type MerkleContextWithMerkleProof, type MerkleContextWithNewAddressProof, MerkleTree, MerkleTreeError, MerkleTreeErrorCode, MultipleCompressedAccountsResult, MultipleMerkleProofsResult, NativeBalanceResult, type NewAddressParams, type NewAddressParamsPacked, NewAddressProofResult, type NonInclusionJsonStruct, type NonInclusionMerkleProofInputs, type OutputCompressedAccountWithPackedContext, type PackedCompressedAccountWithMerkleContext, type PackedMerkleContext, type PaginatedOptions, type ParsedTokenAccount, ProofError, ProofErrorCode, type PublicTransactionEvent, type QueueIndex, Rpc, RpcError, RpcErrorCode, type RpcResult, type RpcResultError, type RpcResultSuccess, STATE_MERKLE_TREE_NETWORK_FEE, STATE_MERKLE_TREE_ROLLOVER_FEE, SelectInUtxosError, SelectInUtxosErrorCode, SignatureListResult, SignatureListWithCursorResult, type SignatureWithMetadata, SlotResult, TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD, TestRpc, type TestRpcConfig, type TokenBalance, TokenBalanceListResult, TokenBalanceListResultV2, TokenBalanceResult, type TokenData$1 as TokenData, TokenDataResult, type TokenTransferOutputData, UTXO_MERGE_MAXIMUM, UTXO_MERGE_THRESHOLD, UtilsError, UtilsErrorCode, UtxoError, UtxoErrorCode, ValidityProofResult, type WithContext, type WithCursor, type WithRpcContext, accountCompressionProgram, addressQueue, addressTree, airdropSol, bn, bufToDecStr, buildAndSignTx, buildTx, byteArrayToKeypair, calculateComputeUnitPrice, checkValidityProofShape, compress, confirmConfig, confirmTransaction, confirmTx, convertMerkleProofsWithContextToHex, convertNonInclusionMerkleProofInputsToHex, createAccount, createAccountWithLamports, createBN254, createCompressedAccount, createCompressedAccountWithMerkleContext, createMerkleContext, createRpc, createRpcResult, decompress, dedupeSigner, defaultStaticAccounts, defaultStaticAccountsStruct, defaultTestStateTreeAccounts, deriveAddress, deriveAddressSeed, encodeBN254toBase58, getAccountCompressionAuthority, getCompressedTokenAccountByHashTest, getCompressedTokenAccounts, getCompressedTokenAccountsByDelegateTest, getCompressedTokenAccountsByOwnerTest, getConnection, getIndexOrAdd, getParsedEvents, getRegisteredProgramPda, getTestKeypair, getTestRpc, hashToBn254FieldSizeBe, hashvToBn254FieldSizeBe, jsonRpcResult, jsonRpcResultAndContext, lightProgram, merkletreePubkey, negateAndCompressProof, newAccountWithLamports, noopProgram, nullifierQueuePubkey, packCompressedAccounts, packNewAddressParams, padOutputStateMerkleTrees, parseAccountData, parseEvents, parsePublicTransactionEventWithIdl, parseTokenLayoutWithIdl, pipe, placeholderValidityProof, proofFromJsonStruct, proverRequest, pushUniqueItems, rpcRequest, selectMinCompressedSolAccountsForTransfer, sendAndConfirmTx, sleep, sumUpLamports, toAccountMetas, toArray, toCamelCase, toHex, toUnixTimestamp, transfer, useWallet, validateSameOwner, validateSufficientBalance };
