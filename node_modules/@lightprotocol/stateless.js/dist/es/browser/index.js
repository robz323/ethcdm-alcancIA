import { Connection, sendAndConfirmTransaction, PublicKey, Keypair, TransactionMessage, VersionedTransaction, SystemProgram, ComputeBudgetProgram, SolanaJSONRPCError } from '@solana/web3.js';
import { BN, AnchorProvider, setProvider, Program, BorshCoder } from '@coral-xyz/anchor';
import require$$0, { Buffer as Buffer$2 } from 'buffer';
import nacl from 'tweetnacl';
import { coerce, instance, string, number as number$1, unknown, type, nullable, array, any, union, literal, create } from 'superstruct';

const IDL$3 = {
    version: '1.2.0',
    name: 'light_system_program',
    constants: [
        {
            name: 'SOL_POOL_PDA_SEED',
            type: 'bytes',
            value: '[115, 111, 108, 95, 112, 111, 111, 108, 95, 112, 100, 97]',
        },
    ],
    instructions: [
        {
            name: 'initCpiContextAccount',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'cpiContextAccount',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'associatedMerkleTree',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'invoke',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.',
                    ],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                    docs: [
                        'This pda is used to invoke the account compression program.',
                    ],
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['Merkle trees.'],
                },
                {
                    name: 'solPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol.",
                    ],
                },
                {
                    name: 'decompressionRecipient',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.',
                    ],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'invokeCpi',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.',
                    ],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'invokingProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'solPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'decompressionRecipient',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiContextAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'stubIdlBuild',
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Fee payer needs to be mutable to pay rollover and protocol fees.',
                    ],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                    docs: [
                        'This pda is used to invoke the account compression program.',
                    ],
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['Merkle trees.'],
                },
                {
                    name: 'solPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                    docs: [
                        'Sol pool pda is used to store the native sol that has been compressed.',
                        "It's only required when compressing or decompressing sol.",
                    ],
                },
                {
                    name: 'decompressionRecipient',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                    docs: [
                        'Only needs to be provided for decompression as a recipient for the',
                        'decompressed sol.',
                        'Compressed sol originate from authority.',
                    ],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs1',
                    type: {
                        defined: 'InstructionDataInvoke',
                    },
                },
                {
                    name: 'inputs2',
                    type: {
                        defined: 'InstructionDataInvokeCpi',
                    },
                },
                {
                    name: 'inputs3',
                    type: {
                        defined: 'PublicTransactionEvent',
                    },
                },
            ],
        },
    ],
    accounts: [
        {
            name: 'stateMerkleTreeAccount',
            docs: [
                'Concurrent state Merkle tree used for public compressed transactions.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'metadata',
                        type: {
                            defined: 'MerkleTreeMetadata',
                        },
                    },
                ],
            },
        },
        {
            name: 'cpiContextAccount',
            docs: [
                'Collects instruction data without executing a compressed transaction.',
                'Signer checks are performed on instruction data.',
                'Collected instruction data is combined with the instruction data of the executing cpi,',
                'and executed as a single transaction.',
                'This enables to use input compressed accounts that are owned by multiple programs,',
                'with one zero-knowledge proof.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'feePayer',
                        type: 'publicKey',
                    },
                    {
                        name: 'associatedMerkleTree',
                        type: 'publicKey',
                    },
                    {
                        name: 'context',
                        type: {
                            vec: {
                                defined: 'InstructionDataInvokeCpi',
                            },
                        },
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: 'AccessMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        docs: ['Owner of the Merkle tree.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'programOwner',
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.',
                        ],
                        type: 'publicKey',
                    },
                    {
                        name: 'forester',
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.',
                        ],
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'accessMetadata',
                        type: {
                            defined: 'AccessMetadata',
                        },
                    },
                    {
                        name: 'rolloverMetadata',
                        type: {
                            defined: 'RolloverMetadata',
                        },
                    },
                    {
                        name: 'associatedQueue',
                        type: 'publicKey',
                    },
                    {
                        name: 'nextMerkleTree',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'RolloverMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'index',
                        docs: ['Unique index.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverFee',
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverThreshold',
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        docs: ['Tip for maintaining the account.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolledoverSlot',
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'closeThreshold',
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'additionalBytes',
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.',
                        ],
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvoke',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'NewAddressParamsPacked',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'seed',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'addressQueueAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeRootIndex',
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'OutputCompressedAccountWithPackedContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleTreeIndex',
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'CompressedProof',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'a',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'b',
                        type: {
                            array: ['u8', 64],
                        },
                    },
                    {
                        name: 'c',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvokeCpi',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'cpiContext',
                        type: {
                            option: {
                                defined: 'CompressedCpiContext',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedCpiContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'setContext',
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'firstSetContext',
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'cpiContextAccountIndex',
                        docs: [
                            'Index of cpi context account in remaining accounts.',
                        ],
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'CompressedAccount',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'lamports',
                        type: 'u64',
                    },
                    {
                        name: 'address',
                        type: {
                            option: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'data',
                        type: {
                            option: {
                                defined: 'CompressedAccountData',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedAccountData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'discriminator',
                        type: {
                            array: ['u8', 8],
                        },
                    },
                    {
                        name: 'data',
                        type: 'bytes',
                    },
                    {
                        name: 'dataHash',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleContext',
                        type: {
                            defined: 'PackedMerkleContext',
                        },
                    },
                    {
                        name: 'rootIndex',
                        docs: [
                            'Index of root used in inclusion validity proof.',
                        ],
                        type: 'u16',
                    },
                    {
                        name: 'readOnly',
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.',
                        ],
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'PackedMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'leafIndex',
                        type: 'u32',
                    },
                    {
                        name: 'queueIndex',
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.',
                        ],
                        type: {
                            option: {
                                defined: 'QueueIndex',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'QueueIndex',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'queueId',
                        docs: ['Id of queue in queue account.'],
                        type: 'u8',
                    },
                    {
                        name: 'index',
                        docs: ['Index of compressed account hash in queue.'],
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeSequenceNumber',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'pubkey',
                        type: 'publicKey',
                    },
                    {
                        name: 'seq',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'PublicTransactionEvent',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'inputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'outputLeafIndices',
                        type: {
                            vec: 'u32',
                        },
                    },
                    {
                        name: 'sequenceNumbers',
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'pubkeyArray',
                        type: {
                            vec: 'publicKey',
                        },
                    },
                    {
                        name: 'message',
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: 'SumCheckFailed',
            msg: 'Sum check failed',
        },
        {
            code: 6001,
            name: 'SignerCheckFailed',
            msg: 'Signer check failed',
        },
        {
            code: 6002,
            name: 'CpiSignerCheckFailed',
            msg: 'Cpi signer check failed',
        },
        {
            code: 6003,
            name: 'ComputeInputSumFailed',
            msg: 'Computing input sum failed.',
        },
        {
            code: 6004,
            name: 'ComputeOutputSumFailed',
            msg: 'Computing output sum failed.',
        },
        {
            code: 6005,
            name: 'ComputeRpcSumFailed',
            msg: 'Computing rpc sum failed.',
        },
        {
            code: 6006,
            name: 'InvalidAddress',
            msg: 'InvalidAddress',
        },
        {
            code: 6007,
            name: 'DeriveAddressError',
            msg: 'DeriveAddressError',
        },
        {
            code: 6008,
            name: 'CompressedSolPdaUndefinedForCompressSol',
            msg: 'CompressedSolPdaUndefinedForCompressSol',
        },
        {
            code: 6009,
            name: 'DeCompressLamportsUndefinedForCompressSol',
            msg: 'DeCompressLamportsUndefinedForCompressSol',
        },
        {
            code: 6010,
            name: 'CompressedSolPdaUndefinedForDecompressSol',
            msg: 'CompressedSolPdaUndefinedForDecompressSol',
        },
        {
            code: 6011,
            name: 'DeCompressLamportsUndefinedForDecompressSol',
            msg: 'DeCompressLamportsUndefinedForDecompressSol',
        },
        {
            code: 6012,
            name: 'DecompressRecipientUndefinedForDecompressSol',
            msg: 'DecompressRecipientUndefinedForDecompressSol',
        },
        {
            code: 6013,
            name: 'WriteAccessCheckFailed',
            msg: 'WriteAccessCheckFailed',
        },
        {
            code: 6014,
            name: 'InvokingProgramNotProvided',
            msg: 'InvokingProgramNotProvided',
        },
        {
            code: 6015,
            name: 'InvalidCapacity',
            msg: 'InvalidCapacity',
        },
        {
            code: 6016,
            name: 'InvalidMerkleTreeOwner',
            msg: 'InvalidMerkleTreeOwner',
        },
        {
            code: 6017,
            name: 'ProofIsNone',
            msg: 'ProofIsNone',
        },
        {
            code: 6018,
            name: 'ProofIsSome',
            msg: 'Proof is some but no input compressed accounts or new addresses provided.',
        },
        {
            code: 6019,
            name: 'EmptyInputs',
            msg: 'EmptyInputs',
        },
        {
            code: 6020,
            name: 'CpiContextAccountUndefined',
            msg: 'CpiContextAccountUndefined',
        },
        {
            code: 6021,
            name: 'CpiContextEmpty',
            msg: 'CpiContextEmpty',
        },
        {
            code: 6022,
            name: 'CpiContextMissing',
            msg: 'CpiContextMissing',
        },
        {
            code: 6023,
            name: 'DecompressionRecipientDefined',
            msg: 'DecompressionRecipientDefined',
        },
        {
            code: 6024,
            name: 'SolPoolPdaDefined',
            msg: 'SolPoolPdaDefined',
        },
        {
            code: 6025,
            name: 'AppendStateFailed',
            msg: 'AppendStateFailed',
        },
        {
            code: 6026,
            name: 'InstructionNotCallable',
            msg: 'The instruction is not callable',
        },
        {
            code: 6027,
            name: 'CpiContextFeePayerMismatch',
            msg: 'CpiContextFeePayerMismatch',
        },
        {
            code: 6028,
            name: 'CpiContextAssociatedMerkleTreeMismatch',
            msg: 'CpiContextAssociatedMerkleTreeMismatch',
        },
        {
            code: 6029,
            name: 'NoInputs',
            msg: 'NoInputs',
        },
        {
            code: 6030,
            name: 'InputMerkleTreeIndicesNotInOrder',
            msg: 'Input merkle tree indices are not in ascending order.',
        },
        {
            code: 6031,
            name: 'OutputMerkleTreeIndicesNotInOrder',
            msg: 'Output merkle tree indices are not in ascending order.',
        },
        {
            code: 6032,
            name: 'OutputMerkleTreeNotUnique',
        },
        {
            code: 6033,
            name: 'DataFieldUndefined',
        },
    ],
};

/// TODO: extract wallet into its own npm package
const { sign } = nacl;
/// Mock Solana web3 library
class Wallet {
    _publicKey;
    _keypair;
    _connection;
    _url;
    _commitment;
    constructor(keypair, url, commitment) {
        this._publicKey = keypair.publicKey;
        this._keypair = keypair;
        this._connection = new Connection(url);
        this._url = url;
        this._commitment = commitment;
    }
    signTransaction = async (tx) => {
        await tx.sign([this._keypair]);
        return tx;
    };
    sendTransaction = async (transaction) => {
        const signature = await this._connection.sendTransaction(transaction);
        return signature;
    };
    signAllTransactions = async (transactions) => {
        const signedTxs = await Promise.all(transactions.map(async (tx) => {
            return await this.signTransaction(tx);
        }));
        return signedTxs;
    };
    signMessage = async (message) => {
        return sign.detached(message, this._keypair.secretKey);
    };
    sendAndConfirmTransaction = async (transaction, signers = []) => {
        const response = await sendAndConfirmTransaction(this._connection, transaction, [this._keypair, ...signers], {
            commitment: this._commitment,
        });
        return response;
    };
}

// TODO consider adding isNodeWallet
const useWallet = (keypair, url = 'http://127.0.0.1:8899', commitment = 'confirmed') => {
    url = url !== 'mock' ? url : 'http://127.0.0.1:8899';
    const wallet = new Wallet(keypair, url, commitment);
    return {
        publicKey: wallet._publicKey,
        sendAndConfirmTransaction: wallet.sendAndConfirmTransaction,
        signMessage: wallet.signMessage,
        signTransaction: wallet.signTransaction,
        signAllTransactions: wallet.signAllTransactions,
        sendTransaction: wallet.sendTransaction,
    };
};

const FIELD_SIZE = new BN('21888242871839275222246405745257275088548364400416034343698204186575808495617');
const HIGHEST_ADDRESS_PLUS_ONE = new BN('452312848583266388373324160190187140051835877600158453279131187530910662655');
// TODO: implement properly
const noopProgram = 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';
const lightProgram = 'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7';
const accountCompressionProgram = // also: merkletree program
 'compr6CUsB5m2jS4Y3831ztGSTnDpnKJTKS95d64XVq';
const getRegisteredProgramPda = () => new PublicKey('35hkDgaAKwMCaxRz2ocSZ6NaUrtKkyNqU6c4RV3tYJRh'); // TODO: better labelling. gov authority pda
const getAccountCompressionAuthority = () => PublicKey.findProgramAddressSync([Buffer$2.from('cpi_authority')], new PublicKey(
// TODO: can add check to ensure its consistent with the idl
lightProgram))[0];
const defaultStaticAccounts = () => [
    new PublicKey(getRegisteredProgramPda()),
    new PublicKey(noopProgram),
    new PublicKey(accountCompressionProgram),
    new PublicKey(getAccountCompressionAuthority()),
];
const defaultStaticAccountsStruct = () => {
    return {
        registeredProgramPda: new PublicKey(getRegisteredProgramPda()),
        noopProgram: new PublicKey(noopProgram),
        accountCompressionProgram: new PublicKey(accountCompressionProgram),
        accountCompressionAuthority: new PublicKey(getAccountCompressionAuthority()),
        cpiSignatureAccount: null,
    };
};
const defaultTestStateTreeAccounts = () => {
    return {
        nullifierQueue: new PublicKey(nullifierQueuePubkey),
        merkleTree: new PublicKey(merkletreePubkey),
        merkleTreeHeight: DEFAULT_MERKLE_TREE_HEIGHT,
        addressTree: new PublicKey(addressTree),
        addressQueue: new PublicKey(addressQueue),
    };
};
const nullifierQueuePubkey = 'nfq1NvQDJ2GEgnS8zt9prAe8rjjpAW1zFkrvZoBR148';
const merkletreePubkey = 'smt1NamzXdq4AMqS2fS2F1i5KTYPZRhoHgWx38d8WsT';
const addressTree = 'amt1Ayt45jfbdw5YSo7iz6WZxUmnZsQTYXy82hVwyC2';
const addressQueue = 'aq1S9z4reTSQAdgWHGD2zDaS39sjGrAxbR31vxJ2F4F';
const confirmConfig = {
    commitment: 'confirmed',
    preflightCommitment: 'confirmed',
};
const DEFAULT_MERKLE_TREE_HEIGHT = 26;
const DEFAULT_MERKLE_TREE_ROOTS = 2800;
/** Threshold (per asset) at which new in-UTXOs get merged, in order to reduce UTXO pool size */
const UTXO_MERGE_THRESHOLD = 20;
const UTXO_MERGE_MAXIMUM = 10;
/**
 * Treshold after which the currently used transaction Merkle tree is switched
 * to the next one
 */
const TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD = new BN(Math.floor(2 ** DEFAULT_MERKLE_TREE_HEIGHT * 0.95));
/**
 * Fee to provide continous funding for the state Merkle tree.
 * Once the state Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next state Merkle tree with the same parameters.
 *
 * Is charged per output compressed account.
 */
const STATE_MERKLE_TREE_ROLLOVER_FEE = new BN(300);
/**
 * Fee to provide continous funding for the address queue and address Merkle tree.
 * Once the address Merkle tree is at 95% capacity the accumulated fees
 * will be used to fund the next address queue and address tree with the same parameters.
 *
 * Is charged per newly created address.
 */
const ADDRESS_QUEUE_ROLLOVER_FEE = new BN(392);
/**
 * Is charged if the transaction nullifies at least one compressed account.
 */
const STATE_MERKLE_TREE_NETWORK_FEE = new BN(5000);
/**
 * Is charged if the transaction creates at least one address.
 */
const ADDRESS_TREE_NETWORK_FEE = new BN(5000);

var _a$1;
/**
 * Returns true if being run inside a web browser,
 * false if in a Node process or electron app.
 */
process.env.ANCHOR_BROWSER ||
    (typeof window !== "undefined" && !((_a$1 = window.process) === null || _a$1 === void 0 ? void 0 : _a$1.hasOwnProperty("type")));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

(function (module, exports) {
	/* eslint-disable node/no-deprecated-api */
	var buffer = require$$0;
	var Buffer = buffer.Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = buffer;
	} else {
	  // Copy properties from require('buffer')
	  copyProps(buffer, exports);
	  exports.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	SafeBuffer.prototype = Object.create(Buffer.prototype);

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return buffer.SlowBuffer(size)
	}; 
} (safeBuffer, safeBuffer.exports));

var safeBufferExports = safeBuffer.exports;

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = safeBufferExports.Buffer;
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    var b58 = new Uint8Array(size);
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0;
        // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
      if (carry === 255) { return }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
        // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0x00, 0, zeroes);
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
var src = base;

var basex = src;
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

var bs58$2 = basex(ALPHABET);

var bs58$3 = /*@__PURE__*/getDefaultExportFromCjs(bs58$2);

function encode$4(data) {
    return bs58$3.encode(data);
}
function decode$4(data) {
    return bs58$3.decode(data);
}

// TODO: consider implementing BN254 as wrapper class around _BN mirroring
// PublicKey this would encapsulate our runtime checks and also enforce
// typesafety at compile time
const bn = (number, base, endian) => new BN(number, base, endian);
/** Create a bigint instance with <254-bit max size and base58 capabilities */
const createBN254 = (number, base) => {
    if (base === 'base58') {
        if (typeof number !== 'string')
            throw new Error('Must be a base58 string');
        return createBN254(decode$4(number));
    }
    const bigintNumber = new BN(number, base);
    return enforceSize(bigintNumber);
};
/**
 * Enforces a maximum size of <254 bits for bigint instances. This is necessary
 * for compatibility with zk-SNARKs, where hashes must be less than the field
 * modulus (~2^254).
 */
function enforceSize(bigintNumber) {
    if (bigintNumber.gte(FIELD_SIZE)) {
        throw new Error('Value is too large. Max <254 bits');
    }
    return bigintNumber;
}
/** Convert <254-bit bigint to Base58 string.  */
function encodeBN254toBase58(bigintNumber) {
    /// enforce size
    const bn254 = createBN254(bigintNumber);
    const bn254Buffer = bn254.toArrayLike(Buffer$2, undefined, 32);
    return encode$4(bn254Buffer);
}

const createCompressedAccount = (owner, lamports, data, address) => ({
    owner,
    lamports: lamports ?? bn(0),
    address: address ?? null,
    data: data ?? null,
});
const createCompressedAccountWithMerkleContext = (merkleContext, owner, lamports, data, address) => ({
    ...createCompressedAccount(owner, lamports, data, address),
    ...merkleContext,
    readOnly: false,
});
const createMerkleContext = (merkleTree, nullifierQueue, hash, // TODO: BN254,
leafIndex) => ({
    merkleTree,
    nullifierQueue,
    hash,
    leafIndex,
});

function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
}
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes$1(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes$1(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = (word) => ((word << 24) & 0xff000000) |
    ((word << 8) & 0xff0000) |
    ((word >>> 8) & 0xff00) |
    ((word >>> 24) & 0xff);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes$1(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes$1(data);
    bytes$1(data);
    return data;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}

// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        if (!isLE)
            byteSwap32(this.state32);
        keccakP(this.state32, this.rounds);
        if (!isLE)
            byteSwap32(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        exists(this, false);
        bytes$1(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);

function byteArrayToKeypair(byteArray) {
    return Keypair.fromSecretKey(Uint8Array.from(byteArray));
}
/**
 * @internal
 * convert BN to hex with '0x' prefix
 */
function toHex$1(bn) {
    return '0x' + bn.toString('hex');
}
const toArray = (value) => Array.isArray(value) ? value : [value];
const bufToDecStr = (buf) => {
    return createBN254(buf).toString();
};
function isSmallerThanBn254FieldSizeBe(bytes) {
    const bigint = bn(bytes, undefined, 'be');
    return bigint.lt(FIELD_SIZE);
}
/**
 * Hash the provided `bytes` with Keccak256 and ensure the result fits in the
 * BN254 prime field by repeatedly hashing the inputs with various "bump seeds"
 * and truncating the resulting hash to 31 bytes.
 *
 * @deprecated Use `hashvToBn254FieldSizeBe` instead.
 */
function hashToBn254FieldSizeBe(bytes) {
    // TODO(vadorovsky, affects-onchain): Get rid of the bump mechanism, it
    // makes no sense. Doing the same as in the `hashvToBn254FieldSizeBe` below
    // - overwriting the most significant byte with zero - is sufficient for
    // truncation, it's also faster, doesn't force us to return `Option` and
    // care about handling an error which is practically never returned.
    //
    // The reason we can't do it now is that it would affect on-chain programs.
    // Once we can update programs, we can get rid of the seed bump (or even of
    // this function all together in favor of the `hashv` variant).
    let bumpSeed = 255;
    while (bumpSeed >= 0) {
        const inputWithBumpSeed = Buffer$2.concat([
            bytes,
            Buffer$2.from([bumpSeed]),
        ]);
        const hash = keccak_256(inputWithBumpSeed);
        if (hash.length !== 32) {
            throw new Error('Invalid hash length');
        }
        hash[0] = 0;
        if (isSmallerThanBn254FieldSizeBe(Buffer$2.from(hash))) {
            return [Buffer$2.from(hash), bumpSeed];
        }
        bumpSeed -= 1;
    }
    return null;
}
/**
 * Hash the provided `bytes` with Keccak256 and ensure that the result fits in
 * the BN254 prime field by truncating the resulting hash to 31 bytes.
 *
 * @param bytes Input bytes
 *
 * @returns     Hash digest
 */
function hashvToBn254FieldSizeBe(bytes) {
    const hasher = keccak_256.create();
    for (const input of bytes) {
        hasher.update(input);
    }
    const hash = hasher.digest();
    hash[0] = 0;
    return hash;
}
/** Mutates array in place */
function pushUniqueItems(items, map) {
    items.forEach(item => {
        if (!map.includes(item)) {
            map.push(item);
        }
    });
}
function toCamelCase(obj) {
    if (Array.isArray(obj)) {
        return obj.map(v => toCamelCase(v));
    }
    else if (obj !== null && obj.constructor === Object) {
        return Object.keys(obj).reduce((result, key) => {
            const camelCaseKey = key.replace(/([-_][a-z])/gi, $1 => {
                return $1.toUpperCase().replace('-', '').replace('_', '');
            });
            result[camelCaseKey] = toCamelCase(obj[key]);
            return result;
        }, {});
    }
    return obj;
}
// FIXME: check bundling and how to resolve the type error
//@ts-ignore
if (import.meta.vitest) {
    //@ts-ignore
    const { it, expect, describe } = import.meta.vitest;
    describe('toArray function', () => {
        it('should convert a single item to an array', () => {
            expect(toArray(1)).toEqual([1]);
        });
        it('should leave an array unchanged', () => {
            expect(toArray([1, 2, 3])).toEqual([1, 2, 3]);
        });
    });
    describe('isSmallerThanBn254FieldSizeBe function', () => {
        it('should return true for a small number', () => {
            const buf = Buffer$2.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
            expect(isSmallerThanBn254FieldSizeBe(buf)).toBe(true);
        });
        it('should return false for a large number', () => {
            const buf = Buffer$2.from('0000000000000000000000000000000000000000000000000000000000000065', 'hex').reverse();
            expect(isSmallerThanBn254FieldSizeBe(buf)).toBe(false);
        });
    });
    describe('hashToBn254FieldSizeBe function', () => {
        const bytes = [
            131, 219, 249, 246, 221, 196, 33, 3, 114, 23, 121, 235, 18, 229, 71,
            152, 39, 87, 169, 208, 143, 101, 43, 128, 245, 59, 22, 134, 182,
            231, 116, 33,
        ];
        const refResult = [
            0, 146, 15, 187, 171, 163, 183, 93, 237, 121, 37, 231, 55, 162, 208,
            188, 244, 77, 185, 157, 93, 9, 101, 193, 220, 247, 109, 94, 48, 212,
            98, 149,
        ];
        it('should return a valid value for initial buffer', async () => {
            const result = await hashToBn254FieldSizeBe(Buffer$2.from(bytes));
            expect(Array.from(result[0])).toEqual(refResult);
        });
        it('should return a valid value for initial buffer', async () => {
            const buf = Buffer$2.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
            const result = await hashToBn254FieldSizeBe(buf);
            expect(result).not.toBeNull();
            if (result) {
                expect(result[0]).toBeInstanceOf(Buffer$2);
                expect(result[1]).toBe(255);
            }
        });
        it('should return a valid value for a buffer that can be hashed to a smaller value', async () => {
            const buf = Buffer$2.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'hex');
            const result = await hashToBn254FieldSizeBe(buf);
            expect(result).not.toBeNull();
            if (result) {
                expect(result[1]).toBeLessThanOrEqual(255);
                expect(result[0]).toBeInstanceOf(Buffer$2);
                // Check if the hashed value is indeed smaller than the bn254 field size
                expect(isSmallerThanBn254FieldSizeBe(result[0])).toBe(true);
            }
        });
        it('should correctly hash the input buffer', async () => {
            const buf = Buffer$2.from('deadbeef', 'hex');
            const result = await hashToBn254FieldSizeBe(buf);
            expect(result).not.toBeNull();
            if (result) {
                // Since the actual hash value depends on the crypto implementation and input,
                // we cannot predict the exact output. However, we can check if the output is valid.
                expect(result[0].length).toBe(32); // SHA-256 hash length
                expect(result[1]).toBeLessThanOrEqual(255);
                expect(isSmallerThanBn254FieldSizeBe(result[0])).toBe(true);
            }
        });
    });
    describe('pushUniqueItems function', () => {
        it('should add unique items', () => {
            const map = [1, 2, 3];
            const itemsToAdd = [3, 4, 5];
            pushUniqueItems(itemsToAdd, map);
            expect(map).toEqual([1, 2, 3, 4, 5]);
        });
        it('should ignore duplicates', () => {
            const map = [1, 2, 3];
            const itemsToAdd = [1, 2, 3];
            pushUniqueItems(itemsToAdd, map);
            expect(map).toEqual([1, 2, 3]);
        });
        it('should handle empty arrays', () => {
            const map = [];
            const itemsToAdd = [];
            pushUniqueItems(itemsToAdd, map);
            expect(map).toEqual([]);
        });
    });
    describe('bufToDecStr', () => {
        it("should convert buffer [0] to '0'", () => {
            expect(bufToDecStr(Buffer$2.from([0]))).toEqual('0');
        });
        it("should convert buffer [1] to '1'", () => {
            expect(bufToDecStr(Buffer$2.from([1]))).toEqual('1');
        });
        it("should convert buffer [1, 0] to '256'", () => {
            expect(bufToDecStr(Buffer$2.from([1, 0]))).toEqual('256');
        });
        it("should convert buffer [1, 1] to '257'", () => {
            expect(bufToDecStr(Buffer$2.from([1, 1]))).toEqual('257');
        });
        it("should convert buffer [7, 91, 205, 21] to '123456789'", () => {
            expect(bufToDecStr(Buffer$2.from([7, 91, 205, 21]))).toEqual('123456789');
        });
    });
    describe('toCamelCase', () => {
        it('should convert object keys to camelCase', () => {
            const input = { test_key: 1, 'another-testKey': 2 };
            const expected = { testKey: 1, anotherTestKey: 2 };
            expect(toCamelCase(input)).toEqual(expected);
        });
        it('should handle arrays of objects', () => {
            const input = [{ array_key: 3 }, { 'another_array-key': 4 }];
            const expected = [{ arrayKey: 3 }, { anotherArrayKey: 4 }];
            expect(toCamelCase(input)).toEqual(expected);
        });
        it('should return the input if it is neither an object nor an array', () => {
            const input = 'testString';
            expect(toCamelCase(input)).toBe(input);
        });
    });
}

/**
 * @internal Finds the index of a PublicKey in an array, or adds it if not
 * present
 * */
function getIndexOrAdd(accountsArray, key) {
    const index = accountsArray.findIndex(existingKey => existingKey.equals(key));
    if (index === -1) {
        accountsArray.push(key);
        return accountsArray.length - 1;
    }
    return index;
}
/** @internal */
function padOutputStateMerkleTrees(outputStateMerkleTrees, numberOfOutputCompressedAccounts, inputCompressedAccountsWithMerkleContext) {
    if (numberOfOutputCompressedAccounts <= 0) {
        return [];
    }
    /// Default: use the 0th state tree of input state for all output accounts
    if (outputStateMerkleTrees === undefined) {
        if (inputCompressedAccountsWithMerkleContext.length === 0) {
            return new Array(numberOfOutputCompressedAccounts).fill(defaultTestStateTreeAccounts().merkleTree);
        }
        return new Array(numberOfOutputCompressedAccounts).fill(inputCompressedAccountsWithMerkleContext[0].merkleTree);
        /// Align the number of output state trees with the number of output
        /// accounts, and fill up with 0th output state tree
    }
    else {
        /// Into array
        const treesArray = toArray(outputStateMerkleTrees);
        if (treesArray.length >= numberOfOutputCompressedAccounts) {
            return treesArray.slice(0, numberOfOutputCompressedAccounts);
        }
        else {
            return treesArray.concat(new Array(numberOfOutputCompressedAccounts - treesArray.length).fill(treesArray[0]));
        }
    }
}
function toAccountMetas(remainingAccounts) {
    return remainingAccounts.map((account) => ({
        pubkey: account,
        isWritable: true,
        isSigner: false,
    }));
}
// TODO: include owner and lamports in packing.
/**
 * Packs Compressed Accounts.
 *
 * Replaces PublicKey with index pointer to remaining accounts.
 *
 * @param inputCompressedAccounts           Ix input state to be consumed
 * @param inputStateRootIndices             The recent state root indices of the
 *                                          input state. The expiry is tied to
 *                                          the proof.
 * @param outputCompressedAccounts          Ix output state to be created
 * @param outputStateMerkleTrees            Optional output state trees to be
 *                                          inserted into the output state.
 *                                          Defaults to the 0th state tree of
 *                                          the input state. Gets padded to the
 *                                          length of outputCompressedAccounts.
 *
 * @param remainingAccounts                 Optional existing array of accounts
 *                                          to append to.
 **/
function packCompressedAccounts(inputCompressedAccounts, inputStateRootIndices, outputCompressedAccounts, outputStateMerkleTrees, remainingAccounts = []) {
    const _remainingAccounts = remainingAccounts.slice();
    const packedInputCompressedAccounts = [];
    const packedOutputCompressedAccounts = [];
    /// input
    inputCompressedAccounts.forEach((account, index) => {
        const merkleTreePubkeyIndex = getIndexOrAdd(_remainingAccounts, account.merkleTree);
        const nullifierQueuePubkeyIndex = getIndexOrAdd(_remainingAccounts, account.nullifierQueue);
        packedInputCompressedAccounts.push({
            compressedAccount: {
                owner: account.owner,
                lamports: account.lamports,
                address: account.address,
                data: account.data,
            },
            merkleContext: {
                merkleTreePubkeyIndex,
                nullifierQueuePubkeyIndex,
                leafIndex: account.leafIndex,
                queueIndex: null,
            },
            rootIndex: inputStateRootIndices[index],
            readOnly: false,
        });
    });
    /// output
    const paddedOutputStateMerkleTrees = padOutputStateMerkleTrees(outputStateMerkleTrees, outputCompressedAccounts.length, inputCompressedAccounts);
    outputCompressedAccounts.forEach((account, index) => {
        const merkleTreePubkeyIndex = getIndexOrAdd(_remainingAccounts, paddedOutputStateMerkleTrees[index]);
        packedOutputCompressedAccounts.push({
            compressedAccount: {
                owner: account.owner,
                lamports: account.lamports,
                address: account.address,
                data: account.data,
            },
            merkleTreeIndex: merkleTreePubkeyIndex,
        });
    });
    return {
        packedInputCompressedAccounts,
        packedOutputCompressedAccounts,
        remainingAccounts: _remainingAccounts,
    };
}

const validateSufficientBalance = (balance) => {
    if (balance.lt(bn(0))) {
        throw new Error('Not enough balance for transfer');
    }
};
const validateSameOwner = (compressedAccounts) => {
    if (compressedAccounts.length === 0) {
        throw new Error('No accounts provided for validation');
    }
    const zerothOwner = compressedAccounts[0].owner;
    if (!compressedAccounts.every(account => account.owner.equals(zerothOwner))) {
        throw new Error('All input accounts must have the same owner');
    }
};

function deriveAddressSeed(seeds, programId) {
    const combinedSeeds = [programId.toBytes(), ...seeds];
    const hash = hashvToBn254FieldSizeBe(combinedSeeds);
    return hash;
}
/**
 * Derive an address for a compressed account from a seed and an address Merkle
 * tree public key.
 *
 * @param seed                     Seed to derive the address from
 * @param addressMerkleTreePubkey  Merkle tree public key. Defaults to
 *                                 defaultTestStateTreeAccounts().addressTree
 * @returns                        Derived address
 */
function deriveAddress(seed, addressMerkleTreePubkey = defaultTestStateTreeAccounts()
    .addressTree) {
    if (seed.length != 32) {
        throw new Error('Seed length is not 32 bytes.');
    }
    const bytes = addressMerkleTreePubkey.toBytes();
    const combined = Buffer.from([...bytes, ...seed]);
    const hash = hashToBn254FieldSizeBe(combined);
    if (hash === null) {
        throw new Error('DeriveAddressError');
    }
    const buf = hash[0];
    return new PublicKey(buf);
}
/**
 * Packs new address params for instruction data in TypeScript clients
 *
 * @param newAddressParams      New address params
 * @param remainingAccounts     Remaining accounts
 * @returns                     Packed new address params
 */
function packNewAddressParams(newAddressParams, remainingAccounts) {
    const _remainingAccounts = remainingAccounts.slice();
    const newAddressParamsPacked = newAddressParams.map(x => ({
        seed: Array.from(x.seed),
        addressMerkleTreeRootIndex: x.addressMerkleTreeRootIndex,
        addressMerkleTreeAccountIndex: 0, // will be assigned later
        addressQueueAccountIndex: 0, // will be assigned later
    }));
    newAddressParams.forEach((params, i) => {
        newAddressParamsPacked[i].addressMerkleTreeAccountIndex = getIndexOrAdd(_remainingAccounts, params.addressMerkleTreePubkey);
    });
    newAddressParams.forEach((params, i) => {
        newAddressParamsPacked[i].addressQueueAccountIndex = getIndexOrAdd(_remainingAccounts, params.addressQueuePubkey);
    });
    return { newAddressParamsPacked, remainingAccounts: _remainingAccounts };
}
//@ts-ignore
if (import.meta.vitest) {
    //@ts-ignore
    const { it, expect, describe } = import.meta.vitest;
    const programId = new PublicKey('7yucc7fL3JGbyMwg4neUaenNSdySS39hbAk89Ao3t1Hz');
    describe('derive address seed', () => {
        it('should derive a valid address seed', () => {
            const seeds = [
                new TextEncoder().encode('foo'),
                new TextEncoder().encode('bar'),
            ];
            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(new Uint8Array([
                0, 246, 150, 3, 192, 95, 53, 123, 56, 139, 206, 179, 253,
                133, 115, 103, 120, 155, 251, 72, 250, 47, 117, 217, 118,
                59, 174, 207, 49, 101, 201, 110,
            ]));
        });
        it('should derive a valid address seed', () => {
            const seeds = [
                new TextEncoder().encode('ayy'),
                new TextEncoder().encode('lmao'),
            ];
            expect(deriveAddressSeed(seeds, programId)).toStrictEqual(new Uint8Array([
                0, 202, 44, 25, 221, 74, 144, 92, 69, 168, 38, 19, 206, 208,
                29, 162, 53, 27, 120, 214, 152, 116, 15, 107, 212, 168, 33,
                121, 187, 10, 76, 233,
            ]));
        });
    });
    describe('deriveAddress function', () => {
        it('should derive a valid address from a seed and a merkle tree public key', async () => {
            const seeds = [
                new TextEncoder().encode('foo'),
                new TextEncoder().encode('bar'),
            ];
            const seed = deriveAddressSeed(seeds, programId);
            const merkleTreePubkey = new PublicKey('11111111111111111111111111111111');
            const derivedAddress = deriveAddress(seed, merkleTreePubkey);
            expect(derivedAddress).toBeInstanceOf(PublicKey);
            expect(derivedAddress).toStrictEqual(new PublicKey('139uhyyBtEh4e1CBDJ68ooK5nCeWoncZf9HPyAfRrukA'));
        });
        it('should derive a valid address from a seed and a merkle tree public key', async () => {
            const seeds = [
                new TextEncoder().encode('ayy'),
                new TextEncoder().encode('lmao'),
            ];
            const seed = deriveAddressSeed(seeds, programId);
            const merkleTreePubkey = new PublicKey('11111111111111111111111111111111');
            const derivedAddress = deriveAddress(seed, merkleTreePubkey);
            expect(derivedAddress).toBeInstanceOf(PublicKey);
            expect(derivedAddress).toStrictEqual(new PublicKey('12bhHm6PQjbNmEn3Yu1Gq9k7XwVn2rZpzYokmLwbFazN'));
        });
    });
    describe('packNewAddressParams function', () => {
        it('should pack new address params correctly', () => {
            const newAddressParams = [
                {
                    seed: new Uint8Array([1, 2, 3, 4]),
                    addressMerkleTreeRootIndex: 0,
                    addressMerkleTreePubkey: new PublicKey('11111111111111111111111111111111'),
                    addressQueuePubkey: new PublicKey('11111111111111111111111111111112'),
                },
            ];
            const remainingAccounts = [
                new PublicKey('11111111111111111111111111111112'),
                new PublicKey('11111111111111111111111111111111'),
            ];
            const packedParams = packNewAddressParams(newAddressParams, remainingAccounts);
            expect(packedParams.newAddressParamsPacked[0]
                .addressMerkleTreeAccountIndex).toBe(1);
            expect(packedParams.newAddressParamsPacked[0].addressQueueAccountIndex).toBe(0);
        });
    });
}

async function airdropSol({ connection, lamports, recipientPublicKey, }) {
    const txHash = await connection.requestAirdrop(recipientPublicKey, lamports);
    await confirmTransaction(connection, txHash);
    return txHash;
}
async function confirmTransaction(connection, signature, confirmation = 'confirmed') {
    const latestBlockHash = await connection.getLatestBlockhash(confirmation);
    const strategy = {
        signature: signature.toString(),
        lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
        blockhash: latestBlockHash.blockhash,
    };
    return await connection.confirmTransaction(strategy, confirmation);
}

const placeholderValidityProof = () => ({
    a: Array.from({ length: 32 }, (_, i) => i + 1),
    b: Array.from({ length: 64 }, (_, i) => i + 1),
    c: Array.from({ length: 32 }, (_, i) => i + 1),
});
const checkValidityProofShape = (proof) => {
    if (proof.a.length !== 32 ||
        proof.b.length !== 64 ||
        proof.c.length !== 32) {
        throw new Error('ValidityProof has invalid shape');
    }
};
function proofFromJsonStruct(json) {
    const proofAX = deserializeHexStringToBeBytes(json.ar[0]);
    const proofAY = deserializeHexStringToBeBytes(json.ar[1]);
    const proofA = new Uint8Array([...proofAX, ...proofAY]);
    const proofBX0 = deserializeHexStringToBeBytes(json.bs[0][0]);
    const proofBX1 = deserializeHexStringToBeBytes(json.bs[0][1]);
    const proofBY0 = deserializeHexStringToBeBytes(json.bs[1][0]);
    const proofBY1 = deserializeHexStringToBeBytes(json.bs[1][1]);
    const proofB = new Uint8Array([
        ...proofBX0,
        ...proofBX1,
        ...proofBY0,
        ...proofBY1,
    ]);
    const proofCX = deserializeHexStringToBeBytes(json.krs[0]);
    const proofCY = deserializeHexStringToBeBytes(json.krs[1]);
    const proofC = new Uint8Array([...proofCX, ...proofCY]);
    const proofABC = { a: proofA, b: proofB, c: proofC };
    return proofABC;
}
// TODO: add unit test for negation
// TODO: test if LE BE issue. unit test
function negateAndCompressProof(proof) {
    const proofA = proof.a;
    const proofB = proof.b;
    const proofC = proof.c;
    const aXElement = proofA.slice(0, 32);
    const aYElement = new BN(proofA.slice(32, 64), 32, 'be');
    /// Negate
    const proofAIsPositive = yElementIsPositiveG1(aYElement) ? false : true;
    /// First byte of proofA is the bitmask
    aXElement[0] = addBitmaskToByte(aXElement[0], proofAIsPositive);
    const bXElement = proofB.slice(0, 64);
    const bYElement = proofB.slice(64, 128);
    const proofBIsPositive = yElementIsPositiveG2(new BN(bYElement.slice(0, 32), 32, 'be'), new BN(bYElement.slice(32, 64), 32, 'be'));
    bXElement[0] = addBitmaskToByte(bXElement[0], proofBIsPositive);
    const cXElement = proofC.slice(0, 32);
    const cYElement = proofC.slice(32, 64);
    const proofCIsPositive = yElementIsPositiveG1(new BN(cYElement, 32, 'be'));
    cXElement[0] = addBitmaskToByte(cXElement[0], proofCIsPositive);
    const compressedProof = {
        a: Array.from(aXElement),
        b: Array.from(bXElement),
        c: Array.from(cXElement),
    };
    return compressedProof;
}
function deserializeHexStringToBeBytes(hexStr) {
    // Using BN for simpler conversion from hex string to byte array
    const bn = new BN(hexStr.startsWith('0x') ? hexStr.substring(2) : hexStr, 'hex');
    return new Uint8Array(bn.toArray('be', 32));
}
function yElementIsPositiveG1(yElement) {
    return yElement.lte(FIELD_SIZE.sub(yElement));
}
function yElementIsPositiveG2(yElement1, yElement2) {
    const fieldMidpoint = FIELD_SIZE.div(new BN(2));
    // Compare the first component of the y coordinate
    if (yElement1.lt(fieldMidpoint)) {
        return true;
    }
    else if (yElement1.gt(fieldMidpoint)) {
        return false;
    }
    // If the first component is equal to the midpoint, compare the second component
    return yElement2.lt(fieldMidpoint);
}
// bitmask compatible with solana altbn128 compression syscall and arkworks' implementation
// https://github.com/arkworks-rs/algebra/blob/master/ff/src/fields/models/fp/mod.rs#L580
// https://github.com/arkworks-rs/algebra/blob/master/serialize/src/flags.rs#L18
// fn u8_bitmask(value: u8, inf: bool, neg: bool) -> u8 {
//     let mut mask = 0;
//     match self {
//         inf => mask |= 1 << 6,
//         neg => mask |= 1 << 7,
//         _ => (),
//     }
//     mask
// }
function addBitmaskToByte(byte, yIsPositive) {
    if (!yIsPositive) {
        return (byte |= 1 << 7);
    }
    else {
        return byte;
    }
}
//@ts-ignore
if (import.meta.vitest) {
    //@ts-ignore
    const { it, expect, describe } = import.meta.vitest;
    // Unit test for addBitmaskToByte function
    describe('addBitmaskToByte', () => {
        it('should add a bitmask to the byte if yIsPositive is false', () => {
            const byte = 0b00000000;
            const yIsPositive = false;
            const result = addBitmaskToByte(byte, yIsPositive);
            expect(result).toBe(0b10000000); // 128 in binary, which is 1 << 7
        });
        it('should not modify the byte if yIsPositive is true', () => {
            const byte = 0b00000000;
            const yIsPositive = true;
            const result = addBitmaskToByte(byte, yIsPositive);
            expect(result).toBe(0b00000000);
        });
    });
    describe('test prover server', () => {
        const TEST_JSON = {
            ar: [
                '0x22bdaa3187d8fe294925a66fa0165a11bc9e07678fa2fc72402ebfd33d521c69',
                '0x2d18ff780b69898b4cdd8d7b6ac72d077799399f0f45e52665426456f3903584',
            ],
            bs: [
                [
                    '0x138cc0962e49f76a701d2871d2799892c9782940095eb0429e979f336d2e162d',
                    '0x2fe1bfbb15cbfb83d7e00ace23e45f890604003783eaf34affa35e0d6f4822bc',
                ],
                [
                    '0x1a89264f82cc6e8ef1c696bea0b5803c28c0ba6ab61366bcb71e73a4135cae8d',
                    '0xf778d857b3df01a4100265c9d014ce02d47425f0114685356165fa5ee3f3a26',
                ],
            ],
            krs: [
                '0x176b6ae9001f66832951e2d43a98a972667447bb1781f534b70cb010270dcdd3',
                '0xb748d5fac1686db28d94c02250af7eb4f28dfdabc8983305c45bcbc6e163eeb',
            ],
        };
        const COMPRESSED_PROOF_A = [
            34, 189, 170, 49, 135, 216, 254, 41, 73, 37, 166, 111, 160, 22, 90,
            17, 188, 158, 7, 103, 143, 162, 252, 114, 64, 46, 191, 211, 61, 82,
            28, 105,
        ];
        const COMPRESSED_PROOF_B = [
            147, 140, 192, 150, 46, 73, 247, 106, 112, 29, 40, 113, 210, 121,
            152, 146, 201, 120, 41, 64, 9, 94, 176, 66, 158, 151, 159, 51, 109,
            46, 22, 45, 47, 225, 191, 187, 21, 203, 251, 131, 215, 224, 10, 206,
            35, 228, 95, 137, 6, 4, 0, 55, 131, 234, 243, 74, 255, 163, 94, 13,
            111, 72, 34, 188,
        ];
        const COMPRESSED_PROOF_C = [
            23, 107, 106, 233, 0, 31, 102, 131, 41, 81, 226, 212, 58, 152, 169,
            114, 102, 116, 71, 187, 23, 129, 245, 52, 183, 12, 176, 16, 39, 13,
            205, 211,
        ];
        it('should execute a compressed token mint', async () => {
            const proof = proofFromJsonStruct(TEST_JSON);
            const compressedProof = negateAndCompressProof(proof);
            expect(compressedProof.a).toEqual(COMPRESSED_PROOF_A);
            expect(compressedProof.b).toEqual(COMPRESSED_PROOF_B);
            expect(compressedProof.c).toEqual(COMPRESSED_PROOF_C);
        });
    });
    describe('Validity Proof Functions', () => {
        describe('placeholderValidityProof', () => {
            it('should create a validity proof with correct shape', () => {
                const validityProof = placeholderValidityProof();
                expect(validityProof.a.length).toBe(32);
                expect(validityProof.b.length).toBe(64);
                expect(validityProof.c.length).toBe(32);
            });
        });
        describe('checkValidityProofShape', () => {
            it('should not throw an error for valid proof shape', () => {
                const validProof = {
                    a: Array.from(new Uint8Array(32)),
                    b: Array.from(new Uint8Array(64)),
                    c: Array.from(new Uint8Array(32)),
                };
                expect(() => checkValidityProofShape(validProof)).not.toThrow();
            });
            it('should throw an error for an invalid proof', () => {
                const invalidProof = {
                    a: Array.from(new Uint8Array(31)), // incorrect length
                    b: Array.from(new Uint8Array(64)),
                    c: Array.from(new Uint8Array(32)),
                };
                expect(() => checkValidityProofShape(invalidProof)).toThrow('ValidityProof has invalid shape');
            });
        });
    });
}

/** pipe function */
function pipe(initialFunction, ...functions) {
    return (initialValue) => functions.reduce((currentValue, currentFunction) => currentFunction(currentValue), initialFunction(initialValue));
}
//@ts-ignore
if (import.meta.vitest) {
    //@ts-ignore
    const { it, expect, describe } = import.meta.vitest;
    describe('pipe', () => {
        it('should return the result of applying all fns to the initial value', () => {
            const addOne = (x) => x + 1;
            const multiplyByTwo = (x) => x * 2;
            const subtractThree = (x) => x - 3;
            const addOneMultiplyByTwoSubtractThree = pipe(addOne, multiplyByTwo, subtractThree);
            expect(addOneMultiplyByTwoSubtractThree(5)).toBe(9);
        });
    });
}

/**
 * Builds a versioned Transaction from instructions.
 *
 * @param instructions          instructions to include
 * @param payerPublicKey        fee payer public key
 * @param blockhash             blockhash to use
 * @param lookupTableAccounts   lookup table accounts to include
 *
 * @return VersionedTransaction
 */
function buildTx(instructions, payerPublicKey, blockhash, lookupTableAccounts) {
    const messageV0 = new TransactionMessage({
        payerKey: payerPublicKey,
        recentBlockhash: blockhash,
        instructions,
    }).compileToV0Message(lookupTableAccounts);
    return new VersionedTransaction(messageV0);
}
/**
 * Sends a versioned transaction and confirms it.
 *
 * @param rpc               connection to use
 * @param tx                versioned transaction to send
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 *
 * @return TransactionSignature
 */
async function sendAndConfirmTx(rpc, tx, confirmOptions, blockHashCtx) {
    const txId = await rpc.sendTransaction(tx, confirmOptions);
    if (!blockHashCtx)
        blockHashCtx = await rpc.getLatestBlockhash();
    const transactionConfirmationStrategy0 = {
        signature: txId,
        blockhash: blockHashCtx.blockhash,
        lastValidBlockHeight: blockHashCtx.lastValidBlockHeight,
    };
    const ctxAndRes = await rpc.confirmTransaction(transactionConfirmationStrategy0, confirmOptions?.commitment || rpc.commitment || 'confirmed');
    const slot = ctxAndRes.context.slot;
    await rpc.confirmTransactionIndexed(slot);
    return txId;
}
/**
 * Confirms a transaction with a given txId.
 *
 * @param rpc               connection to use
 * @param txId              transaction signature to confirm
 * @param confirmOptions    confirmation options
 * @param blockHashCtx      blockhash context for confirmation
 * @return SignatureResult
 */
async function confirmTx(rpc, txId, confirmOptions, blockHashCtx) {
    if (!blockHashCtx)
        blockHashCtx = await rpc.getLatestBlockhash();
    const transactionConfirmationStrategy = {
        signature: txId,
        blockhash: blockHashCtx.blockhash,
        lastValidBlockHeight: blockHashCtx.lastValidBlockHeight,
    };
    const res = await rpc.confirmTransaction(transactionConfirmationStrategy, confirmOptions?.commitment || rpc.commitment || 'confirmed');
    const slot = res.context.slot;
    await rpc.confirmTransactionIndexed(slot);
    return res;
}
/**
 * Builds a versioned Transaction from instructions and signs it.
 *
 * @param instructions          instructions to include in the transaction
 * @param payer                 payer of the transaction
 * @param blockhash             recent blockhash to use in the transaction
 * @param additionalSigners     non-feepayer signers to include in the
 *                              transaction
 * @param lookupTableAccounts   lookup table accounts to include in the
 *                              transaction
 */
function buildAndSignTx(instructions, payer, blockhash, additionalSigners = [], lookupTableAccounts) {
    if (additionalSigners.includes(payer))
        throw new Error('payer must not be in additionalSigners');
    const allSigners = [payer, ...additionalSigners];
    const tx = buildTx(instructions, payer.publicKey, blockhash, lookupTableAccounts);
    tx.sign(allSigners);
    return tx;
}

// zzz
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

let c = 1;
const ALICE = getTestKeypair(255);
const BOB = getTestKeypair(254);
const CHARLIE = getTestKeypair(253);
const DAVE = getTestKeypair(252);
/**
 * Create a new account and airdrop lamports to it
 *
 * @param rpc       connection to use
 * @param lamports  amount of lamports to airdrop
 * @param counter   counter to use for generating the keypair.
 *                  If undefined or >255, generates random keypair.
 */
async function newAccountWithLamports(rpc, lamports = 1000000000, counter = undefined) {
    /// get random keypair
    if (counter === undefined || counter > 255) {
        counter = 256;
    }
    const account = getTestKeypair(counter);
    const sig = await rpc.requestAirdrop(account.publicKey, lamports);
    await confirmTx(rpc, sig);
    return account;
}
function getConnection() {
    const url = 'http://127.0.0.1:8899';
    const connection = new Connection(url, 'confirmed');
    return connection;
}
/**
 * For use in tests.
 * Generate a unique keypair by passing in a counter <255. If no counter
 * is supplied, it uses and increments a global counter.
 * if counter > 255, generates random keypair
 */
function getTestKeypair(counter = undefined) {
    if (!counter) {
        counter = c;
        c++;
    }
    if (counter > 255) {
        return Keypair.generate();
    }
    const seed = new Uint8Array(32);
    seed[31] = counter; // le
    return Keypair.fromSeed(seed);
}
//@ts-ignore
if (import.meta.vitest) {
    //@ts-ignore
    const { describe, it, expect } = import.meta.vitest;
    describe('getTestKeypair', () => {
        it('should generate a keypair with a specific counter', () => {
            const keypair = getTestKeypair(10);
            const keypair2 = getTestKeypair(10);
            expect(keypair).toEqual(keypair2);
            expect(keypair).toBeInstanceOf(Keypair);
            expect(keypair.publicKey).toBeDefined();
            expect(keypair.secretKey).toBeDefined();
        });
        it('should generate random keypair if counter is greater than 255', () => {
            const testFn = () => getTestKeypair(256);
            const kp1 = testFn();
            const kp2 = testFn();
            expect(kp1).not.toEqual(kp2);
        });
        it('should increment the global counter if no counter is provided', () => {
            const initialKeypair = getTestKeypair();
            const nextKeypair = getTestKeypair();
            const nextNextKeypair = getTestKeypair();
            const nextNextNextKeypair = getTestKeypair(3);
            expect(initialKeypair).not.toEqual(nextKeypair);
            expect(nextKeypair).not.toEqual(nextNextKeypair);
            expect(nextNextKeypair).toEqual(nextNextNextKeypair);
        });
    });
}

/**
 * @param targetLamports - Target priority fee in lamports
 * @param computeUnits - Expected compute units used by the transaction
 * @returns microLamports per compute unit (use in
 * `ComputeBudgetProgram.setComputeUnitPrice`)
 */
function calculateComputeUnitPrice(targetLamports, computeUnits) {
    return Math.ceil((targetLamports * 1_000_000) / computeUnits);
}

const sumUpLamports = (accounts) => {
    return accounts.reduce((acc, account) => acc.add(bn(account.lamports)), bn(0));
};
const SOL_POOL_PDA_SEED = Buffer$2.from('sol_pool_pda');
class LightSystemProgram {
    /**
     * @internal
     */
    constructor() { }
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId = new PublicKey(
    // TODO: can add check to ensure its consistent with the idl
    'SySTEM1eSU2p4BGQfQpimFEWWSC1XDFeun3Nqzz3rT7');
    static _program = null;
    static get program() {
        if (!this._program) {
            this.initializeProgram();
        }
        return this._program;
    }
    /**
     * @internal
     * Cwct1kQLwJm8Z3HetLu8m4SXkhD6FZ5fXbJQCxTxPnGY
     *
     */
    static deriveCompressedSolPda() {
        const seeds = [SOL_POOL_PDA_SEED];
        const [address, _] = PublicKey.findProgramAddressSync(seeds, this.programId);
        return address;
    }
    /**
     * Initializes the program statically if not already initialized.
     */
    static initializeProgram() {
        if (!this._program) {
            const mockKeypair = Keypair.generate();
            const mockConnection = new Connection('http://127.0.0.1:8899', 'confirmed');
            const mockProvider = new AnchorProvider(mockConnection, useWallet(mockKeypair), {
                commitment: 'confirmed',
                preflightCommitment: 'confirmed',
            });
            setProvider(mockProvider);
            this._program = new Program(IDL$3, this.programId, mockProvider);
        }
    }
    static createTransferOutputState(inputCompressedAccounts, toAddress, lamports) {
        lamports = bn(lamports);
        const inputLamports = sumUpLamports(inputCompressedAccounts);
        const changeLamports = inputLamports.sub(lamports);
        validateSufficientBalance(changeLamports);
        if (changeLamports.eq(bn(0))) {
            return [createCompressedAccount(toAddress, lamports)];
        }
        validateSameOwner(inputCompressedAccounts);
        const outputCompressedAccounts = [
            createCompressedAccount(inputCompressedAccounts[0].owner, changeLamports),
            createCompressedAccount(toAddress, lamports),
        ];
        return outputCompressedAccounts;
    }
    static createDecompressOutputState(inputCompressedAccounts, lamports) {
        lamports = bn(lamports);
        const inputLamports = sumUpLamports(inputCompressedAccounts);
        const changeLamports = inputLamports.sub(lamports);
        validateSufficientBalance(changeLamports);
        /// lamports gets decompressed
        if (changeLamports.eq(bn(0))) {
            return [];
        }
        validateSameOwner(inputCompressedAccounts);
        const outputCompressedAccounts = [
            createCompressedAccount(inputCompressedAccounts[0].owner, changeLamports),
        ];
        return outputCompressedAccounts;
    }
    /**
     * No data by default
     */
    static createNewAddressOutputState(address, owner, lamports, inputCompressedAccounts) {
        lamports = bn(lamports ?? 0);
        const inputLamports = sumUpLamports(inputCompressedAccounts ?? []);
        const changeLamports = inputLamports.sub(lamports);
        validateSufficientBalance(changeLamports);
        if (changeLamports.eq(bn(0)) || !inputCompressedAccounts) {
            return [
                createCompressedAccount(owner, lamports, undefined, address),
            ];
        }
        validateSameOwner(inputCompressedAccounts);
        const outputCompressedAccounts = [
            createCompressedAccount(inputCompressedAccounts[0].owner, changeLamports),
            createCompressedAccount(owner, lamports, undefined, address),
        ];
        return outputCompressedAccounts;
    }
    /**
     * Creates instruction to create compressed account with PDA.
     * Cannot write data.
     *
     * TODO: support transfer of lamports to the new account.
     */
    static async createAccount({ payer, newAddressParams, newAddress, recentValidityProof, outputStateTree, inputCompressedAccounts, inputStateRootIndices, lamports, }) {
        const outputCompressedAccounts = this.createNewAddressOutputState(newAddress, payer, lamports, inputCompressedAccounts);
        /// Pack accounts
        const { packedInputCompressedAccounts, packedOutputCompressedAccounts, remainingAccounts: _remainingAccounts, } = packCompressedAccounts(inputCompressedAccounts ?? [], inputStateRootIndices ?? [], outputCompressedAccounts, outputStateTree);
        const { newAddressParamsPacked, remainingAccounts } = packNewAddressParams([newAddressParams], _remainingAccounts);
        const rawData = {
            proof: recentValidityProof,
            inputCompressedAccountsWithMerkleContext: packedInputCompressedAccounts,
            outputCompressedAccounts: packedOutputCompressedAccounts,
            relayFee: null,
            newAddressParams: newAddressParamsPacked,
            compressOrDecompressLamports: null,
            isCompress: false,
        };
        /// Encode instruction data
        const ixData = this.program.coder.types.encode('InstructionDataInvoke', rawData);
        /// Build anchor instruction
        const instruction = await this.program.methods
            .invoke(ixData)
            .accounts({
            ...defaultStaticAccountsStruct(),
            feePayer: payer,
            authority: payer,
            solPoolPda: null,
            decompressionRecipient: null,
            systemProgram: SystemProgram.programId,
        })
            .remainingAccounts(toAccountMetas(remainingAccounts))
            .instruction();
        return instruction;
    }
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static async transfer({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTrees, }) {
        /// Create output state
        const outputCompressedAccounts = this.createTransferOutputState(inputCompressedAccounts, toAddress, lamports);
        /// Pack accounts
        const { packedInputCompressedAccounts, packedOutputCompressedAccounts, remainingAccounts, } = packCompressedAccounts(inputCompressedAccounts, recentInputStateRootIndices, outputCompressedAccounts, outputStateTrees);
        /// Encode instruction data
        const data = this.program.coder.types.encode('InstructionDataInvoke', {
            proof: recentValidityProof,
            inputCompressedAccountsWithMerkleContext: packedInputCompressedAccounts,
            outputCompressedAccounts: packedOutputCompressedAccounts,
            relayFee: null,
            /// TODO: here and on-chain: option<newAddressInputs> or similar.
            newAddressParams: [],
            compressOrDecompressLamports: null,
            isCompress: false,
        });
        /// Build anchor instruction
        const instruction = await this.program.methods
            .invoke(data)
            .accounts({
            ...defaultStaticAccountsStruct(),
            feePayer: payer,
            authority: payer,
            solPoolPda: null,
            decompressionRecipient: null,
            systemProgram: SystemProgram.programId,
        })
            .remainingAccounts(toAccountMetas(remainingAccounts))
            .instruction();
        return instruction;
    }
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    // TODO: add support for non-fee-payer owner
    static async compress({ payer, toAddress, lamports, outputStateTree, }) {
        /// Create output state
        lamports = bn(lamports);
        const outputCompressedAccount = createCompressedAccount(toAddress, lamports);
        /// Pack accounts
        const { packedInputCompressedAccounts, packedOutputCompressedAccounts, remainingAccounts, } = packCompressedAccounts([], [], [outputCompressedAccount], outputStateTree);
        /// Encode instruction data
        const rawInputs = {
            proof: null,
            inputCompressedAccountsWithMerkleContext: packedInputCompressedAccounts,
            outputCompressedAccounts: packedOutputCompressedAccounts,
            relayFee: null,
            /// TODO: here and on-chain: option<newAddressInputs> or similar.
            newAddressParams: [],
            compressOrDecompressLamports: lamports,
            isCompress: true,
        };
        const data = this.program.coder.types.encode('InstructionDataInvoke', rawInputs);
        /// Build anchor instruction
        const instruction = await this.program.methods
            .invoke(data)
            .accounts({
            ...defaultStaticAccountsStruct(),
            feePayer: payer,
            authority: payer,
            solPoolPda: this.deriveCompressedSolPda(),
            decompressionRecipient: null,
            systemProgram: SystemProgram.programId,
        })
            .remainingAccounts(toAccountMetas(remainingAccounts))
            .instruction();
        return instruction;
    }
    /**
     * Creates a transaction instruction that transfers compressed lamports from
     * one owner to another.
     */
    static async decompress({ payer, inputCompressedAccounts, toAddress, lamports, recentInputStateRootIndices, recentValidityProof, outputStateTree, }) {
        /// Create output state
        lamports = bn(lamports);
        const outputCompressedAccounts = this.createDecompressOutputState(inputCompressedAccounts, lamports);
        /// Pack accounts
        const { packedInputCompressedAccounts, packedOutputCompressedAccounts, remainingAccounts, } = packCompressedAccounts(inputCompressedAccounts, recentInputStateRootIndices, outputCompressedAccounts, outputStateTree);
        /// Encode instruction data
        const data = this.program.coder.types.encode('InstructionDataInvoke', {
            proof: recentValidityProof,
            inputCompressedAccountsWithMerkleContext: packedInputCompressedAccounts,
            outputCompressedAccounts: packedOutputCompressedAccounts,
            relayFee: null,
            /// TODO: here and on-chain: option<newAddressInputs> or similar.
            newAddressParams: [],
            compressOrDecompressLamports: lamports,
            isCompress: false,
        });
        /// Build anchor instruction
        const instruction = await this.program.methods
            .invoke(data)
            .accounts({
            ...defaultStaticAccountsStruct(),
            feePayer: payer,
            authority: payer,
            solPoolPda: this.deriveCompressedSolPda(),
            decompressionRecipient: toAddress,
            systemProgram: SystemProgram.programId,
        })
            .remainingAccounts(toAccountMetas(remainingAccounts))
            .instruction();
        return instruction;
    }
}
/**
 * Selects the minimal number of compressed SOL accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
function selectMinCompressedSolAccountsForTransfer(accounts, transferLamports) {
    let accumulatedLamports = bn(0);
    transferLamports = bn(transferLamports);
    const selectedAccounts = [];
    accounts.sort((a, b) => b.lamports.cmp(a.lamports));
    for (const account of accounts) {
        if (accumulatedLamports.gte(bn(transferLamports)))
            break;
        accumulatedLamports = accumulatedLamports.add(account.lamports);
        selectedAccounts.push(account);
    }
    if (accumulatedLamports.lt(bn(transferLamports))) {
        throw new Error(`Not enough balance for transfer. Required: ${transferLamports.toString()}, available: ${accumulatedLamports.toString()}`);
    }
    return [selectedAccounts, accumulatedLamports];
}

/**
 * Compress lamports to a solana address
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
/// TODO: add multisig support
/// TODO: add support for payer != owner
async function compress(rpc, payer, lamports, toAddress, outputStateTree, confirmOptions) {
    const { blockhash } = await rpc.getLatestBlockhash();
    const ix = await LightSystemProgram.compress({
        payer: payer.publicKey,
        toAddress,
        lamports,
        outputStateTree,
    });
    const tx = buildAndSignTx([ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix], payer, blockhash, []);
    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/**
 * Create compressed account with address
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
async function createAccount(rpc, payer, seeds, programId, addressTree, addressQueue, outputStateTree, confirmOptions) {
    const { blockhash } = await rpc.getLatestBlockhash();
    addressTree = addressTree ?? defaultTestStateTreeAccounts().addressTree;
    addressQueue = addressQueue ?? defaultTestStateTreeAccounts().addressQueue;
    const seed = deriveAddressSeed(seeds, programId);
    const address = deriveAddress(seed, addressTree);
    const proof = await rpc.getValidityProofV0(undefined, [
        {
            address: bn(address.toBytes()),
            tree: addressTree,
            queue: addressQueue,
        },
    ]);
    const params = {
        seed: seed,
        addressMerkleTreeRootIndex: proof.rootIndices[0],
        addressMerkleTreePubkey: proof.merkleTrees[0],
        addressQueuePubkey: proof.nullifierQueues[0],
    };
    const ix = await LightSystemProgram.createAccount({
        payer: payer.publicKey,
        newAddressParams: params,
        newAddress: Array.from(address.toBytes()),
        recentValidityProof: proof.compressedProof,
        programId,
        outputStateTree,
    });
    const tx = buildAndSignTx([ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix], payer, blockhash, []);
    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}
/**
 * Create compressed account with address and lamports
 *
 * @param rpc               RPC to use
 * @param payer             Payer of the transaction and initialization fees
 * @param seeds             Seeds to derive the new account address
 * @param lamports          Number of compressed lamports to initialize the
 *                          account with
 * @param programId         Owner of the new account
 * @param addressTree       Optional address tree. Defaults to a current shared
 *                          address tree.
 * @param addressQueue      Optional address queue. Defaults to a current shared
 *                          address queue.
 * @param outputStateTree   Optional output state tree. Defaults to a current
 *                          shared state tree.
 * @param confirmOptions    Options for confirming the transaction
 *
 * @return                  Transaction signature
 */
// TODO: add support for payer != user owner
async function createAccountWithLamports(rpc, payer, seeds, lamports, programId, addressTree, addressQueue, outputStateTree, confirmOptions) {
    lamports = bn(lamports);
    const compressedAccounts = await rpc.getCompressedAccountsByOwner(payer.publicKey);
    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(compressedAccounts.items, lamports);
    const { blockhash } = await rpc.getLatestBlockhash();
    addressTree = addressTree ?? defaultTestStateTreeAccounts().addressTree;
    addressQueue = addressQueue ?? defaultTestStateTreeAccounts().addressQueue;
    const seed = deriveAddressSeed(seeds, programId);
    const address = deriveAddress(seed, addressTree);
    const proof = await rpc.getValidityProof(inputAccounts.map(account => bn(account.hash)), [bn(address.toBytes())]);
    /// TODO(crank): Adapt before supporting addresses in rpc / cranked address trees.
    /// Currently expects address roots to be consistent with one another and
    /// static. See test-rpc.ts for more details.
    const params = {
        seed: seed,
        addressMerkleTreeRootIndex: proof.rootIndices[proof.rootIndices.length - 1],
        addressMerkleTreePubkey: proof.merkleTrees[proof.merkleTrees.length - 1],
        addressQueuePubkey: proof.nullifierQueues[proof.nullifierQueues.length - 1],
    };
    const ix = await LightSystemProgram.createAccount({
        payer: payer.publicKey,
        newAddressParams: params,
        newAddress: Array.from(address.toBytes()),
        recentValidityProof: proof.compressedProof,
        inputCompressedAccounts: inputAccounts,
        inputStateRootIndices: proof.rootIndices,
        programId,
        outputStateTree,
    });
    const tx = buildAndSignTx([ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix], payer, blockhash, []);
    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/**
 * Decompress lamports into a solana account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param lamports        Amount of lamports to compress
 * @param toAddress       Address of the recipient compressed account
 * @param outputStateTree Optional output state tree. Defaults to a current shared state tree.
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Transaction signature
 */
/// TODO: add multisig support
/// TODO: add support for payer != owner
async function decompress(rpc, payer, lamports, recipient, outputStateTree, confirmOptions) {
    /// TODO: use dynamic state tree and nullifier queue
    const userCompressedAccountsWithMerkleContext = (await rpc.getCompressedAccountsByOwner(payer.publicKey)).items;
    lamports = bn(lamports);
    const inputLamports = sumUpLamports(userCompressedAccountsWithMerkleContext);
    if (lamports.gt(inputLamports)) {
        throw new Error(`Not enough compressed lamports. Expected ${lamports}, got ${inputLamports}`);
    }
    const proof = await rpc.getValidityProof(userCompressedAccountsWithMerkleContext.map(x => bn(x.hash)));
    const { blockhash } = await rpc.getLatestBlockhash();
    const ix = await LightSystemProgram.decompress({
        payer: payer.publicKey,
        toAddress: recipient,
        outputStateTree: outputStateTree,
        inputCompressedAccounts: userCompressedAccountsWithMerkleContext,
        recentValidityProof: proof.compressedProof,
        recentInputStateRootIndices: proof.rootIndices,
        lamports,
    });
    const tx = buildAndSignTx([ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix], payer, blockhash, []);
    const txId = await sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/** @internal remove signer from signers if part of signers */
function dedupeSigner(signer, signers) {
    if (signers.includes(signer)) {
        return signers.filter(s => s.publicKey.toString() !== signer.publicKey.toString());
    }
    return signers;
}

/**
 * Transfer compressed lamports from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of transaction fees
 * @param lamports       Number of lamports to transfer
 * @param owner          Owner of the compressed lamports
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed lamports should be
 *                       inserted into. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 * @param config         Configuration for fetching compressed accounts
 *
 *
 * @return Signature of the confirmed transaction
 */
async function transfer(rpc, payer, lamports, owner, toAddress, 
/// TODO: allow multiple
merkleTree, confirmOptions) {
    let accumulatedLamports = bn(0);
    const compressedAccounts = [];
    let cursor;
    const batchSize = 1000; // Maximum allowed by the API
    lamports = bn(lamports);
    while (accumulatedLamports.lt(lamports)) {
        const batchConfig = {
            filters: undefined,
            dataSlice: undefined,
            cursor,
            limit: new BN(batchSize),
        };
        const batch = await rpc.getCompressedAccountsByOwner(owner.publicKey, batchConfig);
        for (const account of batch.items) {
            if (account.lamports.gt(new BN(0))) {
                compressedAccounts.push(account);
                accumulatedLamports = accumulatedLamports.add(account.lamports);
            }
        }
        cursor = batch.cursor ?? undefined;
        if (batch.items.length < batchSize || accumulatedLamports.gte(lamports))
            break;
    }
    if (accumulatedLamports.lt(lamports)) {
        throw new Error(`Not enough balance for transfer. Required: ${lamports.toString()}, available: ${accumulatedLamports.toString()}`);
    }
    const [inputAccounts] = selectMinCompressedSolAccountsForTransfer(compressedAccounts, lamports);
    const proof = await rpc.getValidityProof(inputAccounts.map(account => bn(account.hash)));
    const ix = await LightSystemProgram.transfer({
        payer: payer.publicKey,
        inputCompressedAccounts: inputAccounts,
        toAddress,
        lamports,
        recentInputStateRootIndices: proof.rootIndices,
        recentValidityProof: proof.compressedProof,
        outputStateTrees: merkleTree,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const signedTx = buildAndSignTx([ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }), ix], payer, blockhash);
    const txId = await sendAndConfirmTx(rpc, signedTx, confirmOptions);
    return txId;
}

const IDL$2 = {
    version: '1.2.0',
    name: 'account_compression',
    constants: [
        {
            name: 'CPI_AUTHORITY_PDA_SEED',
            type: 'bytes',
            value: '[99, 112, 105, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]',
        },
        {
            name: 'GROUP_AUTHORITY_SEED',
            type: 'bytes',
            value: '[103, 114, 111, 117, 112, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121]',
        },
        {
            name: 'STATE_MERKLE_TREE_HEIGHT',
            type: 'u64',
            value: '26',
        },
        {
            name: 'STATE_MERKLE_TREE_CHANGELOG',
            type: 'u64',
            value: '1400',
        },
        {
            name: 'STATE_MERKLE_TREE_ROOTS',
            type: 'u64',
            value: '2400',
        },
        {
            name: 'STATE_MERKLE_TREE_CANOPY_DEPTH',
            type: 'u64',
            value: '10',
        },
        {
            name: 'STATE_NULLIFIER_QUEUE_VALUES',
            type: 'u16',
            value: '28_807',
        },
        {
            name: 'STATE_NULLIFIER_QUEUE_SEQUENCE_THRESHOLD',
            type: 'u64',
            value: '2400',
        },
        {
            name: 'ADDRESS_MERKLE_TREE_HEIGHT',
            type: 'u64',
            value: '26',
        },
        {
            name: 'ADDRESS_MERKLE_TREE_CHANGELOG',
            type: 'u64',
            value: '1400',
        },
        {
            name: 'ADDRESS_MERKLE_TREE_ROOTS',
            type: 'u64',
            value: '2400',
        },
        {
            name: 'ADDRESS_MERKLE_TREE_CANOPY_DEPTH',
            type: 'u64',
            value: '10',
        },
        {
            name: 'ADDRESS_MERKLE_TREE_INDEXED_CHANGELOG',
            type: 'u64',
            value: '1400',
        },
        {
            name: 'ADDRESS_QUEUE_VALUES',
            type: 'u16',
            value: '28_807',
        },
        {
            name: 'ADDRESS_QUEUE_SEQUENCE_THRESHOLD',
            type: 'u64',
            value: '2400',
        },
        {
            name: 'NOOP_PUBKEY',
            type: {
                array: ['u8', 32],
            },
            value: '[11 , 188 , 15 , 192 , 187 , 71 , 202 , 47 , 116 , 196 , 17 , 46 , 148 , 171 , 19 , 207 , 163 , 198 , 52 , 229 , 220 , 23 , 234 , 203 , 3 , 205 , 26 , 35 , 205 , 126 , 120 , 124 ,]',
        },
    ],
    instructions: [
        {
            name: 'initializeAddressMerkleTreeAndQueue',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'queue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'index',
                    type: 'u64',
                },
                {
                    name: 'programOwner',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'forester',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'addressMerkleTreeConfig',
                    type: {
                        defined: 'AddressMerkleTreeConfig',
                    },
                },
                {
                    name: 'addressQueueConfig',
                    type: {
                        defined: 'AddressQueueConfig',
                    },
                },
            ],
        },
        {
            name: 'insertAddresses',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['Fee payer pays rollover fee.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'addresses',
                    type: {
                        vec: {
                            array: ['u8', 32],
                        },
                    },
                },
            ],
        },
        {
            name: 'updateAddressMerkleTree',
            docs: ['Updates the address Merkle tree with a new address.'],
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'queue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'logWrapper',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'changelogIndex',
                    type: 'u16',
                },
                {
                    name: 'indexedChangelogIndex',
                    type: 'u16',
                },
                {
                    name: 'value',
                    type: 'u16',
                },
                {
                    name: 'lowAddressIndex',
                    type: 'u64',
                },
                {
                    name: 'lowAddressValue',
                    type: {
                        array: ['u8', 32],
                    },
                },
                {
                    name: 'lowAddressNextIndex',
                    type: 'u64',
                },
                {
                    name: 'lowAddressNextValue',
                    type: {
                        array: ['u8', 32],
                    },
                },
                {
                    name: 'lowAddressProof',
                    type: {
                        array: [
                            {
                                array: ['u8', 32],
                            },
                            16,
                        ],
                    },
                },
            ],
        },
        {
            name: 'rolloverAddressMerkleTreeAndQueue',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Signer used to receive rollover accounts rentexemption reimbursement.',
                    ],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'newAddressMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldAddressMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldQueue',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'initializeGroupAuthority',
            docs: [
                'initialize group (a group can be used to give multiple programs access',
                'to the same Merkle trees by registering the programs to the group)',
            ],
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'seed',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Seed public key used to derive the group authority.',
                    ],
                },
                {
                    name: 'groupAuthority',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'authority',
                    type: 'publicKey',
                },
            ],
        },
        {
            name: 'updateGroupAuthority',
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'groupAuthority',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'authority',
                    type: 'publicKey',
                },
            ],
        },
        {
            name: 'registerProgramToGroup',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'programToBeRegistered',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'groupAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'deregisterProgram',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'groupAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'closeRecipient',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'initializeStateMerkleTreeAndNullifierQueue',
            docs: [
                'Initializes a new Merkle tree from config bytes.',
                'Index is an optional identifier and not checked by the program.',
            ],
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'nullifierQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'index',
                    type: 'u64',
                },
                {
                    name: 'programOwner',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'forester',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'stateMerkleTreeConfig',
                    type: {
                        defined: 'StateMerkleTreeConfig',
                    },
                },
                {
                    name: 'nullifierQueueConfig',
                    type: {
                        defined: 'NullifierQueueConfig',
                    },
                },
                {
                    name: 'additionalBytes',
                    type: 'u64',
                },
            ],
        },
        {
            name: 'appendLeavesToMerkleTrees',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['Fee payer pays rollover fee.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Checked whether instruction is accessed by a registered program or owner = authority.',
                    ],
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                    docs: [
                        'Some assumes that the Merkle trees are accessed by a registered program.',
                        'None assumes that the Merkle trees are accessed by its owner.',
                    ],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'leaves',
                    type: {
                        vec: {
                            defined: '(u8,[u8;32])',
                        },
                    },
                },
            ],
        },
        {
            name: 'nullifyLeaves',
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'logWrapper',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'nullifierQueue',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'changeLogIndices',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'leavesQueueIndices',
                    type: {
                        vec: 'u16',
                    },
                },
                {
                    name: 'leafIndices',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'proofs',
                    type: {
                        vec: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                },
            ],
        },
        {
            name: 'insertIntoNullifierQueues',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['Fee payer pays rollover fee.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'nullifiers',
                    type: {
                        vec: {
                            array: ['u8', 32],
                        },
                    },
                },
            ],
        },
        {
            name: 'rolloverStateMerkleTreeAndNullifierQueue',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Signer used to receive rollover accounts rentexemption reimbursement.',
                    ],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'newStateMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newNullifierQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldStateMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldNullifierQueue',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [],
        },
    ],
    accounts: [
        {
            name: 'registeredProgram',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'registeredProgramId',
                        type: 'publicKey',
                    },
                    {
                        name: 'groupAuthorityPda',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'accessMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        docs: ['Owner of the Merkle tree.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'programOwner',
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.',
                        ],
                        type: 'publicKey',
                    },
                    {
                        name: 'forester',
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.',
                        ],
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'addressMerkleTreeAccount',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'metadata',
                        type: {
                            defined: 'MerkleTreeMetadata',
                        },
                    },
                ],
            },
        },
        {
            name: 'groupAuthority',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'authority',
                        type: 'publicKey',
                    },
                    {
                        name: 'seed',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'merkleTreeMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'accessMetadata',
                        type: {
                            defined: 'AccessMetadata',
                        },
                    },
                    {
                        name: 'rolloverMetadata',
                        type: {
                            defined: 'RolloverMetadata',
                        },
                    },
                    {
                        name: 'associatedQueue',
                        type: 'publicKey',
                    },
                    {
                        name: 'nextMerkleTree',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'stateMerkleTreeAccount',
            docs: [
                'Concurrent state Merkle tree used for public compressed transactions.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'metadata',
                        type: {
                            defined: 'MerkleTreeMetadata',
                        },
                    },
                ],
            },
        },
        {
            name: 'queueMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'accessMetadata',
                        type: {
                            defined: 'AccessMetadata',
                        },
                    },
                    {
                        name: 'rolloverMetadata',
                        type: {
                            defined: 'RolloverMetadata',
                        },
                    },
                    {
                        name: 'associatedMerkleTree',
                        type: 'publicKey',
                    },
                    {
                        name: 'nextQueue',
                        type: 'publicKey',
                    },
                    {
                        name: 'queueType',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'queueAccount',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'metadata',
                        type: {
                            defined: 'QueueMetadata',
                        },
                    },
                ],
            },
        },
        {
            name: 'rolloverMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'index',
                        docs: ['Unique index.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverFee',
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverThreshold',
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        docs: ['Tip for maintaining the account.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolledoverSlot',
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'closeThreshold',
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'additionalBytes',
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.',
                        ],
                        type: 'u64',
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: 'AddressMerkleTreeConfig',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'height',
                        type: 'u32',
                    },
                    {
                        name: 'changelogSize',
                        type: 'u64',
                    },
                    {
                        name: 'rootsSize',
                        type: 'u64',
                    },
                    {
                        name: 'canopyDepth',
                        type: 'u64',
                    },
                    {
                        name: 'addressChangelogSize',
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'rolloverThreshold',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'closeThreshold',
                        type: {
                            option: 'u64',
                        },
                    },
                ],
            },
        },
        {
            name: 'StateMerkleTreeConfig',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'height',
                        type: 'u32',
                    },
                    {
                        name: 'changelogSize',
                        type: 'u64',
                    },
                    {
                        name: 'rootsSize',
                        type: 'u64',
                    },
                    {
                        name: 'canopyDepth',
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'rolloverThreshold',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'closeThreshold',
                        type: {
                            option: 'u64',
                        },
                    },
                ],
            },
        },
        {
            name: 'NullifierQueueConfig',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'capacity',
                        type: 'u16',
                    },
                    {
                        name: 'sequenceThreshold',
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        type: {
                            option: 'u64',
                        },
                    },
                ],
            },
        },
        {
            name: 'QueueType',
            type: {
                kind: 'enum',
                variants: [
                    {
                        name: 'NullifierQueue',
                    },
                    {
                        name: 'AddressQueue',
                    },
                ],
            },
        },
        {
            name: 'AddressQueueConfig',
            type: {
                kind: 'alias',
                value: {
                    defined: 'NullifierQueueConfig',
                },
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: 'IntegerOverflow',
            msg: 'Integer overflow',
        },
        {
            code: 6001,
            name: 'InvalidAuthority',
            msg: 'InvalidAuthority',
        },
        {
            code: 6002,
            name: 'NumberOfLeavesMismatch',
            msg: 'Leaves <> remaining accounts mismatch. The number of remaining accounts must match the number of leaves.',
        },
        {
            code: 6003,
            name: 'InvalidNoopPubkey',
            msg: 'Provided noop program public key is invalid',
        },
        {
            code: 6004,
            name: 'NumberOfChangeLogIndicesMismatch',
            msg: 'Number of change log indices mismatch',
        },
        {
            code: 6005,
            name: 'NumberOfIndicesMismatch',
            msg: 'Number of indices mismatch',
        },
        {
            code: 6006,
            name: 'NumberOfProofsMismatch',
            msg: 'NumberOfProofsMismatch',
        },
        {
            code: 6007,
            name: 'InvalidMerkleProof',
            msg: 'InvalidMerkleProof',
        },
        {
            code: 6008,
            name: 'LeafNotFound',
            msg: 'Could not find the leaf in the queue',
        },
        {
            code: 6009,
            name: 'MerkleTreeAndQueueNotAssociated',
            msg: 'MerkleTreeAndQueueNotAssociated',
        },
        {
            code: 6010,
            name: 'MerkleTreeAlreadyRolledOver',
            msg: 'MerkleTreeAlreadyRolledOver',
        },
        {
            code: 6011,
            name: 'NotReadyForRollover',
            msg: 'NotReadyForRollover',
        },
        {
            code: 6012,
            name: 'RolloverNotConfigured',
            msg: 'RolloverNotConfigured',
        },
        {
            code: 6013,
            name: 'NotAllLeavesProcessed',
            msg: 'NotAllLeavesProcessed',
        },
        {
            code: 6014,
            name: 'InvalidQueueType',
            msg: 'InvalidQueueType',
        },
        {
            code: 6015,
            name: 'InputElementsEmpty',
            msg: 'InputElementsEmpty',
        },
        {
            code: 6016,
            name: 'NoLeavesForMerkleTree',
            msg: 'NoLeavesForMerkleTree',
        },
        {
            code: 6017,
            name: 'InvalidAccountSize',
            msg: 'InvalidAccountSize',
        },
        {
            code: 6018,
            name: 'InsufficientRolloverFee',
            msg: 'InsufficientRolloverFee',
        },
        {
            code: 6019,
            name: 'UnsupportedHeight',
            msg: 'Unsupported Merkle tree height',
        },
        {
            code: 6020,
            name: 'UnsupportedCanopyDepth',
            msg: 'Unsupported canopy depth',
        },
        {
            code: 6021,
            name: 'InvalidSequenceThreshold',
            msg: 'Invalid sequence threshold',
        },
        {
            code: 6022,
            name: 'UnsupportedCloseThreshold',
            msg: 'Unsupported close threshold',
        },
        {
            code: 6023,
            name: 'InvalidAccountBalance',
            msg: 'InvalidAccountBalance',
        },
        {
            code: 6024,
            name: 'UnsupportedAdditionalBytes',
        },
        {
            code: 6025,
            name: 'InvalidGroup',
        },
        {
            code: 6026,
            name: 'ProofLengthMismatch',
        },
    ],
};

const IDL$1 = {
    version: '1.2.0',
    name: 'light_registry',
    constants: [
        {
            name: 'FORESTER_SEED',
            type: 'bytes',
            value: '[102, 111, 114, 101, 115, 116, 101, 114]',
        },
        {
            name: 'FORESTER_EPOCH_SEED',
            type: 'bytes',
            value: '[102, 111, 114, 101, 115, 116, 101, 114, 95, 101, 112, 111, 99, 104]',
        },
        {
            name: 'PROTOCOL_CONFIG_PDA_SEED',
            type: 'bytes',
            value: '[97, 117, 116, 104, 111, 114, 105, 116, 121]',
        },
    ],
    instructions: [
        {
            name: 'initializeProtocolConfig',
            docs: [
                'Initializes the protocol config pda. Can only be called once by the',
                'program account keypair.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'protocolConfig',
                    type: {
                        defined: 'ProtocolConfig',
                    },
                },
            ],
        },
        {
            name: 'updateProtocolConfig',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newAuthority',
                    isMut: false,
                    isSigner: true,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'protocolConfig',
                    type: {
                        option: {
                            defined: 'ProtocolConfig',
                        },
                    },
                },
            ],
        },
        {
            name: 'registerSystemProgram',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthority',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'groupPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'programToBeRegistered',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        '- is signer so that only the program deployer can register a program.',
                    ],
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
            ],
        },
        {
            name: 'deregisterSystemProgram',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthority',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'groupPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
            ],
        },
        {
            name: 'registerForester',
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'foresterPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'authority',
                    type: 'publicKey',
                },
                {
                    name: 'config',
                    type: {
                        defined: 'ForesterConfig',
                    },
                },
                {
                    name: 'weight',
                    type: {
                        option: 'u64',
                    },
                },
            ],
        },
        {
            name: 'updateForesterPda',
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'foresterPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newAuthority',
                    isMut: false,
                    isSigner: true,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'config',
                    type: {
                        option: {
                            defined: 'ForesterConfig',
                        },
                    },
                },
            ],
        },
        {
            name: 'updateForesterPdaWeight',
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'foresterPda',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'newWeight',
                    type: 'u64',
                },
            ],
        },
        {
            name: 'registerForesterEpoch',
            docs: [
                'Registers the forester for the epoch.',
                '1. Only the forester can register herself for the epoch.',
                '2. Protocol config is copied.',
                '3. Epoch account is created if needed.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'foresterPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'foresterEpochPda',
                    isMut: true,
                    isSigner: false,
                    docs: [
                        'Instruction checks that current_epoch is the the current epoch and that',
                        'the epoch is in registration phase.',
                    ],
                },
                {
                    name: 'protocolConfig',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'epochPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'epoch',
                    type: 'u64',
                },
            ],
        },
        {
            name: 'finalizeRegistration',
            docs: [
                'This transaction can be included as additional instruction in the first',
                'work instructions during the active phase.',
                'Registration Period must be over.',
            ],
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'foresterEpochPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'epochPda',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'reportWork',
            accounts: [
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'foresterEpochPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'epochPda',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'initializeAddressMerkleTree',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Anyone can create new trees just the fees cannot be set arbitrarily.',
                    ],
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'queue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthority',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiContextAccount',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'programOwner',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'forester',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'merkleTreeConfig',
                    type: {
                        defined: 'AddressMerkleTreeConfig',
                    },
                },
                {
                    name: 'queueConfig',
                    type: {
                        defined: 'AddressQueueConfig',
                    },
                },
            ],
        },
        {
            name: 'initializeStateMerkleTree',
            accounts: [
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                    docs: [
                        'Anyone can create new trees just the fees cannot be set arbitrarily.',
                    ],
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'queue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthority',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiContextAccount',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'programOwner',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'forester',
                    type: {
                        option: 'publicKey',
                    },
                },
                {
                    name: 'merkleTreeConfig',
                    type: {
                        defined: 'StateMerkleTreeConfig',
                    },
                },
                {
                    name: 'queueConfig',
                    type: {
                        defined: 'NullifierQueueConfig',
                    },
                },
            ],
        },
        {
            name: 'nullify',
            accounts: [
                {
                    name: 'registeredForesterPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'logWrapper',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'nullifierQueue',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'changeLogIndices',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'leavesQueueIndices',
                    type: {
                        vec: 'u16',
                    },
                },
                {
                    name: 'indices',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'proofs',
                    type: {
                        vec: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                },
            ],
        },
        {
            name: 'updateAddressMerkleTree',
            accounts: [
                {
                    name: 'registeredForesterPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'queue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'logWrapper',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
                {
                    name: 'changelogIndex',
                    type: 'u16',
                },
                {
                    name: 'indexedChangelogIndex',
                    type: 'u16',
                },
                {
                    name: 'value',
                    type: 'u16',
                },
                {
                    name: 'lowAddressIndex',
                    type: 'u64',
                },
                {
                    name: 'lowAddressValue',
                    type: {
                        array: ['u8', 32],
                    },
                },
                {
                    name: 'lowAddressNextIndex',
                    type: 'u64',
                },
                {
                    name: 'lowAddressNextValue',
                    type: {
                        array: ['u8', 32],
                    },
                },
                {
                    name: 'lowAddressProof',
                    type: {
                        array: [
                            {
                                array: ['u8', 32],
                            },
                            16,
                        ],
                    },
                },
            ],
        },
        {
            name: 'rolloverAddressMerkleTreeAndQueue',
            accounts: [
                {
                    name: 'registeredForesterPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'newMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldQueue',
                    isMut: true,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
            ],
        },
        {
            name: 'rolloverStateMerkleTreeAndQueue',
            accounts: [
                {
                    name: 'registeredForesterPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'authority',
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'newMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'newQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldMerkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'oldQueue',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'cpiContextAccount',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'protocolConfigPda',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'bump',
                    type: 'u8',
                },
            ],
        },
    ],
    accounts: [
        {
            name: 'epochPda',
            docs: ['Is used for tallying and rewards calculation'],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'epoch',
                        type: 'u64',
                    },
                    {
                        name: 'protocolConfig',
                        type: {
                            defined: 'ProtocolConfig',
                        },
                    },
                    {
                        name: 'totalWork',
                        type: 'u64',
                    },
                    {
                        name: 'registeredWeight',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'foresterEpochPda',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'authority',
                        type: 'publicKey',
                    },
                    {
                        name: 'config',
                        type: {
                            defined: 'ForesterConfig',
                        },
                    },
                    {
                        name: 'epoch',
                        type: 'u64',
                    },
                    {
                        name: 'weight',
                        type: 'u64',
                    },
                    {
                        name: 'workCounter',
                        type: 'u64',
                    },
                    {
                        name: 'hasReportedWork',
                        docs: [
                            'Work can be reported in an extra round to earn extra performance based',
                            'rewards.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'foresterIndex',
                        docs: [
                            'Start index of the range that determines when the forester is eligible to perform work.',
                            'End index is forester_start_index + weight',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'epochActivePhaseStartSlot',
                        type: 'u64',
                    },
                    {
                        name: 'totalEpochWeight',
                        docs: [
                            'Total epoch weight is registered weight of the epoch account after',
                            'registration is concluded and active epoch period starts.',
                        ],
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'protocolConfig',
                        type: {
                            defined: 'ProtocolConfig',
                        },
                    },
                    {
                        name: 'finalizeCounter',
                        docs: [
                            'Incremented every time finalize registration is called.',
                        ],
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'protocolConfigPda',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'authority',
                        type: 'publicKey',
                    },
                    {
                        name: 'bump',
                        type: 'u8',
                    },
                    {
                        name: 'config',
                        type: {
                            defined: 'ProtocolConfig',
                        },
                    },
                ],
            },
        },
        {
            name: 'foresterPda',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'authority',
                        type: 'publicKey',
                    },
                    {
                        name: 'config',
                        type: {
                            defined: 'ForesterConfig',
                        },
                    },
                    {
                        name: 'activeWeight',
                        type: 'u64',
                    },
                    {
                        name: 'pendingWeight',
                        docs: [
                            'Pending weight which will get active once the next epoch starts.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'currentEpoch',
                        type: 'u64',
                    },
                    {
                        name: 'lastCompressedForesterEpochPdaHash',
                        docs: [
                            'Link to previous compressed forester epoch account hash.',
                        ],
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'lastRegisteredEpoch',
                        type: 'u64',
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: 'ProtocolConfig',
            docs: [
                'Epoch Phases:',
                '1. Registration',
                '2. Active',
                '3. Report Work',
                '4. Post (Epoch has ended, and rewards can be claimed.)',
                '- There is always an active phase in progress, registration and report work',
                'phases run in parallel to a currently active phase.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'genesisSlot',
                        docs: [
                            'Solana slot when the protocol starts operating.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'minWeight',
                        docs: [
                            'Minimum weight required for a forester to register to an epoch.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'slotLength',
                        docs: ['Light protocol slot length.'],
                        type: 'u64',
                    },
                    {
                        name: 'registrationPhaseLength',
                        docs: ['Foresters can register for this phase.'],
                        type: 'u64',
                    },
                    {
                        name: 'activePhaseLength',
                        docs: ['Foresters can perform work in this phase.'],
                        type: 'u64',
                    },
                    {
                        name: 'reportWorkPhaseLength',
                        docs: [
                            'Foresters can report work to receive performance based rewards in this',
                            'phase.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        type: 'u64',
                    },
                    {
                        name: 'cpiContextSize',
                        type: 'u64',
                    },
                    {
                        name: 'finalizeCounterLimit',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolder',
                        docs: ['Placeholder for future protocol updates.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'placeHolderA',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolderB',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolderC',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolderD',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolderE',
                        type: 'u64',
                    },
                    {
                        name: 'placeHolderF',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'ForesterConfig',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'fee',
                        docs: ['Fee in percentage points.'],
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'EpochState',
            type: {
                kind: 'enum',
                variants: [
                    {
                        name: 'Registration',
                    },
                    {
                        name: 'Active',
                    },
                    {
                        name: 'ReportWork',
                    },
                    {
                        name: 'Post',
                    },
                    {
                        name: 'Pre',
                    },
                ],
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: 'InvalidForester',
            msg: 'InvalidForester',
        },
        {
            code: 6001,
            name: 'NotInReportWorkPhase',
        },
        {
            code: 6002,
            name: 'StakeAccountAlreadySynced',
        },
        {
            code: 6003,
            name: 'EpochEnded',
        },
        {
            code: 6004,
            name: 'ForesterNotEligible',
        },
        {
            code: 6005,
            name: 'NotInRegistrationPeriod',
        },
        {
            code: 6006,
            name: 'WeightInsuffient',
        },
        {
            code: 6007,
            name: 'ForesterAlreadyRegistered',
        },
        {
            code: 6008,
            name: 'InvalidEpochAccount',
        },
        {
            code: 6009,
            name: 'InvalidEpoch',
        },
        {
            code: 6010,
            name: 'EpochStillInProgress',
        },
        {
            code: 6011,
            name: 'NotInActivePhase',
        },
        {
            code: 6012,
            name: 'ForesterAlreadyReportedWork',
        },
        {
            code: 6013,
            name: 'InvalidNetworkFee',
        },
        {
            code: 6014,
            name: 'FinalizeCounterExceeded',
        },
        {
            code: 6015,
            name: 'CpiContextAccountMissing',
        },
        {
            code: 6016,
            name: 'ArithmeticUnderflow',
        },
        {
            code: 6017,
            name: 'RegistrationNotFinalized',
        },
        {
            code: 6018,
            name: 'CpiContextAccountInvalidDataLen',
        },
        {
            code: 6019,
            name: 'InvalidConfigUpdate',
        },
        {
            code: 6020,
            name: 'InvalidSigner',
        },
        {
            code: 6021,
            name: 'GetLatestRegisterEpochFailed',
        },
        {
            code: 6022,
            name: 'GetCurrentActiveEpochFailed',
        },
        {
            code: 6023,
            name: 'ForesterUndefined',
        },
        {
            code: 6024,
            name: 'ForesterDefined',
        },
    ],
};

const IDL = {
    version: '1.2.0',
    name: 'light_compressed_token',
    instructions: [
        {
            name: 'createTokenPool',
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'mintTo',
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['programs'],
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'solPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'publicKeys',
                    type: {
                        vec: 'publicKey',
                    },
                },
                {
                    name: 'amounts',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'lamports',
                    type: {
                        option: 'u64',
                    },
                },
            ],
        },
        {
            name: 'compressSplTokenAccount',
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'owner',
                    type: 'publicKey',
                },
                {
                    name: 'remainingAmount',
                    type: {
                        option: 'u64',
                    },
                },
                {
                    name: 'cpiContext',
                    type: {
                        option: {
                            defined: 'CompressedCpiContext',
                        },
                    },
                },
            ],
        },
        {
            name: 'transfer',
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'approve',
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'revoke',
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'freeze',
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['that this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'thaw',
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['that this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'burn',
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'stubIdlBuild',
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs1',
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer',
                    },
                },
                {
                    name: 'inputs2',
                    type: {
                        defined: 'TokenData',
                    },
                },
            ],
        },
    ],
    types: [
        {
            name: 'AccessMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        docs: ['Owner of the Merkle tree.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'programOwner',
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.',
                        ],
                        type: 'publicKey',
                    },
                    {
                        name: 'forester',
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.',
                        ],
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'AccountState',
            type: {
                kind: 'enum',
                variants: [
                    {
                        name: 'Initialized',
                    },
                    {
                        name: 'Frozen',
                    },
                ],
            },
        },
        {
            name: 'CompressedAccount',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'lamports',
                        type: 'u64',
                    },
                    {
                        name: 'address',
                        type: {
                            option: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'data',
                        type: {
                            option: {
                                defined: 'CompressedAccountData',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedAccountData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'discriminator',
                        type: {
                            array: ['u8', 8],
                        },
                    },
                    {
                        name: 'data',
                        type: 'bytes',
                    },
                    {
                        name: 'dataHash',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedCpiContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'setContext',
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'firstSetContext',
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'cpiContextAccountIndex',
                        docs: [
                            'Index of cpi context account in remaining accounts.',
                        ],
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'CompressedProof',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'a',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'b',
                        type: {
                            array: ['u8', 64],
                        },
                    },
                    {
                        name: 'c',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedTokenInstructionDataTransfer',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'mint',
                        type: 'publicKey',
                    },
                    {
                        name: 'delegatedTransfer',
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.',
                        ],
                        type: {
                            option: {
                                defined: 'DelegatedTransfer',
                            },
                        },
                    },
                    {
                        name: 'inputTokenDataWithContext',
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData',
                            },
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'compressOrDecompressAmount',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'cpiContext',
                        type: {
                            option: {
                                defined: 'CompressedCpiContext',
                            },
                        },
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex',
                        type: {
                            option: 'u8',
                        },
                    },
                ],
            },
        },
        {
            name: 'DelegatedTransfer',
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'delegateChangeAccountIndex',
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.',
                        ],
                        type: {
                            option: 'u8',
                        },
                    },
                ],
            },
        },
        {
            name: 'InputTokenDataWithContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'amount',
                        type: 'u64',
                    },
                    {
                        name: 'delegateIndex',
                        type: {
                            option: 'u8',
                        },
                    },
                    {
                        name: 'merkleContext',
                        type: {
                            defined: 'PackedMerkleContext',
                        },
                    },
                    {
                        name: 'rootIndex',
                        type: 'u16',
                    },
                    {
                        name: 'lamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvoke',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvokeCpi',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'cpiContext',
                        type: {
                            option: {
                                defined: 'CompressedCpiContext',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'accessMetadata',
                        type: {
                            defined: 'AccessMetadata',
                        },
                    },
                    {
                        name: 'rolloverMetadata',
                        type: {
                            defined: 'RolloverMetadata',
                        },
                    },
                    {
                        name: 'associatedQueue',
                        type: 'publicKey',
                    },
                    {
                        name: 'nextMerkleTree',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeSequenceNumber',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'pubkey',
                        type: 'publicKey',
                    },
                    {
                        name: 'seq',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'NewAddressParamsPacked',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'seed',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'addressQueueAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeRootIndex',
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'OutputCompressedAccountWithPackedContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleTreeIndex',
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleContext',
                        type: {
                            defined: 'PackedMerkleContext',
                        },
                    },
                    {
                        name: 'rootIndex',
                        docs: [
                            'Index of root used in inclusion validity proof.',
                        ],
                        type: 'u16',
                    },
                    {
                        name: 'readOnly',
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.',
                        ],
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'PackedMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'leafIndex',
                        type: 'u32',
                    },
                    {
                        name: 'queueIndex',
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.',
                        ],
                        type: {
                            option: {
                                defined: 'QueueIndex',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'PackedTokenTransferOutputData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'amount',
                        type: 'u64',
                    },
                    {
                        name: 'lamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'merkleTreeIndex',
                        type: 'u8',
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'PublicTransactionEvent',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'inputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'outputLeafIndices',
                        type: {
                            vec: 'u32',
                        },
                    },
                    {
                        name: 'sequenceNumbers',
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'pubkeyArray',
                        type: {
                            vec: 'publicKey',
                        },
                    },
                    {
                        name: 'message',
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'QueueIndex',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'queueId',
                        docs: ['Id of queue in queue account.'],
                        type: 'u8',
                    },
                    {
                        name: 'index',
                        docs: ['Index of compressed account hash in queue.'],
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'RolloverMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'index',
                        docs: ['Unique index.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverFee',
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverThreshold',
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        docs: ['Tip for maintaining the account.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolledoverSlot',
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'closeThreshold',
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'additionalBytes',
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.',
                        ],
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'TokenData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'mint',
                        docs: ['The mint associated with this account'],
                        type: 'publicKey',
                    },
                    {
                        name: 'owner',
                        docs: ['The owner of this account.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'amount',
                        docs: ['The amount of tokens this account holds.'],
                        type: 'u64',
                    },
                    {
                        name: 'delegate',
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate',
                        ],
                        type: {
                            option: 'publicKey',
                        },
                    },
                    {
                        name: 'state',
                        docs: ["The account's state"],
                        type: {
                            defined: 'AccountState',
                        },
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: 'PublicKeyAmountMissmatch',
            msg: 'public keys and amounts must be of same length',
        },
        {
            code: 6001,
            name: 'ComputeInputSumFailed',
            msg: 'ComputeInputSumFailed',
        },
        {
            code: 6002,
            name: 'ComputeOutputSumFailed',
            msg: 'ComputeOutputSumFailed',
        },
        {
            code: 6003,
            name: 'ComputeCompressSumFailed',
            msg: 'ComputeCompressSumFailed',
        },
        {
            code: 6004,
            name: 'ComputeDecompressSumFailed',
            msg: 'ComputeDecompressSumFailed',
        },
        {
            code: 6005,
            name: 'SumCheckFailed',
            msg: 'SumCheckFailed',
        },
        {
            code: 6006,
            name: 'DecompressRecipientUndefinedForDecompress',
            msg: 'DecompressRecipientUndefinedForDecompress',
        },
        {
            code: 6007,
            name: 'CompressedPdaUndefinedForDecompress',
            msg: 'CompressedPdaUndefinedForDecompress',
        },
        {
            code: 6008,
            name: 'DeCompressAmountUndefinedForDecompress',
            msg: 'DeCompressAmountUndefinedForDecompress',
        },
        {
            code: 6009,
            name: 'CompressedPdaUndefinedForCompress',
            msg: 'CompressedPdaUndefinedForCompress',
        },
        {
            code: 6010,
            name: 'DeCompressAmountUndefinedForCompress',
            msg: 'DeCompressAmountUndefinedForCompress',
        },
        {
            code: 6011,
            name: 'DelegateSignerCheckFailed',
            msg: 'DelegateSignerCheckFailed',
        },
        {
            code: 6012,
            name: 'MintTooLarge',
            msg: 'Minted amount greater than u64::MAX',
        },
        {
            code: 6013,
            name: 'SplTokenSupplyMismatch',
            msg: 'SplTokenSupplyMismatch',
        },
        {
            code: 6014,
            name: 'HeapMemoryCheckFailed',
            msg: 'HeapMemoryCheckFailed',
        },
        {
            code: 6015,
            name: 'InstructionNotCallable',
            msg: 'The instruction is not callable',
        },
        {
            code: 6016,
            name: 'ArithmeticUnderflow',
            msg: 'ArithmeticUnderflow',
        },
        {
            code: 6017,
            name: 'HashToFieldError',
            msg: 'HashToFieldError',
        },
        {
            code: 6018,
            name: 'InvalidAuthorityMint',
            msg: 'Expected the authority to be also a mint authority',
        },
        {
            code: 6019,
            name: 'InvalidFreezeAuthority',
            msg: 'Provided authority is not the freeze authority',
        },
        {
            code: 6020,
            name: 'InvalidDelegateIndex',
        },
        {
            code: 6021,
            name: 'TokenPoolPdaUndefined',
        },
        {
            code: 6022,
            name: 'IsTokenPoolPda',
            msg: 'Compress or decompress recipient is the same account as the token pool pda.',
        },
        {
            code: 6023,
            name: 'InvalidTokenPoolPda',
        },
        {
            code: 6024,
            name: 'NoInputTokenAccountsProvided',
        },
        {
            code: 6025,
            name: 'NoInputsProvided',
        },
        {
            code: 6026,
            name: 'MintHasNoFreezeAuthority',
        },
        {
            code: 6027,
            name: 'MintWithInvalidExtension',
        },
        {
            code: 6028,
            name: 'InsufficientTokenAccountBalance',
            msg: 'The token account balance is less than the remaining amount.',
        },
    ],
};

// TODO: Clean up
var UtxoErrorCode;
(function (UtxoErrorCode) {
    UtxoErrorCode["NEGATIVE_LAMPORTS"] = "NEGATIVE_LAMPORTS";
    UtxoErrorCode["NOT_U64"] = "NOT_U64";
    UtxoErrorCode["BLINDING_EXCEEDS_FIELD_SIZE"] = "BLINDING_EXCEEDS_FIELD_SIZE";
})(UtxoErrorCode || (UtxoErrorCode = {}));
var SelectInUtxosErrorCode;
(function (SelectInUtxosErrorCode) {
    SelectInUtxosErrorCode["FAILED_TO_FIND_UTXO_COMBINATION"] = "FAILED_TO_FIND_UTXO_COMBINATION";
    SelectInUtxosErrorCode["INVALID_NUMBER_OF_IN_UTXOS"] = "INVALID_NUMBER_OF_IN_UTXOS";
})(SelectInUtxosErrorCode || (SelectInUtxosErrorCode = {}));
var CreateUtxoErrorCode;
(function (CreateUtxoErrorCode) {
    CreateUtxoErrorCode["OWNER_UNDEFINED"] = "OWNER_UNDEFINED";
    CreateUtxoErrorCode["INVALID_OUTPUT_UTXO_LENGTH"] = "INVALID_OUTPUT_UTXO_LENGTH";
    CreateUtxoErrorCode["UTXO_DATA_UNDEFINED"] = "UTXO_DATA_UNDEFINED";
})(CreateUtxoErrorCode || (CreateUtxoErrorCode = {}));
var RpcErrorCode;
(function (RpcErrorCode) {
    RpcErrorCode["CONNECTION_UNDEFINED"] = "CONNECTION_UNDEFINED";
    RpcErrorCode["RPC_PUBKEY_UNDEFINED"] = "RPC_PUBKEY_UNDEFINED";
    RpcErrorCode["RPC_METHOD_NOT_IMPLEMENTED"] = "RPC_METHOD_NOT_IMPLEMENTED";
    RpcErrorCode["RPC_INVALID"] = "RPC_INVALID";
})(RpcErrorCode || (RpcErrorCode = {}));
var LookupTableErrorCode;
(function (LookupTableErrorCode) {
    LookupTableErrorCode["LOOK_UP_TABLE_UNDEFINED"] = "LOOK_UP_TABLE_UNDEFINED";
    LookupTableErrorCode["LOOK_UP_TABLE_NOT_INITIALIZED"] = "LOOK_UP_TABLE_NOT_INITIALIZED";
})(LookupTableErrorCode || (LookupTableErrorCode = {}));
var HashErrorCode;
(function (HashErrorCode) {
    HashErrorCode["NO_POSEIDON_HASHER_PROVIDED"] = "NO_POSEIDON_HASHER_PROVIDED";
})(HashErrorCode || (HashErrorCode = {}));
var ProofErrorCode;
(function (ProofErrorCode) {
    ProofErrorCode["INVALID_PROOF"] = "INVALID_PROOF";
    ProofErrorCode["PROOF_INPUT_UNDEFINED"] = "PROOF_INPUT_UNDEFINED";
    ProofErrorCode["PROOF_GENERATION_FAILED"] = "PROOF_GENERATION_FAILED";
})(ProofErrorCode || (ProofErrorCode = {}));
var MerkleTreeErrorCode;
(function (MerkleTreeErrorCode) {
    MerkleTreeErrorCode["MERKLE_TREE_NOT_INITIALIZED"] = "MERKLE_TREE_NOT_INITIALIZED";
    MerkleTreeErrorCode["SOL_MERKLE_TREE_UNDEFINED"] = "SOL_MERKLE_TREE_UNDEFINED";
    MerkleTreeErrorCode["MERKLE_TREE_UNDEFINED"] = "MERKLE_TREE_UNDEFINED";
    MerkleTreeErrorCode["INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE"] = "INPUT_UTXO_NOT_INSERTED_IN_MERKLE_TREE";
    MerkleTreeErrorCode["MERKLE_TREE_INDEX_UNDEFINED"] = "MERKLE_TREE_INDEX_UNDEFINED";
    MerkleTreeErrorCode["MERKLE_TREE_SET_SPACE_UNDEFINED"] = "MERKLE_TREE_SET_SPACE_UNDEFINED";
})(MerkleTreeErrorCode || (MerkleTreeErrorCode = {}));
var UtilsErrorCode;
(function (UtilsErrorCode) {
    UtilsErrorCode["ACCOUNT_NAME_UNDEFINED_IN_IDL"] = "ACCOUNT_NAME_UNDEFINED_IN_IDL";
    UtilsErrorCode["PROPERTY_UNDEFINED"] = "PROPERTY_UNDEFINED";
    UtilsErrorCode["LOOK_UP_TABLE_CREATION_FAILED"] = "LOOK_UP_TABLE_CREATION_FAILED";
    UtilsErrorCode["UNSUPPORTED_ARCHITECTURE"] = "UNSUPPORTED_ARCHITECTURE";
    UtilsErrorCode["UNSUPPORTED_PLATFORM"] = "UNSUPPORTED_PLATFORM";
    UtilsErrorCode["ACCOUNTS_UNDEFINED"] = "ACCOUNTS_UNDEFINED";
    UtilsErrorCode["INVALID_NUMBER"] = "INVALID_NUMBER";
})(UtilsErrorCode || (UtilsErrorCode = {}));
class MetaError extends Error {
    code;
    functionName;
    codeMessage;
    constructor(code, functionName, codeMessage) {
        super(`${code}: ${codeMessage}`);
        this.code = code;
        this.functionName = functionName;
        this.codeMessage = codeMessage;
    }
}
class UtxoError extends MetaError {
}
class SelectInUtxosError extends MetaError {
}
class CreateUtxoError extends MetaError {
}
class RpcError extends MetaError {
}
class LookupTableError extends MetaError {
}
class HashError extends MetaError {
}
class ProofError extends MetaError {
}
class MerkleTreeError extends MetaError {
}
class UtilsError extends MetaError {
}

/**
 * @internal
 */
const PublicKeyFromString = coerce(instance(PublicKey), string(), value => new PublicKey(value));
/**
 * @internal
 */
const ArrayFromString = coerce(instance((Array)), string(), value => Array.from(new PublicKey(value).toBytes()));
/**
 * @internal
 */
const BN254FromString = coerce(instance(BN), string(), value => {
    return createBN254(value, 'base58');
});
const BNFromInt = coerce(instance(BN), number$1(), value => {
    // Check if the number is safe
    if (Number.isSafeInteger(value)) {
        return bn(value);
    }
    else {
        // Convert to string if the number is unsafe
        return bn(value.toString(), 10);
    }
});
/**
 * @internal
 */
const Base64EncodedCompressedAccountDataResult = coerce(string(), string(), value => (value === '' ? null : value));
/**
 * @internal
 */
function createRpcResult(result) {
    return union([
        type({
            jsonrpc: literal('2.0'),
            id: string(),
            result,
        }),
        type({
            jsonrpc: literal('2.0'),
            id: string(),
            error: type({
                code: unknown(),
                message: string(),
                data: nullable(any()),
            }),
        }),
    ]);
}
/**
 * @internal
 */
const UnknownRpcResult = createRpcResult(unknown());
/**
 * @internal
 */
function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, value => {
        if ('error' in value) {
            return value;
        }
        else {
            return {
                ...value,
                result: create(value.result, schema),
            };
        }
    });
}
/**
 * @internal
 */
function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
        context: type({
            slot: number$1(),
        }),
        value,
    }));
}
/**
 * @internal
 */
const CompressedAccountResult = type({
    address: nullable(ArrayFromString),
    hash: BN254FromString,
    data: nullable(type({
        data: Base64EncodedCompressedAccountDataResult,
        dataHash: BN254FromString,
        discriminator: BNFromInt,
    })),
    lamports: BNFromInt,
    owner: PublicKeyFromString,
    leafIndex: number$1(),
    tree: PublicKeyFromString,
    seq: nullable(BNFromInt),
    slotCreated: BNFromInt,
});
const TokenDataResult = type({
    mint: PublicKeyFromString,
    owner: PublicKeyFromString,
    amount: BNFromInt,
    delegate: nullable(PublicKeyFromString),
    state: string(),
});
/**
 * @internal
 */
const CompressedTokenAccountResult = type({
    tokenData: TokenDataResult,
    account: CompressedAccountResult,
});
/**
 * @internal
 */
const MultipleCompressedAccountsResult = type({
    items: array(CompressedAccountResult),
});
/**
 * @internal
 */
const CompressedAccountsByOwnerResult = type({
    items: array(CompressedAccountResult),
    cursor: nullable(string()),
});
/**
 * @internal
 */
const CompressedTokenAccountsByOwnerOrDelegateResult = type({
    items: array(CompressedTokenAccountResult),
    cursor: nullable(string()),
});
/**
 * @internal
 */
const SlotResult = number$1();
/**
 * @internal
 */
const HealthResult = string();
/**
 * @internal
 */
const LatestNonVotingSignaturesResult = type({
    items: array(type({
        signature: string(),
        slot: number$1(),
        blockTime: number$1(),
        error: nullable(string()),
    })),
});
/**
 * @internal
 */
const LatestNonVotingSignaturesResultPaginated = type({
    items: array(type({
        signature: string(),
        slot: number$1(),
        blockTime: number$1(),
    })),
    cursor: nullable(string()),
});
/**
 * @internal
 */
const MerkeProofResult = type({
    hash: BN254FromString,
    leafIndex: number$1(),
    merkleTree: PublicKeyFromString,
    proof: array(BN254FromString),
    rootSeq: number$1(),
    root: BN254FromString,
});
/**
 * @internal
 */
const NewAddressProofResult = type({
    address: BN254FromString,
    nextIndex: number$1(),
    merkleTree: PublicKeyFromString,
    proof: array(BN254FromString), // this is: merkleProofHashedIndexedElementLeaf
    rootSeq: number$1(),
    root: BN254FromString,
    lowerRangeAddress: BN254FromString, // this is: leafLowerRangeValue.
    higherRangeAddress: BN254FromString, // this is: leafHigherRangeValue
    lowElementLeafIndex: number$1(), // this is: indexHashedIndexedElementLeaf
});
/**
 * @internal
 */
const CompressedProofResult = type({
    a: array(number$1()),
    b: array(number$1()),
    c: array(number$1()),
});
/**
 * @internal
 */
const ValidityProofResult = type({
    compressedProof: CompressedProofResult,
    leafIndices: array(number$1()),
    leaves: array(BN254FromString),
    rootIndices: array(number$1()),
    roots: array(BN254FromString),
    merkleTrees: array(PublicKeyFromString),
    // TODO: enable nullifierQueues
    // nullifierQueues: array(PublicKeyFromString),
});
/**
 * @internal
 */
const MultipleMerkleProofsResult = array(MerkeProofResult);
/**
 * @internal
 */
const BalanceResult = type({
    amount: BNFromInt,
});
const NativeBalanceResult = BNFromInt;
const TokenBalanceResult = type({
    balance: BNFromInt,
    mint: PublicKeyFromString,
});
const TokenBalanceListResult = type({
    tokenBalances: array(TokenBalanceResult),
    cursor: nullable(string()),
});
const TokenBalanceListResultV2 = type({
    items: array(TokenBalanceResult),
    cursor: nullable(string()),
});
const CompressedMintTokenHoldersResult = type({
    cursor: nullable(string()),
    items: array(type({
        balance: BNFromInt,
        owner: PublicKeyFromString,
    })),
});
const AccountProofResult = type({
    hash: array(number$1()),
    root: array(number$1()),
    proof: array(array(number$1())),
});
const toUnixTimestamp = (blockTime) => {
    return new Date(blockTime).getTime();
};
const SignatureListResult = type({
    items: array(type({
        blockTime: number$1(),
        signature: string(),
        slot: number$1(),
    })),
});
const SignatureListWithCursorResult = type({
    items: array(type({
        blockTime: number$1(),
        signature: string(),
        slot: number$1(),
    })),
    cursor: nullable(string()),
});
const CompressedTransactionResult = type({
    compressionInfo: type({
        closedAccounts: array(type({
            account: CompressedAccountResult,
            optionalTokenData: nullable(TokenDataResult),
        })),
        openedAccounts: array(type({
            account: CompressedAccountResult,
            optionalTokenData: nullable(TokenDataResult),
        })),
    }),
    /// TODO: add transaction struct
    /// https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/transaction-status/src/lib.rs#L1061
    transaction: any(),
});

/** @internal */
function parseAccountData({ discriminator, data, dataHash, }) {
    return {
        discriminator: discriminator.toArray('le', 8),
        data: Buffer$2.from(data, 'base64'),
        dataHash: dataHash.toArray('le', 32),
    };
}
/** @internal */
async function getCompressedTokenAccountsByOwnerOrDelegate(rpc, ownerOrDelegate, options, filterByDelegate = false) {
    const endpoint = filterByDelegate
        ? 'getCompressedTokenAccountsByDelegate'
        : 'getCompressedTokenAccountsByOwner';
    const propertyToCheck = filterByDelegate ? 'delegate' : 'owner';
    const unsafeRes = await rpcRequest(rpc.compressionApiEndpoint, endpoint, {
        [propertyToCheck]: ownerOrDelegate.toBase58(),
        mint: options.mint?.toBase58(),
        limit: options.limit?.toNumber(),
        cursor: options.cursor,
    });
    const res = create(unsafeRes, jsonRpcResultAndContext(CompressedTokenAccountsByOwnerOrDelegateResult));
    if ('error' in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for compressed accounts by ${propertyToCheck} ${ownerOrDelegate.toBase58()}`);
    }
    if (res.result.value === null) {
        throw new Error('not implemented: NULL result');
    }
    const accounts = [];
    res.result.value.items.map(item => {
        const _account = item.account;
        const _tokenData = item.tokenData;
        const compressedAccount = createCompressedAccountWithMerkleContext(createMerkleContext(_account.tree, mockNullifierQueue, _account.hash.toArray('be', 32), _account.leafIndex), _account.owner, bn(_account.lamports), _account.data ? parseAccountData(_account.data) : undefined, _account.address || undefined);
        const parsed = {
            mint: _tokenData.mint,
            owner: _tokenData.owner,
            amount: _tokenData.amount,
            delegate: _tokenData.delegate,
            state: ['uninitialized', 'initialized', 'frozen'].indexOf(_tokenData.state),
            tlv: null,
        };
        if (parsed[propertyToCheck]?.toBase58() !== ownerOrDelegate.toBase58()) {
            throw new Error(`RPC returned token account with ${propertyToCheck} different from requested ${propertyToCheck}`);
        }
        accounts.push({
            compressedAccount,
            parsed,
        });
    });
    /// TODO: consider custom or different sort. Most recent here.
    return {
        items: accounts.sort((a, b) => b.compressedAccount.leafIndex - a.compressedAccount.leafIndex),
        cursor: res.result.value.cursor,
    };
}
/** @internal */
function buildCompressedAccountWithMaybeTokenData(accountStructWithOptionalTokenData) {
    const compressedAccountResult = accountStructWithOptionalTokenData.account;
    const tokenDataResult = accountStructWithOptionalTokenData.optionalTokenData;
    const compressedAccount = createCompressedAccountWithMerkleContext(createMerkleContext(compressedAccountResult.merkleTree, mockNullifierQueue, compressedAccountResult.hash.toArray('be', 32), compressedAccountResult.leafIndex), compressedAccountResult.owner, bn(compressedAccountResult.lamports), compressedAccountResult.data
        ? parseAccountData(compressedAccountResult.data)
        : undefined, compressedAccountResult.address || undefined);
    if (tokenDataResult === null) {
        return { account: compressedAccount, maybeTokenData: null };
    }
    const parsed = {
        mint: tokenDataResult.mint,
        owner: tokenDataResult.owner,
        amount: tokenDataResult.amount,
        delegate: tokenDataResult.delegate,
        state: ['uninitialized', 'initialized', 'frozen'].indexOf(tokenDataResult.state),
        tlv: null,
    };
    return { account: compressedAccount, maybeTokenData: parsed };
}
/**
 * Establish a Compression-compatible JSON RPC connection
 *
 * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or
 *                                      Connection object
 * @param compressionApiEndpoint        Endpoint to the compression server
 * @param proverEndpoint                Endpoint to the prover server. defaults
 *                                      to endpoint
 * @param connectionConfig              Optional connection config
 */
function createRpc(endpointOrWeb3JsConnection = 'http://127.0.0.1:8899', compressionApiEndpoint = 'http://127.0.0.1:8784', proverEndpoint = 'http://127.0.0.1:3001', config) {
    const endpoint = typeof endpointOrWeb3JsConnection === 'string'
        ? endpointOrWeb3JsConnection
        : endpointOrWeb3JsConnection.rpcEndpoint;
    return new Rpc(endpoint, compressionApiEndpoint, proverEndpoint, config);
}
/** @internal */
const rpcRequest = async (rpcEndpoint, method, params = [], convertToCamelCase = true, debug = false) => {
    const body = JSON.stringify({
        jsonrpc: '2.0',
        id: 'test-account',
        method: method,
        params: params,
    });
    if (debug) {
        const generateCurlSnippet = () => {
            const escapedBody = body.replace(/"/g, '\\"');
            return `curl -X POST ${rpcEndpoint} \\
     -H "Content-Type: application/json" \\
     -d "${escapedBody}"`;
        };
        console.log('Debug: Stack trace:');
        console.log(new Error().stack);
        console.log('\nDebug: curl:');
        console.log(generateCurlSnippet());
        console.log('\n');
    }
    const response = await fetch(rpcEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: body,
    });
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    if (convertToCamelCase) {
        const res = await response.json();
        return toCamelCase(res);
    }
    return await response.json();
};
/** @internal */
const proverRequest = async (proverEndpoint, method, params = [], log = false) => {
    let logMsg = '';
    if (log) {
        logMsg = `Proof generation for method:${method}`;
        console.time(logMsg);
    }
    let body;
    if (method === 'inclusion') {
        body = JSON.stringify({ 'input-compressed-accounts': params });
    }
    else if (method === 'new-address') {
        body = JSON.stringify({ 'new-addresses': params });
    }
    else if (method === 'combined') {
        body = JSON.stringify({
            'input-compressed-accounts': params[0],
            'new-addresses': params[1],
        });
    }
    const response = await fetch(`${proverEndpoint}/prove`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: body,
    });
    if (!response.ok) {
        throw new Error(`Error fetching proof: ${response.statusText}`);
    }
    const data = await response.json();
    const parsed = proofFromJsonStruct(data);
    const compressedProof = negateAndCompressProof(parsed);
    if (log)
        console.timeEnd(logMsg);
    return compressedProof;
};
function convertMerkleProofsWithContextToHex(merkleProofsWithContext) {
    const inputs = [];
    for (let i = 0; i < merkleProofsWithContext.length; i++) {
        const input = {
            root: toHex$1(merkleProofsWithContext[i].root),
            pathIndex: merkleProofsWithContext[i].leafIndex,
            pathElements: merkleProofsWithContext[i].merkleProof.map(hex => toHex$1(hex)),
            leaf: toHex$1(bn(merkleProofsWithContext[i].hash)),
        };
        inputs.push(input);
    }
    return inputs;
}
function convertNonInclusionMerkleProofInputsToHex(nonInclusionMerkleProofInputs) {
    const inputs = [];
    for (let i = 0; i < nonInclusionMerkleProofInputs.length; i++) {
        const input = {
            root: toHex$1(nonInclusionMerkleProofInputs[i].root),
            value: toHex$1(nonInclusionMerkleProofInputs[i].value),
            pathIndex: nonInclusionMerkleProofInputs[i].indexHashedIndexedElementLeaf.toNumber(),
            pathElements: nonInclusionMerkleProofInputs[i].merkleProofHashedIndexedElementLeaf.map(hex => toHex$1(hex)),
            nextIndex: nonInclusionMerkleProofInputs[i].nextIndex.toNumber(),
            leafLowerRangeValue: toHex$1(nonInclusionMerkleProofInputs[i].leafLowerRangeValue),
            leafHigherRangeValue: toHex$1(nonInclusionMerkleProofInputs[i].leafHigherRangeValue),
        };
        inputs.push(input);
    }
    return inputs;
}
/// TODO: replace with dynamic nullifierQueue
const mockNullifierQueue = defaultTestStateTreeAccounts().nullifierQueue;
const mockAddressQueue = defaultTestStateTreeAccounts().addressQueue;
/**
 *
 */
class Rpc extends Connection {
    compressionApiEndpoint;
    proverEndpoint;
    /**
     * Establish a Compression-compatible JSON RPC connection
     *
     * @param endpoint                      Endpoint to the solana cluster
     * @param compressionApiEndpoint        Endpoint to the compression server
     * @param proverEndpoint                Endpoint to the prover server.
     * @param connectionConfig              Optional connection config
     */
    constructor(endpoint, compressionApiEndpoint, proverEndpoint, config) {
        super(endpoint, config || 'confirmed');
        this.compressionApiEndpoint = compressionApiEndpoint;
        this.proverEndpoint = proverEndpoint;
    }
    /**
     * Fetch the compressed account for the specified account address or hash
     */
    async getCompressedAccount(address, hash) {
        if (!hash && !address) {
            throw new Error('Either hash or address must be provided');
        }
        if (hash && address) {
            throw new Error('Only one of hash or address must be provided');
        }
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedAccount', {
            hash: hash ? encodeBN254toBase58(hash) : undefined,
            address: address ? encodeBN254toBase58(address) : undefined,
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(nullable(CompressedAccountResult)));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`);
        }
        if (res.result.value === null) {
            return null;
        }
        const item = res.result.value;
        const account = createCompressedAccountWithMerkleContext(createMerkleContext(item.tree, mockNullifierQueue, item.hash.toArray('be', 32), item.leafIndex), item.owner, bn(item.lamports), item.data ? parseAccountData(item.data) : undefined, item.address || undefined);
        return account;
    }
    /**
     * Fetch the compressed balance for the specified account address or hash
     */
    async getCompressedBalance(address, hash) {
        if (!hash && !address) {
            throw new Error('Either hash or address must be provided');
        }
        if (hash && address) {
            throw new Error('Only one of hash or address must be provided');
        }
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedBalance', {
            hash: hash ? encodeBN254toBase58(hash) : undefined,
            address: address ? encodeBN254toBase58(address) : undefined,
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(NativeBalanceResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for compressed account ${hash ? hash.toString() : address ? address.toString() : ''}`);
        }
        if (res.result.value === null) {
            return bn(0);
        }
        return bn(res.result.value);
    }
    /// TODO: validate that this is just for sol accounts
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    async getCompressedBalanceByOwner(owner) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedBalanceByOwner', { owner: owner.toBase58() });
        const res = create(unsafeRes, jsonRpcResultAndContext(NativeBalanceResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for compressed account ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            return bn(0);
        }
        return bn(res.result.value);
    }
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    async getCompressedAccountProof(hash) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedAccountProof', { hash: encodeBN254toBase58(hash) });
        const res = create(unsafeRes, jsonRpcResultAndContext(MerkeProofResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get proof for compressed account ${hash.toString()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get proof for compressed account ${hash.toString()}`);
        }
        const value = {
            hash: res.result.value.hash.toArray('be', 32),
            merkleTree: res.result.value.merkleTree,
            leafIndex: res.result.value.leafIndex,
            merkleProof: res.result.value.proof,
            nullifierQueue: mockNullifierQueue, // TODO(photon): support nullifierQueue in response.
            rootIndex: res.result.value.rootSeq % 2400,
            root: res.result.value.root,
        };
        return value;
    }
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    async getMultipleCompressedAccounts(hashes) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getMultipleCompressedAccounts', { hashes: hashes.map(hash => encodeBN254toBase58(hash)) });
        const res = create(unsafeRes, jsonRpcResultAndContext(MultipleCompressedAccountsResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get info for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`);
        }
        const accounts = [];
        res.result.value.items.map(item => {
            const account = createCompressedAccountWithMerkleContext(createMerkleContext(item.tree, mockNullifierQueue, item.hash.toArray('be', 32), item.leafIndex), item.owner, bn(item.lamports), item.data ? parseAccountData(item.data) : undefined, item.address || undefined);
            accounts.push(account);
        });
        return accounts.sort((a, b) => b.leafIndex - a.leafIndex);
    }
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    async getMultipleCompressedAccountProofs(hashes) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getMultipleCompressedAccountProofs', hashes.map(hash => encodeBN254toBase58(hash)));
        const res = create(unsafeRes, jsonRpcResultAndContext(array(MerkeProofResult)));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get proofs for compressed accounts ${hashes.map(hash => encodeBN254toBase58(hash)).join(', ')}`);
        }
        const merkleProofs = [];
        for (const proof of res.result.value) {
            const value = {
                hash: proof.hash.toArray('be', 32),
                merkleTree: proof.merkleTree,
                leafIndex: proof.leafIndex,
                merkleProof: proof.proof,
                nullifierQueue: mockAddressQueue, // TODO(photon): support nullifierQueue in response.
                rootIndex: proof.rootSeq % 2400,
                root: proof.root,
            };
            merkleProofs.push(value);
        }
        return merkleProofs;
    }
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    async getCompressedAccountsByOwner(owner, config) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedAccountsByOwner', {
            owner: owner.toBase58(),
            filters: config?.filters || [],
            dataSlice: config?.dataSlice,
            cursor: config?.cursor,
            limit: config?.limit?.toNumber(),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(CompressedAccountsByOwnerResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for compressed accounts owned by ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            return {
                items: [],
                cursor: null,
            };
        }
        const accounts = [];
        res.result.value.items.map(item => {
            const account = createCompressedAccountWithMerkleContext(createMerkleContext(item.tree, mockNullifierQueue, item.hash.toArray('be', 32), item.leafIndex), item.owner, bn(item.lamports), item.data ? parseAccountData(item.data) : undefined, item.address || undefined);
            accounts.push(account);
        });
        return {
            items: accounts.sort((a, b) => b.leafIndex - a.leafIndex),
            cursor: res.result.value.cursor,
        };
    }
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    async getCompressedTokenAccountsByOwner(owner, options) {
        if (!options)
            options = {};
        return await getCompressedTokenAccountsByOwnerOrDelegate(this, owner, options, false);
    }
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    async getCompressedTokenAccountsByDelegate(delegate, options) {
        if (!options)
            options = {};
        return getCompressedTokenAccountsByOwnerOrDelegate(this, delegate, options, true);
    }
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    async getCompressedTokenAccountBalance(hash) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedTokenAccountBalance', { hash: encodeBN254toBase58(hash) });
        const res = create(unsafeRes, jsonRpcResultAndContext(BalanceResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for compressed token account ${hash.toString()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get balance for compressed token account ${hash.toString()}`);
        }
        return { amount: bn(res.result.value.amount) };
    }
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.
     *
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Returns without context.
     */
    async getCompressedTokenBalancesByOwner(owner, options) {
        if (!options)
            options = {};
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedTokenBalancesByOwner', {
            owner: owner.toBase58(),
            mint: options.mint?.toBase58(),
            limit: options.limit?.toNumber(),
            cursor: options.cursor,
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenBalanceListResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get compressed token balances for owner ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get compressed token balances for owner ${owner.toBase58()}`);
        }
        const maybeFiltered = options.mint
            ? res.result.value.tokenBalances.filter(tokenBalance => tokenBalance.mint.toBase58() === options.mint.toBase58())
            : res.result.value.tokenBalances;
        return {
            items: maybeFiltered,
            cursor: res.result.value.cursor,
        };
    }
    /**
     * Fetch the compressed token balances owned by the specified public
     * key. Paginated. Can filter by mint. Returns with context.
     */
    async getCompressedTokenBalancesByOwnerV2(owner, options) {
        if (!options)
            options = {};
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedTokenBalancesByOwnerV2', {
            owner: owner.toBase58(),
            mint: options.mint?.toBase58(),
            limit: options.limit?.toNumber(),
            cursor: options.cursor,
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(TokenBalanceListResultV2));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get compressed token balances for owner ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get compressed token balances for owner ${owner.toBase58()}`);
        }
        const maybeFiltered = options.mint
            ? res.result.value.items.filter(tokenBalance => tokenBalance.mint.toBase58() === options.mint.toBase58())
            : res.result.value.items;
        return {
            context: res.result.context,
            value: {
                items: maybeFiltered,
                cursor: res.result.value.cursor,
            },
        };
    }
    /**
     * Returns confirmed compression signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    async getCompressionSignaturesForAccount(hash) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressionSignaturesForAccount', { hash: encodeBN254toBase58(hash) });
        const res = create(unsafeRes, jsonRpcResultAndContext(SignatureListResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get signatures for compressed account ${hash.toString()}`);
        }
        return res.result.value.items;
    }
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    async getTransactionWithCompressionInfo(signature) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getTransactionWithCompressionInfo', { signature });
        const res = create(unsafeRes, jsonRpcResult(CompressedTransactionResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get slot');
        }
        if (res.result.transaction === null)
            return null;
        const closedAccounts = [];
        const openedAccounts = [];
        res.result.compressionInfo.closedAccounts.map(item => {
            closedAccounts.push(buildCompressedAccountWithMaybeTokenData(item));
        });
        res.result.compressionInfo.openedAccounts.map(item => {
            openedAccounts.push(buildCompressedAccountWithMaybeTokenData(item));
        });
        const calculateTokenBalances = (accounts) => {
            const balances = Object.values(accounts.reduce((acc, { maybeTokenData }) => {
                if (maybeTokenData) {
                    const { owner, mint, amount } = maybeTokenData;
                    const key = `${owner.toBase58()}_${mint.toBase58()}`;
                    if (key in acc) {
                        acc[key].amount = acc[key].amount.add(amount);
                    }
                    else {
                        acc[key] = { owner, mint, amount };
                    }
                }
                return acc;
            }, {}));
            return balances.length > 0 ? balances : undefined;
        };
        const preTokenBalances = calculateTokenBalances(closedAccounts);
        const postTokenBalances = calculateTokenBalances(openedAccounts);
        return {
            compressionInfo: {
                closedAccounts,
                openedAccounts,
                preTokenBalances,
                postTokenBalances,
            },
            transaction: res.result.transaction,
        };
    }
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed block
     *
     * @param address queried compressed account address
     */
    async getCompressionSignaturesForAddress(address, options) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressionSignaturesForAddress', {
            address: address.toBase58(),
            cursor: options?.cursor,
            limit: options?.limit?.toNumber(),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(SignatureListWithCursorResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get signatures for address ${address.toBase58()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get signatures for address ${address.toBase58()}`);
        }
        return res.result.value;
    }
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    async getCompressionSignaturesForOwner(owner, options) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressionSignaturesForOwner', {
            owner: owner.toBase58(),
            cursor: options?.cursor,
            limit: options?.limit?.toNumber(),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(SignatureListWithCursorResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get signatures for owner ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get signatures for owner ${owner.toBase58()}`);
        }
        return res.result.value;
    }
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    async getCompressionSignaturesForTokenOwner(owner, options) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressionSignaturesForTokenOwner', {
            owner: owner.toBase58(),
            cursor: options?.cursor,
            limit: options?.limit?.toNumber(),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(SignatureListWithCursorResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get signatures for owner ${owner.toBase58()}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get signatures for owner ${owner.toBase58()}`);
        }
        return res.result.value;
    }
    /**
     * Fetch the current indexer health status
     */
    async getIndexerHealth() {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getIndexerHealth');
        const res = create(unsafeRes, jsonRpcResult(HealthResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get health');
        }
        return res.result;
    }
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    async confirmTransactionIndexed(slot) {
        const startTime = Date.now();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const indexerSlot = await this.getIndexerSlot();
            if (indexerSlot >= slot) {
                return true;
            }
            if (Date.now() - startTime > 20000) {
                // 20 seconds
                throw new Error('Timeout: Indexer slot did not reach the required slot within 20 seconds');
            }
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    /**
     * Fetch the current slot that the node is processing
     */
    async getIndexerSlot() {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getIndexerSlot');
        const res = create(unsafeRes, jsonRpcResult(SlotResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get slot');
        }
        return res.result;
    }
    /**
     * Fetch all the compressed token holders for a given mint. Paginated.
     */
    async getCompressedMintTokenHolders(mint, options) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getCompressedMintTokenHolders', {
            mint: mint.toBase58(),
            cursor: options?.cursor,
            limit: options?.limit?.toNumber(),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(CompressedMintTokenHoldersResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get mint token holders');
        }
        return res.result;
    }
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    async getLatestCompressionSignatures(cursor, limit) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getLatestCompressionSignatures', { limit, cursor });
        const res = create(unsafeRes, jsonRpcResultAndContext(LatestNonVotingSignaturesResultPaginated));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get latest non-voting signatures');
        }
        return res.result;
    }
    /**
     * Fetch all non-voting signatures
     */
    async getLatestNonVotingSignatures(limit, cursor) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getLatestNonVotingSignatures', { limit, cursor });
        const res = create(unsafeRes, jsonRpcResultAndContext(LatestNonVotingSignaturesResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get latest non-voting signatures');
        }
        return res.result;
    }
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in
     * respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    async getMultipleNewAddressProofs(addresses) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getMultipleNewAddressProofs', addresses.map(address => encodeBN254toBase58(address)));
        const res = create(unsafeRes, jsonRpcResultAndContext(array(NewAddressProofResult)));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`);
        }
        if (res.result.value === null) {
            throw new Error(`failed to get proofs for new addresses ${addresses.map(address => encodeBN254toBase58(address)).join(', ')}`);
        }
        /// Creates proof for each address
        const newAddressProofs = [];
        for (const proof of res.result.value) {
            const _proof = {
                root: proof.root,
                rootIndex: proof.rootSeq % 2400,
                value: proof.address,
                leafLowerRangeValue: proof.lowerRangeAddress,
                leafHigherRangeValue: proof.higherRangeAddress,
                nextIndex: bn(proof.nextIndex),
                merkleProofHashedIndexedElementLeaf: proof.proof,
                indexHashedIndexedElementLeaf: bn(proof.lowElementLeafIndex),
                merkleTree: proof.merkleTree,
                nullifierQueue: mockAddressQueue,
            };
            newAddressProofs.push(_proof);
        }
        return newAddressProofs;
    }
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    async getValidityProofDirect(hashes = [], newAddresses = []) {
        let validityProof;
        if (hashes.length === 0 && newAddresses.length === 0) {
            throw new Error('Empty input. Provide hashes and/or new addresses.');
        }
        else if (hashes.length > 0 && newAddresses.length === 0) {
            /// inclusion
            const merkleProofsWithContext = await this.getMultipleCompressedAccountProofs(hashes);
            const inputs = convertMerkleProofsWithContextToHex(merkleProofsWithContext);
            const compressedProof = await proverRequest(this.proverEndpoint, 'inclusion', inputs, false);
            validityProof = {
                compressedProof,
                roots: merkleProofsWithContext.map(proof => proof.root),
                rootIndices: merkleProofsWithContext.map(proof => proof.rootIndex),
                leafIndices: merkleProofsWithContext.map(proof => proof.leafIndex),
                leaves: merkleProofsWithContext.map(proof => bn(proof.hash)),
                merkleTrees: merkleProofsWithContext.map(proof => proof.merkleTree),
                nullifierQueues: merkleProofsWithContext.map(proof => proof.nullifierQueue),
            };
        }
        else if (hashes.length === 0 && newAddresses.length > 0) {
            /// new-address
            const newAddressProofs = await this.getMultipleNewAddressProofs(newAddresses);
            const inputs = convertNonInclusionMerkleProofInputsToHex(newAddressProofs);
            const compressedProof = await proverRequest(this.proverEndpoint, 'new-address', inputs, false);
            validityProof = {
                compressedProof,
                roots: newAddressProofs.map(proof => proof.root),
                rootIndices: newAddressProofs.map(proof => proof.rootIndex),
                leafIndices: newAddressProofs.map(proof => proof.nextIndex.toNumber()),
                leaves: newAddressProofs.map(proof => bn(proof.value)),
                merkleTrees: newAddressProofs.map(proof => proof.merkleTree),
                nullifierQueues: newAddressProofs.map(proof => proof.nullifierQueue),
            };
        }
        else if (hashes.length > 0 && newAddresses.length > 0) {
            /// combined
            const merkleProofsWithContext = await this.getMultipleCompressedAccountProofs(hashes);
            const inputs = convertMerkleProofsWithContextToHex(merkleProofsWithContext);
            const newAddressProofs = await this.getMultipleNewAddressProofs(newAddresses);
            const newAddressInputs = convertNonInclusionMerkleProofInputsToHex(newAddressProofs);
            const compressedProof = await proverRequest(this.proverEndpoint, 'combined', [inputs, newAddressInputs], false);
            validityProof = {
                compressedProof,
                roots: merkleProofsWithContext
                    .map(proof => proof.root)
                    .concat(newAddressProofs.map(proof => proof.root)),
                rootIndices: merkleProofsWithContext
                    .map(proof => proof.rootIndex)
                    .concat(newAddressProofs.map(proof => proof.rootIndex)),
                leafIndices: merkleProofsWithContext
                    .map(proof => proof.leafIndex)
                    .concat(newAddressProofs.map(proof => proof.nextIndex.toNumber())),
                leaves: merkleProofsWithContext
                    .map(proof => bn(proof.hash))
                    .concat(newAddressProofs.map(proof => bn(proof.value))),
                merkleTrees: merkleProofsWithContext
                    .map(proof => proof.merkleTree)
                    .concat(newAddressProofs.map(proof => proof.merkleTree)),
                nullifierQueues: merkleProofsWithContext
                    .map(proof => proof.nullifierQueue)
                    .concat(newAddressProofs.map(proof => proof.nullifierQueue)),
            };
        }
        else
            throw new Error('Invalid input');
        return validityProof;
    }
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    async getValidityProof(hashes = [], newAddresses = []) {
        const defaultAddressTreePublicKey = defaultTestStateTreeAccounts().addressTree;
        const defaultAddressQueuePublicKey = defaultTestStateTreeAccounts().addressQueue;
        const defaultStateTreePublicKey = defaultTestStateTreeAccounts().merkleTree;
        const defaultStateQueuePublicKey = defaultTestStateTreeAccounts().nullifierQueue;
        const formattedHashes = hashes.map(item => {
            return {
                hash: item,
                tree: defaultStateTreePublicKey,
                queue: defaultStateQueuePublicKey,
            };
        });
        const formattedNewAddresses = newAddresses.map(item => {
            return {
                address: item,
                tree: defaultAddressTreePublicKey,
                queue: defaultAddressQueuePublicKey,
            };
        });
        return this.getValidityProofV0(formattedHashes, formattedNewAddresses);
    }
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.
     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.
     * @returns             validity proof with context
     */
    async getValidityProofV0(hashes = [], newAddresses = []) {
        const { value } = await this.getValidityProofAndRpcContext(hashes, newAddresses);
        return value;
    }
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses. Returns with context slot.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses. Optionally specify the
     *                      tree and queue for each address. Default to public
     *                      state tree/queue.
     * @returns             validity proof with context
     */
    async getValidityProofAndRpcContext(hashes = [], newAddresses = []) {
        const unsafeRes = await rpcRequest(this.compressionApiEndpoint, 'getValidityProof', {
            hashes: hashes.map(({ hash }) => encodeBN254toBase58(hash)),
            newAddressesWithTrees: newAddresses.map(({ address, tree }) => ({
                address: encodeBN254toBase58(address),
                tree: tree.toBase58(),
            })),
        });
        const res = create(unsafeRes, jsonRpcResultAndContext(ValidityProofResult));
        if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get ValidityProof for compressed accounts ${hashes.map(hash => hash.toString())}`);
        }
        const result = res.result.value;
        if (result === null) {
            throw new Error(`failed to get ValidityProof for compressed accounts ${hashes.map(hash => hash.toString())}`);
        }
        const value = {
            compressedProof: result.compressedProof,
            merkleTrees: result.merkleTrees,
            leafIndices: result.leafIndices,
            nullifierQueues: [
                ...hashes.map(({ queue }) => queue),
                ...newAddresses.map(({ queue }) => queue),
            ],
            rootIndices: result.rootIndices,
            roots: result.roots,
            leaves: result.leaves,
        };
        return { value, context: res.result.context };
    }
}

class IndexedElement {
    index;
    value;
    nextIndex;
    constructor(index, value, nextIndex) {
        this.index = index;
        this.value = value;
        this.nextIndex = nextIndex;
    }
    equals(other) {
        return this.value.eq(other.value);
    }
    compareTo(other) {
        return this.value.cmp(other.value);
    }
    hash(lightWasm, nextValue) {
        try {
            const hash = lightWasm.poseidonHash([
                bn(this.value.toArray('be', 32)).toString(),
                bn(this.nextIndex).toString(),
                bn(nextValue.toArray('be', 32)).toString(),
            ]);
            return hash;
        }
        catch (error) {
            throw new Error('Hashing failed');
        }
    }
}
class IndexedElementBundle {
    newLowElement;
    newElement;
    newElementNextValue;
    constructor(newLowElement, newElement, newElementNextValue) {
        this.newLowElement = newLowElement;
        this.newElement = newElement;
        this.newElementNextValue = newElementNextValue;
    }
}
/**
 * This indexed array implementation mirrors the rust implementation of the
 * indexed merkle tree. It stores the elements of the indexed merkle tree.
 */
class IndexedArray {
    elements;
    currentNodeIndex;
    highestElementIndex;
    constructor(elements, currentNodeIndex, highestElementIndex) {
        this.elements = elements;
        this.currentNodeIndex = currentNodeIndex;
        this.highestElementIndex = highestElementIndex;
    }
    static default() {
        return new IndexedArray([new IndexedElement(0, bn(0), 0)], 0, 0);
    }
    get(index) {
        return this.elements[index];
    }
    length() {
        return Number(this.currentNodeIndex);
    }
    isEmpty() {
        return this.currentNodeIndex === 0;
    }
    findElement(value) {
        return this.elements
            .slice(0, this.length() + 1)
            .find(node => node.value === value);
    }
    init() {
        try {
            const init_value = HIGHEST_ADDRESS_PLUS_ONE;
            return this.append(init_value);
        }
        catch (error) {
            throw new Error(`Failed to initialize IndexedArray: ${error}`);
        }
    }
    /**
     * Finds the index of the low element for the given `value` which should not be part of the array.
     * Low element is the greatest element which still has a lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElementIndex(value) {
        // Try to find element whose next element is higher than the provided value.
        for (let i = 0; i <= this.length(); i++) {
            const node = this.elements[i];
            if (this.elements[node.nextIndex].value.gt(value) &&
                node.value.lt(value)) {
                return i;
            }
            else if (node.value.eq(value)) {
                throw new Error('Element already exists in the array');
            }
        }
        // If no such element was found, it means that our value is going to be the greatest in the array.
        // This means that the currently greatest element is going to be the low element of our value.
        return this.highestElementIndex;
    }
    /**
     * Returns the low element for the given value and the next value for that low element.
     * Low element is the greatest element which still has lower value than the provided one.
     * Low elements are used in non-membership proofs.
     */
    findLowElement(value) {
        const lowElementIndex = this.findLowElementIndex(value);
        if (lowElementIndex === undefined)
            return [undefined, undefined];
        const lowElement = this.elements[lowElementIndex];
        return [lowElement, this.elements[lowElement.nextIndex].value];
    }
    // /**
    //  * Returns the index of the low element for the given `value`, which should be the part of the array.
    //  * Low element is the greatest element which still has lower value than the provided one.
    //  * Low elements are used in non-membership proofs.
    //  */
    // public findLowElementIndexForExistingElement(
    //     value: BN,
    // ): number | undefined {
    //     for (let i = 0; i <= this.length(); i++) {
    //         const node = this.elements[i];
    //         if (this.elements[node.nextIndex].value === value) {
    //             return i;
    //         }
    //     }
    //     return undefined;
    // }
    /**
     * Returns the hash of the given element. That hash consists of:
     * - The value of the given element.
     * - The `nextIndex` of the given element.
     * - The value of the element pointed by `nextIndex`.
     */
    hashElement(lightWasm, index) {
        const element = this.elements[index];
        if (!element)
            return undefined;
        const nextElement = this.elements[element.nextIndex];
        if (!nextElement)
            return undefined;
        const hash = lightWasm.poseidonHash([
            bn(element.value.toArray('be', 32)).toString(),
            bn(element.nextIndex).toString(),
            bn(nextElement.value.toArray('be', 32)).toString(),
        ]);
        return hash;
    }
    /**
     * Appends a new element with the given value to the indexed array.
     * It finds the low element index and uses it to append the new element correctly.
     * @param value The value of the new element to append.
     * @returns The new element and its low element after insertion.
     */
    append(value) {
        const lowElementIndex = this.findLowElementIndex(value);
        if (lowElementIndex === undefined) {
            throw new Error('Low element index not found.');
        }
        return this.appendWithLowElementIndex(lowElementIndex, value);
    }
    /**
     * Appends a new element with the given value to the indexed array using a specific low element index.
     * This method ensures the new element is placed correctly relative to the low element.
     * @param lowElementIndex The index of the low element.
     * @param value The value of the new element to append.
     * @returns The new element and its updated low element.
     */
    appendWithLowElementIndex(lowElementIndex, value) {
        const lowElement = this.elements[lowElementIndex];
        if (lowElement.nextIndex === 0) {
            if (value.lte(lowElement.value)) {
                throw new Error('New element value must be greater than the low element value.');
            }
        }
        else {
            const nextElement = this.elements[lowElement.nextIndex];
            if (value.lte(lowElement.value)) {
                throw new Error('New element value must be greater than the low element value.');
            }
            if (value.gte(nextElement.value)) {
                throw new Error('New element value must be less than the next element value.');
            }
        }
        const newElementBundle = this.newElementWithLowElementIndex(lowElementIndex, value);
        // If the old low element wasn't pointing to any element, it means that:
        //
        // * It used to be the highest element.
        // * Our new element, which we are appending, is going the be the
        //   highest element.
        //
        // Therefore, we need to save the new element index as the highest
        // index.
        if (lowElement.nextIndex === 0) {
            this.highestElementIndex = newElementBundle.newElement.index;
        }
        // Insert new node.
        this.currentNodeIndex = newElementBundle.newElement.index;
        this.elements[this.length()] = newElementBundle.newElement;
        // Update low element.
        this.elements[lowElementIndex] = newElementBundle.newLowElement;
        return newElementBundle;
    }
    /**
     * Finds the lowest element in the array.
     * @returns The lowest element or undefined if the array is empty.
     */
    lowest() {
        return this.elements.length > 0 ? this.elements[0] : undefined;
    }
    /**
     * Creates a new element with the specified value and updates the low element index accordingly.
     * @param lowElementIndex The index of the low element.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElementWithLowElementIndex(lowElementIndex, value) {
        const newLowElement = this.elements[lowElementIndex];
        const newElementIndex = this.currentNodeIndex + 1;
        const newElement = new IndexedElement(newElementIndex, value, newLowElement.nextIndex);
        newLowElement.nextIndex = newElementIndex;
        const newElementNextValue = this.elements[newElement.nextIndex].value;
        return new IndexedElementBundle(newLowElement, newElement, newElementNextValue);
    }
    /**
     * Creates a new element with the specified value by first finding the appropriate low element index.
     * @param value The value for the new element.
     * @returns A bundle containing the new element, the updated low element, and the value of the next element.
     */
    newElement(value) {
        const lowElementIndex = this.findLowElementIndex(value);
        if (lowElementIndex === undefined) {
            throw new Error('Low element index not found.');
        }
        return this.newElementWithLowElementIndex(lowElementIndex, value);
    }
}

const DEFAULT_ZERO = '0';
/**
 * @callback hashFunction
 * @param left Left leaf
 * @param right Right leaf
 */
/**
 * Merkle tree
 */
class MerkleTree {
    /**
     * Constructor
     * @param {number} levels Number of levels in the tree
     * @param {Array} [elements] Initial elements
     * @param {Object} options
     * @param {hashFunction} [options.hashFunction] Function used to hash 2 leaves
     * @param [options.zeroElement] Value for non-existent leaves
     */
    levels;
    capacity;
    zeroElement;
    _zeros;
    _layers;
    _lightWasm;
    constructor(levels, lightWasm, elements = [], { zeroElement = DEFAULT_ZERO } = {}) {
        this.levels = levels;
        this.capacity = 2 ** levels;
        this.zeroElement = zeroElement;
        this._lightWasm = lightWasm;
        if (elements.length > this.capacity) {
            throw new Error('Tree is full');
        }
        this._zeros = [];
        this._layers = [];
        this._layers[0] = elements;
        this._zeros[0] = this.zeroElement;
        for (let i = 1; i <= levels; i++) {
            this._zeros[i] = this._lightWasm.poseidonHashString([
                this._zeros[i - 1],
                this._zeros[i - 1],
            ]);
        }
        this._rebuild();
    }
    _rebuild() {
        for (let level = 1; level <= this.levels; level++) {
            this._layers[level] = [];
            for (let i = 0; i < Math.ceil(this._layers[level - 1].length / 2); i++) {
                this._layers[level][i] = this._lightWasm.poseidonHashString([
                    this._layers[level - 1][i * 2],
                    i * 2 + 1 < this._layers[level - 1].length
                        ? this._layers[level - 1][i * 2 + 1]
                        : this._zeros[level - 1],
                ]);
            }
        }
    }
    /**
     * Get tree root
     * @returns {*}
     */
    root() {
        return this._layers[this.levels].length > 0
            ? this._layers[this.levels][0]
            : this._zeros[this.levels];
    }
    /**
     * Insert new element into the tree
     * @param element Element to insert
     */
    insert(element) {
        if (this._layers[0].length >= this.capacity) {
            throw new Error('Tree is full');
        }
        this.update(this._layers[0].length, element);
    }
    /**
     * Insert multiple elements into the tree. Tree will be fully rebuilt during this operation.
     * @param {Array} elements Elements to insert
     */
    bulkInsert(elements) {
        if (this._layers[0].length + elements.length > this.capacity) {
            throw new Error('Tree is full');
        }
        this._layers[0].push(...elements);
        this._rebuild();
    }
    // TODO: update does not work debug
    /**
     * Change an element in the tree
     * @param {number} index Index of element to change
     * @param element Updated element value
     */
    update(index, element) {
        // index 0 and 1 and element is the commitment hash
        if (isNaN(Number(index)) ||
            index < 0 ||
            index > this._layers[0].length ||
            index >= this.capacity) {
            throw new Error('Insert index out of bounds: ' + index);
        }
        this._layers[0][index] = element;
        for (let level = 1; level <= this.levels; level++) {
            index >>= 1;
            this._layers[level][index] = this._lightWasm.poseidonHashString([
                this._layers[level - 1][index * 2],
                index * 2 + 1 < this._layers[level - 1].length
                    ? this._layers[level - 1][index * 2 + 1]
                    : this._zeros[level - 1],
            ]);
        }
    }
    /**
     * Get merkle path to a leaf
     * @param {number} index Leaf index to generate path for
     * @returns {{pathElements: number[], pathIndex: number[]}} An object containing adjacent elements and left-right index
     */
    path(index) {
        if (isNaN(Number(index)) ||
            index < 0 ||
            index >= this._layers[0].length) {
            throw new Error('Index out of bounds: ' + index);
        }
        const pathElements = [];
        const pathIndices = [];
        for (let level = 0; level < this.levels; level++) {
            pathIndices[level] = index % 2;
            pathElements[level] =
                (index ^ 1) < this._layers[level].length
                    ? this._layers[level][index ^ 1]
                    : this._zeros[level];
            index >>= 1;
        }
        return {
            pathElements,
            pathIndices,
        };
    }
    /**
     * Find an element in the tree
     * @param element An element to find
     * @param comparator A function that checks leaf value equality
     * @returns {number} Index if element is found, otherwise -1
     */
    indexOf(element, comparator = null) {
        if (comparator) {
            return this._layers[0].findIndex((el) => comparator(element, el));
        }
        else {
            return this._layers[0].indexOf(element);
        }
    }
    /**
     * Returns a copy of non-zero tree elements
     * @returns {Object[]}
     */
    elements() {
        return this._layers[0].slice();
    }
    /**
     * Serialize entire tree state including intermediate layers into a plain object
     * Deserializing it back will not require to recompute any hashes
     * Elements are not converted to a plain type, this is responsibility of the caller
     */
    serialize() {
        return {
            levels: this.levels,
            _zeros: this._zeros,
            _layers: this._layers,
        };
    }
    /**
     * Deserialize data into a MerkleTree instance
     * Make sure to provide the same hashFunction as was used in the source tree,
     * otherwise the tree state will be invalid
     *
     * @param data
     * @param hashFunction
     * @returns {MerkleTree}
     */
    static deserialize(data, hashFunction) {
        const instance = Object.assign(Object.create(this.prototype), data);
        instance._hash = hashFunction;
        instance.capacity = 2 ** instance.levels;
        instance.zeroElement = instance._zeros[0];
        return instance;
    }
}

var bytes = {};

var hex = {};

Object.defineProperty(hex, "__esModule", { value: true });
hex.decode = hex.encode = void 0;
const buffer_1$1 = require$$0;
function encode$3(data) {
    return data.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "0x");
}
hex.encode = encode$3;
function decode$3(data) {
    if (data.indexOf("0x") === 0) {
        data = data.substr(2);
    }
    if (data.length % 2 === 1) {
        data = "0" + data;
    }
    let key = data.match(/.{2}/g);
    if (key === null) {
        return buffer_1$1.Buffer.from([]);
    }
    return buffer_1$1.Buffer.from(key.map((byte) => parseInt(byte, 16)));
}
hex.decode = decode$3;

var utf8 = {};

var common = {};

var _a;
Object.defineProperty(common, "__esModule", { value: true });
common.isVersionedTransaction = common.chunks = common.isBrowser = void 0;
/**
 * Returns true if being run inside a web browser,
 * false if in a Node process or electron app.
 */
common.isBrowser = process.env.ANCHOR_BROWSER ||
    (typeof window !== "undefined" && !((_a = window.process) === null || _a === void 0 ? void 0 : _a.hasOwnProperty("type")));
/**
 * Splits an array into chunks
 *
 * @param array Array of objects to chunk.
 * @param size The max size of a chunk.
 * @returns A two dimensional array where each T[] length is < the provided size.
 */
function chunks(array, size) {
    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}
common.chunks = chunks;
/**
 * Check if a transaction object is a VersionedTransaction or not
 *
 * @param tx
 * @returns bool
 */
const isVersionedTransaction = (tx) => {
    return "version" in tx;
};
common.isVersionedTransaction = isVersionedTransaction;

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$1 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (browser$1.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNullOrUndefined(arg) {
  return arg == null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return Buffer$1.isBuffer(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

var _polyfillNode_util = {
  inherits: inherits$1,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray,
  inspect: inspect,
  deprecate: deprecate,
  format: format,
  debuglog: debuglog,
  promisify: promisify,
  callbackify: callbackify,
};

var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _extend: _extend,
    callbackify: callbackify,
    debuglog: debuglog,
    default: _polyfillNode_util,
    deprecate: deprecate,
    format: format,
    inherits: inherits$1,
    inspect: inspect,
    isArray: isArray,
    isBoolean: isBoolean,
    isBuffer: isBuffer,
    isDate: isDate,
    isError: isError,
    isFunction: isFunction,
    isNull: isNull,
    isNullOrUndefined: isNullOrUndefined,
    isNumber: isNumber,
    isObject: isObject,
    isPrimitive: isPrimitive,
    isRegExp: isRegExp,
    isString: isString,
    isSymbol: isSymbol,
    isUndefined: isUndefined,
    log: log,
    promisify: promisify
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

Object.defineProperty(utf8, "__esModule", { value: true });
utf8.encode = utf8.decode = void 0;
const common_1 = common;
function decode$2(array) {
    const decoder = common_1.isBrowser
        ? new TextDecoder("utf-8") // Browser https://caniuse.com/textencoder.
        : new (require$$1.TextDecoder)("utf-8"); // Node.
    return decoder.decode(array);
}
utf8.decode = decode$2;
function encode$2(input) {
    const encoder = common_1.isBrowser
        ? new TextEncoder() // Browser.
        : new (require$$1.TextEncoder)("utf-8"); // Node.
    return encoder.encode(input);
}
utf8.encode = encode$2;

var bs58$1 = {};

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(bs58$1, "__esModule", { value: true });
bs58$1.decode = bs58$1.encode = void 0;
const bs58_1 = __importDefault(bs58$2);
function encode$1(data) {
    return bs58_1.default.encode(data);
}
bs58$1.encode = encode$1;
function decode$1(data) {
    return bs58_1.default.decode(data);
}
bs58$1.decode = decode$1;

var base64 = {};

Object.defineProperty(base64, "__esModule", { value: true });
base64.decode = base64.encode = void 0;
const buffer_1 = require$$0;
function encode(data) {
    return data.toString("base64");
}
base64.encode = encode;
function decode(data) {
    return buffer_1.Buffer.from(data, "base64");
}
base64.decode = decode;

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(bytes, "__esModule", { value: true });
bytes.base64 = bs58 = bytes.bs58 = bytes.utf8 = bytes.hex = void 0;
bytes.hex = __importStar(hex);
bytes.utf8 = __importStar(utf8);
var bs58 = bytes.bs58 = __importStar(bs58$1);
bytes.base64 = __importStar(base64);

/**
 * @internal
 * Returns newest first.
 *
 * */
async function getParsedEvents(rpc) {
    const { noopProgram, accountCompressionProgram } = defaultStaticAccountsStruct();
    /// Get raw transactions
    const signatures = (await rpc.getConfirmedSignaturesForAddress2(accountCompressionProgram, undefined, 'confirmed')).map(s => s.signature);
    const txs = await rpc.getParsedTransactions(signatures, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed',
    });
    /// Filter by NOOP program
    const transactionEvents = txs.filter((tx) => {
        if (!tx) {
            return false;
        }
        const accountKeys = tx.transaction.message.accountKeys;
        const hasSplNoopAddress = accountKeys.some((item) => {
            const itemStr = typeof item === 'string'
                ? item
                : item.pubkey.toBase58();
            return itemStr === noopProgram.toBase58();
        });
        return hasSplNoopAddress;
    });
    /// Parse events
    const parsedEvents = parseEvents(transactionEvents, parsePublicTransactionEventWithIdl);
    return parsedEvents;
}
const parseEvents = (indexerEventsTransactions, deserializeFn) => {
    const { noopProgram } = defaultStaticAccountsStruct();
    const transactions = [];
    indexerEventsTransactions.forEach(tx => {
        if (!tx ||
            !tx.meta ||
            tx.meta.err ||
            !tx.meta.innerInstructions ||
            tx.meta.innerInstructions.length <= 0) {
            return;
        }
        /// We only care about the very last inner instruction as it contains the
        /// PublicTransactionEvent
        tx.meta.innerInstructions.forEach(ix => {
            if (ix.instructions.length > 0) {
                const ixInner = ix.instructions[ix.instructions.length - 1];
                // Type guard for partially parsed web3js types.
                if ('data' in ixInner &&
                    ixInner.data &&
                    ixInner.programId.toBase58() === noopProgram.toBase58()) {
                    const data = bs58.decode(ixInner.data);
                    const decodedEvent = deserializeFn(Buffer.from(data), tx);
                    if (decodedEvent !== null && decodedEvent !== undefined) {
                        transactions.push(decodedEvent);
                    }
                }
            }
        });
    });
    return transactions;
};
// TODO: make it type safe. have to reimplement the types from the IDL.
const parsePublicTransactionEventWithIdl = (data) => {
    const numericData = Buffer.from(data.map(byte => byte));
    try {
        return LightSystemProgram.program.coder.types.decode('PublicTransactionEvent', numericData);
    }
    catch (error) {
        console.error('Error deserializing event:', error);
        return null;
    }
};

async function getCompressedAccountsByOwnerTest(rpc, owner) {
    const unspentAccounts = await getCompressedAccountsForTest(rpc);
    const byOwner = unspentAccounts.filter(acc => acc.owner.equals(owner));
    return byOwner;
}
async function getCompressedAccountByHashTest(rpc, hash) {
    const unspentAccounts = await getCompressedAccountsForTest(rpc);
    return unspentAccounts.find(acc => bn(acc.hash).eq(hash));
}
async function getMultipleCompressedAccountsByHashTest(rpc, hashes) {
    const unspentAccounts = await getCompressedAccountsForTest(rpc);
    return unspentAccounts
        .filter(acc => hashes.some(hash => bn(acc.hash).eq(hash)))
        .sort((a, b) => b.leafIndex - a.leafIndex);
}
/// Returns all unspent compressed accounts
async function getCompressedAccountsForTest(rpc) {
    const events = (await getParsedEvents(rpc)).reverse();
    const allOutputAccounts = [];
    const allInputAccountHashes = [];
    for (const event of events) {
        for (let index = 0; index < event.outputCompressedAccounts.length; index++) {
            const account = event.outputCompressedAccounts[index];
            const merkleContext = {
                merkleTree: defaultTestStateTreeAccounts().merkleTree,
                nullifierQueue: defaultTestStateTreeAccounts().nullifierQueue,
                hash: event.outputCompressedAccountHashes[index],
                leafIndex: event.outputLeafIndices[index],
            };
            const withCtx = createCompressedAccountWithMerkleContext(merkleContext, account.compressedAccount.owner, account.compressedAccount.lamports, account.compressedAccount.data ?? undefined, account.compressedAccount.address ?? undefined);
            allOutputAccounts.push(withCtx);
        }
        for (let index = 0; index < event.inputCompressedAccountHashes.length; index++) {
            const hash = event.inputCompressedAccountHashes[index];
            allInputAccountHashes.push(bn(hash));
        }
    }
    const unspentAccounts = allOutputAccounts.filter(account => !allInputAccountHashes.some(hash => hash.eq(bn(account.hash))));
    unspentAccounts.sort((a, b) => b.leafIndex - a.leafIndex);
    return unspentAccounts;
}

const tokenProgramId = new PublicKey(
// TODO: can add check to ensure its consistent with the idl
'cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m');
/**
 * Manually parse the compressed token layout for a given compressed account.
 * @param compressedAccount - The compressed account
 * @returns The parsed token data
 */
function parseTokenLayoutWithIdl(compressedAccount, programId = tokenProgramId) {
    if (compressedAccount.data === null)
        return null;
    const { data } = compressedAccount.data;
    if (data.length === 0)
        return null;
    if (compressedAccount.owner.toBase58() !== programId.toBase58()) {
        throw new Error(`Invalid owner ${compressedAccount.owner.toBase58()} for token layout`);
    }
    const decodedLayout = new BorshCoder(IDL).types.decode('TokenData', Buffer.from(data));
    return decodedLayout;
}
/**
 * parse compressed accounts of an event with token layout
 * @internal
 * TODO: refactor
 */
async function parseEventWithTokenTlvData(event) {
    const pubkeyArray = event.pubkeyArray;
    const outputHashes = event.outputCompressedAccountHashes;
    const outputCompressedAccountsWithParsedTokenData = event.outputCompressedAccounts.map((compressedAccount, i) => {
        const merkleContext = {
            merkleTree: pubkeyArray[event.outputCompressedAccounts[i].merkleTreeIndex],
            nullifierQueue: 
            // FIXME: fix make dynamic
            defaultTestStateTreeAccounts().nullifierQueue,
            hash: outputHashes[i],
            leafIndex: event.outputLeafIndices[i],
        };
        if (!compressedAccount.compressedAccount.data)
            throw new Error('No data');
        const parsedData = parseTokenLayoutWithIdl(compressedAccount.compressedAccount);
        if (!parsedData)
            throw new Error('Invalid token data');
        const withMerkleContext = createCompressedAccountWithMerkleContext(merkleContext, compressedAccount.compressedAccount.owner, compressedAccount.compressedAccount.lamports, compressedAccount.compressedAccount.data, compressedAccount.compressedAccount.address ?? undefined);
        return {
            compressedAccount: withMerkleContext,
            parsed: parsedData,
        };
    });
    return {
        inputCompressedAccountHashes: event.inputCompressedAccountHashes,
        outputCompressedAccounts: outputCompressedAccountsWithParsedTokenData,
    };
}
/**
 * Retrieves all compressed token accounts for a given mint and owner.
 *
 * Note: This function is intended for testing purposes only. For production, use rpc.getCompressedTokenAccounts.
 *
 * @param events    Public transaction events
 * @param owner     PublicKey of the token owner
 * @param mint      PublicKey of the token mint
 */
async function getCompressedTokenAccounts(events) {
    const eventsWithParsedTokenTlvData = await Promise.all(events.map(event => parseEventWithTokenTlvData(event)));
    /// strip spent compressed accounts if an output compressed account of tx n is
    /// an input compressed account of tx n+m, it is spent
    const allOutCompressedAccounts = eventsWithParsedTokenTlvData.flatMap(event => event.outputCompressedAccounts);
    const allInCompressedAccountHashes = eventsWithParsedTokenTlvData.flatMap(event => event.inputCompressedAccountHashes);
    const unspentCompressedAccounts = allOutCompressedAccounts.filter(outputCompressedAccount => !allInCompressedAccountHashes.some(hash => {
        return (JSON.stringify(hash) ===
            JSON.stringify(outputCompressedAccount.compressedAccount.hash));
    }));
    return unspentCompressedAccounts;
}
/** @internal */
async function getCompressedTokenAccountsByOwnerTest(rpc, owner, mint) {
    const events = await getParsedEvents(rpc);
    const compressedTokenAccounts = await getCompressedTokenAccounts(events);
    const accounts = compressedTokenAccounts.filter(acc => acc.parsed.owner.equals(owner) && acc.parsed.mint.equals(mint));
    return {
        items: accounts.sort((a, b) => b.compressedAccount.leafIndex - a.compressedAccount.leafIndex),
        cursor: null,
    };
}
async function getCompressedTokenAccountsByDelegateTest(rpc, delegate, mint) {
    const events = await getParsedEvents(rpc);
    const compressedTokenAccounts = await getCompressedTokenAccounts(events);
    return {
        items: compressedTokenAccounts.filter(acc => acc.parsed.delegate?.equals(delegate) &&
            acc.parsed.mint.equals(mint)),
        cursor: null,
    };
}
async function getCompressedTokenAccountByHashTest(rpc, hash) {
    const events = await getParsedEvents(rpc);
    const compressedTokenAccounts = await getCompressedTokenAccounts(events);
    const filtered = compressedTokenAccounts.filter(acc => bn(acc.compressedAccount.hash).eq(hash));
    if (filtered.length === 0) {
        throw new Error('No compressed account found');
    }
    return filtered[0];
}

/**
 * Returns a mock RPC instance for use in unit tests.
 *
 * @param lightWasm               Wasm hasher instance.
 * @param endpoint                RPC endpoint URL. Defaults to
 *                                'http://127.0.0.1:8899'.
 * @param proverEndpoint          Prover server endpoint URL. Defaults to
 *                                'http://localhost:3001'.
 * @param merkleTreeAddress       Address of the merkle tree to index. Defaults
 *                                to the public default test state tree.
 * @param nullifierQueueAddress   Optional address of the associated nullifier
 *                                queue.
 * @param depth                   Depth of the merkle tree.
 * @param log                     Log proof generation time.
 */
async function getTestRpc(lightWasm, endpoint = 'http://127.0.0.1:8899', compressionApiEndpoint = 'http://127.0.0.1:8784', proverEndpoint = 'http://127.0.0.1:3001', merkleTreeAddress, nullifierQueueAddress, depth, log = false) {
    const defaultAccounts = defaultTestStateTreeAccounts();
    return new TestRpc(endpoint, lightWasm, compressionApiEndpoint, proverEndpoint, undefined, {
        merkleTreeAddress: merkleTreeAddress || defaultAccounts.merkleTree,
        nullifierQueueAddress: nullifierQueueAddress || defaultAccounts.nullifierQueue,
        depth: depth || defaultAccounts.merkleTreeHeight,
        log,
    });
}
/**
 * Simple mock rpc for unit tests that simulates the compression rpc interface.
 * Fetches, parses events and builds merkletree on-demand, i.e. it does not persist state.
 * Constraints:
 * - Can only index 1 merkletree
 * - Can only index up to 1000 transactions
 *
 * For advanced testing use photon: https://github.com/helius-labs/photon
 */
class TestRpc extends Connection {
    compressionApiEndpoint;
    proverEndpoint;
    merkleTreeAddress;
    nullifierQueueAddress;
    addressTreeAddress;
    addressQueueAddress;
    lightWasm;
    depth;
    log = false;
    /**
     * Establish a Compression-compatible JSON RPC mock-connection
     *
     * @param endpoint                  endpoint to the solana cluster (use for
     *                                  localnet only)
     * @param hasher                    light wasm hasher instance
     * @param compressionApiEndpoint    Endpoint to the compression server.
     * @param proverEndpoint            Endpoint to the prover server. defaults
     *                                  to endpoint
     * @param connectionConfig          Optional connection config
     * @param testRpcConfig             Config for the mock rpc
     */
    constructor(endpoint, hasher, compressionApiEndpoint, proverEndpoint, connectionConfig, testRpcConfig) {
        super(endpoint, connectionConfig || 'confirmed');
        this.compressionApiEndpoint = compressionApiEndpoint;
        this.proverEndpoint = proverEndpoint;
        const { merkleTreeAddress, nullifierQueueAddress, depth, log, addressTreeAddress, addressQueueAddress, } = testRpcConfig ?? {};
        const { merkleTree, nullifierQueue, merkleTreeHeight, addressQueue, addressTree, } = defaultTestStateTreeAccounts();
        this.lightWasm = hasher;
        this.merkleTreeAddress = merkleTreeAddress ?? merkleTree;
        this.nullifierQueueAddress = nullifierQueueAddress ?? nullifierQueue;
        this.addressTreeAddress = addressTreeAddress ?? addressTree;
        this.addressQueueAddress = addressQueueAddress ?? addressQueue;
        this.depth = depth ?? merkleTreeHeight;
        this.log = log ?? false;
    }
    /**
     * Fetch the compressed account for the specified account hash
     */
    async getCompressedAccount(address, hash) {
        if (address) {
            throw new Error('address is not supported in test-rpc');
        }
        if (!hash) {
            throw new Error('hash is required');
        }
        const account = await getCompressedAccountByHashTest(this, hash);
        return account ?? null;
    }
    /**
     * Fetch the compressed balance for the specified account hash
     */
    async getCompressedBalance(address, hash) {
        if (address) {
            throw new Error('address is not supported in test-rpc');
        }
        if (!hash) {
            throw new Error('hash is required');
        }
        const account = await getCompressedAccountByHashTest(this, hash);
        if (!account) {
            throw new Error('Account not found');
        }
        return bn(account.lamports);
    }
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    async getCompressedBalanceByOwner(owner) {
        const accounts = await this.getCompressedAccountsByOwner(owner);
        return accounts.items.reduce((acc, account) => acc.add(account.lamports), bn(0));
    }
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    async getCompressedAccountProof(hash) {
        const proofs = await this.getMultipleCompressedAccountProofs([hash]);
        return proofs[0];
    }
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    async getMultipleCompressedAccounts(hashes) {
        return await getMultipleCompressedAccountsByHashTest(this, hashes);
    }
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    async confirmTransactionIndexed(_slot) {
        return true;
    }
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    async getMultipleCompressedAccountProofs(hashes) {
        /// Build tree
        const events = await getParsedEvents(this).then(events => events.reverse());
        const allLeaves = [];
        const allLeafIndices = [];
        for (const event of events) {
            for (let index = 0; index < event.outputCompressedAccounts.length; index++) {
                const hash = event.outputCompressedAccountHashes[index];
                allLeaves.push(hash);
                allLeafIndices.push(event.outputLeafIndices[index]);
            }
        }
        const tree = new MerkleTree(this.depth, this.lightWasm, allLeaves.map(leaf => bn(leaf).toString()));
        /// create merkle proofs and assemble return type
        const merkleProofs = [];
        for (let i = 0; i < hashes.length; i++) {
            const leafIndex = tree.indexOf(hashes[i].toString());
            const pathElements = tree.path(leafIndex).pathElements;
            const bnPathElements = pathElements.map(value => bn(value));
            const root = bn(tree.root());
            const merkleProof = {
                hash: hashes[i].toArray('be', 32),
                merkleTree: this.merkleTreeAddress,
                leafIndex: leafIndex,
                merkleProof: bnPathElements,
                nullifierQueue: this.nullifierQueueAddress,
                rootIndex: allLeaves.length,
                root: root,
            };
            merkleProofs.push(merkleProof);
        }
        /// Validate
        merkleProofs.forEach((proof, index) => {
            const leafIndex = proof.leafIndex;
            const computedHash = tree.elements()[leafIndex];
            const hashArr = bn(computedHash).toArray('be', 32);
            if (!hashArr.every((val, index) => val === proof.hash[index])) {
                throw new Error(`Mismatch at index ${index}: expected ${proof.hash.toString()}, got ${hashArr.toString()}`);
            }
        });
        return merkleProofs;
    }
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    async getCompressedAccountsByOwner(owner, _config) {
        // TODO(swen): revisit
        // if (_config) {
        //     throw new Error(
        //         'dataSlice or filters are not supported in test-rpc. Please use rpc.ts instead.',
        //     );
        // }
        const accounts = await getCompressedAccountsByOwnerTest(this, owner);
        return {
            items: accounts,
            cursor: null,
        };
    }
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    async getLatestCompressionSignatures(_cursor, _limit) {
        throw new Error('getLatestNonVotingSignaturesWithContext not supported in test-rpc');
    }
    /**
     * Fetch the latest non-voting signatures on the cluster. Results are
     * not paginated.
     */
    async getLatestNonVotingSignatures(_limit) {
        throw new Error('getLatestNonVotingSignaturesWithContext not supported in test-rpc');
    }
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    async getCompressedTokenAccountsByOwner(owner, options) {
        return await getCompressedTokenAccountsByOwnerTest(this, owner, options.mint);
    }
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    async getCompressedTokenAccountsByDelegate(delegate, options) {
        return await getCompressedTokenAccountsByDelegateTest(this, delegate, options.mint);
    }
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    async getCompressedTokenAccountBalance(hash) {
        const account = await getCompressedTokenAccountByHashTest(this, hash);
        return { amount: bn(account.parsed.amount) };
    }
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2}.
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint.
     */
    async getCompressedTokenBalancesByOwner(publicKey, options) {
        const accounts = await getCompressedTokenAccountsByOwnerTest(this, publicKey, options.mint);
        return {
            items: accounts.items.map(account => ({
                balance: bn(account.parsed.amount),
                mint: account.parsed.mint,
            })),
            cursor: null,
        };
    }
    /**
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Uses context.
     */
    async getCompressedTokenBalancesByOwnerV2(publicKey, options) {
        const accounts = await getCompressedTokenAccountsByOwnerTest(this, publicKey, options.mint);
        return {
            context: { slot: 1 },
            value: {
                items: accounts.items.map(account => ({
                    balance: bn(account.parsed.amount),
                    mint: account.parsed.mint,
                })),
                cursor: null,
            },
        };
    }
    /**
     * Returns confirmed signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    async getCompressionSignaturesForAccount(_hash) {
        throw new Error('getCompressionSignaturesForAccount not implemented in test-rpc');
    }
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    async getTransactionWithCompressionInfo(_signature) {
        throw new Error('getCompressedTransaction not implemented in test-rpc');
    }
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed
     * block
     *
     * @param address queried compressed account address
     */
    async getCompressionSignaturesForAddress(_address, _options) {
        throw new Error('getSignaturesForAddress3 not implemented');
    }
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    async getCompressionSignaturesForOwner(_owner, _options) {
        throw new Error('getSignaturesForOwner not implemented');
    }
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    async getCompressionSignaturesForTokenOwner(_owner, _options) {
        throw new Error('getSignaturesForTokenOwner not implemented');
    }
    /**
     * Fetch the current indexer health status
     */
    async getIndexerHealth() {
        return 'ok';
    }
    /**
     * Fetch the current slot that the node is processing
     */
    async getIndexerSlot() {
        return 1;
    }
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    async getMultipleNewAddressProofs(addresses) {
        /// Build tree
        const indexedArray = IndexedArray.default();
        const allAddresses = [];
        indexedArray.init();
        const hashes = [];
        // TODO(crank): add support for cranked address tree in 'allAddresses'.
        // The Merkle tree root doesnt actually advance beyond init() unless we
        // start emptying the address queue.
        for (let i = 0; i < allAddresses.length; i++) {
            indexedArray.append(bn(allAddresses[i]));
        }
        for (let i = 0; i < indexedArray.elements.length; i++) {
            const hash = indexedArray.hashElement(this.lightWasm, i);
            hashes.push(bn(hash));
        }
        const tree = new MerkleTree(this.depth, this.lightWasm, hashes.map(hash => bn(hash).toString()));
        /// Creates proof for each address
        const newAddressProofs = [];
        for (let i = 0; i < addresses.length; i++) {
            const [lowElement] = indexedArray.findLowElement(addresses[i]);
            if (!lowElement)
                throw new Error('Address not found');
            const leafIndex = lowElement.index;
            const pathElements = tree.path(leafIndex).pathElements;
            const bnPathElements = pathElements.map(value => bn(value));
            const higherRangeValue = indexedArray.get(lowElement.nextIndex).value;
            const root = bn(tree.root());
            const proof = {
                root,
                rootIndex: 3,
                value: addresses[i],
                leafLowerRangeValue: lowElement.value,
                leafHigherRangeValue: higherRangeValue,
                nextIndex: bn(lowElement.nextIndex),
                merkleProofHashedIndexedElementLeaf: bnPathElements,
                indexHashedIndexedElementLeaf: bn(lowElement.index),
                merkleTree: this.addressTreeAddress,
                nullifierQueue: this.addressQueueAddress,
            };
            newAddressProofs.push(proof);
        }
        return newAddressProofs;
    }
    async getCompressedMintTokenHolders(_mint, _options) {
        throw new Error('getCompressedMintTokenHolders not implemented in test-rpc');
    }
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Note: Use RPC class for forested trees. TestRpc is only for custom
     * testing purposes.
     */
    async getValidityProofDirect(hashes = [], newAddresses = []) {
        return this.getValidityProof(hashes, newAddresses);
    }
    /**
     * @deprecated This method is not available for TestRpc. Please use
     * {@link getValidityProof} instead.
     */
    async getValidityProofAndRpcContext(hashes = [], newAddresses = []) {
        if (newAddresses.some(address => !(address instanceof BN))) {
            throw new Error('AddressWithTree is not supported in test-rpc');
        }
        return {
            value: await this.getValidityProofV0(hashes, newAddresses),
            context: { slot: 1 },
        };
    }
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    async getValidityProof(hashes = [], newAddresses = []) {
        if (newAddresses.some(address => !(address instanceof BN))) {
            throw new Error('AddressWithTree is not supported in test-rpc');
        }
        let validityProof;
        if (hashes.length === 0 && newAddresses.length === 0) {
            throw new Error('Empty input. Provide hashes and/or new addresses.');
        }
        else if (hashes.length > 0 && newAddresses.length === 0) {
            /// inclusion
            const merkleProofsWithContext = await this.getMultipleCompressedAccountProofs(hashes);
            const inputs = convertMerkleProofsWithContextToHex(merkleProofsWithContext);
            const compressedProof = await proverRequest(this.proverEndpoint, 'inclusion', inputs, this.log);
            validityProof = {
                compressedProof,
                roots: merkleProofsWithContext.map(proof => proof.root),
                rootIndices: merkleProofsWithContext.map(proof => proof.rootIndex),
                leafIndices: merkleProofsWithContext.map(proof => proof.leafIndex),
                leaves: merkleProofsWithContext.map(proof => bn(proof.hash)),
                merkleTrees: merkleProofsWithContext.map(proof => proof.merkleTree),
                nullifierQueues: merkleProofsWithContext.map(proof => proof.nullifierQueue),
            };
        }
        else if (hashes.length === 0 && newAddresses.length > 0) {
            /// new-address
            const newAddressProofs = await this.getMultipleNewAddressProofs(newAddresses);
            const inputs = convertNonInclusionMerkleProofInputsToHex(newAddressProofs);
            const compressedProof = await proverRequest(this.proverEndpoint, 'new-address', inputs, this.log);
            validityProof = {
                compressedProof,
                roots: newAddressProofs.map(proof => proof.root),
                // TODO(crank): make dynamic to enable forester support in
                // test-rpc.ts. Currently this is a static root because the
                // address tree doesn't advance.
                rootIndices: newAddressProofs.map(_ => 3),
                leafIndices: newAddressProofs.map(proof => proof.indexHashedIndexedElementLeaf.toNumber()),
                leaves: newAddressProofs.map(proof => bn(proof.value)),
                merkleTrees: newAddressProofs.map(proof => proof.merkleTree),
                nullifierQueues: newAddressProofs.map(proof => proof.nullifierQueue),
            };
        }
        else if (hashes.length > 0 && newAddresses.length > 0) {
            /// combined
            const merkleProofsWithContext = await this.getMultipleCompressedAccountProofs(hashes);
            const inputs = convertMerkleProofsWithContextToHex(merkleProofsWithContext);
            const newAddressProofs = await this.getMultipleNewAddressProofs(newAddresses);
            const newAddressInputs = convertNonInclusionMerkleProofInputsToHex(newAddressProofs);
            const compressedProof = await proverRequest(this.proverEndpoint, 'combined', [inputs, newAddressInputs], this.log);
            validityProof = {
                compressedProof,
                roots: merkleProofsWithContext
                    .map(proof => proof.root)
                    .concat(newAddressProofs.map(proof => proof.root)),
                rootIndices: merkleProofsWithContext
                    .map(proof => proof.rootIndex)
                    // TODO(crank): make dynamic to enable forester support in
                    // test-rpc.ts. Currently this is a static root because the
                    // address tree doesn't advance.
                    .concat(newAddressProofs.map(_ => 3)),
                leafIndices: merkleProofsWithContext
                    .map(proof => proof.leafIndex)
                    .concat(newAddressProofs.map(proof => proof.indexHashedIndexedElementLeaf.toNumber())),
                leaves: merkleProofsWithContext
                    .map(proof => bn(proof.hash))
                    .concat(newAddressProofs.map(proof => bn(proof.value))),
                merkleTrees: merkleProofsWithContext
                    .map(proof => proof.merkleTree)
                    .concat(newAddressProofs.map(proof => proof.merkleTree)),
                nullifierQueues: merkleProofsWithContext
                    .map(proof => proof.nullifierQueue)
                    .concat(newAddressProofs.map(proof => proof.nullifierQueue)),
            };
        }
        else
            throw new Error('Invalid input');
        return validityProof;
    }
    async getValidityProofV0(hashes = [], newAddresses = []) {
        /// TODO(swen): add support for custom trees
        return this.getValidityProof(hashes.map(hash => hash.hash), newAddresses.map(address => address.address));
    }
}

export { ADDRESS_QUEUE_ROLLOVER_FEE, ADDRESS_TREE_NETWORK_FEE, ALICE, IDL$2 as AccountCompressionIDL, AccountProofResult, BOB, BalanceResult, CHARLIE, CompressedAccountResult, CompressedAccountsByOwnerResult, CompressedMintTokenHoldersResult, CompressedTokenAccountResult, CompressedTokenAccountsByOwnerOrDelegateResult, CompressedTransactionResult, CreateUtxoError, CreateUtxoErrorCode, DAVE, DEFAULT_MERKLE_TREE_HEIGHT, DEFAULT_MERKLE_TREE_ROOTS, DEFAULT_ZERO, FIELD_SIZE, HIGHEST_ADDRESS_PLUS_ONE, HashError, HashErrorCode, HealthResult, IndexedArray, IndexedElement, IndexedElementBundle, LatestNonVotingSignaturesResult, LatestNonVotingSignaturesResultPaginated, IDL as LightCompressedTokenIDL, IDL$1 as LightRegistryIDL, IDL$3 as LightSystemIDL, LightSystemProgram, LookupTableError, LookupTableErrorCode, MerkeProofResult, MerkleTree, MerkleTreeError, MerkleTreeErrorCode, MultipleCompressedAccountsResult, MultipleMerkleProofsResult, NativeBalanceResult, NewAddressProofResult, ProofError, ProofErrorCode, Rpc, RpcError, RpcErrorCode, STATE_MERKLE_TREE_NETWORK_FEE, STATE_MERKLE_TREE_ROLLOVER_FEE, SelectInUtxosError, SelectInUtxosErrorCode, SignatureListResult, SignatureListWithCursorResult, SlotResult, TRANSACTION_MERKLE_TREE_ROLLOVER_THRESHOLD, TestRpc, TokenBalanceListResult, TokenBalanceListResultV2, TokenBalanceResult, TokenDataResult, UTXO_MERGE_MAXIMUM, UTXO_MERGE_THRESHOLD, UtilsError, UtilsErrorCode, UtxoError, UtxoErrorCode, ValidityProofResult, accountCompressionProgram, addressQueue, addressTree, airdropSol, bn, bufToDecStr, buildAndSignTx, buildTx, byteArrayToKeypair, calculateComputeUnitPrice, checkValidityProofShape, compress, confirmConfig, confirmTransaction, confirmTx, convertMerkleProofsWithContextToHex, convertNonInclusionMerkleProofInputsToHex, createAccount, createAccountWithLamports, createBN254, createCompressedAccount, createCompressedAccountWithMerkleContext, createMerkleContext, createRpc, createRpcResult, decompress, dedupeSigner, defaultStaticAccounts, defaultStaticAccountsStruct, defaultTestStateTreeAccounts, deriveAddress, deriveAddressSeed, encodeBN254toBase58, getAccountCompressionAuthority, getCompressedTokenAccountByHashTest, getCompressedTokenAccounts, getCompressedTokenAccountsByDelegateTest, getCompressedTokenAccountsByOwnerTest, getConnection, getIndexOrAdd, getParsedEvents, getRegisteredProgramPda, getTestKeypair, getTestRpc, hashToBn254FieldSizeBe, hashvToBn254FieldSizeBe, jsonRpcResult, jsonRpcResultAndContext, lightProgram, merkletreePubkey, negateAndCompressProof, newAccountWithLamports, noopProgram, nullifierQueuePubkey, packCompressedAccounts, packNewAddressParams, padOutputStateMerkleTrees, parseAccountData, parseEvents, parsePublicTransactionEventWithIdl, parseTokenLayoutWithIdl, pipe, placeholderValidityProof, proofFromJsonStruct, proverRequest, pushUniqueItems, rpcRequest, selectMinCompressedSolAccountsForTransfer, sendAndConfirmTx, sleep, sumUpLamports, toAccountMetas, toArray, toCamelCase, toHex$1 as toHex, toUnixTimestamp, transfer, useWallet, validateSameOwner, validateSufficientBalance };
//# sourceMappingURL=index.js.map
