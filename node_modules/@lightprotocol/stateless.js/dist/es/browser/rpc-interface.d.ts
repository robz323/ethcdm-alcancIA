import { PublicKey, MemcmpFilter, DataSlice } from '@solana/web3.js';
import { Struct } from 'superstruct';
import { BN254, CompressedProof, CompressedAccountWithMerkleContext, MerkleContextWithMerkleProof, TokenData } from './state';
import { BN } from '@coral-xyz/anchor';
export interface LatestNonVotingSignatures {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
            error: string | null;
        }[];
    };
}
export interface GetCompressedAccountsByOwnerConfig {
    filters?: GetCompressedAccountsFilter[];
    dataSlice?: DataSlice;
    cursor?: string;
    limit?: BN;
}
export interface CompressedMintTokenHolders {
    balance: BN;
    owner: PublicKey;
}
export interface LatestNonVotingSignaturesPaginated {
    context: {
        slot: number;
    };
    value: {
        items: {
            signature: string;
            slot: number;
            blockTime: number;
        }[];
        cursor: string | null;
    };
}
export interface SignatureWithMetadata {
    blockTime: number;
    signature: string;
    slot: number;
}
export interface HashWithTree {
    hash: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
export interface AddressWithTree {
    address: BN254;
    tree: PublicKey;
    queue: PublicKey;
}
export interface CompressedTransaction {
    compressionInfo: {
        closedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData | null;
        }[];
        openedAccounts: {
            account: CompressedAccountWithMerkleContext;
            maybeTokenData: TokenData | null;
        }[];
        preTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
        postTokenBalances?: {
            owner: PublicKey;
            mint: PublicKey;
            amount: BN;
        }[];
    };
    transaction: any;
}
export interface HexBatchInputsForProver {
    'input-compressed-accounts': HexInputsForProver[];
}
export interface HexInputsForProver {
    root: string;
    pathIndex: number;
    pathElements: string[];
    leaf: string;
}
export type CompressedProofWithContext = {
    compressedProof: CompressedProof;
    roots: BN[];
    rootIndices: number[];
    leafIndices: number[];
    leaves: BN[];
    merkleTrees: PublicKey[];
    nullifierQueues: PublicKey[];
};
export interface GetCompressedTokenAccountsByOwnerOrDelegateOptions {
    mint?: PublicKey;
    cursor?: string;
    limit?: BN;
}
export type TokenBalance = {
    balance: BN;
    mint: PublicKey;
};
/**
 * **Cursor** is a unique identifier for a page of results by which the next page can be fetched.
 *
 * **Limit** is the maximum number of results to return per page.
 */
export interface PaginatedOptions {
    cursor?: string;
    limit?: BN;
}
/**
 * Note, DataSizeFilter is currently not available.
 */
export type GetCompressedAccountsFilter = MemcmpFilter;
export type GetCompressedAccountConfig = {
    encoding?: string;
};
export type GetCompressedAccountsConfig = {
    dataSlice: DataSlice;
    filters?: GetCompressedAccountsFilter[];
};
export interface ParsedTokenAccount {
    compressedAccount: CompressedAccountWithMerkleContext;
    parsed: TokenData;
}
export type WithContext<T> = {
    /** context */
    context: {
        slot: number;
    };
    /** response value */
    value: T;
};
export type WithCursor<T> = {
    /** context */
    cursor: string | null;
    /** response value */
    items: T;
};
/**
 * @internal
 */
export declare function createRpcResult<T, U>(result: Struct<T, U>): Struct<RpcResult<T>, null>;
/**
 * @internal
 */
export declare function jsonRpcResult<T, U>(schema: Struct<T, U>): Struct<RpcResult<T>, null>;
export type WithRpcContext<T> = {
    context: {
        slot: number;
    };
    value: T;
};
/**
 * @internal
 */
export declare function jsonRpcResultAndContext<T, U>(value: Struct<T, U>): Struct<RpcResult<WithRpcContext<T>>, null>;
/**
 * @internal
 */
export declare const CompressedAccountResult: Struct<{
    data: {
        data: string;
        discriminator: BN;
        dataHash: BN;
    } | null;
    owner: PublicKey;
    lamports: BN;
    address: number[] | null;
    leafIndex: number;
    seq: BN | null;
    hash: BN;
    tree: PublicKey;
    slotCreated: BN;
}, {
    address: Struct<number[] | null, null>;
    hash: Struct<BN, null>;
    data: Struct<{
        data: string;
        discriminator: BN;
        dataHash: BN;
    } | null, {
        data: Struct<string, null>;
        dataHash: Struct<BN, null>;
        discriminator: Struct<BN, null>;
    }>;
    lamports: Struct<BN, null>;
    owner: Struct<PublicKey, null>;
    leafIndex: Struct<number, null>;
    tree: Struct<PublicKey, null>;
    seq: Struct<BN | null, null>;
    slotCreated: Struct<BN, null>;
}>;
export declare const TokenDataResult: Struct<{
    mint: PublicKey;
    owner: PublicKey;
    state: string;
    amount: BN;
    delegate: PublicKey | null;
}, {
    mint: Struct<PublicKey, null>;
    owner: Struct<PublicKey, null>;
    amount: Struct<BN, null>;
    delegate: Struct<PublicKey | null, null>;
    state: Struct<string, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountResult: Struct<{
    account: {
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    };
    tokenData: {
        mint: PublicKey;
        owner: PublicKey;
        state: string;
        amount: BN;
        delegate: PublicKey | null;
    };
}, {
    tokenData: Struct<{
        mint: PublicKey;
        owner: PublicKey;
        state: string;
        amount: BN;
        delegate: PublicKey | null;
    }, {
        mint: Struct<PublicKey, null>;
        owner: Struct<PublicKey, null>;
        amount: Struct<BN, null>;
        delegate: Struct<PublicKey | null, null>;
        state: Struct<string, null>;
    }>;
    account: Struct<{
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>;
}>;
/**
 * @internal
 */
export declare const MultipleCompressedAccountsResult: Struct<{
    items: {
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[];
}, {
    items: Struct<{
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[], Struct<{
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
}>;
/**
 * @internal
 */
export declare const CompressedAccountsByOwnerResult: Struct<{
    items: {
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }[], Struct<{
        data: {
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null;
        owner: PublicKey;
        lamports: BN;
        address: number[] | null;
        leafIndex: number;
        seq: BN | null;
        hash: BN;
        tree: PublicKey;
        slotCreated: BN;
    }, {
        address: Struct<number[] | null, null>;
        hash: Struct<BN, null>;
        data: Struct<{
            data: string;
            discriminator: BN;
            dataHash: BN;
        } | null, {
            data: Struct<string, null>;
            dataHash: Struct<BN, null>;
            discriminator: Struct<BN, null>;
        }>;
        lamports: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
        leafIndex: Struct<number, null>;
        tree: Struct<PublicKey, null>;
        seq: Struct<BN | null, null>;
        slotCreated: Struct<BN, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const CompressedTokenAccountsByOwnerOrDelegateResult: Struct<{
    items: {
        account: {
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
        tokenData: {
            mint: PublicKey;
            owner: PublicKey;
            state: string;
            amount: BN;
            delegate: PublicKey | null;
        };
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        account: {
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
        tokenData: {
            mint: PublicKey;
            owner: PublicKey;
            state: string;
            amount: BN;
            delegate: PublicKey | null;
        };
    }[], Struct<{
        account: {
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        };
        tokenData: {
            mint: PublicKey;
            owner: PublicKey;
            state: string;
            amount: BN;
            delegate: PublicKey | null;
        };
    }, {
        tokenData: Struct<{
            mint: PublicKey;
            owner: PublicKey;
            state: string;
            amount: BN;
            delegate: PublicKey | null;
        }, {
            mint: Struct<PublicKey, null>;
            owner: Struct<PublicKey, null>;
            amount: Struct<BN, null>;
            delegate: Struct<PublicKey | null, null>;
            state: Struct<string, null>;
        }>;
        account: Struct<{
            data: {
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null;
            owner: PublicKey;
            lamports: BN;
            address: number[] | null;
            leafIndex: number;
            seq: BN | null;
            hash: BN;
            tree: PublicKey;
            slotCreated: BN;
        }, {
            address: Struct<number[] | null, null>;
            hash: Struct<BN, null>;
            data: Struct<{
                data: string;
                discriminator: BN;
                dataHash: BN;
            } | null, {
                data: Struct<string, null>;
                dataHash: Struct<BN, null>;
                discriminator: Struct<BN, null>;
            }>;
            lamports: Struct<BN, null>;
            owner: Struct<PublicKey, null>;
            leafIndex: Struct<number, null>;
            tree: Struct<PublicKey, null>;
            seq: Struct<BN | null, null>;
            slotCreated: Struct<BN, null>;
        }>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const SlotResult: Struct<number, null>;
/**
 * @internal
 */
export declare const HealthResult: Struct<string, null>;
/**
 * @internal
 */
export declare const LatestNonVotingSignaturesResult: Struct<{
    items: {
        blockTime: number;
        signature: string;
        error: string | null;
        slot: number;
    }[];
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        error: string | null;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        error: string | null;
        slot: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
        error: Struct<string | null, null>;
    }>>;
}>;
/**
 * @internal
 */
export declare const LatestNonVotingSignaturesResultPaginated: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        signature: Struct<string, null>;
        slot: Struct<number, null>;
        blockTime: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
/**
 * @internal
 */
export declare const MerkeProofResult: Struct<{
    root: BN;
    proof: BN[];
    leafIndex: number;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>;
/**
 * @internal
 */
export declare const NewAddressProofResult: Struct<{
    root: BN;
    proof: BN[];
    address: BN;
    merkleTree: PublicKey;
    rootSeq: number;
    nextIndex: number;
    lowerRangeAddress: BN;
    higherRangeAddress: BN;
    lowElementLeafIndex: number;
}, {
    address: Struct<BN, null>;
    nextIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
    lowerRangeAddress: Struct<BN, null>;
    higherRangeAddress: Struct<BN, null>;
    lowElementLeafIndex: Struct<number, null>;
}>;
/**
 * @internal
 */
export declare const ValidityProofResult: Struct<{
    compressedProof: {
        a: number[];
        b: number[];
        c: number[];
    };
    leafIndices: number[];
    leaves: BN[];
    rootIndices: number[];
    roots: BN[];
    merkleTrees: PublicKey[];
}, {
    compressedProof: Struct<{
        a: number[];
        b: number[];
        c: number[];
    }, {
        a: Struct<number[], Struct<number, null>>;
        b: Struct<number[], Struct<number, null>>;
        c: Struct<number[], Struct<number, null>>;
    }>;
    leafIndices: Struct<number[], Struct<number, null>>;
    leaves: Struct<BN[], Struct<BN, null>>;
    rootIndices: Struct<number[], Struct<number, null>>;
    roots: Struct<BN[], Struct<BN, null>>;
    merkleTrees: Struct<PublicKey[], Struct<PublicKey, null>>;
}>;
/**
 * @internal
 */
export declare const MultipleMerkleProofsResult: Struct<{
    root: BN;
    proof: BN[];
    leafIndex: number;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}[], Struct<{
    root: BN;
    proof: BN[];
    leafIndex: number;
    hash: BN;
    merkleTree: PublicKey;
    rootSeq: number;
}, {
    hash: Struct<BN, null>;
    leafIndex: Struct<number, null>;
    merkleTree: Struct<PublicKey, null>;
    proof: Struct<BN[], Struct<BN, null>>;
    rootSeq: Struct<number, null>;
    root: Struct<BN, null>;
}>>;
/**
 * @internal
 */
export declare const BalanceResult: Struct<{
    amount: BN;
}, {
    amount: Struct<BN, null>;
}>;
export declare const NativeBalanceResult: Struct<BN, null>;
export declare const TokenBalanceResult: Struct<{
    mint: PublicKey;
    balance: BN;
}, {
    balance: Struct<BN, null>;
    mint: Struct<PublicKey, null>;
}>;
export declare const TokenBalanceListResult: Struct<{
    cursor: string | null;
    tokenBalances: {
        mint: PublicKey;
        balance: BN;
    }[];
}, {
    tokenBalances: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
export declare const TokenBalanceListResultV2: Struct<{
    items: {
        mint: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        mint: PublicKey;
        balance: BN;
    }[], Struct<{
        mint: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        mint: Struct<PublicKey, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
export declare const CompressedMintTokenHoldersResult: Struct<{
    items: {
        owner: PublicKey;
        balance: BN;
    }[];
    cursor: string | null;
}, {
    cursor: Struct<string | null, null>;
    items: Struct<{
        owner: PublicKey;
        balance: BN;
    }[], Struct<{
        owner: PublicKey;
        balance: BN;
    }, {
        balance: Struct<BN, null>;
        owner: Struct<PublicKey, null>;
    }>>;
}>;
export declare const AccountProofResult: Struct<{
    root: number[];
    proof: number[][];
    hash: number[];
}, {
    hash: Struct<number[], Struct<number, null>>;
    root: Struct<number[], Struct<number, null>>;
    proof: Struct<number[][], Struct<number[], Struct<number, null>>>;
}>;
export declare const toUnixTimestamp: (blockTime: string) => number;
export declare const SignatureListResult: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
}>;
export declare const SignatureListWithCursorResult: Struct<{
    items: {
        blockTime: number;
        signature: string;
        slot: number;
    }[];
    cursor: string | null;
}, {
    items: Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }[], Struct<{
        blockTime: number;
        signature: string;
        slot: number;
    }, {
        blockTime: Struct<number, null>;
        signature: Struct<string, null>;
        slot: Struct<number, null>;
    }>>;
    cursor: Struct<string | null, null>;
}>;
export declare const CompressedTransactionResult: Struct<{
    compressionInfo: {
        closedAccounts: {
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[];
    };
    transaction?: any;
}, {
    compressionInfo: Struct<{
        closedAccounts: {
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[];
        openedAccounts: {
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[];
    }, {
        closedAccounts: Struct<{
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[], Struct<{
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }, {
            account: Struct<{
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
        openedAccounts: Struct<{
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }[], Struct<{
            account: {
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            };
            optionalTokenData: {
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null;
        }, {
            account: Struct<{
                data: {
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null;
                owner: PublicKey;
                lamports: BN;
                address: number[] | null;
                leafIndex: number;
                seq: BN | null;
                hash: BN;
                tree: PublicKey;
                slotCreated: BN;
            }, {
                address: Struct<number[] | null, null>;
                hash: Struct<BN, null>;
                data: Struct<{
                    data: string;
                    discriminator: BN;
                    dataHash: BN;
                } | null, {
                    data: Struct<string, null>;
                    dataHash: Struct<BN, null>;
                    discriminator: Struct<BN, null>;
                }>;
                lamports: Struct<BN, null>;
                owner: Struct<PublicKey, null>;
                leafIndex: Struct<number, null>;
                tree: Struct<PublicKey, null>;
                seq: Struct<BN | null, null>;
                slotCreated: Struct<BN, null>;
            }>;
            optionalTokenData: Struct<{
                mint: PublicKey;
                owner: PublicKey;
                state: string;
                amount: BN;
                delegate: PublicKey | null;
            } | null, {
                mint: Struct<PublicKey, null>;
                owner: Struct<PublicKey, null>;
                amount: Struct<BN, null>;
                delegate: Struct<PublicKey | null, null>;
                state: Struct<string, null>;
            }>;
        }>>;
    }>;
    transaction: Struct<any, null>;
}>;
export interface CompressionApiInterface {
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN | null>;
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    getValidityProof(hashes: BN254[], newAddresses: BN254[]): Promise<CompressedProofWithContext>;
    getValidityProofV0(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<CompressedProofWithContext>;
    getValidityProofAndRpcContext(hashes: HashWithTree[], newAddresses: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    getCompressedTokenAccountsByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    getCompressedTokenBalancesByOwner(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    getCompressedTokenBalancesByOwnerV2(publicKey: PublicKey, options: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    getIndexerHealth(): Promise<string>;
    getIndexerSlot(): Promise<number>;
}
export type RpcResultSuccess<T> = {
    jsonrpc: '2.0';
    id: string;
    result: T;
};
export type RpcResultError = {
    jsonrpc: '2.0';
    id: string;
    error: {
        code: unknown;
        message: string;
        data?: any;
    };
};
export type RpcResult<T> = RpcResultSuccess<T> | RpcResultError;
