import { Connection, ConnectionConfig, PublicKey } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { CompressedProofWithContext, CompressedTransaction, CompressionApiInterface, GetCompressedTokenAccountsByOwnerOrDelegateOptions, HexInputsForProver, ParsedTokenAccount, SignatureWithMetadata, LatestNonVotingSignatures, LatestNonVotingSignaturesPaginated, WithContext, GetCompressedAccountsByOwnerConfig, WithCursor, AddressWithTree, HashWithTree, CompressedMintTokenHolders, TokenBalance, PaginatedOptions } from './rpc-interface';
import { MerkleContextWithMerkleProof, BN254, CompressedAccountWithMerkleContext, CompressedProof } from './state';
import { BN } from '@coral-xyz/anchor';
/** @internal */
export declare function parseAccountData({ discriminator, data, dataHash, }: {
    discriminator: BN;
    data: string;
    dataHash: BN;
}): {
    discriminator: number[];
    data: Buffer;
    dataHash: number[];
};
/**
 * Establish a Compression-compatible JSON RPC connection
 *
 * @param endpointOrWeb3JsConnection    endpoint to the solana cluster or
 *                                      Connection object
 * @param compressionApiEndpoint        Endpoint to the compression server
 * @param proverEndpoint                Endpoint to the prover server. defaults
 *                                      to endpoint
 * @param connectionConfig              Optional connection config
 */
export declare function createRpc(endpointOrWeb3JsConnection?: string | Connection, compressionApiEndpoint?: string, proverEndpoint?: string, config?: ConnectionConfig): Rpc;
/** @internal */
export declare const rpcRequest: (rpcEndpoint: string, method: string, params?: any, convertToCamelCase?: boolean, debug?: boolean) => Promise<any>;
/** @internal */
export declare const proverRequest: (proverEndpoint: string, method: "inclusion" | "new-address" | "combined", params?: any, log?: boolean) => Promise<CompressedProof>;
export type NonInclusionMerkleProofInputs = {
    root: BN;
    value: BN;
    leaf_lower_range_value: BN;
    leaf_higher_range_value: BN;
    nextIndex: BN;
    merkle_proof_hashed_indexed_element_leaf: BN[];
    index_hashed_indexed_element_leaf: BN;
};
export type MerkleContextWithNewAddressProof = {
    root: BN;
    rootIndex: number;
    value: BN;
    leafLowerRangeValue: BN;
    leafHigherRangeValue: BN;
    nextIndex: BN;
    merkleProofHashedIndexedElementLeaf: BN[];
    indexHashedIndexedElementLeaf: BN;
    merkleTree: PublicKey;
    nullifierQueue: PublicKey;
};
export type NonInclusionJsonStruct = {
    root: string;
    value: string;
    pathIndex: number;
    pathElements: string[];
    leafLowerRangeValue: string;
    leafHigherRangeValue: string;
    nextIndex: number;
};
export declare function convertMerkleProofsWithContextToHex(merkleProofsWithContext: MerkleContextWithMerkleProof[]): HexInputsForProver[];
export declare function convertNonInclusionMerkleProofInputsToHex(nonInclusionMerkleProofInputs: MerkleContextWithNewAddressProof[]): NonInclusionJsonStruct[];
/**
 *
 */
export declare class Rpc extends Connection implements CompressionApiInterface {
    compressionApiEndpoint: string;
    proverEndpoint: string;
    /**
     * Establish a Compression-compatible JSON RPC connection
     *
     * @param endpoint                      Endpoint to the solana cluster
     * @param compressionApiEndpoint        Endpoint to the compression server
     * @param proverEndpoint                Endpoint to the prover server.
     * @param connectionConfig              Optional connection config
     */
    constructor(endpoint: string, compressionApiEndpoint: string, proverEndpoint: string, config?: ConnectionConfig);
    /**
     * Fetch the compressed account for the specified account address or hash
     */
    getCompressedAccount(address?: BN254, hash?: BN254): Promise<CompressedAccountWithMerkleContext | null>;
    /**
     * Fetch the compressed balance for the specified account address or hash
     */
    getCompressedBalance(address?: BN254, hash?: BN254): Promise<BN>;
    /**
     * Fetch the total compressed balance for the specified owner public key
     */
    getCompressedBalanceByOwner(owner: PublicKey): Promise<BN>;
    /**
     * Fetch the latest merkle proof for the specified account hash from the
     * cluster
     */
    getCompressedAccountProof(hash: BN254): Promise<MerkleContextWithMerkleProof>;
    /**
     * Fetch all the account info for multiple compressed accounts specified by
     * an array of account hashes
     */
    getMultipleCompressedAccounts(hashes: BN254[]): Promise<CompressedAccountWithMerkleContext[]>;
    /**
     * Fetch the latest merkle proofs for multiple compressed accounts specified
     * by an array account hashes
     */
    getMultipleCompressedAccountProofs(hashes: BN254[]): Promise<MerkleContextWithMerkleProof[]>;
    /**
     * Fetch all the compressed accounts owned by the specified public key.
     * Owner can be a program or user account
     */
    getCompressedAccountsByOwner(owner: PublicKey, config?: GetCompressedAccountsByOwnerConfig | undefined): Promise<WithCursor<CompressedAccountWithMerkleContext[]>>;
    /**
     * Fetch all the compressed token accounts owned by the specified public
     * key. Owner can be a program or user account
     */
    getCompressedTokenAccountsByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch all the compressed accounts delegated to the specified public key.
     */
    getCompressedTokenAccountsByDelegate(delegate: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<ParsedTokenAccount[]>>;
    /**
     * Fetch the compressed token balance for the specified account hash
     */
    getCompressedTokenAccountBalance(hash: BN254): Promise<{
        amount: BN;
    }>;
    /**
     * @deprecated use {@link getCompressedTokenBalancesByOwnerV2} instead.
     *
     * Fetch all the compressed token balances owned by the specified public
     * key. Can filter by mint. Returns without context.
     */
    getCompressedTokenBalancesByOwner(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithCursor<TokenBalance[]>>;
    /**
     * Fetch the compressed token balances owned by the specified public
     * key. Paginated. Can filter by mint. Returns with context.
     */
    getCompressedTokenBalancesByOwnerV2(owner: PublicKey, options?: GetCompressedTokenAccountsByOwnerOrDelegateOptions): Promise<WithContext<WithCursor<TokenBalance[]>>>;
    /**
     * Returns confirmed compression signatures for transactions involving the specified
     * account hash forward in time from genesis to the most recent confirmed
     * block
     *
     * @param hash queried account hash
     */
    getCompressionSignaturesForAccount(hash: BN254): Promise<SignatureWithMetadata[]>;
    /**
     * Fetch a confirmed or finalized transaction from the cluster. Return with
     * CompressionInfo
     */
    getTransactionWithCompressionInfo(signature: string): Promise<CompressedTransaction | null>;
    /**
     * Returns confirmed signatures for transactions involving the specified
     * address forward in time from genesis to the most recent confirmed block
     *
     * @param address queried compressed account address
     */
    getCompressionSignaturesForAddress(address: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified account owner forward in time from genesis to the
     * most recent confirmed block
     *
     * @param owner queried owner public key
     */
    getCompressionSignaturesForOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Returns confirmed signatures for compression transactions involving the
     * specified token account owner forward in time from genesis to the most
     * recent confirmed block
     */
    getCompressionSignaturesForTokenOwner(owner: PublicKey, options?: PaginatedOptions): Promise<WithCursor<SignatureWithMetadata[]>>;
    /**
     * Fetch the current indexer health status
     */
    getIndexerHealth(): Promise<string>;
    /**
     * Ensure that the Compression Indexer has already indexed the transaction
     */
    confirmTransactionIndexed(slot: number): Promise<boolean>;
    /**
     * Fetch the current slot that the node is processing
     */
    getIndexerSlot(): Promise<number>;
    /**
     * Fetch all the compressed token holders for a given mint. Paginated.
     */
    getCompressedMintTokenHolders(mint: PublicKey, options?: PaginatedOptions): Promise<WithContext<WithCursor<CompressedMintTokenHolders[]>>>;
    /**
     * Fetch the latest compression signatures on the cluster. Results are
     * paginated.
     */
    getLatestCompressionSignatures(cursor?: string, limit?: number): Promise<LatestNonVotingSignaturesPaginated>;
    /**
     * Fetch all non-voting signatures
     */
    getLatestNonVotingSignatures(limit?: number, cursor?: string): Promise<LatestNonVotingSignatures>;
    /**
     * Fetch the latest address proofs for new unique addresses specified by an
     * array of addresses.
     *
     * the proof states that said address have not yet been created in
     * respective address tree.
     * @param addresses Array of BN254 new addresses
     * @returns Array of validity proofs for new addresses
     */
    getMultipleNewAddressProofs(addresses: BN254[]): Promise<MerkleContextWithNewAddressProof[]>;
    /**
     * Advanced usage of getValidityProof: fetches ZKP directly from a custom
     * non-rpcprover. Note: This uses the proverEndpoint specified in the
     * constructor. For normal usage, please use {@link getValidityProof}
     * instead.
     *
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProofDirect(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses.
     * @returns             validity proof with context
     */
    getValidityProof(hashes?: BN254[], newAddresses?: BN254[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of { hash: BN254, tree: PublicKey, queue: PublicKey }.
     * @param newAddresses  Array of { address: BN254, tree: PublicKey, queue: PublicKey }.
     * @returns             validity proof with context
     */
    getValidityProofV0(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<CompressedProofWithContext>;
    /**
     * Fetch the latest validity proof for (1) compressed accounts specified by
     * an array of account hashes. (2) new unique addresses specified by an
     * array of addresses. Returns with context slot.
     *
     * Validity proofs prove the presence of compressed accounts in state trees
     * and the non-existence of addresses in address trees, respectively. They
     * enable verification without recomputing the merkle proof path, thus
     * lowering verification and data costs.
     *
     * @param hashes        Array of BN254 hashes.
     * @param newAddresses  Array of BN254 new addresses. Optionally specify the
     *                      tree and queue for each address. Default to public
     *                      state tree/queue.
     * @returns             validity proof with context
     */
    getValidityProofAndRpcContext(hashes?: HashWithTree[], newAddresses?: AddressWithTree[]): Promise<WithContext<CompressedProofWithContext>>;
}
