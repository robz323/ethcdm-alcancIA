import { CompressedProof, ParsedTokenAccount, TokenTransferOutputData as TokenTransferOutputData$1, InputTokenDataWithContext as InputTokenDataWithContext$1, Rpc } from '@lightprotocol/stateless.js';
import { PublicKey, AccountMeta, TransactionInstruction, Connection, Signer, ConfirmOptions, TransactionSignature, Keypair } from '@solana/web3.js';
import { BN, Program } from '@coral-xyz/anchor';

type LightCompressedToken = {
    version: '1.2.0';
    name: 'light_compressed_token';
    instructions: [
        {
            name: 'createTokenPool';
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [];
        },
        {
            name: 'mintTo';
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['programs'];
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'merkleTree';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'solPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                }
            ];
            args: [
                {
                    name: 'publicKeys';
                    type: {
                        vec: 'publicKey';
                    };
                },
                {
                    name: 'amounts';
                    type: {
                        vec: 'u64';
                    };
                },
                {
                    name: 'lamports';
                    type: {
                        option: 'u64';
                    };
                }
            ];
        },
        {
            name: 'compressSplTokenAccount';
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'owner';
                    type: 'publicKey';
                },
                {
                    name: 'remainingAmount';
                    type: {
                        option: 'u64';
                    };
                },
                {
                    name: 'cpiContext';
                    type: {
                        option: {
                            defined: 'CompressedCpiContext';
                        };
                    };
                }
            ];
        },
        {
            name: 'transfer';
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'approve';
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'revoke';
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'freeze';
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'thaw';
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['that this program is the signer of the cpi.'];
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'burn';
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'mint';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs';
                    type: 'bytes';
                }
            ];
        },
        {
            name: 'stubIdlBuild';
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.'
            ];
            accounts: [
                {
                    name: 'feePayer';
                    isMut: true;
                    isSigner: true;
                    docs: ['UNCHECKED: only pays fees.'];
                },
                {
                    name: 'authority';
                    isMut: false;
                    isSigner: true;
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.'
                    ];
                },
                {
                    name: 'cpiAuthorityPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'lightSystemProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'registeredProgramPda';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'noopProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionAuthority';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'accountCompressionProgram';
                    isMut: false;
                    isSigner: false;
                },
                {
                    name: 'selfProgram';
                    isMut: false;
                    isSigner: false;
                    docs: ['this program is the signer of the cpi.'];
                },
                {
                    name: 'tokenPoolPda';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'compressOrDecompressTokenAccount';
                    isMut: true;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'tokenProgram';
                    isMut: false;
                    isSigner: false;
                    isOptional: true;
                },
                {
                    name: 'systemProgram';
                    isMut: false;
                    isSigner: false;
                }
            ];
            args: [
                {
                    name: 'inputs1';
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer';
                    };
                },
                {
                    name: 'inputs2';
                    type: {
                        defined: 'TokenData';
                    };
                }
            ];
        }
    ];
    types: [
        {
            name: 'AccessMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        docs: ['Owner of the Merkle tree.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'programOwner';
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.'
                        ];
                        type: 'publicKey';
                    },
                    {
                        name: 'forester';
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.'
                        ];
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'AccountState';
            type: {
                kind: 'enum';
                variants: [
                    {
                        name: 'Initialized';
                    },
                    {
                        name: 'Frozen';
                    }
                ];
            };
        },
        {
            name: 'CompressedAccount';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'lamports';
                        type: 'u64';
                    },
                    {
                        name: 'address';
                        type: {
                            option: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'data';
                        type: {
                            option: {
                                defined: 'CompressedAccountData';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedAccountData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'discriminator';
                        type: {
                            array: ['u8', 8];
                        };
                    },
                    {
                        name: 'data';
                        type: 'bytes';
                    },
                    {
                        name: 'dataHash';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedCpiContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'setContext';
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'firstSetContext';
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.'
                        ];
                        type: 'bool';
                    },
                    {
                        name: 'cpiContextAccountIndex';
                        docs: [
                            'Index of cpi context account in remaining accounts.'
                        ];
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'CompressedProof';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'a';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'b';
                        type: {
                            array: ['u8', 64];
                        };
                    },
                    {
                        name: 'c';
                        type: {
                            array: ['u8', 32];
                        };
                    }
                ];
            };
        },
        {
            name: 'CompressedTokenInstructionDataTransfer';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'mint';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegatedTransfer';
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.'
                        ];
                        type: {
                            option: {
                                defined: 'DelegatedTransfer';
                            };
                        };
                    },
                    {
                        name: 'inputTokenDataWithContext';
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData';
                            };
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressAmount';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex';
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'DelegatedTransfer';
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.'
            ];
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'delegateChangeAccountIndex';
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.'
                        ];
                        type: {
                            option: 'u8';
                        };
                    }
                ];
            };
        },
        {
            name: 'InputTokenDataWithContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'delegateIndex';
                        type: {
                            option: 'u8';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        type: 'u16';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvoke';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'InstructionDataInvokeCpi';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'proof';
                        type: {
                            option: {
                                defined: 'CompressedProof';
                            };
                        };
                    },
                    {
                        name: 'newAddressParams';
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked';
                            };
                        };
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext';
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext';
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'cpiContext';
                        type: {
                            option: {
                                defined: 'CompressedCpiContext';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'accessMetadata';
                        type: {
                            defined: 'AccessMetadata';
                        };
                    },
                    {
                        name: 'rolloverMetadata';
                        type: {
                            defined: 'RolloverMetadata';
                        };
                    },
                    {
                        name: 'associatedQueue';
                        type: 'publicKey';
                    },
                    {
                        name: 'nextMerkleTree';
                        type: 'publicKey';
                    }
                ];
            };
        },
        {
            name: 'MerkleTreeSequenceNumber';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'pubkey';
                        type: 'publicKey';
                    },
                    {
                        name: 'seq';
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'NewAddressParamsPacked';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'seed';
                        type: {
                            array: ['u8', 32];
                        };
                    },
                    {
                        name: 'addressQueueAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex';
                        type: 'u8';
                    },
                    {
                        name: 'addressMerkleTreeRootIndex';
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'OutputCompressedAccountWithPackedContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    }
                ];
            };
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'compressedAccount';
                        type: {
                            defined: 'CompressedAccount';
                        };
                    },
                    {
                        name: 'merkleContext';
                        type: {
                            defined: 'PackedMerkleContext';
                        };
                    },
                    {
                        name: 'rootIndex';
                        docs: [
                            'Index of root used in inclusion validity proof.'
                        ];
                        type: 'u16';
                    },
                    {
                        name: 'readOnly';
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.'
                        ];
                        type: 'bool';
                    }
                ];
            };
        },
        {
            name: 'PackedMerkleContext';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex';
                        type: 'u8';
                    },
                    {
                        name: 'leafIndex';
                        type: 'u32';
                    },
                    {
                        name: 'queueIndex';
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.'
                        ];
                        type: {
                            option: {
                                defined: 'QueueIndex';
                            };
                        };
                    }
                ];
            };
        },
        {
            name: 'PackedTokenTransferOutputData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'owner';
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        type: 'u64';
                    },
                    {
                        name: 'lamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'merkleTreeIndex';
                        type: 'u8';
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'PublicTransactionEvent';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'inputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccountHashes';
                        type: {
                            vec: {
                                array: ['u8', 32];
                            };
                        };
                    },
                    {
                        name: 'outputCompressedAccounts';
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext';
                            };
                        };
                    },
                    {
                        name: 'outputLeafIndices';
                        type: {
                            vec: 'u32';
                        };
                    },
                    {
                        name: 'sequenceNumbers';
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber';
                            };
                        };
                    },
                    {
                        name: 'relayFee';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'isCompress';
                        type: 'bool';
                    },
                    {
                        name: 'compressOrDecompressLamports';
                        type: {
                            option: 'u64';
                        };
                    },
                    {
                        name: 'pubkeyArray';
                        type: {
                            vec: 'publicKey';
                        };
                    },
                    {
                        name: 'message';
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        },
        {
            name: 'QueueIndex';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'queueId';
                        docs: ['Id of queue in queue account.'];
                        type: 'u8';
                    },
                    {
                        name: 'index';
                        docs: ['Index of compressed account hash in queue.'];
                        type: 'u16';
                    }
                ];
            };
        },
        {
            name: 'RolloverMetadata';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'index';
                        docs: ['Unique index.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverFee';
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'rolloverThreshold';
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'networkFee';
                        docs: ['Tip for maintaining the account.'];
                        type: 'u64';
                    },
                    {
                        name: 'rolledoverSlot';
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'closeThreshold';
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.'
                        ];
                        type: 'u64';
                    },
                    {
                        name: 'additionalBytes';
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.'
                        ];
                        type: 'u64';
                    }
                ];
            };
        },
        {
            name: 'TokenData';
            type: {
                kind: 'struct';
                fields: [
                    {
                        name: 'mint';
                        docs: ['The mint associated with this account'];
                        type: 'publicKey';
                    },
                    {
                        name: 'owner';
                        docs: ['The owner of this account.'];
                        type: 'publicKey';
                    },
                    {
                        name: 'amount';
                        docs: ['The amount of tokens this account holds.'];
                        type: 'u64';
                    },
                    {
                        name: 'delegate';
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate'
                        ];
                        type: {
                            option: 'publicKey';
                        };
                    },
                    {
                        name: 'state';
                        docs: ["The account's state"];
                        type: {
                            defined: 'AccountState';
                        };
                    },
                    {
                        name: 'tlv';
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)'
                        ];
                        type: {
                            option: 'bytes';
                        };
                    }
                ];
            };
        }
    ];
    errors: [
        {
            code: 6000;
            name: 'PublicKeyAmountMissmatch';
            msg: 'public keys and amounts must be of same length';
        },
        {
            code: 6001;
            name: 'ComputeInputSumFailed';
            msg: 'ComputeInputSumFailed';
        },
        {
            code: 6002;
            name: 'ComputeOutputSumFailed';
            msg: 'ComputeOutputSumFailed';
        },
        {
            code: 6003;
            name: 'ComputeCompressSumFailed';
            msg: 'ComputeCompressSumFailed';
        },
        {
            code: 6004;
            name: 'ComputeDecompressSumFailed';
            msg: 'ComputeDecompressSumFailed';
        },
        {
            code: 6005;
            name: 'SumCheckFailed';
            msg: 'SumCheckFailed';
        },
        {
            code: 6006;
            name: 'DecompressRecipientUndefinedForDecompress';
            msg: 'DecompressRecipientUndefinedForDecompress';
        },
        {
            code: 6007;
            name: 'CompressedPdaUndefinedForDecompress';
            msg: 'CompressedPdaUndefinedForDecompress';
        },
        {
            code: 6008;
            name: 'DeCompressAmountUndefinedForDecompress';
            msg: 'DeCompressAmountUndefinedForDecompress';
        },
        {
            code: 6009;
            name: 'CompressedPdaUndefinedForCompress';
            msg: 'CompressedPdaUndefinedForCompress';
        },
        {
            code: 6010;
            name: 'DeCompressAmountUndefinedForCompress';
            msg: 'DeCompressAmountUndefinedForCompress';
        },
        {
            code: 6011;
            name: 'DelegateSignerCheckFailed';
            msg: 'DelegateSignerCheckFailed';
        },
        {
            code: 6012;
            name: 'MintTooLarge';
            msg: 'Minted amount greater than u64::MAX';
        },
        {
            code: 6013;
            name: 'SplTokenSupplyMismatch';
            msg: 'SplTokenSupplyMismatch';
        },
        {
            code: 6014;
            name: 'HeapMemoryCheckFailed';
            msg: 'HeapMemoryCheckFailed';
        },
        {
            code: 6015;
            name: 'InstructionNotCallable';
            msg: 'The instruction is not callable';
        },
        {
            code: 6016;
            name: 'ArithmeticUnderflow';
            msg: 'ArithmeticUnderflow';
        },
        {
            code: 6017;
            name: 'HashToFieldError';
            msg: 'HashToFieldError';
        },
        {
            code: 6018;
            name: 'InvalidAuthorityMint';
            msg: 'Expected the authority to be also a mint authority';
        },
        {
            code: 6019;
            name: 'InvalidFreezeAuthority';
            msg: 'Provided authority is not the freeze authority';
        },
        {
            code: 6020;
            name: 'InvalidDelegateIndex';
        },
        {
            code: 6021;
            name: 'TokenPoolPdaUndefined';
        },
        {
            code: 6022;
            name: 'IsTokenPoolPda';
            msg: 'Compress or decompress recipient is the same account as the token pool pda.';
        },
        {
            code: 6023;
            name: 'InvalidTokenPoolPda';
        },
        {
            code: 6024;
            name: 'NoInputTokenAccountsProvided';
        },
        {
            code: 6025;
            name: 'NoInputsProvided';
        },
        {
            code: 6026;
            name: 'MintHasNoFreezeAuthority';
        },
        {
            code: 6027;
            name: 'MintWithInvalidExtension';
        },
        {
            code: 6028;
            name: 'InsufficientTokenAccountBalance';
            msg: 'The token account balance is less than the remaining amount.';
        }
    ];
};
declare const IDL: LightCompressedToken;

type TokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type PackedTokenTransferOutputData = {
    /**
     * The owner of the output token account
     */
    owner: PublicKey;
    /**
     * The amount of tokens of the output token account
     */
    amount: BN;
    /**
     * lamports associated with the output token account
     */
    lamports: BN | null;
    /**
     * Merkle tree pubkey index in remaining accounts
     */
    merkleTreeIndex: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type InputTokenDataWithContext = {
    /**
     * The amount of tokens to transfer
     */
    amount: BN;
    /**
     * Optional: The index of the delegate in remaining accounts
     */
    delegateIndex: number | null;
    /**
     * The index of the merkle tree address in remaining accounts
     */
    merkleTreePubkeyIndex: number;
    /**
     * The index of the nullifier queue address in remaining accounts
     */
    nullifierQueuePubkeyIndex: number;
    /**
     * The index of the leaf in the merkle tree
     */
    leafIndex: number;
    /**
     * Lamports in the input token account.
     */
    lamports: BN | null;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};
type CompressedTokenInstructionDataInvoke = {
    /**
     * Validity proof
     */
    proof: CompressedProof | null;
    /**
     * The root indices of the transfer
     */
    rootIndices: number[];
    /**
     * The mint of the transfer
     */
    mint: PublicKey;
    /**
     * Whether the signer is a delegate
     * TODO: implement delegated transfer struct
     */
    delegatedTransfer: null;
    /**
     * Input token data with packed merkle context
     */
    inputTokenDataWithContext: InputTokenDataWithContext[];
    /**
     * Data of the output token accounts
     */
    outputCompressedAccounts: TokenTransferOutputData[];
    /**
     * The indices of the output state merkle tree accounts in 'remaining
     * accounts'
     */
    outputStateMerkleTreeAccountIndices: Buffer;
    /**
     * The index of the Merkle tree for a lamport change account.
     */
    lamportsChangeAccountMerkleTreeIndex: number | null;
};
type TokenData = {
    /**
     * The mint associated with this account
     */
    mint: PublicKey;
    /**
     * The owner of this account
     */
    owner: PublicKey;
    /**
     * The amount of tokens this account holds
     */
    amount: BN;
    /**
     * If `delegate` is `Some` then `delegated_amount` represents the amount
     * authorized by the delegate
     */
    delegate: PublicKey | null;
    /**
     * The account's state
     */
    state: number;
    /**
     * TokenExtension tlv
     */
    tlv: Buffer | null;
};

type PackCompressedTokenAccountsParams = {
    /** Input state to be consumed */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * State trees that the output should be inserted into. Defaults to the 0th
     * state tree of the input state. Gets padded to the length of
     * outputCompressedAccounts.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
    /** Optional remaining accounts to append to */
    remainingAccounts?: PublicKey[];
    /**
     *  Root indices that are used on-chain to fetch the correct root
     *  from the state Merkle tree account for validity proof verification.
     */
    rootIndices: number[];
    tokenTransferOutputs: TokenTransferOutputData$1[];
};
/**
 * Packs Compressed Token Accounts.
 */
declare function packCompressedTokenAccounts(params: PackCompressedTokenAccountsParams): {
    inputTokenDataWithContext: InputTokenDataWithContext$1[];
    remainingAccountMetas: AccountMeta[];
    packedOutputTokenData: PackedTokenTransferOutputData[];
};

declare const POOL_SEED: Buffer;
declare const CPI_AUTHORITY_SEED: Buffer;
declare const SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = 1461600;

type CompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * owner of the *uncompressed* token account.
     */
    owner: PublicKey;
    /**
     * source (associated) token account address.
     */
    source: PublicKey;
    /**
     * owner of the compressed token account.
     * To compress to a batch of recipients, pass an array of PublicKeys.
     */
    toAddress: PublicKey | PublicKey[];
    /**
     * Mint address of the token to compress.
     */
    mint: PublicKey;
    /**
     * amount of tokens to compress.
     */
    amount: number | BN | number[] | BN[];
    /**
     * The state tree that the tx output should be inserted into. Defaults to a
     * public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type CompressSplTokenAccountParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Authority that owns the token account
     */
    authority: PublicKey;
    /**
     * Token account to compress
     */
    tokenAccount: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Optional: remaining amount to leave in token account. Default: 0
     */
    remainingAmount?: BN;
    /**
     * The state tree that the compressed token account should be inserted into.
     */
    outputStateTree: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type DecompressParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * input state to be consumed
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * address of **uncompressed** destination token account.
     */
    toAddress: PublicKey;
    /**
     * amount of tokens to decompress.
     */
    amount: number | BN;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.
     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state tree that the change tx output should be inserted into.
     * Defaults to a public state tree if unspecified.
     */
    outputStateTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type TransferParams = {
    /**
     * The payer of the transaction
     */
    payer: PublicKey;
    /**
     * The input state to be consumed
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Recipient address
     */
    toAddress: PublicKey;
    /**
     * Amount of tokens to transfer
     */
    amount: BN | number;
    /**
     * The recent state root indices of the input state. The expiry is tied to
     * the proof.

     */
    recentInputStateRootIndices: number[];
    /**
     * The recent validity proof for state inclusion of the input state. It
     * expires after n slots.
     */
    recentValidityProof: CompressedProof;
    /**
     * The state trees that the tx output should be inserted into. This can be a
     * single PublicKey or an array of PublicKey. Defaults to the 0th state tree
     * of input state.
     */
    outputStateTrees?: PublicKey[] | PublicKey;
};
/**
 * Create Mint account for compressed Tokens
 */
type CreateMintParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Mint decimals
     */
    decimals: number;
    /**
     * Optional: freeze authority
     */
    freezeAuthority: PublicKey | null;
    /**
     * lamport amount for mint account rent exemption
     */
    rentExemptBalance: number;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
    /**
     * Optional: Mint size to use, defaults to MINT_SIZE
     */
    mintSize?: number;
};
/**
 * Parameters for merging compressed token accounts
 */
type MergeTokenAccountsParams = {
    /**
     * Tx feepayer
     */
    payer: PublicKey;
    /**
     * Owner of the token accounts to be merged
     */
    owner: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * Array of compressed token accounts to merge
     */
    inputCompressedTokenAccounts: ParsedTokenAccount[];
    /**
     * Optional: Public key of the state tree to merge into
     */
    outputStateTree: PublicKey;
    /**
     * Optional: Recent validity proof for state inclusion
     */
    recentValidityProof: CompressedProof;
    /**
     * Optional: Recent state root indices of the input state
     */
    recentInputStateRootIndices: number[];
};
/**
 * Create compressed token accounts
 */
type MintToParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * The Solana Public Keys to mint to.
     */
    toPubkey: PublicKey[] | PublicKey;
    /**
     * The amount of compressed tokens to mint.
     */
    amount: BN | BN[] | number | number[];
    /**
     * Public key of the state tree to mint into. Defaults to a public state
     * tree if unspecified.
     */
    merkleTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
/**
 * Register an existing SPL mint account to the compressed token program
 * Creates an omnibus account for the mint
 */
type RegisterMintParams = {
    /** Tx feepayer */
    feePayer: PublicKey;
    /** Mint public key */
    mint: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
/**
 * Mint from existing SPL mint to compressed token accounts
 */
type ApproveAndMintToParams = {
    /**
     * Tx feepayer
     */
    feePayer: PublicKey;
    /**
     * Mint authority
     */
    authority: PublicKey;
    /**
     * Mint authority (associated) token account
     */
    authorityTokenAccount: PublicKey;
    /**
     * Mint public key
     */
    mint: PublicKey;
    /**
     * The Solana Public Key to mint to.
     */
    toPubkey: PublicKey;
    /**
     * The amount of compressed tokens to mint.
     */
    amount: BN | number;
    /**
     * Public key of the state tree to mint into. Defaults to a public state
     * tree if unspecified.
     */
    merkleTree?: PublicKey;
    /**
     * Optional: The token program ID. Default: SPL Token Program ID
     */
    tokenProgramId?: PublicKey;
};
type CreateTokenProgramLookupTableParams = {
    /**
     * The payer of the transaction.
     */
    payer: PublicKey;
    /**
     * The authority of the transaction.
     */
    authority: PublicKey;
    /**
     *  Recently finalized Solana slot.
     */
    recentSlot: number;
    /**
     * Optional Mint addresses to store in the lookup table.
     */
    mints?: PublicKey[];
    /**
     * Optional additional addresses to store in the lookup table.
     */
    remainingAccounts?: PublicKey[];
};
/**
 * Sum up the token amounts of the compressed token accounts
 */
declare const sumUpTokenAmount: (accounts: ParsedTokenAccount[]) => BN;
/**
 * Validate that all the compressed token accounts are owned by the same owner.
 */
declare const validateSameTokenOwner: (accounts: ParsedTokenAccount[]) => void;
/**
 * Parse compressed token accounts to get the mint, current owner and delegate.
 */
declare const parseTokenData: (compressedTokenAccounts: ParsedTokenAccount[]) => {
    mint: PublicKey;
    currentOwner: PublicKey;
    delegate: PublicKey | null;
};
/**
 * Create the output state for a transfer transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param toAddress                     Recipient address
 * @param amount                        Amount of tokens to transfer
 * @returns                             Output token data for the transfer
 *                                      instruction
 */
declare function createTransferOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], toAddress: PublicKey, amount: number | BN): TokenTransferOutputData$1[];
/**
 * Create the output state for a compress transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param amount                        Amount of tokens to compress
 * @returns                             Output token data for the compress
 *                                      instruction
 */
declare function createDecompressOutputState(inputCompressedTokenAccounts: ParsedTokenAccount[], amount: number | BN): TokenTransferOutputData$1[];
declare class CompressedTokenProgram {
    /**
     * @internal
     */
    constructor();
    /**
     * Public key that identifies the CompressedPda program
     */
    static programId: PublicKey;
    /**
     * Set a custom programId via PublicKey or base58 encoded string.
     * This method is not required for regular usage.
     *
     * Use this only if you know what you are doing.
     */
    static setProgramId(programId: PublicKey | string): void;
    private static _program;
    /** @internal */
    static get program(): Program<LightCompressedToken>;
    /**
     * @internal
     * Initializes the program statically if not already initialized.
     */
    private static initializeProgram;
    /** @internal */
    static deriveTokenPoolPda(mint: PublicKey): PublicKey;
    /** @internal */
    static get deriveCpiAuthorityPda(): PublicKey;
    /**
     * Construct createMint instruction for compressed tokens.
     * @returns [createMintAccountInstruction, initializeMintInstruction, createTokenPoolInstruction]
     *
     * Note that `createTokenPoolInstruction` must be executed after `initializeMintInstruction`.
     */
    static createMint(params: CreateMintParams): Promise<TransactionInstruction[]>;
    /**
     * Enable compression for an existing SPL mint, creating an omnibus account.
     * For new mints, use `CompressedTokenProgram.createMint`.
     */
    static createTokenPool(params: RegisterMintParams): Promise<TransactionInstruction>;
    /**
     * Construct mintTo instruction for compressed tokens
     */
    static mintTo(params: MintToParams): Promise<TransactionInstruction>;
    /**
     * Mint tokens from registered SPL mint account to a compressed account
     */
    static approveAndMintTo(params: ApproveAndMintToParams): Promise<TransactionInstruction[]>;
    /**
     * Construct transfer instruction for compressed tokens
     */
    static transfer(params: TransferParams): Promise<TransactionInstruction>;
    /**
     * Create lookup table instructions for the token program's default accounts.
     */
    static createTokenProgramLookupTable(params: CreateTokenProgramLookupTableParams): Promise<{
        instructions: TransactionInstruction[];
        address: PublicKey;
    }>;
    /**
     * Create compress instruction
     * @returns compressInstruction
     */
    static compress(params: CompressParams): Promise<TransactionInstruction>;
    /**
     * Construct decompress instruction
     */
    static decompress(params: DecompressParams): Promise<TransactionInstruction>;
    static mergeTokenAccounts(params: MergeTokenAccountsParams): Promise<TransactionInstruction[]>;
    static compressSplTokenAccount(params: CompressSplTokenAccountParams): Promise<TransactionInstruction>;
    static get_mint_program_id(mint: PublicKey, connection: Connection): Promise<PublicKey | undefined>;
}

/**
 * Mint compressed tokens to a solana address from an external mint authority
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to
 * @param authority      Minting authority
 * @param amount         Amount to mint
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function approveAndMintTo(rpc: Rpc, payer: Signer, mint: PublicKey, destination: PublicKey, authority: Signer, amount: number | BN, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Compress SPL tokens
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the compressed token
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens.
 * @param sourceTokenAccount    Source (associated) token account
 * @param toAddress             Destination address of the recipient
 * @param merkleTree            State tree account that the compressed tokens
 *                              should be inserted into. Defaults to a default
 *                              state tree account.
 * @param confirmOptions        Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function compress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN | number[] | BN[], owner: Signer, sourceTokenAccount: PublicKey, toAddress: PublicKey | Array<PublicKey>, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Decompress compressed tokens
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination **uncompressed** (associated) token account
 *                       address.
 * @param merkleTree     State tree account that any change compressed tokens should be
 *                       inserted into. Defaults to a default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function decompress(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Create and initialize a new compressed token mint
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting
 * @param decimals        Location of the decimal place
 * @param keypair         Optional keypair, defaulting to a new random one
 * @param confirmOptions  Options for confirming the transaction
 * @param isToken22       Whether to create a Token 2022 mint. Defaults to false.
 *
 * @return Address of the new mint and the transaction signature
 */
declare function createMint(rpc: Rpc, payer: Signer, mintAuthority: PublicKey, decimals: number, keypair?: Keypair, confirmOptions?: ConfirmOptions, isToken22?: boolean): Promise<{
    mint: PublicKey;
    transactionSignature: TransactionSignature;
}>;

/**
 * Mint compressed tokens to a solana address
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to. Can be an array of
 *                       addresses if the amount is an array of amounts.
 * @param authority      Minting authority
 * @param amount         Amount to mint. Can be an array of amounts if the
 *                       destination is an array of addresses.
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function mintTo(rpc: Rpc, payer: Signer, mint: PublicKey, destination: PublicKey | PublicKey[], authority: Signer, amount: number | BN | number[] | BN[], merkleTree?: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Merge multiple compressed token accounts for a given mint into a single
 * account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction fees
 * @param mint            Public key of the token's mint
 * @param owner           Owner of the token accounts to be merged
 * @param merkleTree      Optional merkle tree for compressed tokens
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Array of transaction signatures
 */
declare function mergeTokenAccounts(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;

/**
 * Register an existing mint with the CompressedToken program
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting. Is signer.
 * @param mintAddress     Address of the existing mint
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return transaction signature
 */
declare function createTokenPool(rpc: Rpc, payer: Signer, mint: PublicKey, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

/**
 * Transfer compressed tokens from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       inserted into. Defaults to the default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
declare function transfer(rpc: Rpc, payer: Signer, mint: PublicKey, amount: number | BN, owner: Signer, toAddress: PublicKey, merkleTree?: PublicKey, confirmOptions?: ConfirmOptions): Promise<TransactionSignature>;
/**
 * Selects the minimal number of compressed token accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
declare function selectMinCompressedTokenAccountsForTransfer(accounts: ParsedTokenAccount[], transferAmount: BN): [
    selectedAccounts: ParsedTokenAccount[],
    total: BN,
    totalLamports: BN | null
];

/**
 * Create a lookup table for the token program's default accounts
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param authority             Authority of the lookup table
 * @param mints                 Optional array of mint public keys to include in
 *                              the lookup table
 * @param additionalAccounts    Optional array of additional account public keys
 *                              to include in the lookup table
 *
 * @return Transaction signatures and the address of the created lookup table
 */
declare function createTokenProgramLookupTable(rpc: Rpc, payer: Signer, authority: Signer, mints?: PublicKey[], additionalAccounts?: PublicKey[]): Promise<{
    txIds: TransactionSignature[];
    address: PublicKey;
}>;

/**
 * Compress SPL tokens into compressed token format
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the token to compress
 * @param owner                 Owner of the token account
 * @param tokenAccount         Token account to compress
 * @param outputStateTree       State tree to insert the compressed token account into
 * @param remainingAmount      Optional: amount to leave in token account. Default: 0
 * @param confirmOptions       Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
declare function compressSplTokenAccount(rpc: Rpc, payer: Signer, mint: PublicKey, owner: Signer, tokenAccount: PublicKey, outputStateTree: PublicKey, remainingAmount?: BN, confirmOptions?: ConfirmOptions, tokenProgramId?: PublicKey): Promise<TransactionSignature>;

export { type ApproveAndMintToParams, CPI_AUTHORITY_SEED, type CompressParams, type CompressSplTokenAccountParams, type CompressedTokenInstructionDataInvoke, CompressedTokenProgram, type CreateMintParams, type CreateTokenProgramLookupTableParams, type DecompressParams, IDL, type InputTokenDataWithContext, type LightCompressedToken, type MergeTokenAccountsParams, type MintToParams, POOL_SEED, type PackCompressedTokenAccountsParams, type PackedTokenTransferOutputData, type RegisterMintParams, SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE, type TokenData, type TokenTransferOutputData, type TransferParams, approveAndMintTo, compress, compressSplTokenAccount, createDecompressOutputState, createMint, createTokenPool, createTokenProgramLookupTable, createTransferOutputState, decompress, mergeTokenAccounts, mintTo, packCompressedTokenAccounts, parseTokenData, selectMinCompressedTokenAccountsForTransfer, sumUpTokenAmount, transfer, validateSameTokenOwner };
