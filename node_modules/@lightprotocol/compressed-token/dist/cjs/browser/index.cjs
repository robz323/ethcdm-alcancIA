'use strict';

var stateless_js = require('@lightprotocol/stateless.js');
var web3_js = require('@solana/web3.js');
var anchor = require('@coral-xyz/anchor');
var splToken = require('@solana/spl-token');

const IDL = {
    version: '1.2.0',
    name: 'light_compressed_token',
    instructions: [
        {
            name: 'createTokenPool',
            docs: [
                'This instruction creates a token pool for a given mint. Every spl mint',
                'can have one token pool. When a token is compressed the tokens are',
                'transferrred to the token pool, and their compressed equivalent is',
                'minted into a Merkle tree.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: 'mintTo',
            docs: [
                'Mints tokens from an spl token mint to a list of compressed accounts.',
                'Minted tokens are transferred to a pool account owned by the compressed',
                'token program. The instruction creates one compressed output account for',
                'every amount and pubkey input pair. A constant amount of lamports can be',
                'transferred to each output account to enable. A use case to add lamports',
                'to a compressed token account is to prevent spam. This is the only way',
                'to add lamports to a compressed token account.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['programs'],
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'merkleTree',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'solPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
            ],
            args: [
                {
                    name: 'publicKeys',
                    type: {
                        vec: 'publicKey',
                    },
                },
                {
                    name: 'amounts',
                    type: {
                        vec: 'u64',
                    },
                },
                {
                    name: 'lamports',
                    type: {
                        option: 'u64',
                    },
                },
            ],
        },
        {
            name: 'compressSplTokenAccount',
            docs: [
                'Compresses the balance of an spl token account sub an optional remaining',
                'amount. This instruction does not close the spl token account. To close',
                'the account bundle a close spl account instruction in your transaction.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'owner',
                    type: 'publicKey',
                },
                {
                    name: 'remainingAmount',
                    type: {
                        option: 'u64',
                    },
                },
                {
                    name: 'cpiContext',
                    type: {
                        option: {
                            defined: 'CompressedCpiContext',
                        },
                    },
                },
            ],
        },
        {
            name: 'transfer',
            docs: [
                'Transfers compressed tokens from one account to another. All accounts',
                'must be of the same mint. Additional spl tokens can be compressed or',
                'decompressed. In one transaction only compression or decompression is',
                'possible. Lamports can be transferred alongside tokens. If output token',
                'accounts specify less lamports than inputs the remaining lamports are',
                'transferred to an output compressed account. Signer must be owner or',
                'delegate. If a delegated token account is transferred the delegate is',
                'not preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'approve',
            docs: [
                'Delegates an amount to a delegate. A compressed token account is either',
                'completely delegated or not. Prior delegates are not preserved. Cannot',
                'be called by a delegate.',
                'The instruction creates two output accounts:',
                '1. one account with delegated amount',
                '2. one account with remaining(change) amount',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'revoke',
            docs: [
                'Revokes a delegation. The instruction merges all inputs into one output',
                'account. Cannot be called by a delegate. Delegates are not preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'freeze',
            docs: [
                'Freezes compressed token accounts. Inputs must not be frozen. Creates as',
                'many outputs as inputs. Balances and delegates are preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['that this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'thaw',
            docs: [
                'Thaws frozen compressed token accounts. Inputs must be frozen. Creates',
                'as many outputs as inputs. Balances and delegates are preserved.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['that this program is the signer of the cpi.'],
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'burn',
            docs: [
                'Burns compressed tokens and spl tokens from the pool account. Delegates',
                'can burn tokens. The output compressed token account remains delegated.',
                'Creates one output compressed token account.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'mint',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs',
                    type: 'bytes',
                },
            ],
        },
        {
            name: 'stubIdlBuild',
            docs: [
                'This function is a stub to allow Anchor to include the input types in',
                'the IDL. It should not be included in production builds nor be called in',
                'practice.',
            ],
            accounts: [
                {
                    name: 'feePayer',
                    isMut: true,
                    isSigner: true,
                    docs: ['UNCHECKED: only pays fees.'],
                },
                {
                    name: 'authority',
                    isMut: false,
                    isSigner: true,
                    docs: [
                        'Authority is verified through proof since both owner and delegate',
                        'are included in the token data hash, which is a public input to the',
                        'validity proof.',
                    ],
                },
                {
                    name: 'cpiAuthorityPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'lightSystemProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'registeredProgramPda',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'noopProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionAuthority',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'accountCompressionProgram',
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: 'selfProgram',
                    isMut: false,
                    isSigner: false,
                    docs: ['this program is the signer of the cpi.'],
                },
                {
                    name: 'tokenPoolPda',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'compressOrDecompressTokenAccount',
                    isMut: true,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'tokenProgram',
                    isMut: false,
                    isSigner: false,
                    isOptional: true,
                },
                {
                    name: 'systemProgram',
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: 'inputs1',
                    type: {
                        defined: 'CompressedTokenInstructionDataTransfer',
                    },
                },
                {
                    name: 'inputs2',
                    type: {
                        defined: 'TokenData',
                    },
                },
            ],
        },
    ],
    types: [
        {
            name: 'AccessMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        docs: ['Owner of the Merkle tree.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'programOwner',
                        docs: [
                            'Program owner of the Merkle tree. This will be used for program owned Merkle trees.',
                        ],
                        type: 'publicKey',
                    },
                    {
                        name: 'forester',
                        docs: [
                            'Optional privileged forester pubkey, can be set for custom Merkle trees',
                            'without a network fee. Merkle trees without network fees are not',
                            'forested by light foresters. The variable is not used in the account',
                            'compression program but the registry program. The registry program',
                            'implements access control to prevent contention during forester. The',
                            'forester pubkey specified in this struct can bypass contention checks.',
                        ],
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'AccountState',
            type: {
                kind: 'enum',
                variants: [
                    {
                        name: 'Initialized',
                    },
                    {
                        name: 'Frozen',
                    },
                ],
            },
        },
        {
            name: 'CompressedAccount',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'lamports',
                        type: 'u64',
                    },
                    {
                        name: 'address',
                        type: {
                            option: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'data',
                        type: {
                            option: {
                                defined: 'CompressedAccountData',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedAccountData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'discriminator',
                        type: {
                            array: ['u8', 8],
                        },
                    },
                    {
                        name: 'data',
                        type: 'bytes',
                    },
                    {
                        name: 'dataHash',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedCpiContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'setContext',
                        docs: [
                            'Is set by the program that is invoking the CPI to signal that is should',
                            'set the cpi context.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'firstSetContext',
                        docs: [
                            'Is set to wipe the cpi context since someone could have set it before',
                            'with unrelated data.',
                        ],
                        type: 'bool',
                    },
                    {
                        name: 'cpiContextAccountIndex',
                        docs: [
                            'Index of cpi context account in remaining accounts.',
                        ],
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'CompressedProof',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'a',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'b',
                        type: {
                            array: ['u8', 64],
                        },
                    },
                    {
                        name: 'c',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                ],
            },
        },
        {
            name: 'CompressedTokenInstructionDataTransfer',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'mint',
                        type: 'publicKey',
                    },
                    {
                        name: 'delegatedTransfer',
                        docs: [
                            'Is required if the signer is delegate,',
                            '-> delegate is authority account,',
                            'owner = Some(owner) is the owner of the token account.',
                        ],
                        type: {
                            option: {
                                defined: 'DelegatedTransfer',
                            },
                        },
                    },
                    {
                        name: 'inputTokenDataWithContext',
                        type: {
                            vec: {
                                defined: 'InputTokenDataWithContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'PackedTokenTransferOutputData',
                            },
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'compressOrDecompressAmount',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'cpiContext',
                        type: {
                            option: {
                                defined: 'CompressedCpiContext',
                            },
                        },
                    },
                    {
                        name: 'lamportsChangeAccountMerkleTreeIndex',
                        type: {
                            option: 'u8',
                        },
                    },
                ],
            },
        },
        {
            name: 'DelegatedTransfer',
            docs: [
                'Struct to provide the owner when the delegate is signer of the transaction.',
            ],
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'delegateChangeAccountIndex',
                        docs: [
                            'Index of change compressed account in output compressed accounts. In',
                            "case that the delegate didn't spend the complete delegated compressed",
                            'account balance the change compressed account will be delegated to her',
                            'as well.',
                        ],
                        type: {
                            option: 'u8',
                        },
                    },
                ],
            },
        },
        {
            name: 'InputTokenDataWithContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'amount',
                        type: 'u64',
                    },
                    {
                        name: 'delegateIndex',
                        type: {
                            option: 'u8',
                        },
                    },
                    {
                        name: 'merkleContext',
                        type: {
                            defined: 'PackedMerkleContext',
                        },
                    },
                    {
                        name: 'rootIndex',
                        type: 'u16',
                    },
                    {
                        name: 'lamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvoke',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'InstructionDataInvokeCpi',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'proof',
                        type: {
                            option: {
                                defined: 'CompressedProof',
                            },
                        },
                    },
                    {
                        name: 'newAddressParams',
                        type: {
                            vec: {
                                defined: 'NewAddressParamsPacked',
                            },
                        },
                    },
                    {
                        name: 'inputCompressedAccountsWithMerkleContext',
                        type: {
                            vec: {
                                defined: 'PackedCompressedAccountWithMerkleContext',
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'cpiContext',
                        type: {
                            option: {
                                defined: 'CompressedCpiContext',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'accessMetadata',
                        type: {
                            defined: 'AccessMetadata',
                        },
                    },
                    {
                        name: 'rolloverMetadata',
                        type: {
                            defined: 'RolloverMetadata',
                        },
                    },
                    {
                        name: 'associatedQueue',
                        type: 'publicKey',
                    },
                    {
                        name: 'nextMerkleTree',
                        type: 'publicKey',
                    },
                ],
            },
        },
        {
            name: 'MerkleTreeSequenceNumber',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'pubkey',
                        type: 'publicKey',
                    },
                    {
                        name: 'seq',
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'NewAddressParamsPacked',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'seed',
                        type: {
                            array: ['u8', 32],
                        },
                    },
                    {
                        name: 'addressQueueAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeAccountIndex',
                        type: 'u8',
                    },
                    {
                        name: 'addressMerkleTreeRootIndex',
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'OutputCompressedAccountWithPackedContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleTreeIndex',
                        type: 'u8',
                    },
                ],
            },
        },
        {
            name: 'PackedCompressedAccountWithMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'compressedAccount',
                        type: {
                            defined: 'CompressedAccount',
                        },
                    },
                    {
                        name: 'merkleContext',
                        type: {
                            defined: 'PackedMerkleContext',
                        },
                    },
                    {
                        name: 'rootIndex',
                        docs: [
                            'Index of root used in inclusion validity proof.',
                        ],
                        type: 'u16',
                    },
                    {
                        name: 'readOnly',
                        docs: [
                            'Placeholder to mark accounts read-only unimplemented set to false.',
                        ],
                        type: 'bool',
                    },
                ],
            },
        },
        {
            name: 'PackedMerkleContext',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'merkleTreePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'nullifierQueuePubkeyIndex',
                        type: 'u8',
                    },
                    {
                        name: 'leafIndex',
                        type: 'u32',
                    },
                    {
                        name: 'queueIndex',
                        docs: [
                            'Index of leaf in queue. Placeholder of batched Merkle tree updates',
                            'currently unimplemented.',
                        ],
                        type: {
                            option: {
                                defined: 'QueueIndex',
                            },
                        },
                    },
                ],
            },
        },
        {
            name: 'PackedTokenTransferOutputData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'owner',
                        type: 'publicKey',
                    },
                    {
                        name: 'amount',
                        type: 'u64',
                    },
                    {
                        name: 'lamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'merkleTreeIndex',
                        type: 'u8',
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'PublicTransactionEvent',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'inputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccountHashes',
                        type: {
                            vec: {
                                array: ['u8', 32],
                            },
                        },
                    },
                    {
                        name: 'outputCompressedAccounts',
                        type: {
                            vec: {
                                defined: 'OutputCompressedAccountWithPackedContext',
                            },
                        },
                    },
                    {
                        name: 'outputLeafIndices',
                        type: {
                            vec: 'u32',
                        },
                    },
                    {
                        name: 'sequenceNumbers',
                        type: {
                            vec: {
                                defined: 'MerkleTreeSequenceNumber',
                            },
                        },
                    },
                    {
                        name: 'relayFee',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'isCompress',
                        type: 'bool',
                    },
                    {
                        name: 'compressOrDecompressLamports',
                        type: {
                            option: 'u64',
                        },
                    },
                    {
                        name: 'pubkeyArray',
                        type: {
                            vec: 'publicKey',
                        },
                    },
                    {
                        name: 'message',
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
        {
            name: 'QueueIndex',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'queueId',
                        docs: ['Id of queue in queue account.'],
                        type: 'u8',
                    },
                    {
                        name: 'index',
                        docs: ['Index of compressed account hash in queue.'],
                        type: 'u16',
                    },
                ],
            },
        },
        {
            name: 'RolloverMetadata',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'index',
                        docs: ['Unique index.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverFee',
                        docs: [
                            'This fee is used for rent for the next account.',
                            'It accumulates in the account so that once the corresponding Merkle tree account is full it can be rolled over',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'rolloverThreshold',
                        docs: [
                            'The threshold in percentage points when the account should be rolled over (95 corresponds to 95% filled).',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'networkFee',
                        docs: ['Tip for maintaining the account.'],
                        type: 'u64',
                    },
                    {
                        name: 'rolledoverSlot',
                        docs: [
                            'The slot when the account was rolled over, a rolled over account should not be written to.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'closeThreshold',
                        docs: [
                            'If current slot is greater than rolledover_slot + close_threshold and',
                            "the account is empty it can be closed. No 'close' functionality has been",
                            'implemented yet.',
                        ],
                        type: 'u64',
                    },
                    {
                        name: 'additionalBytes',
                        docs: [
                            'Placeholder for bytes of additional accounts which are tied to the',
                            'Merkle trees operation and need to be rolled over as well.',
                        ],
                        type: 'u64',
                    },
                ],
            },
        },
        {
            name: 'TokenData',
            type: {
                kind: 'struct',
                fields: [
                    {
                        name: 'mint',
                        docs: ['The mint associated with this account'],
                        type: 'publicKey',
                    },
                    {
                        name: 'owner',
                        docs: ['The owner of this account.'],
                        type: 'publicKey',
                    },
                    {
                        name: 'amount',
                        docs: ['The amount of tokens this account holds.'],
                        type: 'u64',
                    },
                    {
                        name: 'delegate',
                        docs: [
                            'If `delegate` is `Some` then `delegated_amount` represents',
                            'the amount authorized by the delegate',
                        ],
                        type: {
                            option: 'publicKey',
                        },
                    },
                    {
                        name: 'state',
                        docs: ["The account's state"],
                        type: {
                            defined: 'AccountState',
                        },
                    },
                    {
                        name: 'tlv',
                        docs: [
                            'Placeholder for TokenExtension tlv data (unimplemented)',
                        ],
                        type: {
                            option: 'bytes',
                        },
                    },
                ],
            },
        },
    ],
    errors: [
        {
            code: 6000,
            name: 'PublicKeyAmountMissmatch',
            msg: 'public keys and amounts must be of same length',
        },
        {
            code: 6001,
            name: 'ComputeInputSumFailed',
            msg: 'ComputeInputSumFailed',
        },
        {
            code: 6002,
            name: 'ComputeOutputSumFailed',
            msg: 'ComputeOutputSumFailed',
        },
        {
            code: 6003,
            name: 'ComputeCompressSumFailed',
            msg: 'ComputeCompressSumFailed',
        },
        {
            code: 6004,
            name: 'ComputeDecompressSumFailed',
            msg: 'ComputeDecompressSumFailed',
        },
        {
            code: 6005,
            name: 'SumCheckFailed',
            msg: 'SumCheckFailed',
        },
        {
            code: 6006,
            name: 'DecompressRecipientUndefinedForDecompress',
            msg: 'DecompressRecipientUndefinedForDecompress',
        },
        {
            code: 6007,
            name: 'CompressedPdaUndefinedForDecompress',
            msg: 'CompressedPdaUndefinedForDecompress',
        },
        {
            code: 6008,
            name: 'DeCompressAmountUndefinedForDecompress',
            msg: 'DeCompressAmountUndefinedForDecompress',
        },
        {
            code: 6009,
            name: 'CompressedPdaUndefinedForCompress',
            msg: 'CompressedPdaUndefinedForCompress',
        },
        {
            code: 6010,
            name: 'DeCompressAmountUndefinedForCompress',
            msg: 'DeCompressAmountUndefinedForCompress',
        },
        {
            code: 6011,
            name: 'DelegateSignerCheckFailed',
            msg: 'DelegateSignerCheckFailed',
        },
        {
            code: 6012,
            name: 'MintTooLarge',
            msg: 'Minted amount greater than u64::MAX',
        },
        {
            code: 6013,
            name: 'SplTokenSupplyMismatch',
            msg: 'SplTokenSupplyMismatch',
        },
        {
            code: 6014,
            name: 'HeapMemoryCheckFailed',
            msg: 'HeapMemoryCheckFailed',
        },
        {
            code: 6015,
            name: 'InstructionNotCallable',
            msg: 'The instruction is not callable',
        },
        {
            code: 6016,
            name: 'ArithmeticUnderflow',
            msg: 'ArithmeticUnderflow',
        },
        {
            code: 6017,
            name: 'HashToFieldError',
            msg: 'HashToFieldError',
        },
        {
            code: 6018,
            name: 'InvalidAuthorityMint',
            msg: 'Expected the authority to be also a mint authority',
        },
        {
            code: 6019,
            name: 'InvalidFreezeAuthority',
            msg: 'Provided authority is not the freeze authority',
        },
        {
            code: 6020,
            name: 'InvalidDelegateIndex',
        },
        {
            code: 6021,
            name: 'TokenPoolPdaUndefined',
        },
        {
            code: 6022,
            name: 'IsTokenPoolPda',
            msg: 'Compress or decompress recipient is the same account as the token pool pda.',
        },
        {
            code: 6023,
            name: 'InvalidTokenPoolPda',
        },
        {
            code: 6024,
            name: 'NoInputTokenAccountsProvided',
        },
        {
            code: 6025,
            name: 'NoInputsProvided',
        },
        {
            code: 6026,
            name: 'MintHasNoFreezeAuthority',
        },
        {
            code: 6027,
            name: 'MintWithInvalidExtension',
        },
        {
            code: 6028,
            name: 'InsufficientTokenAccountBalance',
            msg: 'The token account balance is less than the remaining amount.',
        },
    ],
};

// TODO: include owner and lamports in packing.
/**
 * Packs Compressed Token Accounts.
 */
function packCompressedTokenAccounts(params) {
    const { inputCompressedTokenAccounts, outputStateTrees, remainingAccounts = [], rootIndices, tokenTransferOutputs, } = params;
    const _remainingAccounts = remainingAccounts.slice();
    let delegateIndex = null;
    if (inputCompressedTokenAccounts.length > 0 &&
        inputCompressedTokenAccounts[0].parsed.delegate) {
        delegateIndex = stateless_js.getIndexOrAdd(_remainingAccounts, inputCompressedTokenAccounts[0].parsed.delegate);
    }
    /// TODO: move pubkeyArray to remainingAccounts
    /// Currently just packs 'delegate' to pubkeyArray
    const packedInputTokenData = [];
    /// pack inputs
    inputCompressedTokenAccounts.forEach((account, index) => {
        const merkleTreePubkeyIndex = stateless_js.getIndexOrAdd(_remainingAccounts, account.compressedAccount.merkleTree);
        const nullifierQueuePubkeyIndex = stateless_js.getIndexOrAdd(_remainingAccounts, account.compressedAccount.nullifierQueue);
        packedInputTokenData.push({
            amount: account.parsed.amount,
            delegateIndex,
            merkleContext: {
                merkleTreePubkeyIndex,
                nullifierQueuePubkeyIndex,
                leafIndex: account.compressedAccount.leafIndex,
                queueIndex: null,
            },
            rootIndex: rootIndices[index],
            lamports: account.compressedAccount.lamports.eq(stateless_js.bn(0))
                ? null
                : account.compressedAccount.lamports,
            tlv: null,
        });
    });
    /// pack output state trees
    const paddedOutputStateMerkleTrees = stateless_js.padOutputStateMerkleTrees(outputStateTrees, tokenTransferOutputs.length, inputCompressedTokenAccounts.map(acc => acc.compressedAccount));
    const packedOutputTokenData = [];
    paddedOutputStateMerkleTrees.forEach((account, index) => {
        var _a;
        const merkleTreeIndex = stateless_js.getIndexOrAdd(_remainingAccounts, account);
        packedOutputTokenData.push({
            owner: tokenTransferOutputs[index].owner,
            amount: tokenTransferOutputs[index].amount,
            lamports: ((_a = tokenTransferOutputs[index].lamports) === null || _a === void 0 ? void 0 : _a.eq(stateless_js.bn(0)))
                ? null
                : tokenTransferOutputs[index].lamports,
            merkleTreeIndex,
            tlv: null,
        });
    });
    // to meta
    const remainingAccountMetas = _remainingAccounts.map((account) => ({
        pubkey: account,
        isWritable: true,
        isSigner: false,
    }));
    return {
        inputTokenDataWithContext: packedInputTokenData,
        remainingAccountMetas,
        packedOutputTokenData,
    };
}

const POOL_SEED = Buffer.from('pool');
const CPI_AUTHORITY_SEED = Buffer.from('cpi_authority');
const SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = 1461600;

/**
 * Sum up the token amounts of the compressed token accounts
 */
const sumUpTokenAmount = (accounts) => {
    return accounts.reduce((acc, account) => acc.add(account.parsed.amount), stateless_js.bn(0));
};
/**
 * Validate that all the compressed token accounts are owned by the same owner.
 */
const validateSameTokenOwner = (accounts) => {
    const owner = accounts[0].parsed.owner;
    accounts.forEach(acc => {
        if (!acc.parsed.owner.equals(owner)) {
            throw new Error('Token accounts must be owned by the same owner');
        }
    });
};
/**
 * Parse compressed token accounts to get the mint, current owner and delegate.
 */
const parseTokenData = (compressedTokenAccounts) => {
    const mint = compressedTokenAccounts[0].parsed.mint;
    const currentOwner = compressedTokenAccounts[0].parsed.owner;
    const delegate = compressedTokenAccounts[0].parsed.delegate;
    return { mint, currentOwner, delegate };
};
/**
 * Create the output state for a transfer transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param toAddress                     Recipient address
 * @param amount                        Amount of tokens to transfer
 * @returns                             Output token data for the transfer
 *                                      instruction
 */
function createTransferOutputState(inputCompressedTokenAccounts, toAddress, amount) {
    amount = stateless_js.bn(amount);
    const inputAmount = sumUpTokenAmount(inputCompressedTokenAccounts);
    const inputLamports = stateless_js.sumUpLamports(inputCompressedTokenAccounts.map(acc => acc.compressedAccount));
    const changeAmount = inputAmount.sub(amount);
    stateless_js.validateSufficientBalance(changeAmount);
    if (changeAmount.eq(stateless_js.bn(0)) && inputLamports.eq(stateless_js.bn(0))) {
        return [
            {
                owner: toAddress,
                amount,
                lamports: inputLamports,
                tlv: null,
            },
        ];
    }
    /// validates token program
    stateless_js.validateSameOwner(inputCompressedTokenAccounts.map(acc => acc.compressedAccount));
    validateSameTokenOwner(inputCompressedTokenAccounts);
    const outputCompressedAccounts = [
        {
            owner: inputCompressedTokenAccounts[0].parsed.owner,
            amount: changeAmount,
            lamports: inputLamports,
            tlv: null,
        },
        {
            owner: toAddress,
            amount,
            lamports: stateless_js.bn(0),
            tlv: null,
        },
    ];
    return outputCompressedAccounts;
}
/**
 * Create the output state for a compress transaction.
 * @param inputCompressedTokenAccounts  Input state
 * @param amount                        Amount of tokens to compress
 * @returns                             Output token data for the compress
 *                                      instruction
 */
function createDecompressOutputState(inputCompressedTokenAccounts, amount) {
    amount = stateless_js.bn(amount);
    const inputLamports = stateless_js.sumUpLamports(inputCompressedTokenAccounts.map(acc => acc.compressedAccount));
    const inputAmount = sumUpTokenAmount(inputCompressedTokenAccounts);
    const changeAmount = inputAmount.sub(amount);
    stateless_js.validateSufficientBalance(changeAmount);
    /// lamports gets decompressed
    if (changeAmount.eq(stateless_js.bn(0)) && inputLamports.eq(stateless_js.bn(0))) {
        return [];
    }
    stateless_js.validateSameOwner(inputCompressedTokenAccounts.map(acc => acc.compressedAccount));
    validateSameTokenOwner(inputCompressedTokenAccounts);
    const tokenTransferOutputs = [
        {
            owner: inputCompressedTokenAccounts[0].parsed.owner,
            amount: changeAmount,
            lamports: inputLamports,
            tlv: null,
        },
    ];
    return tokenTransferOutputs;
}
class CompressedTokenProgram {
    /**
     * @internal
     */
    constructor() { }
    /**
     * Set a custom programId via PublicKey or base58 encoded string.
     * This method is not required for regular usage.
     *
     * Use this only if you know what you are doing.
     */
    static setProgramId(programId) {
        this.programId =
            typeof programId === 'string'
                ? new web3_js.PublicKey(programId)
                : programId;
        // Reset program when programId changes
        this._program = null;
    }
    /** @internal */
    static get program() {
        if (!this._program) {
            this.initializeProgram();
        }
        return this._program;
    }
    /**
     * @internal
     * Initializes the program statically if not already initialized.
     */
    static initializeProgram() {
        if (!this._program) {
            /// Note: We can use a mock connection because we're using the
            /// program only for serde and building instructions, not for
            /// interacting with the network.
            const mockKeypair = web3_js.Keypair.generate();
            const mockConnection = new web3_js.Connection('http://127.0.0.1:8899', 'confirmed');
            const mockProvider = new anchor.AnchorProvider(mockConnection, stateless_js.useWallet(mockKeypair), stateless_js.confirmConfig);
            anchor.setProvider(mockProvider);
            this._program = new anchor.Program(IDL, this.programId, mockProvider);
        }
    }
    /** @internal */
    static deriveTokenPoolPda(mint) {
        const seeds = [POOL_SEED, mint.toBuffer()];
        const [address, _] = web3_js.PublicKey.findProgramAddressSync(seeds, this.programId);
        return address;
    }
    /** @internal */
    static get deriveCpiAuthorityPda() {
        const [address, _] = web3_js.PublicKey.findProgramAddressSync([CPI_AUTHORITY_SEED], this.programId);
        return address;
    }
    /**
     * Construct createMint instruction for compressed tokens.
     * @returns [createMintAccountInstruction, initializeMintInstruction, createTokenPoolInstruction]
     *
     * Note that `createTokenPoolInstruction` must be executed after `initializeMintInstruction`.
     */
    static async createMint(params) {
        const { mint, authority, feePayer, rentExemptBalance, tokenProgramId, freezeAuthority, mintSize, } = params;
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        /// Create and initialize SPL Mint account
        const createMintAccountInstruction = web3_js.SystemProgram.createAccount({
            fromPubkey: feePayer,
            lamports: rentExemptBalance,
            newAccountPubkey: mint,
            programId: tokenProgram,
            space: mintSize !== null && mintSize !== void 0 ? mintSize : splToken.MINT_SIZE,
        });
        const initializeMintInstruction = splToken.createInitializeMint2Instruction(mint, params.decimals, authority, freezeAuthority, tokenProgram);
        const createTokenPoolInstruction = await this.createTokenPool({
            feePayer,
            mint,
            tokenProgramId: tokenProgram,
        });
        return [
            createMintAccountInstruction,
            initializeMintInstruction,
            createTokenPoolInstruction,
        ];
    }
    /**
     * Enable compression for an existing SPL mint, creating an omnibus account.
     * For new mints, use `CompressedTokenProgram.createMint`.
     */
    static async createTokenPool(params) {
        const { mint, feePayer, tokenProgramId } = params;
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        const tokenPoolPda = this.deriveTokenPoolPda(mint);
        const ix = await this.program.methods
            .createTokenPool()
            .accounts({
            mint,
            feePayer,
            tokenPoolPda,
            systemProgram: web3_js.SystemProgram.programId,
            tokenProgram,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
        })
            .instruction();
        return ix;
    }
    /**
     * Construct mintTo instruction for compressed tokens
     */
    static async mintTo(params) {
        const systemKeys = stateless_js.defaultStaticAccountsStruct();
        const { mint, feePayer, authority, merkleTree, toPubkey, amount, tokenProgramId, } = params;
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        const tokenPoolPda = this.deriveTokenPoolPda(mint);
        const amounts = stateless_js.toArray(amount).map(amount => stateless_js.bn(amount));
        const toPubkeys = stateless_js.toArray(toPubkey);
        if (amounts.length !== toPubkeys.length) {
            throw new Error('Amount and toPubkey arrays must have the same length');
        }
        const instruction = await this.program.methods
            .mintTo(toPubkeys, amounts, null)
            .accounts({
            feePayer,
            authority,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
            mint,
            tokenPoolPda,
            tokenProgram,
            lightSystemProgram: stateless_js.LightSystemProgram.programId,
            registeredProgramPda: systemKeys.registeredProgramPda,
            noopProgram: systemKeys.noopProgram,
            accountCompressionAuthority: systemKeys.accountCompressionAuthority,
            accountCompressionProgram: systemKeys.accountCompressionProgram,
            merkleTree: merkleTree !== null && merkleTree !== void 0 ? merkleTree : stateless_js.defaultTestStateTreeAccounts().merkleTree,
            selfProgram: this.programId,
            solPoolPda: null,
        })
            .instruction();
        return instruction;
    }
    /**
     * Mint tokens from registered SPL mint account to a compressed account
     */
    static async approveAndMintTo(params) {
        const { mint, feePayer, authorityTokenAccount, authority, merkleTree, toPubkey, tokenProgramId, } = params;
        const amount = BigInt(params.amount.toString());
        /// 1. Mint to existing ATA of mintAuthority.
        const splMintToInstruction = splToken.createMintToInstruction(mint, authorityTokenAccount, authority, amount, [], tokenProgramId);
        /// 2. Compress from mint authority ATA to recipient compressed account
        const compressInstruction = await this.compress({
            payer: feePayer,
            owner: authority,
            source: authorityTokenAccount,
            toAddress: toPubkey,
            mint,
            amount: params.amount,
            outputStateTree: merkleTree,
            tokenProgramId,
        });
        return [splMintToInstruction, compressInstruction];
    }
    /**
     * Construct transfer instruction for compressed tokens
     */
    static async transfer(params) {
        const { payer, inputCompressedTokenAccounts, recentInputStateRootIndices, recentValidityProof, amount, outputStateTrees, toAddress, } = params;
        const tokenTransferOutputs = createTransferOutputState(inputCompressedTokenAccounts, toAddress, amount);
        const { inputTokenDataWithContext, packedOutputTokenData, remainingAccountMetas, } = packCompressedTokenAccounts({
            inputCompressedTokenAccounts,
            outputStateTrees,
            rootIndices: recentInputStateRootIndices,
            tokenTransferOutputs,
        });
        const { mint, currentOwner } = parseTokenData(inputCompressedTokenAccounts);
        const data = {
            proof: recentValidityProof,
            mint,
            delegatedTransfer: null, // TODO: implement
            inputTokenDataWithContext,
            outputCompressedAccounts: packedOutputTokenData,
            compressOrDecompressAmount: null,
            isCompress: false,
            cpiContext: null,
            lamportsChangeAccountMerkleTreeIndex: null,
        };
        const encodedData = this.program.coder.types.encode('CompressedTokenInstructionDataTransfer', data);
        const { accountCompressionAuthority, noopProgram, registeredProgramPda, accountCompressionProgram, } = stateless_js.defaultStaticAccountsStruct();
        const instruction = await this.program.methods
            .transfer(encodedData)
            .accounts({
            feePayer: payer,
            authority: currentOwner,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
            lightSystemProgram: stateless_js.LightSystemProgram.programId,
            registeredProgramPda: registeredProgramPda,
            noopProgram: noopProgram,
            accountCompressionAuthority: accountCompressionAuthority,
            accountCompressionProgram: accountCompressionProgram,
            selfProgram: this.programId,
            tokenPoolPda: null,
            compressOrDecompressTokenAccount: null,
            tokenProgram: null,
        })
            .remainingAccounts(remainingAccountMetas)
            .instruction();
        return instruction;
    }
    /**
     * Create lookup table instructions for the token program's default accounts.
     */
    static async createTokenProgramLookupTable(params) {
        const { authority, mints, recentSlot, payer, remainingAccounts } = params;
        const [createInstruction, lookupTableAddress] = web3_js.AddressLookupTableProgram.createLookupTable({
            authority,
            payer: authority,
            recentSlot,
        });
        let optionalMintKeys = [];
        if (mints) {
            optionalMintKeys = [
                ...mints,
                ...mints.map(mint => this.deriveTokenPoolPda(mint)),
            ];
        }
        const extendInstruction = web3_js.AddressLookupTableProgram.extendLookupTable({
            payer,
            authority,
            lookupTable: lookupTableAddress,
            addresses: [
                this.deriveCpiAuthorityPda,
                stateless_js.LightSystemProgram.programId,
                stateless_js.defaultStaticAccountsStruct().registeredProgramPda,
                stateless_js.defaultStaticAccountsStruct().noopProgram,
                stateless_js.defaultStaticAccountsStruct().accountCompressionAuthority,
                stateless_js.defaultStaticAccountsStruct().accountCompressionProgram,
                stateless_js.defaultTestStateTreeAccounts().merkleTree,
                stateless_js.defaultTestStateTreeAccounts().nullifierQueue,
                stateless_js.defaultTestStateTreeAccounts().addressTree,
                stateless_js.defaultTestStateTreeAccounts().addressQueue,
                this.programId,
                splToken.TOKEN_PROGRAM_ID,
                splToken.TOKEN_2022_PROGRAM_ID,
                authority,
                ...optionalMintKeys,
                ...(remainingAccounts !== null && remainingAccounts !== void 0 ? remainingAccounts : []),
            ],
        });
        return {
            instructions: [createInstruction, extendInstruction],
            address: lookupTableAddress,
        };
    }
    /**
     * Create compress instruction
     * @returns compressInstruction
     */
    static async compress(params) {
        const { payer, owner, source, toAddress, mint, outputStateTree, tokenProgramId, } = params;
        if (Array.isArray(params.amount) !== Array.isArray(params.toAddress)) {
            throw new Error('Both amount and toAddress must be arrays or both must be single values');
        }
        let tokenTransferOutputs;
        if (Array.isArray(params.amount) && Array.isArray(params.toAddress)) {
            if (params.amount.length !== params.toAddress.length) {
                throw new Error('Amount and toAddress arrays must have the same length');
            }
            tokenTransferOutputs = params.amount.map((amt, index) => {
                const amount = stateless_js.bn(amt);
                return {
                    owner: params.toAddress[index],
                    amount,
                    lamports: stateless_js.bn(0),
                    tlv: null,
                };
            });
        }
        else {
            tokenTransferOutputs = [
                {
                    owner: toAddress,
                    amount: stateless_js.bn(params.amount),
                    lamports: stateless_js.bn(0),
                    tlv: null,
                },
            ];
        }
        const { inputTokenDataWithContext, packedOutputTokenData, remainingAccountMetas, } = packCompressedTokenAccounts({
            inputCompressedTokenAccounts: [],
            outputStateTrees: outputStateTree,
            rootIndices: [],
            tokenTransferOutputs,
        });
        const data = {
            proof: null,
            mint,
            delegatedTransfer: null, // TODO: implement
            inputTokenDataWithContext,
            outputCompressedAccounts: packedOutputTokenData,
            compressOrDecompressAmount: Array.isArray(params.amount)
                ? params.amount
                    .map(amt => new anchor.BN(amt))
                    .reduce((sum, amt) => sum.add(amt), new anchor.BN(0))
                : new anchor.BN(params.amount),
            isCompress: true,
            cpiContext: null,
            lamportsChangeAccountMerkleTreeIndex: null,
        };
        const encodedData = this.program.coder.types.encode('CompressedTokenInstructionDataTransfer', data);
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        const instruction = await this.program.methods
            .transfer(encodedData)
            .accounts({
            feePayer: payer,
            authority: owner,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
            lightSystemProgram: stateless_js.LightSystemProgram.programId,
            registeredProgramPda: stateless_js.defaultStaticAccountsStruct().registeredProgramPda,
            noopProgram: stateless_js.defaultStaticAccountsStruct().noopProgram,
            accountCompressionAuthority: stateless_js.defaultStaticAccountsStruct().accountCompressionAuthority,
            accountCompressionProgram: stateless_js.defaultStaticAccountsStruct().accountCompressionProgram,
            selfProgram: this.programId,
            tokenPoolPda: this.deriveTokenPoolPda(mint),
            compressOrDecompressTokenAccount: source, // token
            tokenProgram,
        })
            .remainingAccounts(remainingAccountMetas)
            .instruction();
        return instruction;
    }
    /**
     * Construct decompress instruction
     */
    static async decompress(params) {
        const { payer, inputCompressedTokenAccounts, toAddress, outputStateTree, recentValidityProof, recentInputStateRootIndices, tokenProgramId, } = params;
        const amount = stateless_js.bn(params.amount);
        const tokenTransferOutputs = createDecompressOutputState(inputCompressedTokenAccounts, amount);
        /// Pack
        const { inputTokenDataWithContext, packedOutputTokenData, remainingAccountMetas, } = packCompressedTokenAccounts({
            inputCompressedTokenAccounts,
            outputStateTrees: outputStateTree,
            rootIndices: recentInputStateRootIndices,
            tokenTransferOutputs: tokenTransferOutputs,
        });
        const { mint, currentOwner } = parseTokenData(inputCompressedTokenAccounts);
        const data = {
            proof: recentValidityProof,
            mint,
            delegatedTransfer: null, // TODO: implement
            inputTokenDataWithContext,
            outputCompressedAccounts: packedOutputTokenData,
            compressOrDecompressAmount: amount,
            isCompress: false,
            cpiContext: null,
            lamportsChangeAccountMerkleTreeIndex: null,
        };
        const encodedData = this.program.coder.types.encode('CompressedTokenInstructionDataTransfer', data);
        const { accountCompressionAuthority, noopProgram, registeredProgramPda, accountCompressionProgram, } = stateless_js.defaultStaticAccountsStruct();
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        const instruction = await this.program.methods
            .transfer(encodedData)
            .accounts({
            feePayer: payer,
            authority: currentOwner,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
            lightSystemProgram: stateless_js.LightSystemProgram.programId,
            registeredProgramPda: registeredProgramPda,
            noopProgram: noopProgram,
            accountCompressionAuthority: accountCompressionAuthority,
            accountCompressionProgram: accountCompressionProgram,
            selfProgram: this.programId,
            tokenPoolPda: this.deriveTokenPoolPda(mint),
            compressOrDecompressTokenAccount: toAddress,
            tokenProgram,
        })
            .remainingAccounts(remainingAccountMetas)
            .instruction();
        return instruction;
    }
    static async mergeTokenAccounts(params) {
        const { payer, owner, inputCompressedTokenAccounts, outputStateTree, recentValidityProof, recentInputStateRootIndices, } = params;
        if (inputCompressedTokenAccounts.length > 3) {
            throw new Error('Cannot merge more than 3 token accounts at once');
        }
        const ix = await this.transfer({
            payer,
            inputCompressedTokenAccounts,
            toAddress: owner,
            amount: inputCompressedTokenAccounts.reduce((sum, account) => sum.add(account.parsed.amount), new anchor.BN(0)),
            outputStateTrees: outputStateTree,
            recentInputStateRootIndices,
            recentValidityProof,
        });
        return [ix];
    }
    static async compressSplTokenAccount(params) {
        const { feePayer, authority, tokenAccount, mint, remainingAmount, outputStateTree, tokenProgramId, } = params;
        const tokenProgram = tokenProgramId !== null && tokenProgramId !== void 0 ? tokenProgramId : splToken.TOKEN_PROGRAM_ID;
        const remainingAccountMetas = [
            {
                pubkey: outputStateTree,
                isSigner: false,
                isWritable: true,
            },
        ];
        const instruction = await this.program.methods
            .compressSplTokenAccount(authority, remainingAmount !== null && remainingAmount !== void 0 ? remainingAmount : null, null)
            .accounts({
            feePayer,
            authority,
            cpiAuthorityPda: this.deriveCpiAuthorityPda,
            lightSystemProgram: stateless_js.LightSystemProgram.programId,
            registeredProgramPda: stateless_js.defaultStaticAccountsStruct().registeredProgramPda,
            noopProgram: stateless_js.defaultStaticAccountsStruct().noopProgram,
            accountCompressionAuthority: stateless_js.defaultStaticAccountsStruct().accountCompressionAuthority,
            accountCompressionProgram: stateless_js.defaultStaticAccountsStruct().accountCompressionProgram,
            selfProgram: this.programId,
            tokenPoolPda: this.deriveTokenPoolPda(mint),
            compressOrDecompressTokenAccount: tokenAccount,
            tokenProgram,
            systemProgram: web3_js.SystemProgram.programId,
        })
            .remainingAccounts(remainingAccountMetas)
            .instruction();
        return instruction;
    }
    static async get_mint_program_id(mint, connection) {
        var _a;
        return (_a = (await connection.getAccountInfo(mint))) === null || _a === void 0 ? void 0 : _a.owner;
    }
}
/**
 * Public key that identifies the CompressedPda program
 */
CompressedTokenProgram.programId = new web3_js.PublicKey('cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m');
CompressedTokenProgram._program = null;

/**
 * Mint compressed tokens to a solana address from an external mint authority
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to
 * @param authority      Minting authority
 * @param amount         Amount to mint
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
async function approveAndMintTo(rpc, payer, mint, destination, authority, amount, merkleTree, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    const authorityTokenAccount = await splToken.getOrCreateAssociatedTokenAccount(rpc, payer, mint, authority.publicKey, undefined, undefined, confirmOptions, tokenProgramId);
    const ixs = await CompressedTokenProgram.approveAndMintTo({
        feePayer: payer.publicKey,
        mint,
        authority: authority.publicKey,
        authorityTokenAccount: authorityTokenAccount.address,
        amount,
        toPubkey: destination,
        merkleTree,
        tokenProgramId,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [authority]);
    const tx = stateless_js.buildAndSignTx([
        web3_js.ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 }),
        ...ixs,
    ], payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/**
 * Compress SPL tokens
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the compressed token
 * @param amount                Number of tokens to transfer
 * @param owner                 Owner of the compressed tokens.
 * @param sourceTokenAccount    Source (associated) token account
 * @param toAddress             Destination address of the recipient
 * @param merkleTree            State tree account that the compressed tokens
 *                              should be inserted into. Defaults to a default
 *                              state tree account.
 * @param confirmOptions        Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
async function compress(rpc, payer, mint, amount, owner, sourceTokenAccount, toAddress, merkleTree, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    const compressIx = await CompressedTokenProgram.compress({
        payer: payer.publicKey,
        owner: owner.publicKey,
        source: sourceTokenAccount,
        toAddress,
        amount,
        mint,
        outputStateTree: merkleTree,
        tokenProgramId,
    });
    const blockhashCtx = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [owner]);
    const signedTx = stateless_js.buildAndSignTx([
        web3_js.ComputeBudgetProgram.setComputeUnitLimit({
            units: 1000000,
        }),
        compressIx,
    ], payer, blockhashCtx.blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, confirmOptions, blockhashCtx);
    return txId;
}

/**
 * Transfer compressed tokens from one owner to another
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination address of the recipient
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       inserted into. Defaults to the default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
async function transfer(rpc, payer, mint, amount, owner, toAddress, 
/// TODO: allow multiple
merkleTree, confirmOptions) {
    amount = stateless_js.bn(amount);
    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(owner.publicKey, {
        mint,
    });
    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(compressedTokenAccounts.items, amount);
    const proof = await rpc.getValidityProof(inputAccounts.map(account => stateless_js.bn(account.compressedAccount.hash)));
    const ix = await CompressedTokenProgram.transfer({
        payer: payer.publicKey,
        inputCompressedTokenAccounts: inputAccounts,
        toAddress,
        amount,
        recentInputStateRootIndices: proof.rootIndices,
        recentValidityProof: proof.compressedProof,
        outputStateTrees: merkleTree,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [owner]);
    const signedTx = stateless_js.buildAndSignTx([web3_js.ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 }), ix], payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, confirmOptions);
    return txId;
}
/**
 * Selects the minimal number of compressed token accounts for a transfer.
 *
 * 1. Sorts the accounts by amount in descending order
 * 2. Accumulates the amount until it is greater than or equal to the transfer
 *    amount
 */
function selectMinCompressedTokenAccountsForTransfer(accounts, transferAmount) {
    let accumulatedAmount = stateless_js.bn(0);
    let accumulatedLamports = stateless_js.bn(0);
    const selectedAccounts = [];
    accounts.sort((a, b) => b.parsed.amount.cmp(a.parsed.amount));
    for (const account of accounts) {
        if (accumulatedAmount.gte(stateless_js.bn(transferAmount)))
            break;
        accumulatedAmount = accumulatedAmount.add(account.parsed.amount);
        accumulatedLamports = accumulatedLamports.add(account.compressedAccount.lamports);
        selectedAccounts.push(account);
    }
    if (accumulatedAmount.lt(stateless_js.bn(transferAmount))) {
        throw new Error(`Not enough balance for transfer. Required: ${transferAmount.toString()}, available: ${accumulatedAmount.toString()}`);
    }
    return [
        selectedAccounts,
        accumulatedAmount,
        accumulatedLamports.lt(stateless_js.bn(0)) ? accumulatedLamports : null,
    ];
}

/**
 * Decompress compressed tokens
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint of the compressed token
 * @param amount         Number of tokens to transfer
 * @param owner          Owner of the compressed tokens
 * @param toAddress      Destination **uncompressed** (associated) token account
 *                       address.
 * @param merkleTree     State tree account that any change compressed tokens should be
 *                       inserted into. Defaults to a default state tree
 *                       account.
 * @param confirmOptions Options for confirming the transaction
 *
 *
 * @return Signature of the confirmed transaction
 */
async function decompress(rpc, payer, mint, amount, owner, toAddress, 
/// TODO: allow multiple
merkleTree, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    amount = stateless_js.bn(amount);
    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(owner.publicKey, {
        mint,
    });
    /// TODO: consider using a different selection algorithm
    const [inputAccounts] = selectMinCompressedTokenAccountsForTransfer(compressedTokenAccounts.items, amount);
    const proof = await rpc.getValidityProof(inputAccounts.map(account => stateless_js.bn(account.compressedAccount.hash)));
    const ix = await CompressedTokenProgram.decompress({
        payer: payer.publicKey,
        inputCompressedTokenAccounts: inputAccounts,
        toAddress, // TODO: add explicit check that it is a token account
        amount,
        outputStateTree: merkleTree,
        recentInputStateRootIndices: proof.rootIndices,
        recentValidityProof: proof.compressedProof,
        tokenProgramId,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [owner]);
    const signedTx = stateless_js.buildAndSignTx([web3_js.ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 }), ix], payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, confirmOptions);
    return txId;
}

/**
 * Create and initialize a new compressed token mint
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting
 * @param decimals        Location of the decimal place
 * @param keypair         Optional keypair, defaulting to a new random one
 * @param confirmOptions  Options for confirming the transaction
 * @param isToken22       Whether to create a Token 2022 mint. Defaults to false.
 *
 * @return Address of the new mint and the transaction signature
 */
async function createMint(rpc, payer, mintAuthority, decimals, keypair = web3_js.Keypair.generate(), confirmOptions, isToken22 = false) {
    const rentExemptBalance = await rpc.getMinimumBalanceForRentExemption(splToken.MINT_SIZE);
    const tokenProgramId = isToken22 ? splToken.TOKEN_2022_PROGRAM_ID : splToken.TOKEN_PROGRAM_ID;
    const ixs = await CompressedTokenProgram.createMint({
        feePayer: payer.publicKey,
        mint: keypair.publicKey,
        decimals,
        authority: mintAuthority,
        freezeAuthority: null, // TODO: add feature
        rentExemptBalance,
        tokenProgramId,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [keypair]);
    const tx = stateless_js.buildAndSignTx(ixs, payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, tx, confirmOptions);
    return { mint: keypair.publicKey, transactionSignature: txId };
}

/**
 * Mint compressed tokens to a solana address
 *
 * @param rpc            Rpc to use
 * @param payer          Payer of the transaction fees
 * @param mint           Mint for the account
 * @param destination    Address of the account to mint to. Can be an array of
 *                       addresses if the amount is an array of amounts.
 * @param authority      Minting authority
 * @param amount         Amount to mint. Can be an array of amounts if the
 *                       destination is an array of addresses.
 * @param merkleTree     State tree account that the compressed tokens should be
 *                       part of. Defaults to the default state tree account.
 * @param confirmOptions Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
async function mintTo(rpc, payer, mint, destination, authority, amount, merkleTree, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    const additionalSigners = stateless_js.dedupeSigner(payer, [authority]);
    const ix = await CompressedTokenProgram.mintTo({
        feePayer: payer.publicKey,
        mint,
        authority: authority.publicKey,
        amount: amount,
        toPubkey: destination,
        merkleTree,
        tokenProgramId,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const tx = stateless_js.buildAndSignTx([web3_js.ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 }), ix], payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/**
 * Merge multiple compressed token accounts for a given mint into a single
 * account
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction fees
 * @param mint            Public key of the token's mint
 * @param owner           Owner of the token accounts to be merged
 * @param merkleTree      Optional merkle tree for compressed tokens
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return Array of transaction signatures
 */
async function mergeTokenAccounts(rpc, payer, mint, owner, merkleTree, confirmOptions) {
    const compressedTokenAccounts = await rpc.getCompressedTokenAccountsByOwner(owner.publicKey, { mint });
    if (compressedTokenAccounts.items.length === 0) {
        throw new Error(`No compressed token accounts found for mint ${mint.toBase58()}`);
    }
    if (compressedTokenAccounts.items.length >= 6) {
        throw new Error(`Too many compressed token accounts used for mint ${mint.toBase58()}`);
    }
    const instructions = [
        web3_js.ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 }),
    ];
    for (let i = 0; i < compressedTokenAccounts.items.slice(0, 6).length; i += 3) {
        const batch = compressedTokenAccounts.items.slice(i, i + 3);
        const proof = await rpc.getValidityProof(batch.map(account => stateless_js.bn(account.compressedAccount.hash)));
        const batchInstructions = await CompressedTokenProgram.mergeTokenAccounts({
            payer: payer.publicKey,
            owner: owner.publicKey,
            mint,
            inputCompressedTokenAccounts: batch,
            outputStateTree: merkleTree,
            recentValidityProof: proof.compressedProof,
            recentInputStateRootIndices: proof.rootIndices,
        });
        instructions.push(...batchInstructions);
    }
    const { blockhash } = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [owner]);
    const signedTx = stateless_js.buildAndSignTx(instructions, payer, blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, confirmOptions);
    return txId;
}

/**
 * Register an existing mint with the CompressedToken program
 *
 * @param rpc             RPC to use
 * @param payer           Payer of the transaction and initialization fees
 * @param mintAuthority   Account or multisig that will control minting. Is signer.
 * @param mintAddress     Address of the existing mint
 * @param confirmOptions  Options for confirming the transaction
 *
 * @return transaction signature
 */
async function createTokenPool(rpc, payer, mint, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    const ix = await CompressedTokenProgram.createTokenPool({
        feePayer: payer.publicKey,
        mint,
        tokenProgramId,
    });
    const { blockhash } = await rpc.getLatestBlockhash();
    const tx = stateless_js.buildAndSignTx([ix], payer, blockhash);
    const txId = await stateless_js.sendAndConfirmTx(rpc, tx, confirmOptions);
    return txId;
}

/**
 * Create a lookup table for the token program's default accounts
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param authority             Authority of the lookup table
 * @param mints                 Optional array of mint public keys to include in
 *                              the lookup table
 * @param additionalAccounts    Optional array of additional account public keys
 *                              to include in the lookup table
 *
 * @return Transaction signatures and the address of the created lookup table
 */
async function createTokenProgramLookupTable(rpc, payer, authority, mints, additionalAccounts) {
    const recentSlot = await rpc.getSlot('finalized');
    const { instructions, address } = await CompressedTokenProgram.createTokenProgramLookupTable({
        payer: payer.publicKey,
        authority: authority.publicKey,
        mints,
        remainingAccounts: additionalAccounts,
        recentSlot,
    });
    const additionalSigners = stateless_js.dedupeSigner(payer, [authority]);
    const blockhashCtx = await rpc.getLatestBlockhash();
    const signedTx = stateless_js.buildAndSignTx([instructions[0]], payer, blockhashCtx.blockhash, additionalSigners);
    /// Must wait for the first instruction to be finalized.
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, { commitment: 'finalized' }, blockhashCtx);
    const blockhashCtx2 = await rpc.getLatestBlockhash();
    const signedTx2 = stateless_js.buildAndSignTx([instructions[1]], payer, blockhashCtx2.blockhash, additionalSigners);
    const txId2 = await stateless_js.sendAndConfirmTx(rpc, signedTx2, { commitment: 'finalized' }, blockhashCtx2);
    return { txIds: [txId, txId2], address };
}

/**
 * Compress SPL tokens into compressed token format
 *
 * @param rpc                   Rpc connection to use
 * @param payer                 Payer of the transaction fees
 * @param mint                  Mint of the token to compress
 * @param owner                 Owner of the token account
 * @param tokenAccount         Token account to compress
 * @param outputStateTree       State tree to insert the compressed token account into
 * @param remainingAmount      Optional: amount to leave in token account. Default: 0
 * @param confirmOptions       Options for confirming the transaction
 *
 * @return Signature of the confirmed transaction
 */
async function compressSplTokenAccount(rpc, payer, mint, owner, tokenAccount, outputStateTree, remainingAmount, confirmOptions, tokenProgramId) {
    tokenProgramId = tokenProgramId
        ? tokenProgramId
        : await CompressedTokenProgram.get_mint_program_id(mint, rpc);
    const compressIx = await CompressedTokenProgram.compressSplTokenAccount({
        feePayer: payer.publicKey,
        authority: owner.publicKey,
        tokenAccount,
        mint,
        remainingAmount,
        outputStateTree,
        tokenProgramId,
    });
    const blockhashCtx = await rpc.getLatestBlockhash();
    const additionalSigners = stateless_js.dedupeSigner(payer, [owner]);
    const signedTx = stateless_js.buildAndSignTx([
        web3_js.ComputeBudgetProgram.setComputeUnitLimit({
            units: 1000000,
        }),
        compressIx,
    ], payer, blockhashCtx.blockhash, additionalSigners);
    const txId = await stateless_js.sendAndConfirmTx(rpc, signedTx, confirmOptions, blockhashCtx);
    return txId;
}

exports.CPI_AUTHORITY_SEED = CPI_AUTHORITY_SEED;
exports.CompressedTokenProgram = CompressedTokenProgram;
exports.IDL = IDL;
exports.POOL_SEED = POOL_SEED;
exports.SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE = SPL_TOKEN_MINT_RENT_EXEMPT_BALANCE;
exports.approveAndMintTo = approveAndMintTo;
exports.compress = compress;
exports.compressSplTokenAccount = compressSplTokenAccount;
exports.createDecompressOutputState = createDecompressOutputState;
exports.createMint = createMint;
exports.createTokenPool = createTokenPool;
exports.createTokenProgramLookupTable = createTokenProgramLookupTable;
exports.createTransferOutputState = createTransferOutputState;
exports.decompress = decompress;
exports.mergeTokenAccounts = mergeTokenAccounts;
exports.mintTo = mintTo;
exports.packCompressedTokenAccounts = packCompressedTokenAccounts;
exports.parseTokenData = parseTokenData;
exports.selectMinCompressedTokenAccountsForTransfer = selectMinCompressedTokenAccountsForTransfer;
exports.sumUpTokenAmount = sumUpTokenAmount;
exports.transfer = transfer;
exports.validateSameTokenOwner = validateSameTokenOwner;
//# sourceMappingURL=index.cjs.map
