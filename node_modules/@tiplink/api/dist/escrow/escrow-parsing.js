"use strict";
// This file is largely copied / shared with anchor program repo
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRecordedEscrowActionsFromTx = exports.getRecordedEscrowActionsFromVault = exports.getAllRecordedEscrowActions = exports.parseEscrowTx = exports.parseEscrowIx = exports.deserializeRecordedEscrowActions = exports.serializeRecordedEscrowActions = exports.EscrowActionType = void 0;
require("dotenv/config");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const tiplink_escrow_1 = require("./anchor-generated/types/tiplink_escrow"); // This is different in anchor program repo
const helpers_1 = require("../helpers");
const constants_1 = require("./constants");
var EscrowActionType;
(function (EscrowActionType) {
    EscrowActionType["DepositLamport"] = "DepositLamport";
    EscrowActionType["WithdrawLamport"] = "WithdrawLamport";
    EscrowActionType["DepositSpl"] = "DepositSpl";
    EscrowActionType["WithdrawSpl"] = "WithdrawSpl";
})(EscrowActionType = exports.EscrowActionType || (exports.EscrowActionType = {}));
function serializeRecordedEscrowActions(recordedActions) {
    return recordedActions.map((recordedAction) => {
        let serializedAction;
        switch (recordedAction.action.type) {
            case EscrowActionType.DepositLamport:
                serializedAction = Object.assign(Object.assign({}, recordedAction), { action: Object.assign(Object.assign({}, recordedAction.action), { pda: recordedAction.action.pda.toBase58(), depositor: recordedAction.action.depositor.toBase58(), receiverTipLink: recordedAction.action.receiverTipLink.toBase58() }) });
                break;
            case EscrowActionType.WithdrawLamport:
                serializedAction = Object.assign(Object.assign({}, recordedAction), { action: Object.assign(Object.assign({}, recordedAction.action), { pda: recordedAction.action.pda.toBase58(), authority: recordedAction.action.authority.toBase58(), destination: recordedAction.action.destination.toBase58() }) });
                break;
            case EscrowActionType.DepositSpl:
                serializedAction = Object.assign(Object.assign({}, recordedAction), { action: Object.assign(Object.assign({}, recordedAction.action), { pda: recordedAction.action.pda.toBase58(), depositor: recordedAction.action.depositor.toBase58(), receiverTipLink: recordedAction.action.receiverTipLink.toBase58(), mint: recordedAction.action.mint.address.toBase58() }) });
                break;
            case EscrowActionType.WithdrawSpl:
                serializedAction = Object.assign(Object.assign({}, recordedAction), { action: Object.assign(Object.assign({}, recordedAction.action), { pda: recordedAction.action.pda.toBase58(), authority: recordedAction.action.authority.toBase58(), destination: recordedAction.action.destination.toBase58(), mint: recordedAction.action.mint.address.toBase58() }) });
                break;
            default:
                throw new Error("Unknown action type");
        }
        return serializedAction;
    });
}
exports.serializeRecordedEscrowActions = serializeRecordedEscrowActions;
function deserializeRecordedEscrowActions(connection, serializedRecordedActions) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(serializedRecordedActions.map((serializedRecordedAction) => __awaiter(this, void 0, void 0, function* () {
            if (serializedRecordedAction.action.type === EscrowActionType.DepositLamport) {
                return Object.assign(Object.assign({}, serializedRecordedAction), { action: Object.assign(Object.assign({}, serializedRecordedAction.action), { pda: new web3_js_1.PublicKey(serializedRecordedAction.action.pda), depositor: new web3_js_1.PublicKey(serializedRecordedAction.action.depositor), receiverTipLink: new web3_js_1.PublicKey(serializedRecordedAction.action.receiverTipLink) }) });
            }
            if (serializedRecordedAction.action.type ===
                EscrowActionType.WithdrawLamport) {
                return Object.assign(Object.assign({}, serializedRecordedAction), { action: Object.assign(Object.assign({}, serializedRecordedAction.action), { pda: new web3_js_1.PublicKey(serializedRecordedAction.action.pda), authority: new web3_js_1.PublicKey(serializedRecordedAction.action.authority), destination: new web3_js_1.PublicKey(serializedRecordedAction.action.destination) }) });
            }
            if (serializedRecordedAction.action.type === EscrowActionType.DepositSpl) {
                // eslint-disable-next-line no-case-declarations
                const mint = yield (0, spl_token_1.getMint)(connection, new web3_js_1.PublicKey(serializedRecordedAction.action.mint));
                return Object.assign(Object.assign({}, serializedRecordedAction), { action: Object.assign(Object.assign({}, serializedRecordedAction.action), { pda: new web3_js_1.PublicKey(serializedRecordedAction.action.pda), depositor: new web3_js_1.PublicKey(serializedRecordedAction.action.depositor), receiverTipLink: new web3_js_1.PublicKey(serializedRecordedAction.action.receiverTipLink), mint }) });
            }
            if (serializedRecordedAction.action.type === EscrowActionType.WithdrawSpl) {
                // eslint-disable-next-line no-case-declarations
                const mint = yield (0, spl_token_1.getMint)(connection, new web3_js_1.PublicKey(serializedRecordedAction.action.mint));
                return Object.assign(Object.assign({}, serializedRecordedAction), { action: Object.assign(Object.assign({}, serializedRecordedAction.action), { pda: new web3_js_1.PublicKey(serializedRecordedAction.action.pda), authority: new web3_js_1.PublicKey(serializedRecordedAction.action.authority), destination: new web3_js_1.PublicKey(serializedRecordedAction.action.destination), mint }) });
            }
            throw new Error("Unknown action type");
        })));
    });
}
exports.deserializeRecordedEscrowActions = deserializeRecordedEscrowActions;
function parseEscrowIx(connection, compIx, accountKeys) {
    return __awaiter(this, void 0, void 0, function* () {
        const coder = new anchor_1.BorshInstructionCoder(tiplink_escrow_1.IDL);
        let ix;
        // CompiledInstruction uses a base58 string
        if (typeof compIx.data === "string") {
            ix = coder.decode(compIx.data, "base58");
            // MessageCompiledInstruction uses a Uint8Array
        }
        else {
            ix = coder.decode(Buffer.from(compIx.data), "base58");
        }
        if (!ix) {
            return undefined;
        }
        let keyIndices;
        if ("accounts" in compIx) {
            keyIndices = compIx.accounts;
        }
        else {
            keyIndices = compIx.accountKeyIndexes;
        }
        // TODO: Get desired indices from IDL instead of magic numbers
        if (ix.name === "initializeLamport") {
            const { amount } = ix.data;
            return {
                type: EscrowActionType.DepositLamport,
                depositor: accountKeys[keyIndices[0]],
                pda: accountKeys[keyIndices[1]],
                receiverTipLink: accountKeys[keyIndices[3]],
                amount: amount.toNumber(),
            };
        }
        if (ix.name === "withdrawLamport") {
            return {
                type: EscrowActionType.WithdrawLamport,
                authority: accountKeys[keyIndices[0]],
                destination: accountKeys[keyIndices[1]],
                pda: accountKeys[keyIndices[2]],
            };
        }
        if (ix.name === "initializeSpl") {
            const { amount } = ix.data;
            const mint = yield (0, spl_token_1.getMint)(connection, accountKeys[keyIndices[6]]);
            return {
                type: EscrowActionType.DepositSpl,
                depositor: accountKeys[keyIndices[0]],
                pda: accountKeys[keyIndices[2]],
                receiverTipLink: accountKeys[keyIndices[5]],
                amount: amount.toNumber(),
                mint,
            };
        }
        if (ix.name === "withdrawSpl") {
            const mint = yield (0, spl_token_1.getMint)(connection, accountKeys[keyIndices[5]]);
            return {
                type: EscrowActionType.WithdrawSpl,
                authority: accountKeys[keyIndices[0]],
                destination: accountKeys[keyIndices[1]],
                pda: accountKeys[keyIndices[3]],
                mint,
            };
        }
        throw new Error("Unknown escrow instruction");
    });
}
exports.parseEscrowIx = parseEscrowIx;
/**
 * @remarks Only use this on the backend for a custom parsing setup. Otherwise,
 * use `getRecordedEscrowActionsFromTx`
 */
function parseEscrowTx(connection, sig) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return __awaiter(this, void 0, void 0, function* () {
        // Get transaction details
        const txRes = yield connection.getTransaction(sig, {
            maxSupportedTransactionVersion: 1,
        });
        if (!txRes || ((_a = txRes.meta) === null || _a === void 0 ? void 0 : _a.err)) {
            return [];
        }
        // Get slot
        const { slot } = txRes;
        const { blockTime } = txRes;
        // Get account keys
        const accountKeys = txRes.transaction.message.staticAccountKeys;
        const writeLutKeys = (_d = (_c = (_b = txRes.meta) === null || _b === void 0 ? void 0 : _b.loadedAddresses) === null || _c === void 0 ? void 0 : _c.writable.map((str) => new web3_js_1.PublicKey(str))) !== null && _d !== void 0 ? _d : [];
        const readLutKeys = (_g = (_f = (_e = txRes.meta) === null || _e === void 0 ? void 0 : _e.loadedAddresses) === null || _f === void 0 ? void 0 : _f.readonly.map((str) => new web3_js_1.PublicKey(str))) !== null && _g !== void 0 ? _g : [];
        // Writeable addresses come first
        accountKeys.push(...writeLutKeys, ...readLutKeys);
        const { compiledInstructions: outerIxs } = txRes.transaction.message;
        // Parse outer instructions
        const recordedActions = yield Promise.all(outerIxs.map((ix, index) => __awaiter(this, void 0, void 0, function* () {
            const action = yield parseEscrowIx(connection, ix, accountKeys);
            if (!action) {
                return undefined;
            }
            return {
                slot,
                blockTime,
                txSig: sig,
                ixIndex: index,
                action,
            };
        })));
        // Parse inner instructions
        const compiledInnerIxs = ((_h = txRes.meta) === null || _h === void 0 ? void 0 : _h.innerInstructions) || [];
        const recordedInnerActions = yield Promise.all(compiledInnerIxs.map((compInnerIx) => __awaiter(this, void 0, void 0, function* () {
            const innerActions = yield Promise.all(compInnerIx.instructions.map((innerIx, innerIndex) => __awaiter(this, void 0, void 0, function* () {
                const action = yield parseEscrowIx(connection, innerIx, accountKeys);
                if (!action) {
                    return undefined;
                }
                return {
                    slot,
                    blockTime,
                    txSig: sig,
                    ixIndex: compInnerIx.index,
                    innerIxIndex: innerIndex,
                    action,
                };
            })));
            return innerActions;
        })));
        // Combine outer and inner actions
        recordedActions.push(...recordedInnerActions.flat());
        // Filter undefined
        const filteredRecordedActions = recordedActions.filter((action) => action !== undefined);
        return filteredRecordedActions;
    });
}
exports.parseEscrowTx = parseEscrowTx;
/**
 * @remarks Only use this on the backend for a custom parsing setup. Otherwise,
 * use `getRecordedEscrowActionsFromVault`
 * @param delay - Delay between RPC requests to avoid rate limiting
 */
function getAllRecordedEscrowActions(connection, pda, delayMs = 400) {
    return __awaiter(this, void 0, void 0, function* () {
        // Limit set to 1,000
        const totalSigInfos = [];
        let sigInfos = yield connection.getSignaturesForAddress(pda);
        while (sigInfos.length > 0) {
            totalSigInfos.push(...sigInfos);
            // eslint-disable-next-line no-await-in-loop
            sigInfos = yield connection.getSignaturesForAddress(pda, {
                before: sigInfos[sigInfos.length - 1].signature,
            });
        }
        const sigs = totalSigInfos.map((sigInfo) => sigInfo.signature);
        const totalRecordedActions = [];
        for (const sig of sigs) {
            // eslint-disable-next-line no-await-in-loop
            const recordedActions = yield parseEscrowTx(connection, sig);
            totalRecordedActions.push(...recordedActions);
            // eslint-disable-next-line no-await-in-loop
            yield (0, helpers_1.sleep)(delayMs);
        }
        // Sort by most recent
        totalRecordedActions.sort((a, b) => {
            // Try slot first
            if (a.slot !== b.slot) {
                return b.slot - a.slot;
            }
            // If in the same transaction (unlikely), sort by index
            if (a.txSig !== b.txSig) {
                return b.ixIndex - a.ixIndex;
            }
            // If in the same index (unlikely), sort by inner index
            if (a.innerIxIndex !== undefined && b.innerIxIndex !== undefined) {
                return b.innerIxIndex - a.innerIxIndex;
            }
            // Otherwise (unlikely), just return 0
            // It may be possible to see the order of transactions in a block but this is
            // overkill
            return 0;
        });
        return totalRecordedActions;
    });
}
exports.getAllRecordedEscrowActions = getAllRecordedEscrowActions;
function getRecordedEscrowActionsFromVault(connection, pda) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetch(`${constants_1.INDEXER_URL_BASE}/api/v1/escrow/${pda.toBase58()}`);
        const json = yield res.json();
        const { data } = json;
        const serializedRecordedActions = data.recordedEscrowActions;
        return deserializeRecordedEscrowActions(connection, serializedRecordedActions);
    });
}
exports.getRecordedEscrowActionsFromVault = getRecordedEscrowActionsFromVault;
function getRecordedEscrowActionsFromTx(connection, sig) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetch(`${constants_1.INDEXER_URL_BASE}/api/v1/transaction/${sig}`);
        const json = yield res.json();
        const { data } = json;
        const serializedRecordedActions = data.recordedEscrowActions;
        return deserializeRecordedEscrowActions(connection, serializedRecordedActions);
    });
}
exports.getRecordedEscrowActionsFromTx = getRecordedEscrowActionsFromTx;
