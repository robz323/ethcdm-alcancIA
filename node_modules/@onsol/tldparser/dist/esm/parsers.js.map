{"version":3,"file":"parsers.js","sourceRoot":"","sources":["../../src/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { PublicKey, Connection } from '@solana/web3.js';\nimport { BN } from 'bn.js';\n\nimport { MainDomain } from './state/main-domain';\nimport { NameRecordHeader } from './state/name-record-header';\nimport {\n    delay,\n    findMainDomain,\n    findNameHouse,\n    findOwnedNameAccountsForUser,\n    findTldHouse,\n    getAllTld,\n    getHashedName,\n    getNameAccountKeyWithBump,\n    getNameOwner,\n    getOriginNameAccountKey,\n    getParsedAllDomainsNftAccountsByOwner,\n    performReverseLookupBatched,\n} from './utils';\nimport { MULTIPLE_ACCOUNT_INFO_MAX } from './constants';\nimport { NameAccountAndDomain, getDomainKey } from './name-record-handler';\n\nexport class TldParser {\n    constructor(private readonly connection: Connection) {}\n\n    /**\n     * retrieves all nameAccounts for any user.\n     *\n     * @param userAccount user publickey or string\n     */\n    async getAllUserDomains(\n        userAccount: PublicKey | string,\n    ): Promise<PublicKey[]> {\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        const allDomains = await findOwnedNameAccountsForUser(\n            this.connection,\n            userAccount,\n            undefined,\n        );\n        return allDomains;\n    }\n\n    /**\n     * retrieves all nameaccounts for any user in a specific tld.\n     *\n     * @param userAccount user publickey or string\n     * @param tld tld to be retrieved from\n     */\n    async getAllUserDomainsFromTld(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<PublicKey[]> {\n        const tldName = '.' + tld;\n\n        const nameOriginTldKey = await getOriginNameAccountKey();\n        const parentHashedName = await getHashedName(tldName);\n        const [parentAccountKey] = getNameAccountKeyWithBump(\n            parentHashedName,\n            undefined,\n            nameOriginTldKey,\n        );\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        const allDomains = await findOwnedNameAccountsForUser(\n            this.connection,\n            userAccount,\n            parentAccountKey,\n        );\n        return allDomains;\n    }\n\n    /**\n     * retrieves owner of a specific Name Account from domain.tld.\n     *\n     * @param domainTld full string of domain and tld e.g. \"miester.poor\"\n     */\n    async getOwnerFromDomainTld(\n        domainTld: string,\n    ): Promise<PublicKey | undefined> {\n        const domainTldSplit = domainTld.split('.');\n        const domain = domainTldSplit[0];\n        const tldName = '.' + domainTldSplit[1];\n\n        const nameOriginTldKey = await getOriginNameAccountKey();\n        const parentHashedName = await getHashedName(tldName);\n        const [parentAccountKey] = getNameAccountKeyWithBump(\n            parentHashedName,\n            undefined,\n            nameOriginTldKey,\n        );\n\n        const domainHashedName = await getHashedName(domain);\n        const [domainAccountKey] = getNameAccountKeyWithBump(\n            domainHashedName,\n            undefined,\n            parentAccountKey,\n        );\n\n        const [tldHouse] = findTldHouse(tldName);\n\n        const nameOwner = await getNameOwner(\n            this.connection,\n            domainAccountKey,\n            tldHouse,\n        );\n        return nameOwner;\n    }\n\n    /**\n     * retrieves domainTld data a domain from domain.tld.\n     *\n     * @param domainTld full string of domain and tld e.g. \"miester.poor\"\n     */\n    async getNameRecordFromDomainTld(\n        domainTld: string,\n    ): Promise<NameRecordHeader | undefined> {\n        const domainTldSplit = domainTld.split('.');\n        const domain = domainTldSplit[0];\n        const tldName = '.' + domainTldSplit[1];\n\n        const nameOriginTldKey = await getOriginNameAccountKey();\n        const parentHashedName = await getHashedName(tldName);\n        const [parentAccountKey] = getNameAccountKeyWithBump(\n            parentHashedName,\n            undefined,\n            nameOriginTldKey,\n        );\n\n        const domainHashedName = await getHashedName(domain);\n        const [domainAccountKey] = getNameAccountKeyWithBump(\n            domainHashedName,\n            undefined,\n            parentAccountKey,\n        );\n        const nameRecord = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            domainAccountKey,\n        );\n        return nameRecord;\n    }\n\n    /**\n     * retrieves tld from parent name via TldHouse account.\n     *\n     * @param parentAccount parent publickey or string\n     */\n    async getTldFromParentAccount(\n        parentAccount: PublicKey | string,\n    ): Promise<string> {\n        if (typeof parentAccount == 'string') {\n            parentAccount = new PublicKey(parentAccount);\n        }\n        const parentNameAccount = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            parentAccount,\n        );\n\n        const tldHouseData = await this.connection.getAccountInfo(\n            parentNameAccount?.owner!,\n        );\n        const tldStart = 8 + 32 + 32 + 32;\n        const tldBuffer = tldHouseData?.data?.subarray(tldStart);\n        const nameLength = new BN(tldBuffer?.subarray(0, 4), 'le').toNumber();\n        const tld = tldBuffer\n            .subarray(4, 4 + nameLength)\n            .toString()\n            .replace(/\\0.*$/g, '');\n        return tld;\n    }\n    \n    /**\n     * retrieves domain from name account via tldParent account.\n     *\n     * @param nameAccount name publickey or string\n     * @param parentAccountOwner parent Owner or string (TldHouse)\n     */\n    async reverseLookupNameAccount(\n        nameAccount: PublicKey | string,\n        parentAccountOwner: PublicKey | string,\n    ): Promise<string> {\n        if (typeof nameAccount == 'string') {\n            nameAccount = new PublicKey(nameAccount);\n        }\n        if (typeof parentAccountOwner == 'string') {\n            parentAccountOwner = new PublicKey(parentAccountOwner);\n        }\n\n        const reverseLookupHashedName = await getHashedName(\n            nameAccount.toString(),\n        );\n        const [reverseLookupAccount] = getNameAccountKeyWithBump(\n            reverseLookupHashedName,\n            parentAccountOwner,\n            undefined,\n        );\n\n        const reverseLookUpResult = await NameRecordHeader.fromAccountAddress(\n            this.connection,\n            reverseLookupAccount,\n        );\n        const domain = reverseLookUpResult?.data?.toString();\n        return domain;\n    }\n\n    /**\n     * retrieves main domain name account and its domain tld from user address.\n     *\n     * @param userAddress user publickey or string\n     */\n    async getMainDomain(userAddress: PublicKey | string): Promise<MainDomain> {\n        if (typeof userAddress == 'string') {\n            userAddress = new PublicKey(userAddress);\n        }\n\n        const [mainDomainAddress] = findMainDomain(userAddress);\n        const mainDomain = await MainDomain.fromAccountAddress(\n            this.connection,\n            mainDomainAddress,\n        );\n        return mainDomain;\n    }\n\n    /**\n     * retrieves all parsed domains as strings with name accounts in an array for user in a specific TLD.\n     * in alphabetical order\n     *\n     * @param userAccount user publickey or string\n     * @param tld tld to be retrieved from\n     */\n    async getParsedAllUserDomainsFromTldUnwrapped(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<NameAccountAndDomain[]> {\n        const tldName = '.' + tld;\n\n        const nameOriginTldKey = await getOriginNameAccountKey();\n        const parentHashedName = await getHashedName(tldName);\n        const [tldHouse] = findTldHouse(tldName);\n        const [parentAccountKey] = getNameAccountKeyWithBump(\n            parentHashedName,\n            undefined,\n            nameOriginTldKey,\n        );\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        const allDomains = await findOwnedNameAccountsForUser(\n            this.connection,\n            userAccount,\n            parentAccountKey,\n        );\n        let parsedNameAccountsAndDomains: NameAccountAndDomain[] = [];\n\n        for (let i = 0; i < allDomains.length; i += MULTIPLE_ACCOUNT_INFO_MAX) {\n            await delay(100);\n            const end = Math.min(\n                i + MULTIPLE_ACCOUNT_INFO_MAX,\n                allDomains.length,\n            );\n            const batch = allDomains.slice(i, end);\n            const batchReverseLookup = await performReverseLookupBatched(\n                this.connection,\n                batch,\n                tldHouse,\n            );\n            const domainsWithTldsAndNameAccounts = batchReverseLookup.map(\n                (domain, index) => {\n                    return {\n                        nameAccount: batch[index],\n                        domain: domain + tldName,\n                    };\n                },\n            );\n            if (domainsWithTldsAndNameAccounts.length > 0) {\n                domainsWithTldsAndNameAccounts.sort((a, b) =>\n                    a.domain.localeCompare(b.domain, undefined, {\n                        numeric: true,\n                        sensitivity: 'base',\n                    }),\n                );\n            }\n            parsedNameAccountsAndDomains.push(\n                ...domainsWithTldsAndNameAccounts,\n            );\n        }\n        return parsedNameAccountsAndDomains;\n    }\n\n    /**\n     * retrieves all parsed domains and name accounts including NFTs in an array for any user in a specific TLD.\n     * in alphabetical order\n     *\n     * @param userAccount user publickey or string\n     * @param tld tld to be retrieved from\n     */\n    async getParsedAllUserDomainsFromTld(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<NameAccountAndDomain[]> {\n        const tldName = '.' + tld;\n\n        const nameOriginTldKey = await getOriginNameAccountKey();\n        const parentHashedName = await getHashedName(tldName);\n        const [tldHouse] = findTldHouse(tldName);\n        const [parentAccountKey] = getNameAccountKeyWithBump(\n            parentHashedName,\n            undefined,\n            nameOriginTldKey,\n        );\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        const allDomains = await findOwnedNameAccountsForUser(\n            this.connection,\n            userAccount,\n            parentAccountKey,\n        );\n        let parsedNameAccountsAndDomains: NameAccountAndDomain[] = [];\n\n        const allNFTDomains = await getParsedAllDomainsNftAccountsByOwner(\n            userAccount,\n            this.connection,\n            findNameHouse(tldHouse)[0],\n        );\n        const nftDomainsWithTlds = allNFTDomains.map(domain => {\n            return domain + tldName;\n        });\n        const domainsWithTldsAndNameAccounts = await Promise.all(\n            nftDomainsWithTlds.map(async domain => {\n                return {\n                    nameAccount: (await getDomainKey(domain)).pubkey,\n                    domain,\n                };\n            }),\n        );\n\n        parsedNameAccountsAndDomains.push(...domainsWithTldsAndNameAccounts);\n\n        for (let i = 0; i < allDomains.length; i += MULTIPLE_ACCOUNT_INFO_MAX) {\n            await delay(100);\n            const end = Math.min(\n                i + MULTIPLE_ACCOUNT_INFO_MAX,\n                allDomains.length,\n            );\n            const batch = allDomains.slice(i, end);\n            const batchReverseLookup = await performReverseLookupBatched(\n                this.connection,\n                batch,\n                tldHouse,\n            );\n            const domainsWithTldsAndNameAccounts = batchReverseLookup.map(\n                (domain, index) => {\n                    return {\n                        nameAccount: batch[index],\n                        domain: domain + tldName,\n                    };\n                },\n            );\n            parsedNameAccountsAndDomains.push(\n                ...domainsWithTldsAndNameAccounts,\n            );\n        }\n        if (parsedNameAccountsAndDomains.length > 0) {\n            parsedNameAccountsAndDomains.sort((a, b) =>\n                a.domain.localeCompare(b.domain, undefined, {\n                    numeric: true,\n                    sensitivity: 'base',\n                }),\n            );\n        }\n        return parsedNameAccountsAndDomains;\n    }\n\n    /**\n     * retrieves all parsed domains and name accounts for user.\n     * in alphabetical order\n     *\n     * @param userAccount user publickey or string\n     * @param tld tld to be retrieved from\n     */\n    async getParsedAllUserDomainsUnwrapped(\n        userAccount: PublicKey | string,\n    ): Promise<NameAccountAndDomain[]> {\n        const allTlds = await getAllTld(this.connection);\n        let parsedNameAccountsAndDomains: NameAccountAndDomain[] = [];\n\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        for (let { parentAccount, tld } of allTlds) {\n            let tldName = tld.toString();\n            const [tldHouse] = findTldHouse(tldName);\n            const allDomains = await findOwnedNameAccountsForUser(\n                this.connection,\n                userAccount,\n                parentAccount,\n            );\n\n            for (\n                let i = 0;\n                i < allDomains.length;\n                i += MULTIPLE_ACCOUNT_INFO_MAX\n            ) {\n                await delay(100);\n                const end = Math.min(\n                    i + MULTIPLE_ACCOUNT_INFO_MAX,\n                    allDomains.length,\n                );\n                const batch = allDomains.slice(i, end);\n                const batchReverseLookup = await performReverseLookupBatched(\n                    this.connection,\n                    batch,\n                    tldHouse,\n                );\n                const domainsWithTldsAndNameAccounts = batchReverseLookup.map(\n                    (domain, index) => {\n                        return {\n                            nameAccount: batch[index],\n                            domain: domain + tldName,\n                        };\n                    },\n                );\n                parsedNameAccountsAndDomains.push(\n                    ...domainsWithTldsAndNameAccounts,\n                );\n            }\n        }\n        if (parsedNameAccountsAndDomains.length > 0) {\n            parsedNameAccountsAndDomains.sort((a, b) =>\n                a.domain.localeCompare(b.domain, undefined, {\n                    numeric: true,\n                    sensitivity: 'base',\n                }),\n            );\n        }\n        return parsedNameAccountsAndDomains;\n    }\n\n    /**\n     * retrieves all parsed domains and name accounts including NFTs for user.\n     * in alphabetical order\n     *\n     * @param userAccount user publickey or string\n     * @param tld tld to be retrieved from\n     */\n    async getParsedAllUserDomains(\n        userAccount: PublicKey | string,\n    ): Promise<NameAccountAndDomain[]> {\n        const allTlds = await getAllTld(this.connection);\n        let parsedNameAccountsAndDomains: NameAccountAndDomain[] = [];\n\n        if (typeof userAccount == 'string') {\n            userAccount = new PublicKey(userAccount);\n        }\n        for (let { parentAccount, tld } of allTlds) {\n            let tldName = tld.toString();\n            const [tldHouse] = findTldHouse(tldName);\n            const allDomains = await findOwnedNameAccountsForUser(\n                this.connection,\n                userAccount,\n                parentAccount,\n            );\n            const allNFTDomains = await getParsedAllDomainsNftAccountsByOwner(\n                userAccount,\n                this.connection,\n                findNameHouse(tldHouse)[0],\n            );\n            const nftDomainsWithTlds = allNFTDomains.map(domain => {\n                return domain + tldName;\n            });\n            const domainsWithTldsAndNameAccounts = await Promise.all(\n                nftDomainsWithTlds.map(async domain => {\n                    return {\n                        nameAccount: (await getDomainKey(domain)).pubkey,\n                        domain,\n                    };\n                }),\n            );\n\n            parsedNameAccountsAndDomains.push(\n                ...domainsWithTldsAndNameAccounts,\n            );\n\n            for (\n                let i = 0;\n                i < allDomains.length;\n                i += MULTIPLE_ACCOUNT_INFO_MAX\n            ) {\n                await delay(100);\n                const end = Math.min(\n                    i + MULTIPLE_ACCOUNT_INFO_MAX,\n                    allDomains.length,\n                );\n                const batch = allDomains.slice(i, end);\n                const batchReverseLookup = await performReverseLookupBatched(\n                    this.connection,\n                    batch,\n                    tldHouse,\n                );\n                const domainsWithTldsAndNameAccounts = batchReverseLookup.map(\n                    (domain, index) => {\n                        return {\n                            nameAccount: batch[index],\n                            domain: domain + tldName,\n                        };\n                    },\n                );\n                parsedNameAccountsAndDomains.push(\n                    ...domainsWithTldsAndNameAccounts,\n                );\n            }\n        }\n        if (parsedNameAccountsAndDomains.length > 0) {\n            parsedNameAccountsAndDomains.sort((a, b) =>\n                a.domain.localeCompare(b.domain, undefined, {\n                    numeric: true,\n                    sensitivity: 'base',\n                }),\n            );\n        }\n        return parsedNameAccountsAndDomains;\n    }\n}\n"]}