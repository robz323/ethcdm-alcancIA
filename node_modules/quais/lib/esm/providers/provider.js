import { defineProperties, getBigInt, getNumber, hexlify, resolveProperties, assert, assertArgument, isError, makeError, } from '../utils/index.js';
import { computeAddress } from '../address/index.js';
import { accessListify } from '../transaction/index.js';
const BN_0 = BigInt(0);
import { toShard, toZone } from '../constants/index.js';
import { getZoneFromNodeLocation, getZoneForAddress } from '../utils/shards.js';
/**
 * Get the value if it is not null or undefined.
 *
 * @ignore
 * @param {undefined | null | T} value - The value to check.
 * @returns {null | T} The value if not null or undefined, otherwise null.
 */
function getValue(value) {
    if (value == null) {
        return null;
    }
    return value;
}
/**
 * Convert a value to a JSON-friendly string.
 *
 * @ignore
 * @param {null | bigint | string} value - The value to convert.
 * @returns {null | string} The JSON-friendly string or null.
 */
function toJson(value) {
    if (value == null) {
        return null;
    }
    return value.toString();
}
/**
 * A **FeeData** wraps all the fee-related values associated with the network.
 *
 * @category Providers
 */
export class FeeData {
    /**
     * The gas price for legacy networks.
     */
    gasPrice;
    /**
     * The additional amount to pay per gas to encourage a validator to include the transaction.
     *
     * The purpose of this is to compensate the validator for the adjusted risk for including a given transaction.
     *
     * This will be `null` on legacy networks (i.e. [pre-EIP-1559](https://eips.ethereum.org/EIPS/eip-1559))
     */
    minerTip;
    /**
     * Creates a new FeeData for `gasPrice`, `gasPrice` and `minerTip`.
     *
     * @param {null | bigint} [gasPrice] - The gas price.
     * @param {null | bigint} [gasPrice] - The maximum fee per gas.
     * @param {null | bigint} [minerTip] - The maximum priority fee per gas.
     */
    constructor(gasPrice, minerTip) {
        defineProperties(this, {
            gasPrice: getValue(gasPrice),
            minerTip: getValue(minerTip),
        });
    }
    /**
     * Returns a JSON-friendly value.
     *
     * @returns {any} The JSON-friendly value.
     */
    toJSON() {
        const { gasPrice, minerTip } = this;
        return {
            _type: 'FeeData',
            gasPrice: toJson(gasPrice),
            minerTip: toJson(minerTip),
        };
    }
}
/**
 * Determines the address from a transaction request.
 *
 * @param {TransactionRequest} tx - The transaction request.
 * @returns {AddressLike} The address from the transaction request.
 * @throws {Error} If unable to determine the address.
 */
export function addressFromTransactionRequest(tx) {
    if ('from' in tx && !!tx.from) {
        return tx.from;
    }
    if ('txInputs' in tx && !!tx.txInputs) {
        const inputs = tx.txInputs;
        return computeAddress(inputs[0].pubkey);
    }
    if ('txIn' in tx && !!tx.txIn) {
        const inputs = tx.txIn;
        return computeAddress(inputs[0].pubkey);
    }
    if ('to' in tx && !!tx.to) {
        return tx.to;
    }
    throw new Error('Unable to determine address from transaction inputs, from or to field');
}
/**
 * Returns a copy of `req` with all properties coerced to their strict types.
 *
 * @category Providers
 * @param {TransactionRequest} req - The transaction request to copy.
 * @returns {PreparedTransactionRequest} The prepared transaction request.
 * @throws {Error} If the request is invalid.
 */
export function copyRequest(req) {
    const result = {};
    // These could be addresses or Addressables
    if ('to' in req && req.to) {
        result.to = req.to;
    }
    if ('from' in req && req.from) {
        result.from = req.from;
    }
    if ('data' in req && req.data) {
        result.data = hexlify(req.data);
    }
    const bigIntKeys = 'chainId,gasLimit,gasPrice,minerTip,value'.split(/,/);
    for (const key of bigIntKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getBigInt(req[key], `request.${key}`);
    }
    const numberKeys = 'type,nonce'.split(/,/);
    for (const key of numberKeys) {
        if (!(key in req) || req[key] == null) {
            continue;
        }
        result[key] = getNumber(req[key], `request.${key}`);
    }
    if ('accessList' in req && req.accessList) {
        result.accessList = accessListify(req.accessList);
    }
    if ('blockTag' in req) {
        result.blockTag = req.blockTag;
    }
    if ('customData' in req) {
        result.customData = req.customData;
    }
    if ('txInputs' in req && req.txInputs) {
        result.txInputs = req.txInputs.map((entry) => ({ ...entry }));
    }
    if ('txOutputs' in req && req.txOutputs) {
        result.txOutputs = req.txOutputs.map((entry) => ({ ...entry }));
    }
    return result;
}
/**
 * Represents the header of a block.
 *
 * @category Providers
 */
export class BlockHeader {
    baseFeePerGas;
    efficiencyScore;
    etxEligibleSlices;
    etxSetRoot;
    evmRoot;
    expansionNumber;
    etxRollupRoot;
    outboundEtxsRoot;
    extraData;
    gasLimit;
    gasUsed;
    interlinkRootHash;
    manifestHash;
    number;
    parentDeltaEntropy;
    parentEntropy;
    parentHash;
    parentUncledDeltaEntropy;
    primeTerminusHash;
    quaiStateSize;
    receiptsRoot;
    uncleHash;
    size;
    stateLimit;
    stateUsed;
    thresholdCount;
    transactionsRoot;
    uncledEntropy;
    utxoRoot;
    exchangeRate;
    quaiToQi;
    qiToQuai;
    secondaryCoinbase;
    constructor(params) {
        this.baseFeePerGas = params.baseFeePerGas;
        this.efficiencyScore = params.efficiencyScore;
        this.etxEligibleSlices = params.etxEligibleSlices;
        this.etxSetRoot = params.etxSetRoot;
        this.evmRoot = params.evmRoot;
        this.expansionNumber = params.expansionNumber;
        this.etxRollupRoot = params.etxRollupRoot;
        this.outboundEtxsRoot = params.outboundEtxsRoot;
        this.extraData = params.extraData;
        this.gasLimit = params.gasLimit;
        this.gasUsed = params.gasUsed;
        this.interlinkRootHash = params.interlinkRootHash;
        this.manifestHash = params.manifestHash;
        this.number = params.number;
        this.parentDeltaEntropy = params.parentDeltaEntropy;
        this.parentEntropy = params.parentEntropy;
        this.parentHash = params.parentHash;
        this.parentUncledDeltaEntropy = params.parentUncledDeltaEntropy;
        this.primeTerminusHash = params.primeTerminusHash;
        this.quaiStateSize = params.quaiStateSize;
        this.receiptsRoot = params.receiptsRoot;
        this.uncleHash = params.uncleHash;
        this.size = params.size;
        this.stateLimit = params.stateLimit;
        this.stateUsed = params.stateUsed;
        this.thresholdCount = params.thresholdCount;
        this.transactionsRoot = params.transactionsRoot;
        this.uncledEntropy = params.uncledEntropy;
        this.utxoRoot = params.utxoRoot;
        this.exchangeRate = params.exchangeRate;
        this.quaiToQi = params.quaiToQi;
        this.qiToQuai = params.qiToQuai;
        this.secondaryCoinbase = params.secondaryCoinbase;
    }
    toJSON() {
        return {
            ...this,
        };
    }
}
/**
 * Represents the header of a work object.
 *
 * @category Providers
 */
export class Uncle {
    primaryCoinbase;
    difficulty;
    headerHash;
    location;
    mixHash;
    nonce;
    number;
    parentHash;
    timestamp;
    txHash;
    lock;
    /**
     * Creates a new Uncle instance.
     *
     * @param {UncleParams} params - The parameters for the Uncle.
     */
    constructor(params) {
        this.primaryCoinbase = params.primaryCoinbase;
        this.difficulty = params.difficulty;
        this.headerHash = params.headerHash;
        this.location = params.location;
        this.mixHash = params.mixHash;
        this.nonce = params.nonce;
        this.number = params.number;
        this.parentHash = params.parentHash;
        this.timestamp = params.timestamp;
        this.txHash = params.txHash;
        this.lock = params.lock;
    }
    toJSON() {
        return {
            primaryCoinbase: this.primaryCoinbase,
            difficulty: this.difficulty,
            headerHash: this.headerHash,
            location: this.location,
            mixHash: this.mixHash,
            nonce: this.nonce,
            number: this.number,
            parentHash: this.parentHash,
            timestamp: this.timestamp,
            txHash: this.txHash,
            lock: this.lock,
        };
    }
}
/**
 * A **Block** represents the data associated with a full block on Ethereum.
 *
 * @category Providers
 */
export class Block {
    #outboundEtxs;
    hash;
    header;
    interlinkHashes; // New parameter
    size;
    subManifest;
    totalEntropy;
    #transactions;
    uncles;
    woHeader;
    workShares;
    /**
     * The provider connected to the block used to fetch additional details if necessary.
     */
    provider;
    /**
     * Create a new **Block** object.
     *
     * This should generally not be necessary as the unless implementing a low-level library.
     *
     * @param {BlockParams} block - The block parameters.
     * @param {Provider} provider - The provider.
     */
    constructor(block, provider) {
        this.#transactions = block.transactions.map((tx) => {
            if (typeof tx === 'string') {
                return tx;
            }
            if ('originatingTxHash' in tx) {
                return new ExternalTransactionResponse(tx, provider);
            }
            if ('from' in tx) {
                return new QuaiTransactionResponse(tx, provider);
            }
            return new QiTransactionResponse(tx, provider);
        });
        this.#outboundEtxs = block.outboundEtxs.map((tx) => {
            if (typeof tx !== 'string') {
                return new ExternalTransactionResponse(tx, provider);
            }
            return tx;
        });
        this.hash = block.hash;
        this.header = new BlockHeader(block.header);
        this.interlinkHashes = block.interlinkHashes;
        this.size = block.size;
        this.subManifest = block.subManifest;
        this.totalEntropy = block.totalEntropy;
        this.uncles = block.uncles.map((uncle) => {
            if (typeof uncle === 'string') {
                return uncle;
            }
            return new Uncle(uncle);
        });
        this.woHeader = new Uncle(block.woHeader);
        this.workShares = block.workShares.map((workShare) => {
            if (typeof workShare === 'string') {
                return workShare;
            }
            return new Uncle(workShare);
        });
        this.provider = provider;
    }
    /**
     * Returns the list of transaction hashes, in the order they were executed within the block.
     *
     * @returns {ReadonlyArray<string>} The list of transaction hashes.
     */
    get transactions() {
        return this.#transactions.map((tx) => {
            if (typeof tx === 'string') {
                return tx;
            }
            return tx.hash;
        });
    }
    /**
     * Returns the list of extended transaction hashes, in the order they were executed within the block.
     *
     * @returns {ReadonlyArray<string>} The list of extended transaction hashes.
     */
    get outboundEtxs() {
        return this.#outboundEtxs.map((tx) => {
            if (typeof tx === 'string') {
                return tx;
            }
            return tx.hash;
        });
    }
    /**
     * Returns the complete transactions, in the order they were executed within the block.
     *
     * This is only available for blocks which prefetched transactions, by passing `true` to `prefetchTxs` into
     * {@link Provider.getBlock | **getBlock**}.
     *
     * @returns {TransactionResponse[]} The list of prefetched transactions.
     * @throws {Error} If the transactions were not prefetched.
     */
    get prefetchedTransactions() {
        const txs = this.#transactions.slice();
        // Doesn't matter...
        if (txs.length === 0) {
            return [];
        }
        // Make sure we prefetched the transactions
        assert(typeof txs[0] === 'object', 'transactions were not prefetched with block request', 'UNSUPPORTED_OPERATION', {
            operation: 'transactionResponses()',
        });
        return txs;
    }
    /**
     * Returns the complete extended transactions, in the order they were executed within the block.
     *
     * This is only available for blocks which prefetched transactions, by passing `true` to `prefetchTxs` into
     * {@link Provider.getBlock | **getBlock**}.
     *
     * @returns {TransactionResponse[]} The list of prefetched extended transactions.
     * @throws {Error} If the transactions were not prefetched.
     */
    get prefetchedExtTransactions() {
        const txs = this.#outboundEtxs.slice();
        // Doesn't matter...
        if (txs.length === 0) {
            return [];
        }
        // Make sure we prefetched the transactions
        assert(typeof txs[0] === 'object', 'transactions were not prefetched with block request', 'UNSUPPORTED_OPERATION', {
            operation: 'transactionResponses()',
        });
        return txs;
    }
    /**
     * Returns a JSON-friendly value.
     *
     * @returns {any} The JSON-friendly value.
     */
    toJSON() {
        const { hash, header, interlinkHashes, size, subManifest, totalEntropy, uncles, woHeader, workShares } = this;
        // Using getters to retrieve the transactions and extTransactions
        const transactions = this.transactions;
        const outboundEtxs = this.outboundEtxs;
        return {
            outboundEtxs,
            hash,
            header: header.toJSON(),
            interlinkHashes,
            transactions,
            size: size,
            subManifest,
            totalEntropy: totalEntropy,
            uncles: uncles.map((uncle) => {
                if (typeof uncle === 'string') {
                    return uncle;
                }
                return uncle.toJSON();
            }),
            woHeader: woHeader.toJSON(),
            workShares: workShares.map((workShare) => {
                if (typeof workShare === 'string') {
                    return workShare;
                }
                return workShare.toJSON();
            }),
        };
    }
    [Symbol.iterator]() {
        let index = 0;
        const txs = this.transactions;
        return {
            next: () => {
                if (index < this.length) {
                    return {
                        value: txs[index++],
                        done: false,
                    };
                }
                return { value: undefined, done: true };
            },
        };
    }
    /**
     * The number of transactions in this block.
     *
     * @returns {number} The number of transactions.
     */
    get length() {
        return this.#transactions.length;
    }
    /**
     * The [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) this block was
     * included at.
     *
     * @returns {null | Date} The date this block was included at, or null if the timestamp is not available.
     */
    get date() {
        const timestampHex = this.woHeader.timestamp;
        if (!timestampHex) {
            return null;
        }
        const timestamp = parseInt(timestampHex, 16);
        return new Date(timestamp * 1000);
    }
    /**
     * Get the transaction at `index` within this block.
     *
     * @param {number | string} indexOrHash - The index or hash of the transaction.
     * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
     * @throws {Error} If the transaction is not found.
     */
    async getTransaction(indexOrHash) {
        // Find the internal value by its index or hash
        let tx = undefined;
        if (typeof indexOrHash === 'number') {
            tx = this.#transactions[indexOrHash];
        }
        else {
            const hash = indexOrHash.toLowerCase();
            for (const v of this.#transactions) {
                if (typeof v === 'string') {
                    if (v !== hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
                else {
                    if (v.hash === hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
            }
        }
        if (tx == null) {
            throw new Error('no such tx');
        }
        if (typeof tx === 'string') {
            return await this.provider.getTransaction(tx);
        }
        else {
            return tx;
        }
    }
    /**
     * Get the extended transaction at `index` within this block.
     *
     * @param {number | string} indexOrHash - The index or hash of the extended transaction.
     * @returns {Promise<TransactionResponse>} A promise resolving to the extended transaction.
     * @throws {Error} If the extended transaction is not found.
     */
    async getExtTransaction(indexOrHash) {
        // Find the internal value by its index or hash
        let tx = undefined;
        if (typeof indexOrHash === 'number') {
            tx = this.#outboundEtxs[indexOrHash];
        }
        else {
            const hash = indexOrHash.toLowerCase();
            for (const v of this.#outboundEtxs) {
                if (typeof v === 'string') {
                    if (v !== hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
                else {
                    if (v.hash === hash) {
                        continue;
                    }
                    tx = v;
                    break;
                }
            }
        }
        if (tx == null) {
            throw new Error('no such tx');
        }
        if (typeof tx === 'string') {
            throw new Error("External Transaction isn't prefetched");
        }
        else {
            return tx;
        }
    }
    /**
     * If a **Block** was fetched with a request to include the transactions this will allow synchronous access to those
     * transactions.
     *
     * If the transactions were not prefetched, this will throw.
     *
     * @param {number | string} indexOrHash - The index or hash of the transaction.
     * @returns {TransactionResponse} The transaction.
     * @throws {Error} If the transaction is not found.
     */
    getPrefetchedTransaction(indexOrHash) {
        const txs = this.prefetchedTransactions;
        if (typeof indexOrHash === 'number') {
            return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        for (const tx of txs) {
            if (tx.hash === indexOrHash) {
                return tx;
            }
        }
        assertArgument(false, 'no matching transaction', 'indexOrHash', indexOrHash);
    }
    /**
     * Returns true if this block been mined. This provides a type guard for all properties on a
     * {@link MinedBlock | **MinedBlock**}.
     *
     * @returns {boolean} True if the block has been mined.
     */
    isMined() {
        return !!this.hash;
    }
    /**
     * @ignore
     */
    orphanedEvent() {
        if (!this.isMined() || !this.woHeader.number) {
            throw new Error('');
        }
        return createOrphanedBlockFilter({
            hash: this.hash,
            number: parseInt(this.woHeader.number, 16),
        });
    }
}
//////////////////////
// Log
/**
 * A **Log** in Ethereum represents an event that has been included in a transaction using the `LOG*` opcodes, which are
 * most commonly used by Solidity's emit for announcing events.
 *
 * @category Providers
 */
export class Log {
    /**
     * The provider connected to the log used to fetch additional details if necessary.
     */
    provider;
    /**
     * The transaction hash of the transaction this log occurred in. Use the
     * {@link Log.getTransaction | **Log.getTransaction**} to get the
     * {@link TransactionResponse | **TransactionResponse}.
     */
    transactionHash;
    /**
     * The block hash of the block this log occurred in. Use the {@link Log.getBlock | **Log.getBlock**} to get the
     * {@link Block | **Block**}.
     */
    blockHash;
    /**
     * The block number of the block this log occurred in. It is preferred to use the {@link Block.hash | **Block.hash**}
     * when fetching the related {@link Block | **Block**}, since in the case of an orphaned block, the block at that
     * height may have changed.
     */
    blockNumber;
    /**
     * If the **Log** represents a block that was removed due to an orphaned block, this will be true.
     *
     * This can only happen within an orphan event listener.
     */
    removed;
    /**
     * The address of the contract that emitted this log.
     */
    address;
    /**
     * The data included in this log when it was emitted.
     */
    data;
    /**
     * The indexed topics included in this log when it was emitted.
     *
     * All topics are included in the bloom filters, so they can be efficiently filtered using the
     * {@link Provider.getLogs | **Provider.getLogs**} method.
     */
    topics;
    /**
     * The index within the block this log occurred at. This is generally not useful to developers, but can be used with
     * the various roots to proof inclusion within a block.
     */
    index;
    /**
     * The index within the transaction of this log.
     */
    transactionIndex;
    /**
     * @ignore
     */
    constructor(log, provider) {
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        defineProperties(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex,
        });
    }
    /**
     * Returns a JSON-compatible object.
     */
    toJSON() {
        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
        return {
            _type: 'log',
            address,
            blockHash,
            blockNumber,
            data,
            index,
            removed,
            topics,
            transactionHash,
            transactionIndex,
        };
    }
    /**
     * Returns the block that this log occurred in.
     *
     * @param {Shard} shard - The shard to fetch the block from.
     * @returns {Promise<Block>} A promise resolving to the block.
     */
    async getBlock(shard) {
        const block = await this.provider.getBlock(shard, this.blockHash);
        assert(!!block, 'failed to find transaction', 'UNKNOWN_ERROR', {});
        return block;
    }
    /**
     * Returns the transaction that this log occurred in.
     *
     * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        assert(!!tx, 'failed to find transaction', 'UNKNOWN_ERROR', {});
        return tx;
    }
    /**
     * Returns the transaction receipt fot the transaction that this log occurred in.
     *
     * @returns {Promise<TransactionReceipt>} A promise resolving to the transaction receipt.
     */
    async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        assert(!!receipt, 'failed to find transaction receipt', 'UNKNOWN_ERROR', {});
        return receipt;
    }
    /**
     * @ignore
     */
    removedEvent() {
        return createRemovedLogFilter(this);
    }
}
//////////////////////
// Transaction Receipt
export function zoneFromHash(hash) {
    return toZone(hash.slice(0, 4));
}
/**
 * A **TransactionReceipt** includes additional information about a transaction that is only available after it has been
 * mined.
 *
 * @category Providers
 */
export class TransactionReceipt {
    /**
     * The provider connected to the log used to fetch additional details if necessary.
     */
    provider;
    /**
     * The address the transaction was sent to.
     */
    to;
    /**
     * The sender of the transaction.
     */
    from;
    /**
     * The address of the contract if the transaction was directly responsible for deploying one.
     *
     * This is non-null **only** if the `to` is empty and the `data` was successfully executed as initcode.
     */
    contractAddress;
    /**
     * The transaction hash.
     */
    hash;
    /**
     * The index of this transaction within the block transactions.
     */
    index;
    /**
     * The block hash of the {@link Block | **Block**} this transaction was included in.
     */
    blockHash;
    /**
     * The block number of the {@link Block | **Block**} this transaction was included in.
     */
    blockNumber;
    /**
     * The bloom filter bytes that represent all logs that occurred within this transaction. This is generally not
     * useful for most developers, but can be used to validate the included logs.
     */
    logsBloom;
    /**
     * The actual amount of gas used by this transaction.
     *
     * When creating a transaction, the amount of gas that will be used can only be approximated, but the sender must
     * pay the gas fee for the entire gas limit. After the transaction, the difference is refunded.
     */
    gasUsed;
    /**
     * The amount of gas used by all transactions within the block for this and all transactions with a lower `index`.
     *
     * This is generally not useful for developers but can be used to validate certain aspects of execution.
     */
    cumulativeGasUsed;
    /**
     * The actual gas price used during execution.
     *
     * Due to the complexity of [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) this value can only be caluclated
     * after the transaction has been mined, snce the base fee is protocol-enforced.
     */
    gasPrice;
    /**
     * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction type.
     */
    type;
    //readonly byzantium!: boolean;
    /**
     * The status of this transaction, indicating success (i.e. `1`) or a revert (i.e. `0`).
     *
     * This is available in post-byzantium blocks, but some backends may backfill this value.
     */
    status;
    /**
     * The root hash of this transaction.
     *
     * This is no present and was only included in pre-byzantium blocks, but could be used to validate certain parts of
     * the receipt.
     */
    #logs;
    outboundEtxs = [];
    etxType;
    originatingTxHash;
    /**
     * @ignore
     */
    constructor(tx, provider) {
        this.#logs = Object.freeze(Array.isArray(tx.logs) ? tx.logs.map((log) => new Log(log, provider)) : []);
        let gasPrice = BN_0;
        if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
        }
        else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
        }
        const outboundEtxs = tx.outboundEtxs
            ? tx.outboundEtxs.map((etx) => {
                const safeConvert = (value, name) => {
                    try {
                        if (value != null) {
                            return BigInt(value);
                        }
                        return null;
                    }
                    catch (error) {
                        console.error(`Conversion to BigInt failed for ${name}: ${value}, error: ${error}`);
                        return null;
                    }
                };
                return {
                    type: etx.type,
                    nonce: etx.nonce,
                    gasPrice: safeConvert(etx.gasPrice, 'gasPrice'),
                    minerTip: safeConvert(etx.minerTip, 'minerTip'),
                    gas: safeConvert(etx.gas, 'gas'),
                    value: safeConvert(etx.value, 'value'),
                    input: etx.input,
                    to: etx.to,
                    accessList: etx.accessList,
                    chainId: safeConvert(etx.chainId, 'chainId'),
                    from: etx.from,
                    hash: etx.hash,
                    originatingTxHash: etx.originatingTxHash,
                    etxIndex: etx.etxIndex,
                };
            })
            : [];
        defineProperties(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            gasPrice,
            outboundEtxs: outboundEtxs,
            type: tx.type,
            status: tx.status,
            etxType: tx.etxType,
            originatingTxHash: tx.originatingTxHash,
        });
    }
    /**
     * The logs for this transaction.
     */
    get logs() {
        return this.#logs;
    }
    /**
     * Returns a JSON-compatible representation.
     */
    toJSON() {
        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium,
        status, outboundEtxs, } = this;
        return {
            _type: 'TransactionReceipt',
            blockHash,
            blockNumber,
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from,
            gasPrice: toJson(this.gasPrice),
            gasUsed: toJson(this.gasUsed),
            hash,
            index,
            logs,
            logsBloom,
            status,
            to,
            outboundEtxs: outboundEtxs ?? [],
        };
    }
    /**
     * @ignore
     */
    get length() {
        return this.logs.length;
    }
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => {
                if (index < this.length) {
                    return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
            },
        };
    }
    /**
     * The total fee for this transaction, in wei.
     */
    get fee() {
        return this.gasUsed * this.gasPrice;
    }
    /**
     * Resolves to the block this transaction occurred in.
     *
     * @param {Shard} shard - The shard to fetch the block from.
     * @returns {Promise<Block>} A promise resolving to the block.
     * @throws {Error} If the block is not found.
     */
    async getBlock(shard) {
        const block = await this.provider.getBlock(shard, this.blockHash);
        if (block == null) {
            throw new Error('TODO');
        }
        return block;
    }
    /**
     * Resolves to the transaction this transaction occurred in.
     *
     * @returns {Promise<TransactionResponse>} A promise resolving to the transaction.
     * @throws {Error} If the transaction is not found.
     */
    async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
            throw new Error('TODO');
        }
        return tx;
    }
    /**
     * Resolves to the return value of the execution of this transaction.
     *
     * Support for this feature is limited, as it requires an archive node with the `debug_` or `trace_` API enabled.
     *
     * @returns {Promise<string>} A promise resolving to the return value of the transaction.
     * @throws {Error} If the transaction is not found.
     */
    async getResult() {
        return await this.provider.getTransactionResult(this.hash);
    }
    /**
     * Resolves to the number of confirmations this transaction has.
     *
     * @returns {Promise<number>} A promise resolving to the number of confirmations.
     * @throws {Error} If the block is not found.
     */
    async confirmations() {
        const zone = zoneFromHash(this.hash);
        return (await this.provider.getBlockNumber(toShard(zone))) - this.blockNumber + 1;
    }
    /**
     * @ignore
     */
    removedEvent() {
        return createRemovedTransactionFilter(this);
    }
    /**
     * @ignore
     */
    reorderedEvent(other) {
        assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", 'UNSUPPORTED_OPERATION', {
            operation: 'reorderedEvent(other)',
        });
        return createReorderedTransactionFilter(this, other);
    }
}
export class ExternalTransactionResponse {
    /**
     * The provider this is connected to, which will influence how its methods will resolve its async inspection
     * methods.
     */
    provider;
    /**
     * The block number of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockNumber;
    /**
     * The blockHash of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockHash;
    /**
     * The index within the block that this transaction resides at.
     */
    index;
    /**
     * The transaction hash.
     */
    hash;
    /**
     * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
     * transactions types.
     */
    type;
    /**
     * The receiver of this transaction.
     *
     * If `null`, then the transaction is an initcode transaction. This means the result of executing the
     * {@link ExternalTransactionResponse.data | **data** } will be deployed as a new contract on chain (assuming it does
     * not revert) and the address may be computed using [getCreateAddress](../functions/getCreateAddress).
     */
    to;
    /**
     * The sender of this transaction. It is implicitly computed from the transaction pre-image hash (as the digest) and
     * the {@link QuaiTransactionResponse.signature | **signature** } using ecrecover.
     */
    from;
    /**
     * The nonce, which is used to prevent replay attacks and offer a method to ensure transactions from a given sender
     * are explicitly ordered.
     *
     * When sending a transaction, this must be equal to the number of transactions ever sent by
     * {@link ExternalTransactionResponse.from | **from** }.
     */
    nonce;
    /**
     * The maximum units of gas this transaction can consume. If execution exceeds this, the entries transaction is
     * reverted and the sender is charged for the full amount, despite not state changes being made.
     */
    gasLimit;
    /**
     * The data.
     */
    data;
    /**
     * The value, in wei. Use [formatEther](../functions/formatEther) to format this value as ether.
     */
    value;
    /**
     * The chain ID.
     */
    chainId;
    /**
     * The signature.
     */
    signature;
    /**
     * The [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list for transaction types that support it,
     * otherwise `null`.
     */
    accessList;
    etxType;
    originatingTxHash;
    sender;
    etxIndex;
    startBlock;
    /**
     * @ignore
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
        this.blockHash = tx.blockHash != null ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = tx.accessList != null ? tx.accessList : null;
        this.startBlock = -1;
        this.originatingTxHash = tx.originatingTxHash != null ? tx.originatingTxHash : null;
        this.etxType = tx.etxType != null ? tx.etxType : null;
        this.etxIndex = tx.etxIndex;
    }
    /**
     * Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, etxType, originatingTxHash, etxIndex, } = this;
        const result = {
            _type: 'TransactionReceipt',
            accessList,
            blockNumber,
            blockHash,
            chainId: toJson(this.chainId),
            data,
            from,
            gasLimit: toJson(this.gasLimit),
            hash,
            nonce,
            signature,
            to,
            index,
            type,
            etxType,
            originatingTxHash,
            etxIndex,
            value: toJson(this.value),
        };
        return result;
    }
    replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
        const tx = new ExternalTransactionResponse(this, this.provider);
        tx.startBlock = startBlock;
        return tx;
    }
}
/**
 * A **QuaiTransactionResponse** includes all properties about a Quai transaction that was sent to the network, which
 * may or may not be included in a block.
 *
 * The {@link TransactionResponse.isMined | **TransactionResponse.isMined**} can be used to check if the transaction has
 * been mined as well as type guard that the otherwise possibly `null` properties are defined.
 *
 * @category Providers
 */
export class QuaiTransactionResponse {
    /**
     * The provider this is connected to, which will influence how its methods will resolve its async inspection
     * methods.
     */
    provider;
    /**
     * The block number of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockNumber;
    /**
     * The blockHash of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockHash;
    /**
     * The index within the block that this transaction resides at.
     */
    index;
    /**
     * The transaction hash.
     */
    hash;
    /**
     * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
     * transactions types.
     */
    type;
    /**
     * The receiver of this transaction.
     *
     * If `null`, then the transaction is an initcode transaction. This means the result of executing the
     * {@link QuaiTransactionResponse.data | **data** } will be deployed as a new contract on chain (assuming it does not
     * revert) and the address may be computed using [getCreateAddress](../functions/getCreateAddress).
     */
    to;
    /**
     * The sender of this transaction. It is implicitly computed from the transaction pre-image hash (as the digest) and
     * the {@link QuaiTransactionResponse.signature | **signature** } using ecrecover.
     */
    from;
    /**
     * The nonce, which is used to prevent replay attacks and offer a method to ensure transactions from a given sender
     * are explicitly ordered.
     *
     * When sending a transaction, this must be equal to the number of transactions ever sent by
     * {@link QuaiTransactionResponse.from | **from** }.
     */
    nonce;
    /**
     * The maximum units of gas this transaction can consume. If execution exceeds this, the entries transaction is
     * reverted and the sender is charged for the full amount, despite not state changes being made.
     */
    gasLimit;
    /**
     * The maximum priority fee (per unit of gas) to allow a validator to charge the sender. This is inclusive of the
     * {@link QuaiTransactionResponse.gasPrice | **gasPrice** }.
     */
    minerTip;
    /**
     * The maximum fee (per unit of gas) to allow this transaction to charge the sender.
     */
    gasPrice;
    /**
     * The data.
     */
    data;
    /**
     * The value, in wei. Use [formatEther](../functions/formatEther) to format this value as ether.
     */
    value;
    /**
     * The chain ID.
     */
    chainId;
    /**
     * The signature.
     */
    signature;
    /**
     * The [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list for transaction types that support it,
     * otherwise `null`.
     */
    accessList;
    etxType;
    sender;
    originatingTxHash;
    startBlock;
    /**
     * @ignore
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
        this.blockHash = tx.blockHash != null ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.minerTip = tx.minerTip != null ? tx.minerTip : null;
        this.gasPrice = tx.gasPrice != null ? tx.gasPrice : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = tx.accessList != null ? tx.accessList : null;
        this.startBlock = -1;
        this.etxType = tx.etxType != null ? tx.etxType : null;
    }
    /**
     * Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;
        const result = {
            _type: 'TransactionReceipt',
            accessList,
            blockNumber,
            blockHash,
            chainId: toJson(this.chainId),
            data,
            from,
            gasLimit: toJson(this.gasLimit),
            hash,
            gasPrice: toJson(this.gasPrice),
            minerTip: toJson(this.minerTip),
            nonce,
            signature,
            to,
            index,
            type,
            value: toJson(this.value),
        };
        return result;
    }
    /**
     * Resolves to the Block that this transaction was included in.
     *
     * This will return null if the transaction has not been included yet.
     *
     * @param {Shard} shard - The shard to fetch the block from.
     * @returns {null | Promise<Block>} A promise resolving to the block.
     */
    async getBlock(shard) {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
                blockNumber = tx.blockNumber;
            }
        }
        if (blockNumber == null) {
            return null;
        }
        const block = this.provider.getBlock(shard, blockNumber);
        if (block == null) {
            throw new Error('TODO');
        }
        return block;
    }
    /**
     * Resolves to this transaction being re-requested from the provider. This can be used if you have an unmined
     * transaction and wish to get an up-to-date populated instance.
     *
     * @returns {null | Promise<TransactionResponse>} A promise resolving to the transaction, or null if not found.
     */
    async getTransaction() {
        const transaction = this.provider.getTransaction(this.hash);
        if (transaction instanceof QuaiTransactionResponse) {
            return transaction;
        }
        else {
            return null;
        }
    }
    /**
     * Resolve to the number of confirmations this transaction has.
     *
     * @returns {Promise<number>} A promise resolving to the number of confirmations.
     * @throws {Error} If the block is not found.
     */
    async confirmations() {
        const zone = zoneFromHash(this.hash);
        if (this.blockNumber == null) {
            const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(toShard(zone)),
            });
            // Not mined yet...
            if (tx == null || tx.blockNumber == null) {
                return 0;
            }
            return blockNumber - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber(toShard(zone));
        return blockNumber - this.blockNumber + 1;
    }
    /**
     * Resolves once this transaction has been mined and has `confirms` blocks including it (default: `1`) with an
     * optional `timeout`.
     *
     * This can resolve to `null` only if `confirms` is `0` and the transaction has not been mined, otherwise this will
     * wait until enough confirmations have completed.
     *
     * @param {number} [_confirms] - The number of confirmations to wait for.
     * @param {number} [_timeout] - The number of milliseconds to wait before rejecting.
     * @returns {Promise<null | TransactionReceipt>} A promise resolving to the transaction receipt.
     * @throws {Error} If the transaction was replaced, repriced, or cancelled.
     */
    async wait(_confirms, _timeout) {
        const confirms = _confirms == null ? 1 : _confirms;
        const timeout = _timeout == null ? 0 : _timeout;
        let startBlock = this.startBlock;
        let nextScan = -1;
        let stopScanning = startBlock === -1 ? true : false;
        const zone = zoneFromHash(this.hash);
        const checkReplacement = async () => {
            // Get the current transaction count for this sender
            if (stopScanning) {
                return null;
            }
            const { blockNumber, nonce } = await resolveProperties({
                blockNumber: this.provider.getBlockNumber(toShard(zone)),
                nonce: this.provider.getTransactionCount(this.from),
            });
            // No transaction or our nonce has not been mined yet; but we
            // can start scanning later when we do start
            if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
            }
            // We were mined; no replacement
            if (stopScanning) {
                return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
                return;
            }
            // We were replaced; start scanning for that transaction
            // Starting to scan; look back a few extra blocks for safety
            if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.startBlock) {
                    nextScan = this.startBlock;
                }
            }
            while (nextScan <= blockNumber) {
                // Get the next block to scan
                if (stopScanning) {
                    return null;
                }
                const block = await this.provider.getBlock(toShard(zone), nextScan, true);
                // This should not happen; but we'll try again shortly
                if (block == null) {
                    return;
                }
                // We were mined; no replacement
                for (const hash of block) {
                    if (hash === this.hash) {
                        return;
                    }
                }
                // Search for the transaction that replaced us
                for (let i = 0; i < block.length; i++) {
                    const tx = await block.getTransaction(i);
                    if ('from' in tx && tx.from === this.from && tx.nonce === this.nonce) {
                        // Get the receipt
                        if (stopScanning) {
                            return null;
                        }
                        const receipt = await this.provider.getTransactionReceipt(tx.hash);
                        // This should not happen; but we'll try again shortly
                        if (receipt == null) {
                            return;
                        }
                        // We will retry this on the next block (this case could be optimized)
                        if (blockNumber - receipt.blockNumber + 1 < confirms) {
                            return;
                        }
                        // The reason we were replaced
                        let reason = 'replaced';
                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                            reason = 'repriced';
                        }
                        else if (tx.data === '0x' && tx.from === tx.to && tx.value === BN_0) {
                            reason = 'cancelled';
                        }
                        assert(false, 'transaction was replaced', 'TRANSACTION_REPLACED', {
                            cancelled: reason === 'replaced' || reason === 'cancelled',
                            reason,
                            replacement: tx.replaceableTransaction(startBlock),
                            hash: tx.hash,
                            receipt,
                        });
                    }
                }
                nextScan++;
            }
            return;
        };
        const checkReceipt = (receipt) => {
            if (receipt == null || receipt.status !== 0) {
                return receipt;
            }
            assert(false, 'transaction execution reverted', 'CALL_EXCEPTION', {
                action: 'sendTransaction',
                data: null,
                reason: null,
                invocation: null,
                revert: null,
                transaction: {
                    to: receipt.to,
                    from: receipt.from,
                    data: '', // @TODO: in v7, split out sendTransaction properties
                },
                receipt,
            });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
            return checkReceipt(receipt);
        }
        if (receipt) {
            if ((await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
            }
        }
        else {
            // Check for a replacement; throws if a replacement was found
            await checkReplacement();
            // Allow null only when the confirms is 0
            if (confirms === 0) {
                return null;
            }
        }
        const waiter = new Promise((resolve, reject) => {
            // List of things to cancel when we have a result (one way or the other)
            const cancellers = [];
            const cancel = () => {
                cancellers.forEach((c) => c());
            };
            // On cancel, stop scanning for replacements
            cancellers.push(() => {
                stopScanning = true;
            });
            // Set up any timeout requested
            if (timeout > 0) {
                const timer = setTimeout(() => {
                    cancel();
                    reject(makeError('wait for transaction timeout', 'TIMEOUT'));
                }, timeout);
                cancellers.push(() => {
                    clearTimeout(timer);
                });
            }
            const txListener = async (receipt) => {
                // Done; return it!
                if ((await receipt.confirmations()) >= confirms) {
                    cancel();
                    try {
                        resolve(checkReceipt(receipt));
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            };
            cancellers.push(() => {
                this.provider.off(this.hash, txListener);
            });
            this.provider.on(this.hash, txListener);
            // We support replacement detection; start checking
            if (startBlock >= 0) {
                const replaceListener = async () => {
                    try {
                        // Check for a replacement; this throws only if one is found
                        await checkReplacement();
                    }
                    catch (error) {
                        // We were replaced (with enough confirms); re-throw the error
                        if (isError(error, 'TRANSACTION_REPLACED')) {
                            cancel();
                            reject(error);
                            return;
                        }
                    }
                    // Rescheudle a check on the next block
                    if (!stopScanning) {
                        this.provider.once('block', replaceListener, zone);
                    }
                };
                cancellers.push(() => {
                    this.provider.off('block', replaceListener, zone);
                });
                this.provider.once('block', replaceListener, zone);
            }
        });
        return await waiter;
    }
    /**
     * Returns `true` if this transaction has been included.
     *
     * This is effective only as of the time the TransactionResponse was instantiated. To get up-to-date information,
     * use {@link QuaiTransactionResponse.getTransaction | **getTransaction**}.
     *
     * This provides a Type Guard that this transaction will have non-null property values for properties that are null
     * for unmined transactions.
     *
     * @returns {QuaiMinedTransactionResponse} True if the transaction has been mined.
     * @throws {Error} If the transaction was replaced, repriced, or cancelled.
     */
    isMined() {
        return this.blockHash != null;
    }
    /**
     * Returns a filter which can be used to listen for orphan events that evict this transaction.
     *
     * @returns {OrphanFilter} The orphan filter.
     */
    removedEvent() {
        assert(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        return createRemovedTransactionFilter(this);
    }
    /**
     * Returns a filter which can be used to listen for orphan events that re-order this event against `other`.
     *
     * @param {TransactionResponse} [other] - The other transaction to compare against.
     * @returns {OrphanFilter} The orphan filter.
     */
    reorderedEvent(other) {
        assert(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        return createReorderedTransactionFilter(this, other);
    }
    /**
     * Returns a new TransactionResponse instance which has the ability to detect (and throw an error) if the
     * transaction is replaced, which will begin scanning at `startBlock`.
     *
     * This should generally not be used by developers and is intended primarily for internal use. Setting an incorrect
     * `startBlock` can have devastating performance consequences if used incorrectly.
     *
     * @param {number} startBlock - The block number to start scanning for replacements.
     * @returns {QuaiTransactionResponse} The replaceable transaction.
     */
    replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
        const tx = new QuaiTransactionResponse(this, this.provider);
        tx.startBlock = startBlock;
        return tx;
    }
}
/**
 * A **QiTransactionResponse** includes all properties about a Qi transaction that was sent to the network, which may or
 * may not be included in a block.
 *
 * The {@link TransactionResponse.isMined | **TransactionResponse.isMined**} can be used to check if the transaction has
 * been mined as well as type guard that the otherwise possibly `null` properties are defined.
 *
 * @category Providers
 */
export class QiTransactionResponse {
    /**
     * The provider this is connected to, which will influence how its methods will resolve its async inspection
     * methods.
     */
    provider;
    /**
     * The block number of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockNumber;
    /**
     * The blockHash of the block that this transaction was included in.
     *
     * This is `null` for pending transactions.
     */
    blockHash;
    /**
     * The index within the block that this transaction resides at.
     */
    index;
    /**
     * The transaction hash.
     */
    hash;
    /**
     * The [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) transaction envelope type. This is `0` for legacy
     * transactions types.
     */
    type;
    /**
     * The chain ID.
     */
    chainId;
    /**
     * The signature.
     */
    signature;
    txInputs;
    txOutputs;
    startBlock;
    /**
     * @ignore
     */
    constructor(tx, provider) {
        this.provider = provider;
        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
        this.blockHash = tx.blockHash != null ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.startBlock = -1;
        this.txInputs = tx.txInputs;
        this.txOutputs = tx.txOutputs;
    }
    /**
     * Returns a JSON-compatible representation of this transaction.
     */
    toJSON() {
        const { blockNumber, blockHash, index, hash, type, signature, txInputs, txOutputs } = this;
        const result = {
            _type: 'TransactionReceipt',
            blockNumber,
            blockHash,
            chainId: toJson(this.chainId),
            hash,
            signature,
            index,
            type,
            txInputs: JSON.parse(JSON.stringify(txInputs)),
            txOutputs: JSON.parse(JSON.stringify(txOutputs)),
        };
        return result;
    }
    /**
     * Resolves to the Block that this transaction was included in.
     *
     * This will return null if the transaction has not been included yet.
     *
     * @param {Shard} shard - The shard to fetch the block from.
     * @returns {null | Promise<Block>} A promise resolving to the block or null if not found.
     */
    async getBlock(shard) {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
                blockNumber = tx.blockNumber;
            }
        }
        if (blockNumber == null) {
            return null;
        }
        const block = this.provider.getBlock(shard, blockNumber);
        if (block == null) {
            throw new Error('TODO');
        }
        return block;
    }
    /**
     * Resolves to this transaction being re-requested from the provider. This can be used if you have an unmined
     * transaction and wish to get an up-to-date populated instance.
     *
     * @returns {null | Promise<TransactionResponse>} A promise resolving to the transaction, or null if not found.
     * @throws {Error} If the transaction is not found.
     */
    async getTransaction() {
        const transaction = this.provider.getTransaction(this.hash);
        if (transaction instanceof QiTransactionResponse) {
            return transaction;
        }
        else {
            return null;
        }
    }
    /**
     * Resolve to the number of confirmations this transaction has.
     *
     * @returns {Promise<number>} A promise resolving to the number of confirmations.
     */
    async confirmations() {
        const zone = zoneFromHash(this.hash);
        if (this.blockNumber == null) {
            const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(toShard(zone)),
            });
            // Not mined yet...
            if (tx == null || tx.blockNumber == null || tx.blockHash == null) {
                return 0;
            }
            return blockNumber - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber(toShard(zone));
        return blockNumber - this.blockNumber + 1;
    }
    async wait(_confirms, _timeout) {
        const confirms = _confirms == null ? 1 : _confirms;
        const timeout = _timeout == null ? 0 : _timeout;
        const tx = await this.provider.getTransaction(this.hash);
        if (confirms === 0 && tx?.blockHash != null) {
            return tx;
        }
        const waiter = new Promise((resolve, reject) => {
            // List of things to cancel when we have a result (one way or the other)
            const cancellers = [];
            const cancel = () => {
                cancellers.forEach((c) => c());
            };
            // Set up any timeout requested
            if (timeout > 0) {
                const timer = setTimeout(() => {
                    cancel();
                    reject(makeError('wait for transaction timeout', 'TIMEOUT'));
                }, timeout);
                cancellers.push(() => {
                    clearTimeout(timer);
                });
            }
            const txListener = async (tx) => {
                // Done; return it!
                if ((await tx.confirmations()) >= confirms) {
                    cancel();
                    try {
                        resolve(tx);
                    }
                    catch (error) {
                        reject(error);
                    }
                }
            };
            cancellers.push(() => {
                this.provider.off(this.hash, txListener);
            });
            this.provider.on(this.hash, txListener);
        });
        return await waiter;
    }
    /**
     * Returns `true` if this transaction has been included.
     *
     * This is effective only as of the time the TransactionResponse was instantiated. To get up-to-date information,
     * use {@link QiTransactionResponse.getTransaction | **getTransaction**}.
     *
     * This provides a Type Guard that this transaction will have non-null property values for properties that are null
     * for unmined transactions.
     *
     * @returns {QiMinedTransactionResponse} True if the transaction has been mined or false otherwise.
     */
    isMined() {
        return this.blockHash != null;
    }
    /**
     * Returns a filter which can be used to listen for orphan events that evict this transaction.
     *
     * @returns {OrphanFilter} The orphan filter.
     */
    removedEvent() {
        assert(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        return createRemovedTransactionFilter(this);
    }
    /**
     * Returns a filter which can be used to listen for orphan events that re-order this event against `other`.
     *
     * @param {TransactionResponse} [other] - The other transaction to compare against.
     * @returns {OrphanFilter} The orphan filter.
     */
    reorderedEvent(other) {
        assert(this.isMined(), 'unmined transaction canot be orphaned', 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", 'UNSUPPORTED_OPERATION', {
            operation: 'removeEvent()',
        });
        return createReorderedTransactionFilter(this, other);
    }
    /**
     * Returns a new TransactionResponse instance which has the ability to detect (and throw an error) if the
     * transaction is replaced, which will begin scanning at `startBlock`.
     *
     * This should generally not be used by developers and is intended primarily for internal use. Setting an incorrect
     * `startBlock` can have devastating performance consequences if used incorrectly.
     *
     * @param {number} startBlock - The block number to start scanning for replacements.
     * @returns {QiTransactionResponse} The replaceable transaction.
     */
    replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, 'invalid startBlock', 'startBlock', startBlock);
        const tx = new QiTransactionResponse(this, this.provider);
        tx.startBlock = startBlock;
        return tx;
    }
}
function createOrphanedBlockFilter(block) {
    return { orphan: 'drop-block', hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
    return { orphan: 'reorder-transaction', tx, other };
}
function createRemovedTransactionFilter(tx) {
    return { orphan: 'drop-transaction', tx };
}
function createRemovedLogFilter(log) {
    return {
        orphan: 'drop-log',
        log: {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            address: log.address,
            data: log.data,
            topics: Object.freeze(log.topics.slice()),
            index: log.index,
        },
    };
}
export function getZoneFromEventFilter(filter) {
    let zone = null;
    if (filter.nodeLocation) {
        zone = getZoneFromNodeLocation(filter.nodeLocation);
    }
    else if (filter.address) {
        let address;
        if (Array.isArray(filter.address)) {
            address = filter.address[0];
        }
        else {
            address = filter.address;
        }
        const addressZone = getZoneForAddress(address);
        if (addressZone) {
            zone = toZone(addressZone);
        }
        else {
            return null;
        }
    }
    return zone;
}
//# sourceMappingURL=provider.js.map