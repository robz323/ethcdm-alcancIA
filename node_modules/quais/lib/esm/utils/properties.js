/**
 * Property helper functions.
 */
function checkType(value, type, name) {
    const types = type.split('|').map((t) => t.trim());
    for (let i = 0; i < types.length; i++) {
        switch (type) {
            case 'any':
                return;
            case 'bigint':
            case 'boolean':
            case 'number':
            case 'string':
                if (typeof value === type) {
                    return;
                }
        }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = 'INVALID_ARGUMENT';
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
}
/**
 * Resolves to a new object that is a copy of `value`, but with all values resolved.
 *
 * @category Utils
 * @param {Object} value - The object to resolve.
 * @returns {Promise<Object>} The resolved object.
 */
export async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
    return results.reduce((accum, v, index) => {
        accum[keys[index]] = v;
        return accum;
    }, {});
}
// Crawl up the constructor chain to find a static method
export function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof ctor.prototype !== 'object') {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
/**
 * Assigns the `values` to `target` as read-only values.
 *
 * It `types` is specified, the values are checked.
 *
 * @category Utils
 * @param {Object} target - The target object to assign to.
 * @param {Object} values - The values to assign.
 * @param {Object} types - The types to check.
 */
export function defineProperties(target, values, types) {
    for (const key in values) {
        const value = values[key];
        const type = types ? types[key] : null;
        if (type) {
            checkType(value, type, key);
        }
        Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
}
//# sourceMappingURL=properties.js.map