import { HDNodeWallet } from './hdnodewallet.js';
import { Mnemonic } from './mnemonic.js';
import { LangEn } from '../wordlists/lang-en.js';
import { randomBytes } from '../crypto/index.js';
import { getZoneForAddress, assertPrivate } from '../utils/index.js';
import { isQiAddress } from '../address/index.js';
import { Zone } from '../constants/index.js';
export const HARDENED_OFFSET = 2 ** 31;
/**
 * Constant to represent the maximum attempt to derive an address.
 */
export const MAX_ADDRESS_DERIVATION_ATTEMPTS = 10000000;
export const _guard = {};
/**
 * Abstract class representing a Hierarchical Deterministic (HD) wallet.
 */
class AbstractHDWallet {
    static _version = 1;
    static _coinType;
    // Map of addresses to address info
    _addresses = new Map();
    /**
     * Root node of the HD wallet.
     */
    _root;
    provider;
    /**
     * @param {HDNodeWallet} root - The root node of the HD wallet.
     * @param {Provider} [provider] - The provider for the HD wallet.
     */
    constructor(guard, root, provider) {
        assertPrivate(guard, _guard, 'AbstractHDWallet');
        this._root = root;
        this.provider = provider;
    }
    /**
     * Returns the parent path for a given coin type.
     *
     * @param {number} coinType - The coin type.
     * @returns {string} The parent path.
     */
    static parentPath(coinType) {
        return `m/44'/${coinType}'`;
    }
    /**
     * Returns the coin type of the wallet.
     *
     * @returns {AllowedCoinType} The coin type.
     */
    coinType() {
        return this.constructor._coinType;
    }
    /**
     * Returns the extended public key of the root node of the HD wallet.
     *
     * @returns {string} The extended public key.
     */
    get xPub() {
        return this._root.extendedKey;
    }
    // helper method to check if an address is valid for a given zone
    isValidAddressForZone(address, zone) {
        const addressZone = getZoneForAddress(address);
        if (!addressZone) {
            return false;
        }
        const isCorrectShard = addressZone === zone;
        const isCorrectLedger = this.coinType() === 969 ? isQiAddress(address) : !isQiAddress(address);
        return isCorrectShard && isCorrectLedger;
    }
    /**
     * Derives the next valid address node for a specified account, starting index, and zone. The method ensures the
     * derived address belongs to the correct shard and ledger, as defined by the Quai blockchain specifications.
     *
     * @param {number} account - The account number from which to derive the address node.
     * @param {number} startingIndex - The index from which to start deriving addresses.
     * @param {Zone} zone - The zone (shard) for which the address should be valid.
     * @param {boolean} [isChange=false] - Whether to derive a change address. Default is `false`
     * @returns {HDNodeWallet} - The derived HD node wallet containing a valid address for the specified zone.
     * @throws {Error} If a valid address for the specified zone cannot be derived within the allowed attempts.
     */
    deriveNextAddressNode(account, startingIndex, zone, isChange = false) {
        const changeIndex = isChange ? 1 : 0;
        const changeNode = this._root.deriveChild(account + HARDENED_OFFSET).deriveChild(changeIndex);
        let addrIndex = startingIndex;
        let addressNode;
        for (let attempts = 0; attempts < MAX_ADDRESS_DERIVATION_ATTEMPTS; attempts++) {
            addressNode = changeNode.deriveChild(addrIndex++);
            if (this.isValidAddressForZone(addressNode.address, zone)) {
                return addressNode;
            }
        }
        throw new Error(`Failed to derive a valid address for the zone ${zone} after ${MAX_ADDRESS_DERIVATION_ATTEMPTS} attempts.`);
    }
    /**
     * Creates an instance of the HD wallet.
     *
     * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
     * @param {Mnemonic} mnemonic - The mnemonic.
     * @returns {T} The created instance.
     */
    static createInstance(mnemonic) {
        const coinType = this._coinType;
        const root = HDNodeWallet.fromMnemonic(mnemonic, this.parentPath(coinType));
        return new this(_guard, root);
    }
    /**
     * Creates an HD wallet from a mnemonic.
     *
     * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
     * @param {Mnemonic} mnemonic - The mnemonic.
     * @returns {T} The created instance.
     */
    static fromMnemonic(mnemonic) {
        return this.createInstance(mnemonic);
    }
    /**
     * Creates a random HD wallet.
     *
     * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
     * @param {string} [password] - The password.
     * @param {Wordlist} [wordlist] - The wordlist.
     * @returns {T} The created instance.
     */
    static createRandom(password, wordlist) {
        if (password == null) {
            password = '';
        }
        if (wordlist == null) {
            wordlist = LangEn.wordlist();
        }
        const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);
        return this.createInstance(mnemonic);
    }
    /**
     * Creates an HD wallet from a phrase.
     *
     * @param {new (root: HDNodeWallet) => T} this - The constructor of the HD wallet.
     * @param {string} phrase - The phrase.
     * @param {string} [password] - The password.
     * @param {Wordlist} [wordlist] - The wordlist.
     * @returns {T} The created instance.
     */
    static fromPhrase(phrase, password, wordlist) {
        if (password == null) {
            password = '';
        }
        if (wordlist == null) {
            wordlist = LangEn.wordlist();
        }
        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
        return this.createInstance(mnemonic);
    }
    /**
     * Connects the wallet to a provider.
     *
     * @param {Provider} provider - The provider.
     */
    connect(provider) {
        this.provider = provider;
    }
    /**
     * Validates the zone.
     *
     * @param {Zone} zone - The zone.
     * @throws {Error} If the zone is invalid.
     */
    validateZone(zone) {
        if (!Object.values(Zone).includes(zone)) {
            throw new Error(`Invalid zone: ${zone}`);
        }
    }
    /**
     * Serializes the HD wallet state into a format suitable for storage or transmission.
     *
     * @returns {SerializedHDWallet} An object representing the serialized state of the HD wallet, including version,
     *   mnemonic phrase, coin type, and addresses.
     */
    serialize() {
        return {
            version: this.constructor._version,
            phrase: this._root.mnemonic.phrase,
            coinType: this.coinType(),
        };
    }
    /**
     * Deserializes a serialized HD wallet object and reconstructs the wallet instance. This method must be implemented
     * in the subclass.
     *
     * @param {SerializedHDWallet} _serialized - The serialized object representing the state of an HD wallet.
     * @returns {AbstractHDWallet} An instance of AbstractHDWallet.
     * @throws {Error} This method must be implemented in the subclass.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static async deserialize(_serialized) {
        throw new Error('deserialize method must be implemented in the subclass');
    }
    /**
     * Validates the NeuteredAddressInfo object.
     *
     * @param {NeuteredAddressInfo} info - The NeuteredAddressInfo object to be validated.
     * @throws {Error} If the NeuteredAddressInfo object is invalid.
     * @protected
     */
    validateNeuteredAddressInfo(info) {
        if (!/^(0x)?[0-9a-fA-F]{40}$/.test(info.address)) {
            throw new Error(`Invalid NeuteredAddressInfo: address must be a 40-character hexadecimal string: ${info.address}`);
        }
        if (!/^0x[0-9a-fA-F]{66}$/.test(info.pubKey)) {
            throw new Error(`Invalid NeuteredAddressInfo: pubKey must be a 32-character hexadecimal string with 0x prefix: ${info.pubKey}`);
        }
        if (!Number.isInteger(info.account) || info.account < 0) {
            throw new Error(`Invalid NeuteredAddressInfo: account must be a non-negative integer: ${info.account}`);
        }
        if (!Number.isInteger(info.index) || info.index < 0) {
            throw new Error(`Invalid NeuteredAddressInfo: index must be a non-negative integer: ${info.index}`);
        }
        if (!Object.values(Zone).includes(info.zone)) {
            throw new Error(`Invalid NeuteredAddressInfo: zone '${info.zone}' is not a valid Zone`);
        }
    }
    /**
     * Validates the version and coinType of the serialized wallet.
     *
     * @param {SerializedHDWallet} serialized - The serialized wallet data to be validated.
     * @throws {Error} If the version or coinType of the serialized wallet does not match the expected values.
     * @protected
     * @static
     */
    static validateSerializedWallet(serialized) {
        if (serialized.version !== this._version) {
            throw new Error(`Invalid version ${serialized.version} for wallet (expected ${this._version})`);
        }
        if (serialized.coinType !== this._coinType) {
            throw new Error(`Invalid coinType ${serialized.coinType} for wallet (expected ${this._coinType})`);
        }
    }
}
export { AbstractHDWallet };
//# sourceMappingURL=hdwallet.js.map