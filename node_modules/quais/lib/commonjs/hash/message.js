"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethVerifyMessage = exports.ethHashMessage = exports.verifyMessage = exports.hashMessage = void 0;
const index_js_1 = require("../crypto/index.js");
const index_js_2 = require("../constants/index.js");
const index_js_3 = require("../address/index.js");
const index_js_4 = require("../utils/index.js");
const index_js_5 = require("../encoding/index.js");
const strings_js_1 = require("../constants/strings.js");
/**
 * Computes the Quai Network equivalent of the [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal-sign message
 * digest to sign.
 *
 * This prefixes the message with {@link MessagePrefix | **MessagePrefix**} and the decimal length of `message` and
 * computes the {@link keccak256 | **keccak256**} digest.
 *
 * If `message` is a string, it is converted to its UTF-8 bytes first. To compute the digest of a
 * [**DataHexString**](../types-aliases/DataHex), it must be converted to [**bytes**](../functions/getBytes).
 *
 * @category Hash
 * @example
 *
 * ```ts
 * hashMessage('Hello World');
 *
 * // Hashes the SIX (6) string characters, i.e.
 * // [ "0", "x", "4", "2", "4", "3" ]
 * hashMessage('0x4243');
 *
 * // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
 * hashMessage(getBytes('0x4243'));
 *
 * // ...which is equal to using data
 * hashMessage(new Uint8Array([0x42, 0x43]));
 * ```
 *
 * @param {Uint8Array | string} message - The message to hash.
 * @returns {string} The message digest.
 */
function hashMessage(message) {
    if (typeof message === 'string') {
        message = (0, index_js_5.toUtf8Bytes)(message);
    }
    return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_5.toUtf8Bytes)(index_js_2.MessagePrefix), (0, index_js_5.toUtf8Bytes)(String(message.length)), message]));
}
exports.hashMessage = hashMessage;
/**
 * Return the address of the private key that produced the signature `sig` during signing for `message`.
 *
 * @category Hash
 * @param {Uint8Array | string} message - The message that was signed.
 * @param {SignatureLike} sig - The signature to verify.
 * @returns {string} The address of the signer.
 */
function verifyMessage(message, sig) {
    const digest = hashMessage(message);
    return (0, index_js_3.recoverAddress)(digest, sig);
}
exports.verifyMessage = verifyMessage;
/**
 * Computes the [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal-sign message digest to sign.
 *
 * This prefixes the message with {@link EthMessagePrefix | **EthMessagePrefix**} and the decimal length of `message` and
 * computes the {@link keccak256 | **keccak256**} digest.
 *
 * If `message` is a string, it is converted to its UTF-8 bytes first. To compute the digest of a
 * [**DataHexString**](../types-aliases/DataHex), it must be converted to [**bytes**](../functions/getBytes).
 *
 * This is the same as `hashMessage` except it uses `EthMessagePrefix` instead of `MessagePrefix` and is available for
 * broader compatibility with EVM signing practices.
 *
 * @category Hash
 * @param message
 * @returns
 */
function ethHashMessage(message) {
    if (typeof message === 'string') {
        message = (0, index_js_5.toUtf8Bytes)(message);
    }
    return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_5.toUtf8Bytes)(strings_js_1.EthMessagePrefix), (0, index_js_5.toUtf8Bytes)(String(message.length)), message]));
}
exports.ethHashMessage = ethHashMessage;
/**
 * Return the address of the private key that produced the signature `sig` during signing for `message`.
 *
 * This is the same as `verifyMessage` except it uses `EthMessagePrefix` instead of `MessagePrefix` and is available for
 * broader compatibility with EVM signing practices.
 *
 * @category Hash
 * @param message - The message that was signed.
 * @param sig - The signature to verify.
 * @returns {string} The address of the signer.
 */
function ethVerifyMessage(message, sig) {
    const digest = ethHashMessage(message);
    return (0, index_js_3.recoverAddress)(digest, sig);
}
exports.ethVerifyMessage = ethVerifyMessage;
//# sourceMappingURL=message.js.map