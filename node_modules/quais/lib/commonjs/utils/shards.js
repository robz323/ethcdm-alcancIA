"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getZoneFromNodeLocation = exports.getNodeLocationFromZone = exports.getTxType = exports.getAddressDetails = exports.getZoneForAddress = void 0;
const zones_js_1 = require("../constants/zones.js");
const checks_js_1 = require("../address/checks.js");
/**
 * Retrieves the shard information for a given address based on its byte prefix. The function parses the address to
 * extract its byte prefix, then filters the ShardData to find a matching shard entry. If no matching shard is found, it
 * returns null.
 *
 * @category Utils
 * @param {string} address - The blockchain address to be analyzed. The address should start with "0x" followed by the
 *   hexadecimal representation.
 * @returns {Object | null} An object containing the shard information, or null if no
 */
function getZoneForAddress(address) {
    try {
        return (0, zones_js_1.toZone)(address.slice(0, 4));
    }
    catch (error) {
        return null;
    }
}
exports.getZoneForAddress = getZoneForAddress;
/**
 * Extracts both zone and UTXO information from a given blockchain address. This function first determines the address's
 * zone by its byte prefix, then checks the 9th bit of the address to ascertain if it's a UTXO or non-UTXO address.
 *
 * @category Utils
 * @param {string} address - The blockchain address to be analyzed, expected to start with "0x" followed by its
 *   hexadecimal representation.
 * @returns {Object | null} An object containing the zone and UTXO information, or null if no address is found.
 */
function getAddressDetails(address) {
    const isQiLedger = (parseInt(address.substring(4, 5), 16) & 0x1) === zones_js_1.Ledger.Qi;
    return { zone: (0, zones_js_1.toZone)(address.substring(0, 4)), ledger: isQiLedger ? zones_js_1.Ledger.Qi : zones_js_1.Ledger.Quai };
}
exports.getAddressDetails = getAddressDetails;
/**
 * Determines the transaction type based on the sender and recipient addresses. The function checks if both addresses
 * are UTXO addresses, in which case it returns 2. If only the sender address is a UTXO address, it returns 1.
 * Otherwise, it returns 0.
 *
 * @category Utils
 * @param {string | null} from - The sender address. If null, the function returns 0.
 * @param {string | null} to - The recipient address. If null, the function returns 0.
 * @returns {number} The transaction type based on the addresses.
 */
function getTxType(from, to) {
    if (from === null || to === null)
        return 0;
    const senderAddressIsQi = (0, checks_js_1.isQiAddress)(from);
    const recipientAddressIsQi = (0, checks_js_1.isQiAddress)(to);
    switch (true) {
        case senderAddressIsQi && recipientAddressIsQi:
            return 2;
        case senderAddressIsQi && !recipientAddressIsQi:
            return 1;
        default:
            return 0;
    }
}
exports.getTxType = getTxType;
/**
 * Location of a chain within the Quai hierarchy
 *
 * Prime = [] region[0] = [0] zone[1,2] = [1, 2]
 *
 * @param shard - The shard to get the location for
 * @returns The location of the chain within the Quai hierarchy
 */
function getNodeLocationFromZone(zone) {
    const zoneId = zone.slice(2);
    if (zoneId.length > 2) {
        throw new Error(`Invalid zone: ${zone}`);
    }
    else if (zoneId.length === 0) {
        return [];
    }
    return zoneId.split('').map(Number);
}
exports.getNodeLocationFromZone = getNodeLocationFromZone;
function getZoneFromNodeLocation(location) {
    if (location.length > 2) {
        throw new Error('Invalid location');
    }
    return (0, zones_js_1.toZone)(`0x${location.join('')}`);
}
exports.getZoneFromNodeLocation = getZoneFromNodeLocation;
//# sourceMappingURL=shards.js.map