"use strict";
/**
 * All errors in quais include properties to ensure they are both human-readable (i.e. `.message`) and machine-readable
 * (i.e. `.code`).
 *
 * The {@link isError | **isError**} function can be used to check the error `code` and provide a type guard for the
 * properties present on that error interface.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;
const _version_js_1 = require("../_version.js");
const properties_js_1 = require("./properties.js");
function stringify(value) {
    if (value == null) {
        return 'null';
    }
    if (Array.isArray(value)) {
        return '[ ' + value.map(stringify).join(', ') + ' ]';
    }
    if (value instanceof Uint8Array) {
        const HEX = '0123456789abcdef';
        let result = '0x';
        for (let i = 0; i < value.length; i++) {
            result += HEX[value[i] >> 4];
            result += HEX[value[i] & 0xf];
        }
        return result;
    }
    if (typeof value === 'object' && typeof value.toJSON === 'function') {
        return stringify(value.toJSON());
    }
    switch (typeof value) {
        case 'boolean':
        case 'symbol':
            return value.toString();
        case 'bigint':
            return BigInt(value).toString();
        case 'number':
            return value.toString();
        case 'string':
            return JSON.stringify(value);
        case 'object': {
            const keys = Object.keys(value);
            keys.sort();
            return '{ ' + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(', ') + ' }';
        }
    }
    return `[ COULD NOT SERIALIZE ]`;
}
/**
 * Returns true if the `error` matches an error thrown by quais that matches the error `code`.
 *
 * In TypeScript environments, this can be used to check that `error` matches an quaisError type, which means the
 * expected properties will be set.
 *
 * @category Utils
 * @example
 *
 * ```ts
 * try {
 *     // code....
 * } catch (e) {
 *     if (isError(e, 'CALL_EXCEPTION')) {
 *         // The Type Guard has validated this object
 *         console.log(e.data);
 *     }
 * }
 * ```
 *
 * @see [ErrorCodes](api:ErrorCode)
 */
function isError(error, code) {
    return error && error.code === code;
}
exports.isError = isError;
/**
 * Returns true if `error` is a {@link CallExceptionError | **CallExceptionError**}.
 *
 * @category Utils
 */
function isCallException(error) {
    return isError(error, 'CALL_EXCEPTION');
}
exports.isCallException = isCallException;
/**
 * Returns a new Error configured to the format quais emits errors, with the `message`, {@link ErrorCode | **ErrorCode**}
 * `code` and additional properties for the corresponding quaisError.
 *
 * Each error in quais includes the version of quais, a machine-readable {@link ErrorCode | **ErrorCode**}, and depending
 * on `code`, additional required properties. The error message will also include the `message`, quais version, `code`
 * and all additional properties, serialized.
 *
 * @category Utils
 * @param {string} message - The error message.
 * @param {ErrorCode} code - The error code.
 * @param {ErrorInfo<T>} [info] - Additional properties for the error.
 * @returns {T} The new error.
 */
function makeError(message, code, info) {
    const shortMessage = message;
    {
        const details = [];
        if (info) {
            if ('message' in info || 'code' in info || 'name' in info) {
                throw new Error(`value will overwrite populated values: ${stringify(info)}`);
            }
            for (const key in info) {
                if (key === 'shortMessage') {
                    continue;
                }
                const value = info[key];
                details.push(key + '=' + stringify(value));
            }
        }
        details.push(`code=${code}`);
        details.push(`version=${_version_js_1.version}`);
        if (details.length) {
            message += ' (' + details.join(', ') + ')';
        }
    }
    let error;
    switch (code) {
        case 'INVALID_ARGUMENT':
            error = new TypeError(message);
            break;
        case 'NUMERIC_FAULT':
        case 'BUFFER_OVERRUN':
            error = new RangeError(message);
            break;
        default:
            error = new Error(message);
    }
    (0, properties_js_1.defineProperties)(error, { code });
    if (info) {
        Object.assign(error, info);
    }
    if (error.shortMessage == null) {
        (0, properties_js_1.defineProperties)(error, { shortMessage });
    }
    return error;
}
exports.makeError = makeError;
/**
 * Throws an quaisError with `message`, `code` and additional error `info` when `check` is falsish..
 *
 * @category Utils
 * @param {unknown} check - The value to check.
 * @param {string} message - The error message.
 * @param {ErrorCode} code - The error code.
 * @param {ErrorInfo<T>} [info] - Additional properties for the error.
 * @throws {T} Throws the error if `check` is falsish.
 */
function assert(check, message, code, info) {
    if (!check) {
        throw makeError(message, code, info);
    }
}
exports.assert = assert;
/**
 * A simple helper to simply ensuring provided arguments match expected constraints, throwing if not.
 *
 * In TypeScript environments, the `check` has been asserted true, so any further code does not need additional
 * compile-time checks.
 *
 * @category Utils
 * @param {unknown} check - The value to check.
 * @param {string} message - The error message.
 * @param {string} name - The name of the argument.
 * @param {unknown} value - The value of the argument.
 * @throws {InvalidArgumentError} Throws if `check` is falsish.
 */
function assertArgument(check, message, name, value) {
    assert(check, message, 'INVALID_ARGUMENT', { argument: name, value: value });
}
exports.assertArgument = assertArgument;
function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
        message = '';
    }
    if (message) {
        message = ': ' + message;
    }
    assert(count >= expectedCount, 'missing arguemnt' + message, 'MISSING_ARGUMENT', {
        count: count,
        expectedCount: expectedCount,
    });
    assert(count <= expectedCount, 'too many arguemnts' + message, 'UNEXPECTED_ARGUMENT', {
        count: count,
        expectedCount: expectedCount,
    });
}
exports.assertArgumentCount = assertArgumentCount;
const _normalizeForms = ['NFD', 'NFC', 'NFKD', 'NFKC'].reduce((accum, form) => {
    try {
        // General test for normalize
        /* c8 ignore start */
        if ('test'.normalize(form) !== 'test') {
            throw new Error('bad');
        }
        /* c8 ignore stop */
        if (form === 'NFD') {
            const check = String.fromCharCode(0xe9).normalize('NFD');
            const expected = String.fromCharCode(0x65, 0x0301);
            /* c8 ignore start */
            if (check !== expected) {
                throw new Error('broken');
            }
            /* c8 ignore stop */
        }
        accum.push(form);
        // eslint-disable-next-line no-empty
    }
    catch (error) { }
    return accum;
}, []);
/**
 * Throws if the normalization `form` is not supported.
 *
 * @category Utils
 * @param {string} form - The normalization form.
 * @throws {UnsupportedOperationError} Throws if the form is not supported.
 */
function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, 'platform missing String.prototype.normalize', 'UNSUPPORTED_OPERATION', {
        operation: 'String.prototype.normalize',
        info: { form },
    });
}
exports.assertNormalize = assertNormalize;
/**
 * Many classes use file-scoped values to guard the constructor, making it effectively private. This facilitates that
 * pattern by ensuring the `givenGuard` matches the file-scoped `guard`, throwing if not, indicating the `className%% if
 * provided.
 *
 * @category Utils
 * @param {any} givenGuard - The guard provided to the constructor.
 * @param {any} guard - The file-scoped guard.
 * @param {string} [className] - The class name.
 * @throws {UnsupportedOperationError} Throws if the guards do not match.
 */
function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
        className = '';
    }
    if (givenGuard !== guard) {
        let method = className, operation = 'new';
        if (className) {
            method += '.';
            operation += ' ' + className;
        }
        assert(false, `private constructor; use ${method}from* methods`, 'UNSUPPORTED_OPERATION', {
            operation,
        });
    }
}
exports.assertPrivate = assertPrivate;
//# sourceMappingURL=errors.js.map