"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isQuaiAddress = exports.isQiAddress = exports.validateAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;
const index_js_1 = require("../utils/index.js");
const address_js_1 = require("./address.js");
/**
 * Returns true if `value` is an object which implements the [**Addressable**](../interfaces/Addressable) interface.
 *
 * @category Address
 * @example
 *
 * ```js
 * // Wallets and AbstractSigner sub-classes
 * isAddressable(Wallet.createRandom());
 *
 * // Contracts
 * contract = new Contract('0x643aA0A61eADCC9Cc202D1915D942d35D005400C', [], provider);
 * isAddressable(contract);
 * ```
 *
 * @param {any} value - The value to check.
 * @returns {boolean} True if the value is an Addressable.
 */
function isAddressable(value) {
    return value && typeof value.getAddress === 'function';
}
exports.isAddressable = isAddressable;
/**
 * Returns true if `value` is a valid address.
 *
 * @category Address
 * @example
 *
 * ```js
 * // Valid address
 * isAddress('0x8ba1f109551bD432803012645Ac136ddd64DBA72');
 *
 * // Invalid checksum
 * isAddress('0x8Ba1f109551bD432803012645Ac136ddd64DBa72');
 * ```
 *
 * @param {any} value - The value to check.
 * @returns {boolean} True if the value is a valid address.
 */
function isAddress(value) {
    try {
        (0, address_js_1.getAddress)(value);
        return true;
        // eslint-disable-next-line no-empty
    }
    catch (error) { }
    return false;
}
exports.isAddress = isAddress;
async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === '0x0000000000000000000000000000000000000000') {
        (0, index_js_1.assertArgument)(false, 'invalid AddressLike value; did not resolve to a value address', 'target', target);
    }
    return result;
}
/**
 * Resolves to an address for the `target`, which may be any supported address type, an
 * [**Addressable**](../interfaces/Addressable) or a Promise which resolves to an address.
 *
 * @category Address
 * @example
 *
 * ```js
 * addr = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
 *
 * // Addresses are return synchronously
 * resolveAddress(addr, provider);
 *
 * // Address promises are resolved asynchronously
 * resolveAddress(Promise.resolve(addr));
 *
 * // Addressable objects are resolved asynchronously
 * contract = new Contract(addr, []);
 * resolveAddress(contract, provider);
 * ```
 *
 * @param {AddressLike} target - The target to resolve to an address.
 * @returns {string | Promise<string>} The resolved address.
 */
function resolveAddress(target) {
    if (typeof target === 'string') {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return target;
        }
    }
    else if (isAddressable(target)) {
        return checkAddress(target, target.getAddress());
    }
    else if (target && typeof target.then === 'function') {
        return checkAddress(target, target);
    }
    (0, index_js_1.assertArgument)(false, 'unsupported addressable value', 'target', target);
}
exports.resolveAddress = resolveAddress;
/**
 * Checks if the address is a valid mixed case checksummed address.
 *
 * @category Address
 * @param address - The address to validate.
 * @returns True if the address is a valid mixed case checksummed address.
 */
function validateAddress(address) {
    (0, index_js_1.assertArgument)(typeof address === 'string', 'address must be string', 'address', address);
    (0, index_js_1.assertArgument)(Boolean(address.match(/^(0x)?[0-9a-fA-F]{40}$/)), 'invalid address string format', 'address', address);
    (0, index_js_1.assertArgument)((0, address_js_1.formatMixedCaseChecksumAddress)(address) === address, 'invalid address checksum', 'address', address);
}
exports.validateAddress = validateAddress;
/**
 * Checks whether a given address is in the Qi ledger scope by checking the 9th bit of the address.
 *
 * @category Address
 * @param {string} address - The address to check
 * @returns {boolean} True if the address is in the Qi ledger scope, false otherwise.
 */
function isQiAddress(address) {
    const secondByte = address.substring(4, 6);
    const binaryString = parseInt(secondByte, 16).toString(2).padStart(8, '0');
    const isUTXO = binaryString[0] === '1';
    return isUTXO;
}
exports.isQiAddress = isQiAddress;
/**
 * Checks whether a given address is in the Quai ledger scope by checking the 9th bit of the address.
 *
 * @category Address
 * @param {string} address - The address to check
 * @returns {boolean} True if the address is in the Quai ledger scope, false otherwise.
 */
function isQuaiAddress(address) {
    return !isQiAddress(address);
}
exports.isQuaiAddress = isQuaiAddress;
//# sourceMappingURL=checks.js.map