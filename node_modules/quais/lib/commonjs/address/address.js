"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverAddress = exports.computeAddress = exports.getContractAddress = exports.getAddress = exports.formatMixedCaseChecksumAddress = void 0;
const index_js_1 = require("../crypto/index.js");
const index_js_2 = require("../utils/index.js");
function formatMixedCaseChecksumAddress(address) {
    address = address.toLowerCase();
    const chars = address.substring(2).split('');
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
    for (let i = 0; i < 40; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return '0x' + chars.join('');
}
exports.formatMixedCaseChecksumAddress = formatMixedCaseChecksumAddress;
/**
 * Returns a normalized and checksumed address for `address`. This accepts non-checksum addressesa and checksum
 * addresses.
 *
 * The checksum in Quai uses the capitalization (upper-case vs lower-case) of the characters within an address to encode
 * its checksum, which offers, on average, a checksum of 15-bits.
 *
 * If `address` contains both upper-case and lower-case, it is assumed to already be a checksum address and its checksum
 * is validated, and if the address fails its expected checksum an error is thrown.
 *
 * If you wish the checksum of `address` to be ignore, it should be converted to lower-case (i.e. `.toLowercase()`)
 * before being passed in. This should be a very rare situation though, that you wish to bypass the safeguards in place
 * to protect against an address that has been incorrectly copied from another source.
 *
 * @category Address
 * @example
 *
 * ```js
 * // Adds the checksum (via upper-casing specific letters)
 * getAddress('0x8ba1f109551bd432803012645ac136ddd64dba72');
 *
 * // Throws an error if an address contains mixed case,
 * // but the checksum fails
 * getAddress('0x8Ba1f109551bD432803012645Ac136ddd64DBA72');
 * ```
 */
function getAddress(address) {
    (0, index_js_2.assertArgument)(typeof address === 'string', 'invalid address', 'address', address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (!address.startsWith('0x')) {
            address = '0x' + address;
        }
        const result = formatMixedCaseChecksumAddress(address);
        // If original address is mix cased and recomputed version doesn't
        // match the original this could indicate a potential typo or mispaste.
        (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, 'invalid address checksum', 'address', address);
        return result;
    }
    (0, index_js_2.assertArgument)(false, 'invalid address string format', 'address', address);
}
exports.getAddress = getAddress;
function getContractAddress(from, nonce, data) {
    const nonceBytes = (0, index_js_2.zeroPadValue)((0, index_js_2.toBeHex)((0, index_js_2.toBigInt)(nonce)), 8);
    return getAddress((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)([getAddress(from), nonceBytes, (0, index_js_2.stripZerosLeft)(data)])), 12));
}
exports.getContractAddress = getContractAddress;
/**
 * Returns the address for the `key`.
 *
 * The key may be any standard form of public key or a private key.
 *
 * @category Address
 * @param {string | SigningKey} key - The key to compute the address for.
 * @returns {string} The address.
 */
function computeAddress(key) {
    let pubkey;
    if (typeof key === 'string') {
        pubkey = index_js_1.SigningKey.computePublicKey(key, false);
    }
    else {
        pubkey = key.publicKey;
    }
    return getAddress((0, index_js_1.keccak256)('0x' + pubkey.substring(4)).substring(26));
}
exports.computeAddress = computeAddress;
/**
 * Returns the recovered address for the private key that was used to sign `digest` that resulted in `signature`.
 *
 * @category Address
 * @param {BytesLike} digest - The digest of the message.
 * @param {SignatureLike} signature - The signature.
 * @returns {string} The address.
 */
function recoverAddress(digest, signature) {
    return computeAddress(index_js_1.SigningKey.recoverPublicKey(digest, signature));
}
exports.recoverAddress = recoverAddress;
//# sourceMappingURL=address.js.map