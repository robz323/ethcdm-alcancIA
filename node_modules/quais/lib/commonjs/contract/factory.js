"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractFactory = void 0;
const index_js_1 = require("../abi/index.js");
const index_js_2 = require("../utils/index.js");
const contract_js_1 = require("./contract.js");
const index_js_3 = require("../address/index.js");
const index_js_4 = require("../utils/index.js");
const index_js_5 = require("../wallet/index.js");
const index_js_6 = require("../address/index.js");
const properties_js_1 = require("../utils/properties.js");
const provider_jsonrpc_js_1 = require("../providers/provider-jsonrpc.js");
// A = Arguments to the constructor
// I = Interface of deployed contracts
/**
 * A **ContractFactory** is used to deploy a Contract to the blockchain.
 *
 * @category Contract
 */
class ContractFactory {
    /**
     * The Contract Interface.
     */
    interface;
    /**
     * The Contract deployment bytecode. Often called the initcode.
     */
    bytecode;
    /**
     * The ContractRunner to deploy the Contract as.
     */
    runner;
    /**
     * Create a new **ContractFactory** with `abi` and `bytecode`, optionally connected to `runner`.
     *
     * The `bytecode` may be the `bytecode` property within the standard Solidity JSON output.
     */
    constructor(abi, bytecode, runner) {
        const iface = index_js_1.Interface.from(abi);
        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
        if (bytecode instanceof Uint8Array) {
            bytecode = (0, index_js_2.hexlify)((0, index_js_2.getBytes)(bytecode));
        }
        else {
            if (typeof bytecode === 'object') {
                bytecode = bytecode.object;
            }
            if (!bytecode.startsWith('0x')) {
                bytecode = '0x' + bytecode;
            }
            bytecode = (0, index_js_2.hexlify)((0, index_js_2.getBytes)(bytecode));
        }
        (0, index_js_2.defineProperties)(this, {
            bytecode,
            interface: iface,
            runner: runner || null,
        });
    }
    attach(target) {
        return new contract_js_1.BaseContract(target, this.interface, this.runner);
    }
    /**
     * Resolves to the transaction to deploy the contract, passing `args` into the constructor.
     *
     * @param {ContractMethods<A>} args - The arguments to the constructor.
     * @returns {Promise<ContractDeployTransaction>} A promise resolving to the deployment transaction.
     */
    async getDeployTransaction(...args) {
        let overrides;
        const fragment = this.interface.deploy;
        if (fragment.inputs.length + 1 === args.length) {
            overrides = await (0, contract_js_1.copyOverrides)(args.pop());
            const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
            const data = (0, index_js_2.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
            return Object.assign({}, overrides, { data });
        }
        if (fragment.inputs.length !== args.length) {
            throw new Error('incorrect number of arguments to constructor');
        }
        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
        const data = (0, index_js_2.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
        const from = args.pop()?.from || undefined;
        return Object.assign({}, from, { data });
    }
    /**
     * Resolves to the Contract deployed by passing `args` into the constructor.
     *
     * This will resovle to the Contract before it has been deployed to the network, so the
     * [baseContract.waitForDeployment](../classes/BaseContract#waitForDeployment) should be used before sending any
     * transactions to it.
     *
     * @param {ContractMethods<A>} args - The arguments to the constructor.
     * @returns {Promise<
     *     BaseContract & { deploymentTransaction(): ContractTransactionResponse } & Omit<I, keyof BaseContract>
     * >}
     *   A promise resolving to the Contract.
     */
    async deploy(...args) {
        const tx = await this.getDeployTransaction(...args);
        (0, index_js_2.assert)(this.runner && typeof this.runner.sendTransaction === 'function', 'factory runner does not support sending transactions', 'UNSUPPORTED_OPERATION', {
            operation: 'sendTransaction',
        });
        if (this.runner instanceof index_js_5.Wallet || this.runner instanceof provider_jsonrpc_js_1.JsonRpcSigner) {
            (0, index_js_3.validateAddress)(this.runner.address);
            tx.from = this.runner.address;
        }
        const grindedTx = await this.grindContractAddress(tx);
        grindedTx.accessList = await this.runner.createAccessList?.(grindedTx);
        const sentTx = await this.runner.sendTransaction(grindedTx);
        const address = (0, properties_js_1.getStatic)(this.constructor, 'getContractAddress')?.(tx);
        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);
    }
    static getContractAddress(transaction) {
        return (0, index_js_6.getContractAddress)(transaction.from, BigInt(transaction.nonce), // Fix: Convert BigInt to bigint
        transaction.data);
    }
    async grindContractAddress(tx) {
        if (tx.nonce == null && tx.from) {
            tx.nonce = await this.runner?.provider?.getTransactionCount(tx.from);
        }
        const sender = String(tx.from);
        const toShard = (0, index_js_4.getZoneForAddress)(sender);
        let i = 0;
        const startingData = tx.data;
        const salt = new Uint8Array(4);
        // initialize salt with the lower 32 bits of the nonce
        new DataView(salt.buffer).setUint32(0, Number(tx.nonce) & 0xffffffff, false);
        while (i < 10000) {
            tx.data = (0, index_js_2.hexlify)((0, index_js_2.concat)([String(startingData), salt]));
            const contractAddress = (0, index_js_6.getContractAddress)(sender, BigInt(tx.nonce || 0), tx.data || '');
            const contractShard = (0, index_js_4.getZoneForAddress)(contractAddress);
            const utxo = (0, index_js_6.isQiAddress)(contractAddress);
            if (contractShard === toShard && !utxo) {
                return tx;
            }
            // Increment the salt
            let saltValue = new DataView(salt.buffer).getUint32(0, false);
            saltValue++;
            new DataView(salt.buffer).setUint32(0, saltValue, false);
            i++;
        }
        return tx;
    }
    /**
     * Return a new **ContractFactory** with the same ABI and bytecode, but connected to `runner`.
     *
     * @param {ContractRunner} runner - The runner to connect to.
     * @returns {ContractFactory<A, I>} A new ContractFactory.
     */
    connect(runner) {
        return new ContractFactory(this.interface, this.bytecode, runner);
    }
    /**
     * Create a new **ContractFactory** from the standard Solidity JSON output.
     *
     * @param {any} output - The Solidity JSON output.
     * @param {ContractRunner} runner - The runner to connect to.
     * @returns {ContractFactory<A, I>} A new ContractFactory.
     */
    static fromSolidity(output, runner) {
        (0, index_js_2.assertArgument)(output != null, 'bad compiler output', 'output', output);
        if (typeof output === 'string') {
            output = JSON.parse(output);
        }
        const abi = output.abi;
        let bytecode = '';
        if (output.bytecode) {
            bytecode = output.bytecode;
        }
        else if (output.evm && output.evm.bytecode) {
            bytecode = output.evm.bytecode;
        }
        return new this(abi, bytecode, runner);
    }
}
exports.ContractFactory = ContractFactory;
//# sourceMappingURL=factory.js.map