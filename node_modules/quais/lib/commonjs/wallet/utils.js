"use strict";
/**
 * @module wallet/utils
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ser_I = exports.encodeBase58Check = exports.zpad = exports.Nibbles = exports.N = exports.HardenedBit = exports.MasterSecret = exports.spelunk = exports.getPassword = exports.looseArrayify = void 0;
const index_js_1 = require("../utils/index.js");
const index_js_2 = require("../crypto/index.js");
const index_js_3 = require("../encoding/index.js");
/**
 * Converts a hex string to a Uint8Array. If the string does not start with '0x', it adds it.
 *
 * @param {string} hexString - The hex string to convert.
 * @returns {Uint8Array} The resulting byte array.
 */
function looseArrayify(hexString) {
    if (typeof hexString === 'string' && !hexString.startsWith('0x')) {
        hexString = '0x' + hexString;
    }
    return (0, index_js_1.getBytesCopy)(hexString);
}
exports.looseArrayify = looseArrayify;
/**
 * Converts a password to a Uint8Array. If the password is a string, it converts it to UTF-8 bytes.
 *
 * @param {string | Uint8Array} password - The password to convert.
 * @returns {Uint8Array} The resulting byte array.
 */
function getPassword(password) {
    if (typeof password === 'string') {
        return (0, index_js_3.toUtf8Bytes)(password, 'NFKC');
    }
    return (0, index_js_1.getBytesCopy)(password);
}
exports.getPassword = getPassword;
/**
 * Traverses an object based on a path and returns the value at that path.
 *
 * @param {any} object - The object to traverse.
 * @param {string} _path - The path to traverse.
 * @returns {T} The value at the specified path.
 */
function spelunk(object, _path) {
    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
    (0, index_js_1.assertArgument)(match != null, 'invalid path', 'path', _path);
    const path = match[1];
    const type = match[3];
    const reqd = match[4] === '!';
    let cur = object;
    for (const comp of path.toLowerCase().split('.')) {
        // Search for a child object with a case-insensitive matching key
        if (Array.isArray(cur)) {
            if (!comp.match(/^[0-9]+$/)) {
                break;
            }
            cur = cur[parseInt(comp)];
        }
        else if (typeof cur === 'object') {
            let found = null;
            for (const key in cur) {
                if (key.toLowerCase() === comp) {
                    found = cur[key];
                    break;
                }
            }
            cur = found;
        }
        else {
            cur = null;
        }
        if (cur == null) {
            break;
        }
    }
    (0, index_js_1.assertArgument)(!reqd || cur != null, 'missing required value', 'path', path);
    if (type && cur != null) {
        if (type === 'int') {
            if (typeof cur === 'string' && cur.match(/^-?[0-9]+$/)) {
                return parseInt(cur);
            }
            else if (Number.isSafeInteger(cur)) {
                return cur;
            }
        }
        if (type === 'number') {
            if (typeof cur === 'string' && cur.match(/^-?[0-9.]*$/)) {
                return parseFloat(cur);
            }
        }
        if (type === 'data') {
            if (typeof cur === 'string') {
                return looseArrayify(cur);
            }
        }
        if (type === 'array' && Array.isArray(cur)) {
            return cur;
        }
        if (type === typeof cur) {
            return cur;
        }
        (0, index_js_1.assertArgument)(false, `wrong type found for ${type} `, 'path', path);
    }
    return cur;
}
exports.spelunk = spelunk;
// HDNODEWallet and UTXO Wallet util methods
/**
 * "Bitcoin seed"
 */
exports.MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
/**
 * Hardened bit constant
 */
exports.HardenedBit = 0x80000000;
/**
 * Constant N used in cryptographic operations
 */
exports.N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
/**
 * Hexadecimal characters
 */
exports.Nibbles = '0123456789abcdef';
/**
 * Pads a value with leading zeros to a specified length.
 *
 * @param {string | number} value - The value to pad.
 * @param {number} length - The desired length.
 * @returns {string} The padded value.
 */
function zpad(value, length) {
    // Determine if the value is hexadecimal
    const isHex = typeof value === 'string' && value.startsWith('0x');
    // Handle hexadecimal values
    if (isHex) {
        let hexValue = value.substring(2); // Remove the "0x" prefix
        while (hexValue.length < length * 2) {
            // Hexadecimal characters count double
            hexValue = '0' + hexValue;
        }
        return '0x' + hexValue;
    }
    // Handle numbers or non-hexadecimal strings
    let result = String(value);
    while (result.length < length) {
        result = '0' + result;
    }
    return result;
}
exports.zpad = zpad;
/**
 * Encodes a value using Base58Check encoding.
 *
 * @param {BytesLike} _value - The value to encode.
 * @returns {string} The Base58Check encoded string.
 */
function encodeBase58Check(_value) {
    const value = (0, index_js_1.getBytes)(_value);
    const check = (0, index_js_1.dataSlice)((0, index_js_2.sha256)((0, index_js_2.sha256)(value)), 0, 4);
    const bytes = (0, index_js_1.concat)([value, check]);
    return (0, index_js_3.encodeBase58)(bytes);
}
exports.encodeBase58Check = encodeBase58Check;
/**
 * Serializes an index, chain code, public key, and private key into a pair of derived keys.
 *
 * @param {number} index - The index to serialize.
 * @param {string} chainCode - The chain code.
 * @param {string} publicKey - The public key.
 * @param {null | string} privateKey - The private key.
 * @returns {{ IL: Uint8Array; IR: Uint8Array }} The derived keys.
 */
function ser_I(index, chainCode, publicKey, privateKey) {
    const data = new Uint8Array(37);
    if (index & exports.HardenedBit) {
        (0, index_js_1.assert)(privateKey != null, 'cannot derive child of neutered node', 'UNSUPPORTED_OPERATION', {
            operation: 'deriveChild',
        });
        // Data = 0x00 || ser_256(k_par)
        data.set((0, index_js_1.getBytes)(privateKey), 1);
    }
    else {
        // Data = ser_p(point(k_par))
        data.set((0, index_js_1.getBytes)(publicKey));
    }
    // Data += ser_32(i)
    for (let i = 24; i >= 0; i -= 8) {
        data[33 + (i >> 3)] = (index >> (24 - i)) & 0xff;
    }
    const I = (0, index_js_1.getBytes)((0, index_js_2.computeHmac)('sha512', chainCode, data));
    return { IL: I.slice(0, 32), IR: I.slice(32) };
}
exports.ser_I = ser_I;
//# sourceMappingURL=utils.js.map