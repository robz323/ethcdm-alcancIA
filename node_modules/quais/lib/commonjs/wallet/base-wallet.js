"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseWallet = void 0;
const index_js_1 = require("../address/index.js");
const index_js_2 = require("../hash/index.js");
const index_js_3 = require("../signers/index.js");
const index_js_4 = require("../utils/index.js");
const quai_transaction_js_1 = require("../transaction/quai-transaction.js");
const index_js_5 = require("../crypto/index.js");
/**
 * The **BaseWallet** is a stream-lined implementation of a {@link AbstractSigner} that operates with a private key.
 *
 * It is preferred to use the {@link Wallet} class, as it offers additional functionality and simplifies loading a
 * variety of JSON formats, Mnemonic Phrases, etc.
 *
 * This class may be of use for those attempting to implement a minimal Signer.
 *
 * @category Wallet
 */
class BaseWallet extends index_js_3.AbstractSigner {
    /**
     * The wallet address.
     *
     * @type {string}
     * @readonly
     */
    #address;
    /**
     * The signing key used for signing payloads.
     *
     * @type {SigningKey}
     * @readonly
     */
    #signingKey;
    /**
     * Creates a new BaseWallet for `privateKey`, optionally connected to `provider`.
     *
     * If `provider` is not specified, only offline methods can be used.
     *
     * @param {SigningKey} privateKey - The private key for the wallet.
     * @param {null | Provider} [provider] - The provider to connect to.
     */
    constructor(privateKey, provider) {
        super(provider);
        (0, index_js_4.assertArgument)(privateKey && typeof privateKey.sign === 'function', 'invalid private key', 'privateKey', '[ REDACTED ]');
        this.#signingKey = privateKey;
        this.#address = (0, index_js_1.computeAddress)(this.signingKey.publicKey);
    }
    // Store private values behind getters to reduce visibility
    /**
     * The address of this wallet.
     *
     * @type {string}
     * @readonly
     */
    get address() {
        return this.#address;
    }
    /**
     * The {@link SigningKey | **SigningKey**} used for signing payloads.
     *
     * @type {SigningKey}
     * @readonly
     */
    get signingKey() {
        return this.#signingKey;
    }
    /**
     * The private key for this wallet.
     *
     * @type {string}
     * @readonly
     */
    get privateKey() {
        return this.signingKey.privateKey;
    }
    // TODO: `_zone` is not used, should it be removed?
    /**
     * Returns the address of this wallet.
     *
     * @param {string} [_zone] - The zone (optional).
     * @returns {Promise<string>} The wallet address.
     */
    // eslint-disable-next-line
    async getAddress(_zone) {
        return this.#address;
    }
    /**
     * Connects the wallet to a provider.
     *
     * @param {null | Provider} provider - The provider to connect to.
     * @returns {BaseWallet} The connected wallet.
     */
    connect(provider) {
        return new BaseWallet(this.#signingKey, provider);
    }
    /**
     * Signs a transaction.
     *
     * @param {QuaiTransactionRequest} tx - The transaction request.
     * @returns {Promise<string>} The signed transaction.
     */
    async signTransaction(tx) {
        // Replace any Addressable with an address
        const { to, from } = await (0, index_js_4.resolveProperties)({
            to: tx.to ? (0, index_js_1.resolveAddress)(tx.to) : undefined,
            from: tx.from ? (0, index_js_1.resolveAddress)(tx.from) : undefined,
        });
        if (to !== undefined) {
            (0, index_js_1.validateAddress)(to);
            tx.to = to;
        }
        if (from !== undefined) {
            (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(from) === this.#address, 'transaction from address mismatch', 'tx.from', from);
        }
        else {
            // No `from` specified, use the wallet's address
            tx.from = this.#address;
        }
        const btx = quai_transaction_js_1.QuaiTransaction.from(tx);
        const digest = (0, index_js_5.keccak256)(btx.unsignedSerialized);
        btx.signature = this.signingKey.sign(digest);
        return btx.serialized;
    }
    /**
     * Signs a message.
     *
     * @async
     * @param {string | Uint8Array} message - The message to sign.
     * @returns {Promise<string>} The signed message.
     */
    async signMessage(message) {
        return this.signMessageSync(message);
    }
    // @TODO: Add a secialized signTx and signTyped sync that enforces
    // all parameters are known?
    /**
     * Returns the signature for `message` signed with this wallet.
     *
     * @param {string | Uint8Array} message - The message to sign.
     * @returns {string} The serialized signature.
     */
    signMessageSync(message) {
        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
    }
    /**
     * Signs typed data.
     *
     * @async
     * @param {TypedDataDomain} domain - The domain of the typed data.
     * @param {Record<string, TypedDataField[]>} types - The types of the typed data.
     * @param {Record<string, any>} value - The value of the typed data.
     * @returns {Promise<string>} The signed typed data.
     */
    async signTypedData(domain, types, value) {
        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(domain, types, value)).serialized;
    }
}
exports.BaseWallet = BaseWallet;
//# sourceMappingURL=base-wallet.js.map