"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessListify = void 0;
const index_js_1 = require("../address/index.js");
const index_js_2 = require("../address/index.js");
const index_js_3 = require("../utils/index.js");
/**
 * Converts an address and storage keys into an access set.
 *
 * @param {string} addr - The address to validate and convert.
 * @param {string[]} storageKeys - The storage keys to validate and convert.
 * @returns {{ address: string; storageKeys: string[] }} The access set.
 */
function accessSetify(addr, storageKeys) {
    (0, index_js_1.validateAddress)(addr);
    return {
        address: (0, index_js_2.getAddress)(addr),
        storageKeys: storageKeys.map((storageKey, index) => {
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(storageKey, 32), 'invalid slot', `storageKeys[${index}]`, storageKey);
            return storageKey.toLowerCase();
        }),
    };
}
/**
 * Returns an {@link AccessList | **AccessList**} from any quasi-supported access-list structure.
 *
 * @category Transaction
 * @param {AccessListish} value - The value to convert to an access list.
 * @returns {AccessList} The access list.
 * @throws {Error} If the value is not a valid access list.
 */
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                (0, index_js_3.assertArgument)(set.length === 2, 'invalid slot set', `value[${index}]`, set);
                return accessSetify((0, index_js_2.formatMixedCaseChecksumAddress)(set[0]), set[1]);
            }
            (0, index_js_3.assertArgument)(set != null && typeof set === 'object', 'invalid address-slot set', 'value', value);
            return accessSetify((0, index_js_2.formatMixedCaseChecksumAddress)(set.address), set.storageKeys);
        });
    }
    (0, index_js_3.assertArgument)(value != null && typeof value === 'object', 'invalid access list', 'value', value);
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => a.address.localeCompare(b.address));
    return result;
}
exports.accessListify = accessListify;
//# sourceMappingURL=accesslist.js.map