"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractTransaction = void 0;
const index_js_1 = require("../crypto/index.js");
const index_js_2 = require("../utils/index.js");
const proto_encode_js_1 = require("../encoding/proto-encode.js");
/**
 * An **AbstractTransaction** describes the common operations to be executed on Quai and Qi ledgers by an Externally
 * Owned Account (EOA). This class must be subclassed by concrete implementations of transactions on each ledger.
 */
class AbstractTransaction {
    _type;
    _signature;
    _chainId;
    /**
     * The transaction type.
     *
     * If null, the type will be automatically inferred based on explicit properties.
     */
    get type() {
        return this._type;
    }
    set type(value) {
        switch (value) {
            case null:
                this._type = null;
                break;
            case 0:
            case 'standard':
                this._type = 0;
                break;
            case 2:
            case 'utxo':
                this._type = 2;
                break;
            default:
                (0, index_js_2.assertArgument)(false, 'unsupported transaction type', 'type', value);
        }
    }
    /**
     * The name of the transaction type.
     */
    get typeName() {
        switch (this.type) {
            case 0:
                return 'standard';
            case 1:
                return 'external';
            case 2:
                return 'utxo';
        }
        return null;
    }
    /**
     * The chain ID this transaction is valid on.
     */
    get chainId() {
        return this._chainId;
    }
    set chainId(value) {
        this._chainId = (0, index_js_2.getBigInt)(value);
    }
    /**
     * If signed, the signature for this transaction.
     */
    get signature() {
        return (this._signature || null);
    }
    set signature(value) {
        if (typeof value === 'string') {
            this._signature = value;
        }
        else {
            this._signature = (value == null ? null : index_js_1.Signature.from(value));
        }
    }
    /**
     * Creates a new Transaction with default values.
     */
    constructor() {
        this._type = null;
        this._chainId = BigInt(0);
        this._signature = null;
    }
    /**
     * The pre-image hash of this transaction.
     *
     * This is the digest that a [Signer](../interfaces/Signer) must sign to authorize this transaction.
     */
    get digest() {
        return (0, index_js_1.keccak256)(this.unsignedSerialized);
    }
    /**
     * Returns true if signed.
     *
     * This provides a Type Guard that properties requiring a signed transaction are non-null.
     *
     * @returns {boolean} Indicates if the transaction is signed.
     */
    isSigned() {
        return this.signature != null;
    }
    /**
     * The serialized transaction.
     *
     * This throws if the transaction is unsigned. For the pre-image, use
     * {@link AbstractTransaction.unsignedSerialized | **unsignedSerialized** }.
     */
    get serialized() {
        (0, index_js_2.assert)(this.signature != null, 'cannot serialize unsigned transaction; maybe you meant .unsignedSerialized', 'UNSUPPORTED_OPERATION', { operation: '.serialized' });
        return (0, proto_encode_js_1.encodeProtoTransaction)(this.toProtobuf(true));
    }
    /**
     * The transaction pre-image.
     *
     * The hash of this is the digest which needs to be signed to authorize this transaction.
     */
    get unsignedSerialized() {
        return (0, proto_encode_js_1.encodeProtoTransaction)(this.toProtobuf(false));
    }
    /**
     * Return the most "likely" type; currently the highest supported transaction type.
     *
     * @returns {number} The inferred transaction type.
     */
    inferType() {
        return this.inferTypes().pop();
    }
    /**
     * Check if the transaction is external.
     *
     * @returns {boolean} True if the transaction is external.
     */
    get isExternal() {
        return this.destZone !== undefined && this.originZone !== this.destZone;
    }
}
exports.AbstractTransaction = AbstractTransaction;
//# sourceMappingURL=abstract-transaction.js.map