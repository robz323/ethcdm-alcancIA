"use strict";
/**
 * A **Network** encapsulates the various properties required to interact with a specific chain.
 *
 * @category Providers
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Network = void 0;
const index_js_1 = require("../utils/index.js");
const Networks = new Map();
/**
 * A **Network** provides access to a chain's properties and allows for plug-ins to extend functionality.
 *
 * @category Providers
 */
class Network {
    #name;
    #chainId;
    /**
     * Creates a new **Network** for `name` and `chainId`.
     *
     * @param {string} name - The network name.
     * @param {BigNumberish} chainId - The network chain ID.
     */
    constructor(name, chainId) {
        this.#name = name;
        this.#chainId = (0, index_js_1.getBigInt)(chainId);
    }
    /**
     * Returns a JSON-compatible representation of a Network.
     *
     * @returns {Object} The JSON representation of the network.
     */
    toJSON() {
        return { name: this.name, chainId: String(this.chainId) };
    }
    /**
     * The network common name.
     *
     * This is the canonical name, as networks might have multiple names.
     *
     * @returns {string} The network name.
     */
    get name() {
        return this.#name;
    }
    /**
     * Sets the network name.
     *
     * @param {string} value - The new network name.
     */
    set name(value) {
        this.#name = value;
    }
    /**
     * The network chain ID.
     *
     * @returns {bigint} The network chain ID.
     */
    get chainId() {
        return this.#chainId;
    }
    /**
     * Sets the network chain ID.
     *
     * @param {BigNumberish} value - The new network chain ID.
     */
    set chainId(value) {
        this.#chainId = (0, index_js_1.getBigInt)(value, 'chainId');
    }
    /**
     * Returns true if `other` matches this network. Any chain ID must match, and if no chain ID is present, the name
     * must match.
     *
     * This method does not currently check for additional properties, such as plug-in compatibility.
     *
     * @ignore
     * @param {Networkish} other - The network to compare.
     * @returns {boolean} True if the networks match.
     */
    matches(other) {
        if (other == null) {
            return false;
        }
        if (typeof other === 'string') {
            try {
                return this.chainId === (0, index_js_1.getBigInt)(other);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            return this.name === other;
        }
        if (typeof other === 'number' || typeof other === 'bigint') {
            try {
                return this.chainId === (0, index_js_1.getBigInt)(other);
                // eslint-disable-next-line no-empty
            }
            catch (error) { }
            return false;
        }
        if (typeof other === 'object') {
            if (other.chainId != null) {
                try {
                    return this.chainId === (0, index_js_1.getBigInt)(other.chainId);
                    // eslint-disable-next-line no-empty
                }
                catch (error) { }
                return false;
            }
            if (other.name != null) {
                return this.name === other.name;
            }
            return false;
        }
        return false;
    }
    /**
     * Create a copy of this Network.
     *
     * @returns {Network} A new Network instance.
     */
    clone() {
        const clone = new Network(this.name, this.chainId);
        return clone;
    }
    /**
     * Returns a new Network for the `network` name or chainId.
     *
     * @param {Networkish} [network] - The network to get.
     * @returns {Network} The Network instance.
     * @throws {Error} If the network is invalid.
     */
    static from(network) {
        // Default network
        if (network == null) {
            return Network.from('mainnet');
        }
        // Canonical name or chain ID
        if (typeof network === 'number') {
            network = BigInt(network);
        }
        if (typeof network === 'string' || typeof network === 'bigint') {
            const networkFunc = Networks.get(network);
            if (networkFunc) {
                return networkFunc();
            }
            if (typeof network === 'bigint') {
                return new Network('unknown', network);
            }
            (0, index_js_1.assertArgument)(false, 'unknown network', 'network', network);
        }
        // Clonable with network-like abilities
        if (typeof network.clone === 'function') {
            const clone = network.clone();
            return clone;
        }
        // Networkish
        if (typeof network === 'object') {
            (0, index_js_1.assertArgument)(typeof network.name === 'string' && typeof network.chainId === 'number', 'invalid network object name or chainId', 'network', network);
            const custom = new Network(network.name, network.chainId);
            return custom;
        }
        (0, index_js_1.assertArgument)(false, 'invalid network', 'network', network);
    }
    /**
     * Register `nameOrChainId` with a function which returns an instance of a Network representing that chain.
     *
     * @param {string | number | bigint} nameOrChainId - The name or chain ID to register.
     * @param {() => Network} networkFunc - The function to create the Network.
     * @throws {Error} If a network is already registered for `nameOrChainId`.
     */
    static register(nameOrChainId, networkFunc) {
        if (typeof nameOrChainId === 'number') {
            nameOrChainId = BigInt(nameOrChainId);
        }
        const existing = Networks.get(nameOrChainId);
        if (existing) {
            (0, index_js_1.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, 'nameOrChainId', nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
    }
}
exports.Network = Network;
//# sourceMappingURL=network.js.map