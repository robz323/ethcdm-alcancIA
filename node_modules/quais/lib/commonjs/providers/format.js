"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatOutpoints = exports.formatExternalTransactionResponse = exports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatEtx = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatNumber = exports.handleNumber = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;
/**
 * @ignore
 */
const index_js_1 = require("../address/index.js");
const index_js_2 = require("../crypto/index.js");
const index_js_3 = require("../transaction/index.js");
const data_js_1 = require("../utils/data.js");
const index_js_4 = require("../utils/index.js");
const BN_0 = BigInt(0);
function allowNull(format, nullValue) {
    return function (value) {
        if (value == null) {
            return nullValue;
        }
        return format(value);
    };
}
exports.allowNull = allowNull;
function arrayOf(format) {
    return (array) => {
        if (!Array.isArray(array)) {
            throw new Error('not an array');
        }
        return array.map((i) => format(i));
    };
}
exports.arrayOf = arrayOf;
// Requires an object which matches a fleet of other formatters
// Any FormatFunc may return `undefined` to have the value omitted
// from the result object. Calls preserve `this`.
function object(format, altNames) {
    return (value) => {
        const result = {};
        for (const key in format) {
            let srcKey = key;
            if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                    if (altKey in value) {
                        srcKey = altKey;
                        break;
                    }
                }
            }
            try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                    result[key] = nv;
                }
            }
            catch (error) {
                const message = error instanceof Error ? error.message : 'not-an-error';
                (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, 'BAD_DATA', { value });
            }
        }
        return result;
    };
}
exports.object = object;
function formatBoolean(value) {
    switch (value) {
        case true:
        case 'true':
            return true;
        case false:
        case 'false':
            return false;
    }
    (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, 'value', value);
}
exports.formatBoolean = formatBoolean;
function formatData(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value), 'invalid data', 'value', value);
    return value;
}
exports.formatData = formatData;
function formatHash(value) {
    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), 'invalid hash', 'value', value);
    return value;
}
exports.formatHash = formatHash;
function formatUint256(value) {
    if (!(0, index_js_4.isHexString)(value)) {
        throw new Error('invalid uint256');
    }
    return (0, index_js_4.zeroPadValue)(value, 32);
}
exports.formatUint256 = formatUint256;
function handleNumber(_value, param) {
    if (_value === '0x') {
        return 0;
    }
    return (0, index_js_4.getNumber)(_value, param);
}
exports.handleNumber = handleNumber;
function formatNumber(_value, name) {
    const value = (0, index_js_4.getBigInt)(_value, 'value');
    const result = (0, index_js_4.toBeArray)(value);
    (0, index_js_4.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);
    return result;
}
exports.formatNumber = formatNumber;
const _formatLog = object({
    address: index_js_1.getAddress,
    blockHash: formatHash,
    blockNumber: index_js_4.getNumber,
    data: formatData,
    index: index_js_4.getNumber,
    removed: allowNull(formatBoolean, false),
    topics: arrayOf(formatHash),
    transactionHash: formatHash,
    transactionIndex: index_js_4.getNumber,
}, {
    index: ['logIndex'],
});
function formatLog(value) {
    return _formatLog(value);
}
exports.formatLog = formatLog;
const _formatHeader = object({
    baseFeePerGas: index_js_4.getBigInt,
    efficiencyScore: index_js_4.getBigInt,
    etxEligibleSlices: formatHash,
    etxSetRoot: formatHash,
    evmRoot: formatHash,
    expansionNumber: index_js_4.getNumber,
    etxRollupRoot: formatHash,
    outboundEtxsRoot: formatHash,
    extraData: formatData,
    gasLimit: index_js_4.getBigInt,
    gasUsed: index_js_4.getBigInt,
    interlinkRootHash: formatHash,
    manifestHash: arrayOf(formatHash),
    number: arrayOf(index_js_4.getNumber),
    parentDeltaEntropy: arrayOf(index_js_4.getBigInt),
    parentEntropy: arrayOf(index_js_4.getBigInt),
    parentHash: arrayOf(formatHash),
    parentUncledDeltaEntropy: arrayOf(index_js_4.getBigInt),
    primeTerminusHash: formatHash,
    quaiStateSize: index_js_4.getBigInt,
    receiptsRoot: formatHash,
    uncleHash: formatHash,
    size: index_js_4.getBigInt,
    stateLimit: index_js_4.getBigInt,
    stateUsed: index_js_4.getBigInt,
    thresholdCount: index_js_4.getBigInt,
    transactionsRoot: formatHash,
    uncledEntropy: index_js_4.getBigInt,
    utxoRoot: formatHash,
    secondaryCoinbase: allowNull(index_js_1.getAddress),
    exchangeRate: index_js_4.getBigInt,
    quaiToQi: index_js_4.getBigInt,
    qiToQuai: index_js_4.getBigInt,
});
const _formatUncle = object({
    primaryCoinbase: allowNull(index_js_1.getAddress),
    difficulty: index_js_4.getNumber,
    headerHash: formatHash,
    location: formatData,
    mixHash: formatHash,
    nonce: formatData,
    number: index_js_4.getNumber,
    parentHash: formatHash,
    primeTerminusNumber: index_js_4.getNumber,
    timestamp: index_js_4.getNumber,
    txHash: formatHash,
    lock: index_js_4.getNumber,
});
const _formatBlock = object({
    outboundEtxs: arrayOf((tx) => {
        if (typeof tx === 'string') {
            return formatHash(tx);
        }
        return formatExternalTransactionResponse(tx);
    }),
    hash: formatHash,
    header: _formatHeader,
    interlinkHashes: arrayOf(formatHash),
    size: index_js_4.getBigInt,
    subManifest: arrayOf(formatData),
    totalEntropy: index_js_4.getBigInt,
    transactions: arrayOf((tx) => {
        if (typeof tx === 'string') {
            return formatHash(tx);
        }
        return formatTransactionResponse(tx);
    }),
    uncles: arrayOf(_formatUncle),
    woHeader: _formatUncle,
    workShares: allowNull(arrayOf(_formatUncle), []),
});
function formatBlock(value) {
    const result = _formatBlock(value);
    result.transactions = value.transactions.map((tx) => {
        if (typeof tx === 'string') {
            return tx;
        }
        if ('originatingTxHash' in tx) {
            return formatExternalTransactionResponse(tx);
        }
        return formatTransactionResponse(tx);
    });
    result.outboundEtxs = value.outboundEtxs.map((tx) => {
        if (typeof tx === 'string') {
            return tx;
        }
        return formatExternalTransactionResponse(tx);
    });
    return result;
}
exports.formatBlock = formatBlock;
const _formatReceiptLog = object({
    transactionIndex: index_js_4.getNumber,
    blockNumber: index_js_4.getNumber,
    transactionHash: formatHash,
    address: index_js_1.getAddress,
    topics: arrayOf(formatHash),
    data: formatData,
    index: index_js_4.getNumber,
    blockHash: formatHash,
}, {
    index: ['logIndex'],
});
function formatReceiptLog(value) {
    return _formatReceiptLog(value);
}
exports.formatReceiptLog = formatReceiptLog;
const _formatEtx = object({
    type: allowNull(index_js_4.getNumber, 0),
    nonce: allowNull(index_js_4.getNumber),
    gasPrice: allowNull(index_js_4.getBigInt),
    minerTip: allowNull(index_js_4.getBigInt),
    gas: allowNull(index_js_4.getBigInt),
    value: allowNull(index_js_4.getBigInt, BN_0),
    input: allowNull(formatData),
    to: allowNull(index_js_1.getAddress, null),
    accessList: allowNull(index_js_3.accessListify, null),
    from: index_js_1.getAddress,
    originatingTxHash: formatHash,
    etxIndex: index_js_4.getNumber,
    chainId: allowNull(index_js_4.getBigInt, null),
    etxType: index_js_4.getNumber,
    hash: formatHash,
}, {
    from: ['from'],
});
function formatEtx(value) {
    return _formatEtx(value);
}
exports.formatEtx = formatEtx;
const _formatTransactionReceipt = object({
    to: allowNull(index_js_1.getAddress, null),
    from: allowNull(index_js_1.getAddress, null),
    contractAddress: allowNull(index_js_1.getAddress, null),
    index: index_js_4.getNumber,
    gasUsed: index_js_4.getBigInt,
    logsBloom: allowNull(formatData),
    blockHash: formatHash,
    hash: formatHash,
    logs: arrayOf(formatReceiptLog),
    blockNumber: index_js_4.getNumber,
    cumulativeGasUsed: index_js_4.getBigInt,
    effectiveGasPrice: allowNull(index_js_4.getBigInt),
    status: allowNull(index_js_4.getNumber),
    type: allowNull(index_js_4.getNumber, 0),
    outboundEtxs: (value) => (value ? arrayOf(formatEtx)(value) : value),
    originatingTxHash: allowNull(formatHash),
    etxType: allowNull(index_js_4.getNumber),
}, {
    hash: ['transactionHash'],
    index: ['transactionIndex'],
});
function formatTransactionReceipt(value) {
    const result = _formatTransactionReceipt(value);
    return result;
}
exports.formatTransactionReceipt = formatTransactionReceipt;
function formatTransactionResponse(value) {
    // Determine if it is a Quai or Qi transaction based on the type
    const transactionType = parseInt(value.type, 16);
    switch (transactionType) {
        case 0x0:
            return formatQuaiTransactionResponse(value);
        case 0x1:
            return formatExternalTransactionResponse(value);
        case 0x2:
            return formatQiTransactionResponse(value);
        default:
            throw new Error('Unknown transaction type');
    }
}
exports.formatTransactionResponse = formatTransactionResponse;
function formatExternalTransactionResponse(value) {
    const result = object({
        hash: formatHash,
        type: (value) => {
            if (value === '0x' || value == null) {
                return 0;
            }
            return parseInt(value, 16);
        },
        accessList: allowNull(index_js_3.accessListify, null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
        index: allowNull((value) => (value ? BigInt(value) : null), null),
        from: allowNull(index_js_1.getAddress, null),
        minerTip: allowNull((value) => (value ? BigInt(value) : null)),
        gasPrice: allowNull((value) => (value ? BigInt(value) : null)),
        gasLimit: allowNull((value) => (value ? BigInt(value) : null), null),
        to: allowNull(index_js_1.getAddress, null),
        value: allowNull((value) => (value ? BigInt(value) : null), null),
        nonce: allowNull((value) => (value ? parseInt(value, 10) : null), null),
        creates: allowNull(index_js_1.getAddress, null),
        chainId: allowNull((value) => (value ? BigInt(value) : null), null),
        originatingTxHash: allowNull(formatHash, null),
        etxIndex: allowNull((value) => (value ? parseInt(value, 10) : null), null),
        etxType: allowNull((value) => value, null),
        data: (value) => value,
    }, {
        data: ['input'],
        gasLimit: ['gas'],
        index: ['transactionIndex'],
    })(value);
    // 0x0000... should actually be null
    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
        result.blockHash = null;
    }
    return result;
}
exports.formatExternalTransactionResponse = formatExternalTransactionResponse;
function formatQuaiTransactionResponse(value) {
    const result = object({
        hash: formatHash,
        type: (value) => {
            if (value === '0x' || value == null) {
                return 0;
            }
            return parseInt(value, 16);
        },
        accessList: allowNull(index_js_3.accessListify, null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
        index: allowNull((value) => (value ? BigInt(value) : null), null),
        from: allowNull(index_js_1.getAddress, null),
        minerTip: allowNull((value) => (value ? BigInt(value) : null)),
        gasPrice: allowNull((value) => (value ? BigInt(value) : null)),
        gasLimit: allowNull((value) => (value ? BigInt(value) : null), null),
        to: allowNull(index_js_1.getAddress, null),
        value: allowNull((value) => (value ? BigInt(value) : null), null),
        nonce: allowNull((value) => (value ? parseInt(value, 10) : null), null),
        creates: allowNull(index_js_1.getAddress, null),
        chainId: allowNull((value) => (value ? BigInt(value) : null), null),
        etxType: allowNull((value) => parseInt(value, 16), null),
        data: (value) => value,
    }, {
        data: ['input'],
        gasLimit: ['gas'],
        index: ['transactionIndex'],
    })(value);
    // Add an access list if missing
    if (value.accessList == null) {
        result.accessList = [];
    }
    // Compute the signature
    if (value.signature) {
        result.signature = index_js_2.Signature.from(value.signature);
        // Some backends omit ChainId on legacy transactions, but we can compute it
        if (result.chainId == null) {
            const chainId = result.signature.legacyChainId;
            if (chainId != null) {
                result.chainId = chainId;
            }
        }
    }
    // 0x0000... should actually be null
    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
        result.blockHash = null;
    }
    return result;
}
function formatQiTransactionResponse(value) {
    return object({
        hash: formatHash,
        type: (value) => {
            if (value === '0x' || value == null) {
                return 0;
            }
            return parseInt(value, 16);
        },
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull((value) => (value ? parseInt(value, 16) : null), null),
        chainId: allowNull((value) => (value ? BigInt(value) : null), null),
        signature: (value) => value,
        txInputs: allowNull(formatTxInputs, []),
        txOutputs: allowNull(formatTxOutputs, []),
    }, {
        index: ['transactionIndex'],
        signature: ['utxoSignature'],
        txInputs: ['inputs'],
        txOutputs: ['outputs'],
    })(value);
}
const formatTxInputs = (value) => {
    return value?.map(_formatTxInput);
};
const _formatTxInput = (value) => {
    return {
        txhash: formatHash(value.previousOutPoint.txHash),
        index: (0, index_js_4.getNumber)(value.previousOutPoint.index),
        pubkey: (0, data_js_1.hexlify)(value.pubKey),
    };
};
const formatTxOutputs = (value) => {
    return value?.map(_formatTxOutput);
};
const _formatTxOutput = (value) => {
    return {
        denomination: (0, index_js_4.getNumber)(value.denomination),
        lock: (0, index_js_4.getNumber)(value.lock),
        address: (0, index_js_1.getAddress)(value.address),
    };
};
const _formatOutpoint = object({
    denomination: (value) => (0, index_js_4.getNumber)(value),
    index: (value) => (0, index_js_4.getNumber)(value),
    lock: (value) => (0, index_js_4.getNumber)(value),
    txhash: formatHash,
}, {
    txhash: ['txHash'],
});
function formatOutpoints(outpoints) {
    return outpoints.map(_formatOutpoint);
}
exports.formatOutpoints = formatOutpoints;
//# sourceMappingURL=format.js.map