"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;
const index_js_1 = require("../utils/index.js");
const subscriber_polling_js_1 = require("./subscriber-polling.js");
const provider_js_1 = require("./provider.js");
/**
 * Deep copies an object.
 *
 * @param {any} obj - The object to copy.
 * @returns {any} A deep copy of the object.
 */
function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * Some backends support subscribing to events using a Filter ID.
 *
 * When subscribing with this technique, the node issues a unique **Filter ID**. At this point the node dedicates
 * resources to the filter, so that periodic calls to follow up on the **Filter ID** will receive any events since the
 * last call.
 *
 * @category Providers
 */
class FilterIdSubscriber {
    #provider;
    #filterIdPromise;
    #poller;
    #running;
    #network;
    #hault;
    zone;
    /**
     * @ignore Creates A new **FilterIdSubscriber** which will use {@link FilterIdSubscriber._subscribe | **_subscribe**}
     *   and {@link FilterIdSubscriber._emitResults | **_emitResults**} to setup the subscription and provide the event
     *   to the `provider`.
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     */
    constructor(provider, zone) {
        this.#provider = provider;
        this.#filterIdPromise = null;
        this.#poller = this.#poll.bind(this);
        this.#running = false;
        this.#network = null;
        this.#hault = false;
        this.zone = zone;
    }
    /**
     * Sub-classes **must** override this to begin the subscription.
     *
     * @ignore
     * @param {JsonRpcApiProvider} provider - The provider to use.
     * @returns {Promise<string>} A promise that resolves to the subscription ID.
     * @throws {Error} If the method is not overridden.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _subscribe(provider) {
        throw new Error('subclasses must override this');
    }
    /**
     * Sub-classes **must** override this to handle the events.
     *
     * @ignore
     * @param {AbstractProvider} provider - The provider to use.
     * @param {any[]} result - The results to handle.
     * @returns {Promise<void>} A promise that resolves when the results are handled.
     * @throws {Error} If the method is not overridden.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _emitResults(provider, result) {
        throw new Error('subclasses must override this');
    }
    /**
     * Sub-classes **must** override this to handle recovery on errors.
     *
     * @ignore
     * @param {AbstractProvider} provider - The provider to use.
     * @returns {Subscriber} The recovered subscriber.
     * @throws {Error} If the method is not overridden.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _recover(provider) {
        throw new Error('subclasses must override this');
    }
    /**
     * Polls for new events.
     *
     * @ignore
     * @param {number} blockNumber - The block number to poll from.
     * @returns {Promise<void>} A promise that resolves when polling is complete.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async #poll(blockNumber) {
        try {
            // Subscribe if necessary
            if (this.#filterIdPromise == null) {
                this.#filterIdPromise = this._subscribe(this.#provider);
            }
            // Get the Filter ID
            let filterId = null;
            try {
                filterId = await this.#filterIdPromise;
            }
            catch (error) {
                if (!(0, index_js_1.isError)(error, 'UNSUPPORTED_OPERATION') || error.operation !== 'quai_newFilter') {
                    throw error;
                }
            }
            // The backend does not support Filter ID; downgrade to
            // polling
            if (filterId == null) {
                this.#filterIdPromise = null;
                this.#provider._recoverSubscriber(this, this._recover(this.#provider));
                return;
            }
            const network = await this.#provider.getNetwork();
            if (!this.#network) {
                this.#network = network;
            }
            if (this.#network.chainId !== network.chainId) {
                throw new Error('chain changed');
            }
            if (this.#hault) {
                return;
            }
            const result = await this.#provider.send('quai_getFilterChanges', [filterId]);
            await this._emitResults(this.#provider, result);
        }
        catch (error) {
            console.log('@TODO', error);
        }
        this.#provider.once('block', this.#poller, this.zone);
    }
    /**
     * Tears down the subscription.
     *
     * @ignore
     */
    #teardown() {
        const filterIdPromise = this.#filterIdPromise;
        if (filterIdPromise) {
            this.#filterIdPromise = null;
            filterIdPromise.then((filterId) => {
                this.#provider.send('quai_uninstallFilter', [filterId]);
            });
        }
    }
    /**
     * Starts the subscriber.
     */
    start() {
        if (this.#running) {
            return;
        }
        this.#running = true;
        this.#poll(-2);
    }
    /**
     * Stops the subscriber.
     */
    stop() {
        if (!this.#running) {
            return;
        }
        this.#running = false;
        this.#hault = true;
        this.#teardown();
        this.#provider.off('block', this.#poller, this.zone);
    }
    /**
     * Pauses the subscriber.
     *
     * @param {boolean} [dropWhilePaused] - Whether to drop the subscription while paused.
     */
    pause(dropWhilePaused) {
        if (dropWhilePaused) {
            this.#teardown();
        }
        this.#provider.off('block', this.#poller, this.zone);
    }
    /**
     * Resumes the subscriber.
     */
    resume() {
        this.start();
    }
}
exports.FilterIdSubscriber = FilterIdSubscriber;
/**
 * A **FilterIdSubscriber** for receiving contract events.
 *
 * @category Providers
 */
class FilterIdEventSubscriber extends FilterIdSubscriber {
    #event;
    /**
     * @ignore Creates A new **FilterIdEventSubscriber** attached to `provider` listening for `filter`.
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     * @param {EventFilter} filter - The event filter to use.
     */
    constructor(provider, filter) {
        const zone = (0, provider_js_1.getZoneFromEventFilter)(filter);
        if (zone == null) {
            throw new Error('Unable to determine zone for event filter');
        }
        super(provider, zone);
        this.#event = copy(filter);
    }
    /**
     * Recovers the subscriber.
     *
     * @ignore
     * @param {AbstractProvider<any>} provider - The provider to use.
     * @returns {Subscriber} The recovered subscriber.
     */
    _recover(provider) {
        return new subscriber_polling_js_1.PollingEventSubscriber(provider, this.#event);
    }
    /**
     * Subscribes to the event filter.
     *
     * @ignore
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     * @returns {Promise<string>} A promise that resolves to the subscription ID.
     */
    async _subscribe(provider) {
        const filterId = await provider.send('quai_newFilter', [this.#event]);
        return filterId;
    }
    /**
     * Emits the results of the event filter.
     *
     * @ignore
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     * @param {any[]} results - The results to emit.
     * @returns {Promise<void>} A promise that resolves when the results are emitted.
     */
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit(this.#event, this.zone, provider._wrapLog(result, provider._network));
        }
    }
}
exports.FilterIdEventSubscriber = FilterIdEventSubscriber;
/**
 * A **FilterIdSubscriber** for receiving pending transactions events.
 *
 * @category Providers
 */
class FilterIdPendingSubscriber extends FilterIdSubscriber {
    /**
     * Subscribes to the pending transactions filter.
     *
     * @ignore
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     * @returns {Promise<string>} A promise that resolves to the subscription ID.
     */
    async _subscribe(provider) {
        return await provider.send('quai_newPendingTransactionFilter', []);
    }
    /**
     * Emits the results of the pending transactions filter.
     *
     * @ignore
     * @param {JsonRpcApiProvider<any>} provider - The provider to use.
     * @param {any[]} results - The results to emit.
     * @returns {Promise<void>} A promise that resolves when the results are emitted.
     */
    async _emitResults(provider, results) {
        for (const result of results) {
            provider.emit('pending', this.zone, result);
        }
    }
}
exports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;
//# sourceMappingURL=subscriber-filterid.js.map