"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var b=Object.defineProperty;var l=(s,t)=>b(s,"name",{value:t,configurable:!0});var _walletevm = require('@goat-sdk/wallet-evm');var _viem = require('viem');var _chains = require('viem/chains');var _ens = require('viem/ens');var _zksync = require('viem/zksync');var m=class extends _walletevm.EVMWalletClient{static{l(this,"ViemEVMWalletClient")}#t;#e;#a;get publicClient(){return this.#t.extend(_viem.publicActions)}constructor(t,e){super(),this.#t=t,this.#e=_nullishCoalesce(_optionalChain([e, 'optionalAccess', _ => _.paymaster, 'optionalAccess', _2 => _2.defaultAddress]), () => ("")),this.#a=_nullishCoalesce(_optionalChain([e, 'optionalAccess', _3 => _3.paymaster, 'optionalAccess', _4 => _4.defaultInput]), () => (_zksync.getGeneralPaymasterInput.call(void 0, {innerInput:"0x"})))}getAddress(){return _nullishCoalesce(_optionalChain([this, 'access', _5 => _5.#t, 'access', _6 => _6.account, 'optionalAccess', _7 => _7.address]), () => (""))}getChain(){return{type:"evm",id:_nullishCoalesce(_optionalChain([this, 'access', _8 => _8.#t, 'access', _9 => _9.chain, 'optionalAccess', _10 => _10.id]), () => (0))}}async resolveAddress(t){if(/^0x[a-fA-F0-9]{40}$/.test(t))return t;try{let e=await this.publicClient.getEnsAddress({name:_ens.normalize.call(void 0, t)});if(!e)throw new Error("ENS name could not be resolved.");return e}catch(e){throw new Error(`Failed to resolve ENS name: ${e}`)}}async signMessage(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signMessage({message:t,account:this.#t.account})}}async signTypedData(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signTypedData({domain:{...t.domain,chainId:typeof t.domain.chainId=="bigint"?Number(t.domain.chainId):t.domain.chainId},types:t.types,primaryType:t.primaryType,message:t.message,account:this.#t.account})}}async sendTransaction(t){let{to:e,abi:n,functionName:a,args:i,value:p,options:w}=t;if(!this.#t.account)throw new Error("No account connected");let y=await this.resolveAddress(e),r=_nullishCoalesce(_optionalChain([w, 'optionalAccess', _11 => _11.paymaster, 'optionalAccess', _12 => _12.address]), () => (this.#e)),c=_nullishCoalesce(_optionalChain([w, 'optionalAccess', _13 => _13.paymaster, 'optionalAccess', _14 => _14.input]), () => (this.#a)),o=!!r&&!!c,f=o?this.#t.extend(_zksync.eip712WalletActions.call(void 0, )):this.#t;if(!n){let d={account:this.#t.account,to:y,chain:this.#t.chain,value:p,...o?{paymaster:r,paymasterInput:c}:{}},h=await f.sendTransaction(d);return this.waitForReceipt(h)}if(!a)throw new Error("Function name is required for contract calls");let{request:u}=await this.publicClient.simulateContract({account:this.#t.account,address:y,abi:n,functionName:a,args:i,chain:this.#t.chain}),g=_viem.encodeFunctionData.call(void 0, {abi:n,functionName:a,args:i});if(o){let d={account:this.#t.account,chain:this.#t.chain,to:u.address,data:g,value:u.value,paymaster:r,paymasterInput:c},h=await f.sendTransaction(d);return this.waitForReceipt(h)}let v=await this.#t.writeContract(u);return this.waitForReceipt(v)}async read(t){let{address:e,abi:n,functionName:a,args:i}=t;if(!n)throw new Error("Read request must include ABI for EVM");return{value:await this.publicClient.readContract({address:await this.resolveAddress(e),abi:n,functionName:a,args:i})}}async balanceOf(t){let e=await this.resolveAddress(t),n=await this.publicClient.getBalance({address:e}),a=_nullishCoalesce(this.#t.chain, () => (_chains.mainnet));return{value:_viem.formatUnits.call(void 0, BigInt(n),a.nativeCurrency.decimals),decimals:a.nativeCurrency.decimals,symbol:a.nativeCurrency.symbol,name:a.nativeCurrency.name,inBaseUnits:n.toString()}}async waitForReceipt(t){let e=await this.publicClient.waitForTransactionReceipt({hash:t});return{hash:e.transactionHash,status:e.status}}};function S(s,t){return new m(s,t)}l(S,"viem");exports.a = m; exports.b = S;
