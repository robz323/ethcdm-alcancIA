var b=Object.defineProperty;var l=(s,t)=>b(s,"name",{value:t,configurable:!0});import{EVMWalletClient as C}from"@goat-sdk/wallet-evm";import{encodeFunctionData as A,formatUnits as x,publicActions as E}from"viem";import{mainnet as I}from"viem/chains";import{normalize as F}from"viem/ens";import{eip712WalletActions as N,getGeneralPaymasterInput as T}from"viem/zksync";var m=class extends C{static{l(this,"ViemEVMWalletClient")}#t;#e;#a;get publicClient(){return this.#t.extend(E)}constructor(t,e){super(),this.#t=t,this.#e=e?.paymaster?.defaultAddress??"",this.#a=e?.paymaster?.defaultInput??T({innerInput:"0x"})}getAddress(){return this.#t.account?.address??""}getChain(){return{type:"evm",id:this.#t.chain?.id??0}}async resolveAddress(t){if(/^0x[a-fA-F0-9]{40}$/.test(t))return t;try{let e=await this.publicClient.getEnsAddress({name:F(t)});if(!e)throw new Error("ENS name could not be resolved.");return e}catch(e){throw new Error(`Failed to resolve ENS name: ${e}`)}}async signMessage(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signMessage({message:t,account:this.#t.account})}}async signTypedData(t){if(!this.#t.account)throw new Error("No account connected");return{signature:await this.#t.signTypedData({domain:{...t.domain,chainId:typeof t.domain.chainId=="bigint"?Number(t.domain.chainId):t.domain.chainId},types:t.types,primaryType:t.primaryType,message:t.message,account:this.#t.account})}}async sendTransaction(t){let{to:e,abi:n,functionName:a,args:i,value:p,options:w}=t;if(!this.#t.account)throw new Error("No account connected");let y=await this.resolveAddress(e),r=w?.paymaster?.address??this.#e,c=w?.paymaster?.input??this.#a,o=!!r&&!!c,f=o?this.#t.extend(N()):this.#t;if(!n){let d={account:this.#t.account,to:y,chain:this.#t.chain,value:p,...o?{paymaster:r,paymasterInput:c}:{}},h=await f.sendTransaction(d);return this.waitForReceipt(h)}if(!a)throw new Error("Function name is required for contract calls");let{request:u}=await this.publicClient.simulateContract({account:this.#t.account,address:y,abi:n,functionName:a,args:i,chain:this.#t.chain}),g=A({abi:n,functionName:a,args:i});if(o){let d={account:this.#t.account,chain:this.#t.chain,to:u.address,data:g,value:u.value,paymaster:r,paymasterInput:c},h=await f.sendTransaction(d);return this.waitForReceipt(h)}let v=await this.#t.writeContract(u);return this.waitForReceipt(v)}async read(t){let{address:e,abi:n,functionName:a,args:i}=t;if(!n)throw new Error("Read request must include ABI for EVM");return{value:await this.publicClient.readContract({address:await this.resolveAddress(e),abi:n,functionName:a,args:i})}}async balanceOf(t){let e=await this.resolveAddress(t),n=await this.publicClient.getBalance({address:e}),a=this.#t.chain??I;return{value:x(BigInt(n),a.nativeCurrency.decimals),decimals:a.nativeCurrency.decimals,symbol:a.nativeCurrency.symbol,name:a.nativeCurrency.name,inBaseUnits:n.toString()}}async waitForReceipt(t){let e=await this.publicClient.waitForTransactionReceipt({hash:t});return{hash:e.transactionHash,status:e.status}}};function U(s,t){return new m(s,t)}l(U,"viem");export{m as a,U as b};
