export declare class AnonControlClient {
    private client;
    constructor(host?: string, port?: number);
    /**
     * AUTHENTICATE
        Sent from the client to the server.  The syntax is:

            "AUTHENTICATE" [ SP 1*HEXDIG / QuotedString ] CRLF

        This command is used to authenticate to the server. The provided string is
        one of the following:

            * (For the HASHEDPASSWORD authentication method; see 3.21)
            The original password represented as a QuotedString.

            * (For the COOKIE is authentication method; see 3.21)
            The contents of the cookie file, formatted in hexadecimal

            * (For the SAFECOOKIE authentication method; see 3.21)
            The HMAC based on the AUTHCHALLENGE message, in hexadecimal.

        The server responds with 250 OK on success or 515 Bad authentication if
        the authentication cookie is incorrect.  Tor closes the connection on an
        authentication failure.

        The authentication token can be specified as either a quoted ASCII string,
        or as an unquoted hexadecimal encoding of that same string (to avoid escaping
        issues).

        For information on how the implementation securely stores authentication
        information on disk, see section 5.1.

        Before the client has authenticated, no command other than
        PROTOCOLINFO, AUTHCHALLENGE, AUTHENTICATE, or QUIT is valid.  If the
        controller sends any other command, or sends a malformed command, or
        sends an unsuccessful AUTHENTICATE command, or sends PROTOCOLINFO or
        AUTHCHALLENGE more than once, Tor sends an error reply and closes
        the connection.

        To prevent some cross-protocol attacks, the AUTHENTICATE command is still
        required even if all authentication methods in Tor are disabled.  In this
        case, the controller should just send "AUTHENTICATE" CRLF.
        (Versions of Tor before 0.1.2.16 and 0.2.0.4-alpha did not close the
        connection after an authentication failure.)
     * @param password
     * @returns
     */
    authenticate(password?: string): Promise<void>;
    sendCommand(command: string): Promise<string>;
    /**
     * GETINFO
        Sent from the client to the server.  The syntax is as for GETCONF:
            "GETINFO" 1*(SP keyword) CRLF

        Unlike GETCONF, this message is used for data that are not stored in the Tor
        configuration file, and that may be longer than a single line.  On success,
        one ReplyLine is sent for each requested value, followed by a final 250 OK
        ReplyLine.  If a value fits on a single line, the format is:
            250-keyword=value

        If a value must be split over multiple lines, the format is:
            250+keyword=
            value
            .
        The server sends a 551 or 552 error on failure.
        Recognized keys and their values include:
     
        "circuit-status"
        A series of lines as for a circuit status event. Each line is of
        the form described in section 4.1.1, omitting the initial
        "650 CIRC ".  Note that clients must be ready to accept additional
        arguments as described in section 4.1.

     * @returns
     */
    circuitStatus(): Promise<CircuitStatus[]>;
    /**
     * GETINFO
        Sent from the client to the server.  The syntax is as for GETCONF:
            "GETINFO" 1*(SP keyword) CRLF

        Unlike GETCONF, this message is used for data that are not stored in the Tor
        configuration file, and that may be longer than a single line.  On success,
        one ReplyLine is sent for each requested value, followed by a final 250 OK
        ReplyLine.  If a value fits on a single line, the format is:
            250-keyword=value

        If a value must be split over multiple lines, the format is:
            250+keyword=
            value
            .
        The server sends a 551 or 552 error on failure.
        Recognized keys and their values include:
     
        "ns/all"
         Router status info (v3 directory style) for all ORs we
        that the consensus has an opinion about, joined by newlines.
        [First implemented in 0.1.2.3-alpha.]
        [In 0.2.0.9-alpha this switched from v2 directory style to v3]

     * @returns
     */
    routerStatus(): Promise<RouterStatus[]>;
    /**
     * EXTENDCIRCUIT
        Sent from the client to the server.  The format is:

        "EXTENDCIRCUIT" SP CircuitID
            [SP ServerSpec *("," ServerSpec)]
            [SP "purpose=" Purpose] CRLF

        This request takes one of two forms: either the CircuitID is zero, in
        which case it is a request for the server to build a new circuit,
        or the CircuitID is nonzero, in which case it is a request for the
        server to extend an existing circuit with that ID according to the
        specified path.

        If the CircuitID is 0, the controller has the option of providing
        a path for Anon to use to build the circuit. If it does not provide
        a path, Anon will select one automatically from high capacity nodes
        according to path-spec.txt.

        If CircuitID is 0 and "purpose=" is specified, then the circuit's
        purpose is set. Two choices are recognized: "general" and
        "controller". If not specified, circuits are created as "general".

        If the request is successful, the server sends a reply containing a
        message body consisting of the CircuitID of the (maybe newly created)
        circuit. The syntax is:
        "250" SP "EXTENDED" SP CircuitID CRLF
     * @param options
     * @returns circuitId
     */
    extendCircuit(options?: ExtendCircuitOptions): Promise<number>;
    /**
     * CLOSECIRCUIT
        The syntax is:

            "CLOSECIRCUIT" SP CircuitID *(SP Flag) CRLF
            Flag = "IfUnused"


        Tells the server to close the specified circuit. If "IfUnused" is
        provided, do not close the circuit unless it is unused.
        Other flags may be defined in the future; Tor SHOULD ignore unrecognized
        flags.

        Tor replies with 250 OK on success, or a 512 if there aren't enough
        arguments, or a 552 if it doesn't recognize the CircuitID.
     * @param circuitId
     */
    closeCircuit(circuitId: number): Promise<void>;
    /**
     * Get relay info by fingerprint
     * @param fingerprint
     * @returns address
     */
    getRelayInfo(fingerprint: string): Promise<RelayInfo>;
    /**
     * QUIT
        Tells the server to hang up on this controller connection. This command
        can be used before authenticating.
     */
    end(): void;
}
interface CircuitStatus {
    circuitId: number;
    state: string;
    relays: Relay[];
    buildFlags: string[];
    purpose: string;
    timeCreated: Date;
}
interface RouterStatus {
    nickname: string;
    fingerprint: string;
    digest: string;
    publishedTime: Date;
    ip: string;
    orPort: number;
    dirPort: number;
    flags: string[];
    bandwidth: number;
}
interface Relay {
    fingerprint: string;
    nickname: string;
}
type Purpose = 'general' | 'controller';
interface ExtendCircuitOptions {
    circuitId?: number;
    serverSpecs?: string[];
    purpose?: Purpose;
}
interface RelayInfo {
    fingerprint: string;
    nickname: string;
    ip: string;
    orPort: number;
    flags: string[];
    bandwidth: number;
}
export {};
