import { Logger } from "../common/logger";
import { AxiosError, AxiosInstance } from "axios";
import type { SetRequired } from "type-fest";
import { Configuration } from './configuration';
import type { AuthorizationUrlResponse, AuthorizationUrlResponseType, BalanceResponse, BanListResponse, BanResponse, BlockListResponse, BulkCastsResponse, BulkFollowResponse, BulkUserAddressType, BulkUsersByAddressResponse, BulkUsersResponse, CastComposerActionsListResponse, CastComposerType, CastConversationSortType, CastEmbedCrawlResponse, CastParamType, CastResponse, CastsMetricsResponse, CastsResponse, CastsSearchResponse, ChannelListResponse, ChannelMemberInviteListResponse, ChannelMemberListResponse, ChannelMemberRole, ChannelResponse, ChannelResponseBulk, ChannelSearchResponse, ChannelType, Conversation, ConversationSummary, DeleteFrameResponse, DeployFungibleFactoryEnum, DeployFungibleMetadataNsfwEnum, DeployFungibleNetworkEnum, DeployFungibleReqBodyMetadataMedia, DeployFungibleResponse, DeveloperManagedSigner, EmbedType, ErrorRes, FarcasterActionReqBodyAction, FeedResponse, FeedTrendingProvider, FeedType, FetchBulkCastsSortTypeEnum, FetchCastMetricsIntervalEnum, FetchFrameMetaTagsFromUrl200Response, FetchRelevantFrames200Response, FetchRepliesAndRecastsForUserFilterEnum, FetchTrendingChannelsTimeWindowEnum, FetchUserInteractions200Response, FilterType, FnameAvailabilityResponse, FollowSortType, FollowersResponse, ForYouProvider, Frame, FrameAction, FrameCatalogResponse, FrameNotificationTokens, FramePayTransactionRequestBody, FrameSignaturePacket, FrameType, FrameValidateAnalyticsResponse, FrameValidateListResponse, LookupCastConversationFoldEnum, MuteListResponse, MuteResponse, Networks, NeynarFrame, NeynarFramePage, NonceResponse, NotificationType, NotificationsResponse, OperationResponse, PostCastReqBodyEmbeds, PostCastResponse, ReactionType, ReactionsCastResponse, ReactionsResponse, ReactionsType, RegisterUserReqBodyMetadata, RegisterUserResponse, RelevantFollowersResponse, RelevantFungibleOwnersResponse, SearchCastsModeEnum, SearchSortType, SendFrameNotificationsReqBodyNotification, SendFrameNotificationsResponse, SignedKeyRequestSponsor, Signer, SignerListResponse, StorageAllocationsResponse, StorageUsageResponse, SubscribedToResponse, SubscribersResponse, SubscriptionCheckResponse, SubscriptionProvider, SubscriptionProviders, SubscriptionsResponse, TransactionFrameResponse, TrendingChannelResponse, TrendingTimeWindow, UpdateUserReqBodyLocation, UpdateUserReqBodyVerifiedAccounts, UserFIDResponse, UserPowerLiteResponse, UserResponse, UserSearchResponse, UsersActiveChannelsResponse, UsersResponse, ValidateFrameActionResponse, ValidateFrameAggregateWindow, ValidateFrameAnalyticsType, VerificationChainId, VerificationType, WebhookListResponse, WebhookPatchReqBodyActiveEnum, WebhookResponse, WebhookSubscriptionFilters } from '../api';
export interface NeynarAPIClientOptions {
    logger?: Logger;
    axiosInstance?: AxiosInstance;
}
export declare class NeynarAPIClient {
    private readonly logger;
    private config;
    private readonly apis;
    constructor(config: Configuration, options?: NeynarAPIClientOptions);
    static isApiErrorResponse(error: any): error is SetRequired<AxiosError<ErrorRes>, "response">;
    /**
     * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\'s Farcaster signer.
     *
     * @summary User actions across apps
     *
     * @param {object} params
     * @param {string} params.signerUuid  - The signer_uuid of the user on behalf of whom the action is being performed.
     * @param {string} params.baseUrl  - The base URL of the app on which the action is being performed.
     * @param {FarcasterActionReqBodyAction} params.action
     *
     * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const baseUrl =
     * const action =
     *
     * client.publishFarcasterAction({signerUuid, baseUrl, action}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)
     *
     */
    publishFarcasterAction(params: {
        signerUuid: string;
        baseUrl: string;
        action: FarcasterActionReqBodyAction;
    }): Promise<{
        [key: string]: any;
    }>;
    /**
     * Creates a new transaction pay mini app that can be used to collect payments through a mini app
     *
     * @summary Create transaction pay mini app
     *
     * @param {object} params
     * @param {FramePayTransactionRequestBody} params.framePayTransactionRequestBody
     *
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const framePayTransactionRequestBody =
     *
     * client.createTransactionPayFrame({ framePayTransactionRequestBody }).then(response => {
     *   console.log('response:', response);
     * });
     */
    createTransactionPayFrame(params: {
        framePayTransactionRequestBody: FramePayTransactionRequestBody;
    }): Promise<TransactionFrameResponse>;
    /**
     * Returns a list of interactions between two users
     *
     * @summary User interactions
     *
     * @param {object} params
     * @param {number[]} params.fids  - Comma separated list of two FIDs
     * @param {Array<NotificationType>} params.type [optional]  - Comma seperated list of Interaction type to fetch
     *
     * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fids =
     * const type =
     *
     * client.fetchUserInteractions({ fids, type }).then(response => {
     *   console.log('response:', response);
     * });
     */
    fetchUserInteractions(params: {
        fids: number[];
        type?: Array<NotificationType>;
    }): Promise<FetchUserInteractions200Response>;
    /**
     * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Warpcast URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.
     *
     * @summary Cast conversation summary
     *
     * @param {object} params
     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)
     * @param {number} params.limit [optional]  - Number of casts to consider in a summary up to a point of target cast (Default: 20, Maximum: 50)
     * @param {string} params.prompt [optional]  - Additional prompt used to generate a summary
     *
     * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const identifier =
     * const limit =
     * const prompt =
     *
     * client.lookupCastConversationSummary({ identifier, limit, prompt }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)
     *
     */
    lookupCastConversationSummary(params: {
        identifier: string;
        limit?: number;
        prompt?: string;
    }): Promise<ConversationSummary>;
    /**
     * Deletes a list of FIDs from the app associated with your API key.
     *
     * @summary Unban FIDs from app
     *
     * @param {object} params
     * @param {Array<number>} params.fids
     *
     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fids =
     *
     * client.deleteBans({fids}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)
     *
     */
    deleteBans(params: {
        fids: Array<number>;
    }): Promise<BanResponse>;
    /**
     * Fetches all FIDs that your app has banned.
     *
     * @summary Banned FIDs of app
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     *
     * client.fetchBanList({ limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)
     *
     */
    fetchBanList(params: {
        limit?: number;
        cursor?: string;
    }): Promise<BanListResponse>;
    /**
     * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.
     *
     * @summary Ban FIDs from app
     *
     * @param {object} params
     * @param {Array<number>} params.fids
     *
     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fids =
     *
     * client.publishBans({fids}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)
     *
     */
    publishBans(params: {
        fids: Array<number>;
    }): Promise<BanResponse>;
    /**
     * Deletes a block for a given FID.
     *
     * @summary Unblock FID
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {number} params.blockedFid  - The unique identifier of a farcaster user (unsigned integer)
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const blockedFid =
     *
     * client.deleteBlock({signerUuid, blockedFid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)
     *
     */
    deleteBlock(params: {
        signerUuid: string;
        blockedFid: number;
    }): Promise<OperationResponse>;
    /**
     * Fetches all FIDs that a user has blocked or has been blocked by
     *
     * @summary Blocked / Blocked by FIDs
     *
     * @param {object} params
     * @param {number} params.blockerFid [optional]  - Providing this will return the users that this user has blocked
     * @param {number} params.blockedFid [optional]  - Providing this will return the users that have blocked this user
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const blockerFid =
     * const blockedFid =
     * const limit =
     *
     * client.fetchBlockList({ blockerFid, blockedFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)
     *
     */
    fetchBlockList(params: {
        blockerFid?: number;
        blockedFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<BlockListResponse>;
    /**
     * Adds a block for a given FID.
     *
     * @summary Block FID
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {number} params.blockedFid  - The unique identifier of a farcaster user (unsigned integer)
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const blockedFid =
     *
     * client.publishBlock({signerUuid, blockedFid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)
     *
     */
    publishBlock(params: {
        signerUuid: string;
        blockedFid: number;
    }): Promise<OperationResponse>;
    /**
     * Delete an existing cast. \\ (In order to delete a cast `signer_uuid` must be approved)
     *
     * @summary Delete a cast
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.targetHash  - Cast Hash
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const targetHash =
     *
     * client.deleteCast({signerUuid, targetHash}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)
     *
     */
    deleteCast(params: {
        signerUuid: string;
        targetHash: string;
    }): Promise<OperationResponse>;
    /**
     * Fetch multiple casts using their respective hashes.
     *
     * @summary Bulk fetch casts
     *
     * @param {object} params
     * @param {string[]} params.casts  - Hashes of the cast to be retrived (Comma separated, no spaces)
     * @param {number} params.viewerFid [optional]  - adds viewer_context to cast object to show whether viewer has liked or recasted the cast.
     * @param {FetchBulkCastsSortTypeEnum} params.sortType [optional]  - Optional parameter to sort the casts based on different criteria
     *
     * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const casts =
     * const viewerFid =
     * const sortType =
     *
     * client.fetchBulkCasts({ casts, viewerFid, sortType }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)
     *
     */
    fetchBulkCasts(params: {
        casts: string[];
        viewerFid?: number;
        sortType?: FetchBulkCastsSortTypeEnum;
    }): Promise<CastsResponse>;
    /**
     * Fetches all composer actions on Warpcast. You can filter by top or featured.
     *
     * @summary Fetch composer actions
     *
     * @param {object} params
     * @param {CastComposerType} params.list  - Type of list to fetch.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 25)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const list =
     * const limit =
     *
     * client.fetchComposerActions({ list, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)
     *
     */
    fetchComposerActions(params: {
        list: CastComposerType;
        limit?: number;
        cursor?: string;
    }): Promise<CastComposerActionsListResponse>;
    /**
     * Crawls the given URL and returns metadata useful when embedding the URL in a cast.
     *
     * @summary Embedded URL metadata
     *
     * @param {object} params
     * @param {string} params.url [optional]  - URL to crawl metadata of
     *
     * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const url =
     *
     * client.fetchEmbeddedUrlMetadata({ url }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)
     *
     */
    fetchEmbeddedUrlMetadata(params: {
        url?: string;
    }): Promise<CastEmbedCrawlResponse>;
    /**
     * Gets information about an individual cast by passing in a Warpcast web URL or cast hash
     *
     * @summary By hash or URL
     *
     * @param {object} params
     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)
     * @param {CastParamType} params.type
     * @param {number} params.viewerFid [optional]  - adds viewer_context to cast object to show whether viewer has liked or recasted the cast.
     *
     * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const identifier =
     * const type =
     * const viewerFid =
     *
     * client.lookupCastByHashOrWarpcastUrl({ identifier, type, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)
     *
     */
    lookupCastByHashOrWarpcastUrl(params: {
        identifier: string;
        type: CastParamType;
        viewerFid?: number;
    }): Promise<CastResponse>;
    /**
     * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Warpcast URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.
     *
     * @summary Conversation for a cast
     *
     * @param {object} params
     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)
     * @param {CastParamType} params.type
     * @param {number} params.replyDepth [optional]  - The depth of replies in the conversation that will be returned (default 2)
     * @param {boolean} params.includeChronologicalParentCasts [optional]  - Include all parent casts in chronological order
     * @param {number} params.viewerFid [optional]  - Providing this will return a conversation that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {CastConversationSortType} params.sortType [optional]  - Sort type for the ordering of descendants. Default is `chron`
     * @param {LookupCastConversationFoldEnum} params.fold [optional]  - Show conversation above or below the fold. Lower quality responses are hidden below the fold. Not passing in a value shows the full conversation without any folding.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 50)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const identifier =
     * const type =
     * const replyDepth =
     * const includeChronologicalParentCasts =
     * const viewerFid =
     * const sortType =
     * const fold =
     * const limit =
     *
     * client.lookupCastConversation({ identifier, type, replyDepth, includeChronologicalParentCasts, viewerFid, sortType, fold, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)
     *
     */
    lookupCastConversation(params: {
        identifier: string;
        type: CastParamType;
        replyDepth?: number;
        includeChronologicalParentCasts?: boolean;
        viewerFid?: number;
        sortType?: CastConversationSortType;
        fold?: LookupCastConversationFoldEnum;
        limit?: number;
        cursor?: string;
    }): Promise<Conversation>;
    /**
     * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)
     *
     * @summary Post a cast
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.text [optional]
     * @param {Array<PostCastReqBodyEmbeds>} params.embeds [optional]
     * @param {string} params.parent [optional]  - parent_url of the channel the cast is in, or hash of the cast
     * @param {string} params.channelId [optional]  - Channel ID of the channel where the cast is to be posted. e.g. neynar, farcaster, warpcast
     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.
     * @param {number} params.parentAuthorFid [optional]  - The unique identifier of a farcaster user (unsigned integer)
     *
     * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const text =
     * const embeds =
     * const parent =
     * const channelId =
     * const idem =
     * const parentAuthorFid =
     *
     * client.publishCast({signerUuid, text, embeds, parent, channelId, idem, parentAuthorFid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)
     *
     */
    publishCast(params: {
        signerUuid: string;
        text?: string;
        embeds?: Array<PostCastReqBodyEmbeds>;
        parent?: string;
        channelId?: string;
        idem?: string;
        parentAuthorFid?: number;
    }): Promise<PostCastResponse>;
    /**
     * Search for casts based on a query string, with optional AND filters
     *
     * @summary Search for casts
     *
     * @param {object} params
     * @param {string} params.q  - Query string to search for casts. Supported operators:  | Operator  | Description                                                                                              | | --------- | -------------------------------------------------------------------------------------------------------- | | `+`       | Acts as the AND operator. This is the default operator between terms and can usually be omitted.         | | `|`      | Acts as the OR operator.                                                                                 | | `*`       | When used at the end of a term, signifies a prefix query.                                                  | | `"`       | Wraps several terms into a phrase (for example, `"star wars"`).                                          | | `(`, `)`  | Wrap a clause for precedence (for example, `star + (wars | trek)`).                                     | | `~n`      | When used after a term (for example, `satr~3`), sets `fuzziness`. When used after a phrase, sets `slop`. | | `-`       | Negates the term.                                                                                        | | `before:` | Search for casts before a specific date. (e.g. `before:2025-04-20`)                                       | | `after:`  | Search for casts after a specific date. (e.g. `after:2025-04-20`)                                         |
     * @param {SearchCastsModeEnum} params.mode [optional]  - Choices are: - `literal` - Searches for the words in the query string (default) - `semantic` - Searches for the meaning of the query string - `hybrid` - Combines both literal and semantic results
     * @param {SearchSortType} params.sortType [optional]  - Choices are: - `desc_chron` - All casts sorted by time (default) - `algorithmic` - Casts sorted by engagement and time
     * @param {number} params.authorFid [optional]  - Fid of the user whose casts you want to search
     * @param {number} params.viewerFid [optional]  - Providing this will return search results that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {string} params.parentUrl [optional]  - Parent URL of the casts you want to search
     * @param {string} params.channelId [optional]  - Channel ID of the casts you want to search
     * @param {boolean} params.priorityMode [optional]  - When true, only returns search results from power badge users and users that the viewer follows (if viewer_fid is provided).
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor
     *
     * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const q =
     * const mode =
     * const sortType =
     * const authorFid =
     * const viewerFid =
     * const parentUrl =
     * const channelId =
     * const priorityMode =
     * const limit =
     *
     * client.searchCasts({ q, mode, sortType, authorFid, viewerFid, parentUrl, channelId, priorityMode, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)
     *
     */
    searchCasts(params: {
        q: string;
        mode?: SearchCastsModeEnum;
        sortType?: SearchSortType;
        authorFid?: number;
        viewerFid?: number;
        parentUrl?: string;
        channelId?: string;
        priorityMode?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<CastsSearchResponse>;
    /**
     * Returns a list of all channels with their details
     *
     * @summary Fetch all channels with their details
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 200)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     *
     * client.fetchAllChannels({ limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)
     *
     */
    fetchAllChannels(params: {
        limit?: number;
        cursor?: string;
    }): Promise<ChannelListResponse>;
    /**
     * Returns details of multiple channels
     *
     * @summary Bulk fetch
     *
     * @param {object} params
     * @param {string[]} params.ids  - Comma separated list of channel IDs or parent_urls, up to 100 at a time
     * @param {ChannelType} params.type [optional]  - Type of identifier being used to query the channels. Defaults to ID.
     * @param {number} params.viewerFid [optional]  - FID of the user viewing the channels.
     *
     * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const ids =
     * const type =
     * const viewerFid =
     *
     * client.fetchBulkChannels({ ids, type, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)
     *
     */
    fetchBulkChannels(params: {
        ids: string[];
        type?: ChannelType;
        viewerFid?: number;
    }): Promise<ChannelResponseBulk>;
    /**
     * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.
     *
     * @summary Open invites
     *
     * @param {object} params
     * @param {string} params.channelId [optional]  - Channel ID for the channel being queried
     * @param {number} params.invitedFid [optional]  - FID of the user being invited
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const channelId =
     * const invitedFid =
     * const limit =
     *
     * client.fetchChannelInvites({ channelId, invitedFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)
     *
     */
    fetchChannelInvites(params: {
        channelId?: string;
        invitedFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<ChannelMemberInviteListResponse>;
    /**
     * Fetch a list of members in a channel
     *
     * @summary Fetch members
     *
     * @param {object} params
     * @param {string} params.channelId  - Channel ID for the channel being queried
     * @param {number} params.fid [optional]  - FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const channelId =
     * const fid =
     * const limit =
     *
     * client.fetchChannelMembers({ channelId, fid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)
     *
     */
    fetchChannelMembers(params: {
        channelId: string;
        fid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<ChannelMemberListResponse>;
    /**
     * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.
     *
     * @summary For channel
     *
     * @param {object} params
     * @param {string} params.id  - Channel ID for the channel being queried
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {string} params.cursor [optional]  - Pagination cursor.
     * @param {number} params.limit [optional]  - Number of followers to fetch (Default: 25, Maximum: 1000)
     *
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const id =
     * const viewerFid =
     * const limit =
     *
     * client.fetchFollowersForAChannel({ id, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)
     *
     */
    fetchFollowersForAChannel(params: {
        id: string;
        viewerFid?: number;
        cursor?: string;
        limit?: number;
    }): Promise<UsersResponse>;
    /**
     * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \"X, Y, Z follow this channel\".
     *
     * @summary Relevant followers
     *
     * @param {object} params
     * @param {string} params.id  - Channel ID being queried
     * @param {number} params.viewerFid  - The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.
     *
     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const id =
     * const viewerFid =
     *
     * client.fetchRelevantFollowersForAChannel({ id, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)
     *
     */
    fetchRelevantFollowersForAChannel(params: {
        id: string;
        viewerFid: number;
    }): Promise<RelevantFollowersResponse>;
    /**
     * Returns a list of trending channels based on activity
     *
     * @summary Channels by activity
     *
     * @param {object} params
     * @param {FetchTrendingChannelsTimeWindowEnum} params.timeWindow [optional]
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 10, Maximum: 25)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const timeWindow =
     * const limit =
     *
     * client.fetchTrendingChannels({ timeWindow, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)
     *
     */
    fetchTrendingChannels(params: {
        timeWindow?: FetchTrendingChannelsTimeWindowEnum;
        limit?: number;
        cursor?: string;
    }): Promise<TrendingChannelResponse>;
    /**
     * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.
     *
     * @summary Member of
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the user.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const limit =
     *
     * client.fetchUserChannelMemberships({ fid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)
     *
     */
    fetchUserChannelMemberships(params: {
        fid: number;
        limit?: number;
        cursor?: string;
    }): Promise<ChannelMemberListResponse>;
    /**
     * Returns a list of all channels with their details that a FID follows.
     *
     * @summary Following
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the user.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const limit =
     *
     * client.fetchUserChannels({ fid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)
     *
     */
    fetchUserChannels(params: {
        fid: number;
        limit?: number;
        cursor?: string;
    }): Promise<ChannelListResponse>;
    /**
     * Fetches all channels that a user has casted in, in reverse chronological order.
     *
     * @summary Fetch channels that user is active in
     *
     * @param {object} params
     * @param {number} params.fid  - The user's FID (identifier)
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const limit =
     *
     * client.fetchUsersActiveChannels({ fid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)
     *
     */
    fetchUsersActiveChannels(params: {
        fid: number;
        limit?: number;
        cursor?: string;
    }): Promise<UsersActiveChannelsResponse>;
    /**
     * Follow a channel
     *
     * @summary Follow a channel
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.channelId  - The unique identifier of a farcaster channel
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const channelId =
     *
     * client.followChannel({signerUuid, channelId}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)
     *
     */
    followChannel(params: {
        signerUuid: string;
        channelId: string;
    }): Promise<OperationResponse>;
    /**
     * Invite a user to a channel
     *
     * @summary Invite
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.channelId  - The unique identifier of a farcaster channel
     * @param {number} params.fid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {ChannelMemberRole} params.role
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const channelId =
     * const fid =
     * const role =
     *
     * client.inviteChannelMember({signerUuid, channelId, fid, role}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)
     *
     */
    inviteChannelMember(params: {
        signerUuid: string;
        channelId: string;
        fid: number;
        role: ChannelMemberRole;
    }): Promise<OperationResponse>;
    /**
     * Returns details of a channel
     *
     * @summary By ID or parent_url
     *
     * @param {object} params
     * @param {string} params.id  - Channel ID for the channel being queried
     * @param {ChannelType} params.type [optional]  - Type of identifier being used to query the channel. Defaults to ID.
     * @param {number} params.viewerFid [optional]  - FID of the user viewing the channel.
     *
     * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const id =
     * const type =
     * const viewerFid =
     *
     * client.lookupChannel({ id, type, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)
     *
     */
    lookupChannel(params: {
        id: string;
        type?: ChannelType;
        viewerFid?: number;
    }): Promise<ChannelResponse>;
    /**
     * Remove a user from a channel or a user\'s invite to a channel role
     *
     * @summary Remove user
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.channelId  - The unique identifier of a farcaster channel
     * @param {number} params.fid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {ChannelMemberRole} params.role
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const channelId =
     * const fid =
     * const role =
     *
     * client.removeChannelMember({signerUuid, channelId, fid, role}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)
     *
     */
    removeChannelMember(params: {
        signerUuid: string;
        channelId: string;
        fid: number;
        role: ChannelMemberRole;
    }): Promise<OperationResponse>;
    /**
     * Accept or reject a channel invite
     *
     * @summary Accept or reject an invite
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.channelId  - The unique identifier of a farcaster channel
     * @param {ChannelMemberRole} params.role
     * @param {boolean} params.accept  - Accept or reject the invite
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const channelId =
     * const role =
     * const accept =
     *
     * client.respondChannelInvite({signerUuid, channelId, role, accept}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)
     *
     */
    respondChannelInvite(params: {
        signerUuid: string;
        channelId: string;
        role: ChannelMemberRole;
        accept: boolean;
    }): Promise<OperationResponse>;
    /**
     * Returns a list of channels based on ID or name
     *
     * @summary Search by ID or name
     *
     * @param {object} params
     * @param {string} params.q  - Channel ID or name for the channel being queried
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 200)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const q =
     * const limit =
     *
     * client.searchChannels({ q, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)
     *
     */
    searchChannels(params: {
        q: string;
        limit?: number;
        cursor?: string;
    }): Promise<ChannelSearchResponse>;
    /**
     * Unfollow a channel
     *
     * @summary Unfollow a channel
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.channelId  - The unique identifier of a farcaster channel
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const channelId =
     *
     * client.unfollowChannel({signerUuid, channelId}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)
     *
     */
    unfollowChannel(params: {
        signerUuid: string;
        channelId: string;
    }): Promise<OperationResponse>;
    /**
     * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel
     *
     * @summary Chronologically
     *
     * @param {object} params
     * @param {number} params.fid  - FID of user whose recent casts you want to fetch
     * @param {number} params.appFid [optional]  - Optionally filter to casts created via a specific app FID, e.g. 9152 for Warpcast
     * @param {number} params.viewerFid [optional]  - FID of the user viewing the feed
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 150)
     * @param {string} params.cursor [optional]  - Pagination cursor
     * @param {boolean} params.includeReplies [optional]  - Include reply casts by the author in the response, true by default
     * @param {string} params.parentUrl [optional]  - Parent URL to filter the feed; mutually exclusive with channel_id
     * @param {string} params.channelId [optional]  - Channel ID to filter the feed; mutually exclusive with parent_url
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const appFid =
     * const viewerFid =
     * const limit =
     * const includeReplies =
     * const parentUrl =
     * const channelId =
     *
     * client.fetchCastsForUser({ fid, appFid, viewerFid, limit, includeReplies, parentUrl, channelId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)
     *
     */
    fetchCastsForUser(params: {
        fid: number;
        appFid?: number;
        viewerFid?: number;
        limit?: number;
        cursor?: string;
        includeReplies?: boolean;
        parentUrl?: string;
        channelId?: string;
    }): Promise<FeedResponse>;
    /**
     * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.
     *
     * @summary By filters
     *
     * @param {object} params
     * @param {FeedType} params.feedType  - Defaults to following (requires FID or address). If set to filter (requires filter_type)
     * @param {FilterType} params.filterType [optional]  - Used when feed_type=filter. Can be set to FIDs (requires FIDs) or parent_url (requires parent_url) or channel_id (requires channel_id)
     * @param {number} params.fid [optional]  - (Optional) FID of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type
     * @param {string} params.fids [optional]  - Used when filter_type=FIDs . Create a feed based on a list of FIDs. Max array size is 100. Requires feed_type and filter_type.
     * @param {string} params.parentUrl [optional]  - Used when filter_type=parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type.
     * @param {string} params.channelId [optional]  - Used when filter_type=channel_id can be used to fetch casts under a channel. Requires feed_type and filter_type.
     * @param {boolean} params.membersOnly [optional]  - Used when filter_type=channel_id. Only include casts from members of the channel. True by default.
     * @param {string} params.embedUrl [optional]  - Used when filter_type=embed_url. Casts with embedded URLs prefixed by this embed_url param will be returned. We normalize your given URL prefix and prepend 'https://' if no protocol is included. Requires feed_type and filter_type.
     * @param {Array<EmbedType>} params.embedTypes [optional]  - Used when filter_type=embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type.
     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const feedType =
     * const filterType =
     * const fid =
     * const fids =
     * const parentUrl =
     * const channelId =
     * const membersOnly =
     * const embedUrl =
     * const embedTypes =
     * const withRecasts =
     * const limit =
     * const viewerFid =
     *
     * client.fetchFeed({ feedType, filterType, fid, fids, parentUrl, channelId, membersOnly, embedUrl, embedTypes, withRecasts, limit, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)
     *
     */
    fetchFeed(params: {
        feedType: FeedType;
        filterType?: FilterType;
        fid?: number;
        fids?: string;
        parentUrl?: string;
        channelId?: string;
        membersOnly?: boolean;
        embedUrl?: string;
        embedTypes?: Array<EmbedType>;
        withRecasts?: boolean;
        limit?: number;
        cursor?: string;
        viewerFid?: number;
    }): Promise<FeedResponse>;
    /**
     * Fetch feed based on channel IDs
     *
     * @summary By channel IDs
     *
     * @param {object} params
     * @param {string[]} params.channelIds  - Comma separated list of up to 10 channel IDs e.g. neynar,farcaster
     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {boolean} params.withReplies [optional]  - Include replies in the response, false by default
     * @param {boolean} params.membersOnly [optional]  - Only include casts from members of the channel. True by default.
     * @param {number[]} params.fids [optional]  - Comma separated list of FIDs to filter the feed by, up to 10 at a time
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     * @param {boolean} params.shouldModerate [optional]  - If true, only casts that have been liked by the moderator (if one exists) will be returned.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const channelIds =
     * const withRecasts =
     * const viewerFid =
     * const withReplies =
     * const membersOnly =
     * const fids =
     * const limit =
     * const shouldModerate =
     *
     * client.fetchFeedByChannelIds({ channelIds, withRecasts, viewerFid, withReplies, membersOnly, fids, limit, shouldModerate }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)
     *
     */
    fetchFeedByChannelIds(params: {
        channelIds: string[];
        withRecasts?: boolean;
        viewerFid?: number;
        withReplies?: boolean;
        membersOnly?: boolean;
        fids?: number[];
        limit?: number;
        cursor?: string;
        shouldModerate?: boolean;
    }): Promise<FeedResponse>;
    /**
     * Fetch feed based on parent URLs
     *
     * @summary By parent URLs
     *
     * @param {object} params
     * @param {string[]} params.parentUrls  - Comma separated list of parent_urls
     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {boolean} params.withReplies [optional]  - Include replies in the response, false by default
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const parentUrls =
     * const withRecasts =
     * const viewerFid =
     * const withReplies =
     * const limit =
     *
     * client.fetchFeedByParentUrls({ parentUrls, withRecasts, viewerFid, withReplies, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)
     *
     */
    fetchFeedByParentUrls(params: {
        parentUrls: string[];
        withRecasts?: boolean;
        viewerFid?: number;
        withReplies?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<FeedResponse>;
    /**
     * Fetch a personalized For You feed for a user
     *
     * @summary For you
     *
     * @param {object} params
     * @param {number} params.fid  - FID of user whose feed you want to create
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {ForYouProvider} params.provider [optional]
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 50)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     * @param {string} params.providerMetadata [optional]  - provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     * const provider =
     * const limit =
     * const providerMetadata =
     *
     * client.fetchFeedForYou({ fid, viewerFid, provider, limit, providerMetadata }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)
     *
     */
    fetchFeedForYou(params: {
        fid: number;
        viewerFid?: number;
        provider?: ForYouProvider;
        limit?: number;
        cursor?: string;
        providerMetadata?: string;
    }): Promise<FeedResponse>;
    /**
     * Fetch feed of casts with mini apps, reverse chronological order
     *
     * @summary Casts with mini apps
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     * const viewerFid =
     *
     * client.fetchFramesOnlyFeed({ limit, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)
     *
     */
    fetchFramesOnlyFeed(params: {
        limit?: number;
        viewerFid?: number;
        cursor?: string;
    }): Promise<FeedResponse>;
    /**
     * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first
     *
     * @summary 10 most popular casts
     *
     * @param {object} params
     * @param {number} params.fid  - FID of user whose feed you want to create
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     *
     * client.fetchPopularCastsByUser({ fid, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)
     *
     */
    fetchPopularCastsByUser(params: {
        fid: number;
        viewerFid?: number;
    }): Promise<BulkCastsResponse>;
    /**
     * Fetch recent replies and recasts for a given user FID; sorted by most recent first
     *
     * @summary Replies and recasts
     *
     * @param {object} params
     * @param {number} params.fid  - FID of user whose replies and recasts you want to fetch
     * @param {FetchRepliesAndRecastsForUserFilterEnum} params.filter [optional]  - filter to fetch only replies or recasts
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 50)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const filter =
     * const limit =
     * const viewerFid =
     *
     * client.fetchRepliesAndRecastsForUser({ fid, filter, limit, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)
     *
     */
    fetchRepliesAndRecastsForUser(params: {
        fid: number;
        filter?: FetchRepliesAndRecastsForUserFilterEnum;
        limit?: number;
        cursor?: string;
        viewerFid?: number;
    }): Promise<FeedResponse>;
    /**
     * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.
     *
     * @summary Trending feeds
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 10, Maximum: 10)
     * @param {string} params.cursor [optional]  - Pagination cursor
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {TrendingTimeWindow} params.timeWindow [optional]  - Time window for trending casts (7d window for channel feeds only)
     * @param {string} params.channelId [optional]  - Channel ID to filter trending casts. Less active channels might have no casts in the time window selected. Provide either `channel_id` or `parent_url`, not both.
     * @param {string} params.parentUrl [optional]  - Parent URL to filter trending casts. Less active channels might have no casts in the time window selected. Provide either `channel_id` or `parent_url`, not both.
     * @param {FeedTrendingProvider} params.provider [optional]  - The provider of the trending casts feed.
     * @param {string} params.providerMetadata [optional]  - provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     * const viewerFid =
     * const timeWindow =
     * const channelId =
     * const parentUrl =
     * const provider =
     * const providerMetadata =
     *
     * client.fetchTrendingFeed({ limit, viewerFid, timeWindow, channelId, parentUrl, provider, providerMetadata }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)
     *
     */
    fetchTrendingFeed(params: {
        limit?: number;
        cursor?: string;
        viewerFid?: number;
        timeWindow?: TrendingTimeWindow;
        channelId?: string;
        parentUrl?: string;
        provider?: FeedTrendingProvider;
        providerMetadata?: string;
    }): Promise<FeedResponse>;
    /**
     * Fetch feed based on who a user is following
     *
     * @summary Following
     *
     * @param {object} params
     * @param {number} params.fid  - FID of user whose feed you want to create
     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     * const withRecasts =
     * const limit =
     *
     * client.fetchUserFollowingFeed({ fid, viewerFid, withRecasts, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)
     *
     */
    fetchUserFollowingFeed(params: {
        fid: number;
        viewerFid?: number;
        withRecasts?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<FeedResponse>;
    /**
     * Check if a given fname is available
     *
     * @summary Check fname availability
     *
     * @param {object} params
     * @param {string} params.fname
     *
     * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fname =
     *
     * client.isFnameAvailable({ fname }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)
     *
     */
    isFnameAvailable(params: {
        fname: string;
    }): Promise<FnameAvailabilityResponse>;
    /**
     * Fetch a list of suggested users to follow. Used to help users discover new users to follow
     *
     * @summary Suggest Follows
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user whose following you want to fetch.
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     *
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     * const limit =
     *
     * client.fetchFollowSuggestions({ fid, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)
     *
     */
    fetchFollowSuggestions(params: {
        fid: number;
        viewerFid?: number;
        limit?: number;
    }): Promise<UsersResponse>;
    /**
     * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \"X, Y and Z follow this user\".
     *
     * @summary Relevant followers
     *
     * @param {object} params
     * @param {number} params.targetFid  - User who's profile you are looking at
     * @param {number} params.viewerFid  - The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.
     *
     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const targetFid =
     * const viewerFid =
     *
     * client.fetchRelevantFollowers({ targetFid, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)
     *
     */
    fetchRelevantFollowers(params: {
        targetFid: number;
        viewerFid: number;
    }): Promise<RelevantFollowersResponse>;
    /**
     * Returns a list of followers for a specific FID.
     *
     * @summary Followers
     *
     * @param {object} params
     * @param {number} params.fid  - User who's profile you are looking at
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {FollowSortType} params.sortType [optional]  - Sort type for fetch followers. Default is `desc_chron`
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     * const sortType =
     * const limit =
     *
     * client.fetchUserFollowers({ fid, viewerFid, sortType, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)
     *
     */
    fetchUserFollowers(params: {
        fid: number;
        viewerFid?: number;
        sortType?: FollowSortType;
        limit?: number;
        cursor?: string;
    }): Promise<FollowersResponse>;
    /**
     * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.
     *
     * @summary Following
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user whose following you want to fetch.
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {FollowSortType} params.sortType [optional]  - Optional parameter to sort the users based on different criteria.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const viewerFid =
     * const sortType =
     * const limit =
     *
     * client.fetchUserFollowing({ fid, viewerFid, sortType, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)
     *
     */
    fetchUserFollowing(params: {
        fid: number;
        viewerFid?: number;
        sortType?: FollowSortType;
        limit?: number;
        cursor?: string;
    }): Promise<FollowersResponse>;
    /**
     * Delete an existing mini app, if it was made by the developer (identified by API key)
     *
     * @summary Delete mini app
     *
     * @param {object} params
     * @param {string} params.uuid [optional]
     *
     * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const uuid =
     *
     * client.deleteNeynarFrame({uuid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)
     *
     */
    deleteNeynarFrame(params: {
        uuid?: string;
    }): Promise<DeleteFrameResponse>;
    /**
     * A curated list of featured mini apps
     *
     * @summary Mini apps catalog
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 100, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor
     * @param {TrendingTimeWindow} params.timeWindow [optional]  - Time window used to calculate the change in trending score for each mini app, used to sort mini app results
     *
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     * const timeWindow =
     *
     * client.fetchFrameCatalog({ limit, timeWindow }).then(response => {
     *   console.log('response:', response);
     * });
     */
    fetchFrameCatalog(params: {
        limit?: number;
        cursor?: string;
        timeWindow?: TrendingTimeWindow;
    }): Promise<FrameCatalogResponse>;
    /**
     * Fetches the mini app meta tags from the URL
     *
     * @summary Meta tags from URL
     *
     * @param {object} params
     * @param {string} params.url  - The mini app URL to crawl
     *
     * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const url =
     *
     * client.fetchFrameMetaTagsFromUrl({ url }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)
     *
     */
    fetchFrameMetaTagsFromUrl(params: {
        url: string;
    }): Promise<FetchFrameMetaTagsFromUrl200Response>;
    /**
     * Fetch a list of mini apps made by the developer (identified by API key)
     *
     * @summary List of mini apps
     *
     *
     * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object.
     *
     * @example
     *
     * client.fetchNeynarFrames().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)
     *
     */
    fetchNeynarFrames(): Promise<Array<NeynarFrame>>;
    /**
     * Returns a list of notifications tokens related to a mini app
     *
     * @summary List of mini app notification tokens
     *
     * @param {object} params
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {number[]} params.fids [optional]  - Comma separated list of FIDs, up to 100 at a time
     * @param {string} params.cursor [optional]  - Pagination cursor
     *
     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const limit =
     * const fids =
     *
     * client.fetchNotificationTokens({ limit, fids }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
     *
     */
    fetchNotificationTokens(params: {
        limit?: number;
        fids?: number[];
        cursor?: string;
    }): Promise<FrameNotificationTokens>;
    /**
     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
     *
     * @summary Relevant mini apps
     *
     * @param {object} params
     * @param {number} params.viewerFid  - FID of the user to fetch relevant mini apps for
     * @param {TrendingTimeWindow} params.timeWindow [optional]  - Time window used to limit statistics used to calculate mini app relevance
     *
     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const viewerFid =
     * const timeWindow =
     *
     * client.fetchRelevantFrames({ viewerFid, timeWindow }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)
     *
     */
    fetchRelevantFrames(params: {
        viewerFid: number;
        timeWindow?: TrendingTimeWindow;
    }): Promise<FetchRelevantFrames200Response>;
    /**
     * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.
     *
     * @summary Analytics for the mini app
     *
     * @param {object} params
     * @param {string} params.frameUrl
     * @param {ValidateFrameAnalyticsType} params.analyticsType
     * @param {string} params.start
     * @param {string} params.stop
     * @param {ValidateFrameAggregateWindow} params.aggregateWindow [optional]  - Required for `analytics_type=interactions-per-cast`
     *
     * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const frameUrl =
     * const analyticsType =
     * const start =
     * const stop =
     * const aggregateWindow =
     *
     * client.fetchValidateFrameAnalytics({ frameUrl, analyticsType, start, stop, aggregateWindow }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)
     *
     */
    fetchValidateFrameAnalytics(params: {
        frameUrl: string;
        analyticsType: ValidateFrameAnalyticsType;
        start: string;
        stop: string;
        aggregateWindow?: ValidateFrameAggregateWindow;
    }): Promise<FrameValidateAnalyticsResponse>;
    /**
     * Fetch a list of all the mini apps validated by a user
     *
     * @summary All mini apps validated by user
     *
     *
     * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object.
     *
     * @example
     *
     * client.fetchValidateFrameList().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)
     *
     */
    fetchValidateFrameList(): Promise<FrameValidateListResponse>;
    /**
     * Retrieves details about a transaction pay mini app by ID
     *
     * @summary Get transaction pay mini app
     *
     * @param {object} params
     * @param {string} params.id  - ID of the transaction mini app to retrieve
     *
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const id =
     *
     * client.getTransactionPayFrame({ id }).then(response => {
     *   console.log('response:', response);
     * });
     */
    getTransactionPayFrame(params: {
        id: string;
    }): Promise<TransactionFrameResponse>;
    /**
     * Fetch a mini app either by UUID or Neynar URL
     *
     * @summary Mini app by UUID or URL
     *
     * @param {object} params
     * @param {FrameType} params.type
     * @param {string} params.uuid [optional]  - UUID of the mini app to fetch
     * @param {string} params.url [optional]  - URL of the Neynar mini app to fetch
     *
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const type =
     * const uuid =
     * const url =
     *
     * client.lookupNeynarFrame({ type, uuid, url }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)
     *
     */
    lookupNeynarFrame(params: {
        type: FrameType;
        uuid?: string;
        url?: string;
    }): Promise<NeynarFrame>;
    /**
     * Post mini app actions, cast actions or cast composer actions to the server  \\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.
     *
     * @summary Post a mini app action, cast action or a cast composer action
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.castHash [optional]  - Cast Hash
     * @param {FrameAction} params.action
     *
     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const castHash =
     * const action =
     *
     * client.postFrameAction({signerUuid, castHash, action}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)
     *
     */
    postFrameAction(params: {
        signerUuid: string;
        castHash?: string;
        action: FrameAction;
    }): Promise<Frame>;
    /**
     * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.
     *
     * @summary Signature packet
     *
     * @param {object} params
     * @param {string} params.castHash [optional]  - Cast Hash
     * @param {FrameAction} params.action
     * @param {FrameSignaturePacket} params.signaturePacket
     *
     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const castHash =
     * const action =
     * const signaturePacket =
     *
     * client.postFrameActionDeveloperManaged({castHash, action, signaturePacket}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)
     *
     */
    postFrameActionDeveloperManaged(params: {
        castHash?: string;
        action: FrameAction;
        signaturePacket: FrameSignaturePacket;
    }): Promise<Frame>;
    /**
     * Send notifications to interactors of a mini app
     *
     * @summary Send notifications
     *
     * @param {object} params
     * @param {Array<number>} params.targetFids  - An array of target FIDs to whom the notifications should be sent. Each FID must be a positive integer, with a maximum of 100 FIDs allowed per call.
     * @param {SendFrameNotificationsReqBodyNotification} params.notification
     *
     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const targetFids =
     * const notification =
     *
     * client.publishFrameNotifications({targetFids, notification}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
     *
     */
    publishFrameNotifications(params: {
        targetFids: Array<number>;
        notification: SendFrameNotificationsReqBodyNotification;
    }): Promise<SendFrameNotificationsResponse>;
    /**
     * Create a new mini app with a list of pages.
     *
     * @summary Create mini app
     *
     * @param {object} params
     * @param {string} params.name  - The name of the mini app.
     * @param {Array<NeynarFramePage>} params.pages
     *
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const name =
     * const pages =
     *
     * client.publishNeynarFrame({name, pages}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)
     *
     */
    publishNeynarFrame(params: {
        name: string;
        pages: Array<NeynarFramePage>;
    }): Promise<NeynarFrame>;
    /**
     * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)
     *
     * @summary Update mini app
     *
     * @param {object} params
     * @param {string} params.uuid  - The UUID of the mini app to update.
     * @param {string} params.name [optional]  - The name of the mini app.
     * @param {Array<NeynarFramePage>} params.pages
     *
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const uuid =
     * const name =
     * const pages =
     *
     * client.updateNeynarFrame({uuid, name, pages}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)
     *
     */
    updateNeynarFrame(params: {
        uuid: string;
        name?: string;
        pages: Array<NeynarFramePage>;
    }): Promise<NeynarFrame>;
    /**
     * Validates a mini app against by an interacting user against a Farcaster Hub \\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)
     *
     * @summary Validate mini app action
     *
     * @param {object} params
     * @param {string} params.messageBytesInHex  - Hexadecimal string of message bytes.
     * @param {boolean} params.castReactionContext [optional]  - Adds viewer_context inside the cast object to indicate whether the interactor reacted to the cast housing the mini app.
     * @param {boolean} params.followContext [optional]  - Adds viewer_context inside the user (interactor) object to indicate whether the interactor follows or is followed by the cast author.
     * @param {boolean} params.signerContext [optional]  - Adds context about the app used by the user inside `frame.action`.
     * @param {boolean} params.channelFollowContext [optional]  - Adds context about the channel that the cast belongs to inside of the cast object.
     *
     * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const messageBytesInHex =
     * const castReactionContext =
     * const followContext =
     * const signerContext =
     * const channelFollowContext =
     *
     * client.validateFrameAction({messageBytesInHex, castReactionContext, followContext, signerContext, channelFollowContext}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)
     *
     */
    validateFrameAction(params: {
        messageBytesInHex: string;
        castReactionContext?: boolean;
        followContext?: boolean;
        signerContext?: boolean;
        channelFollowContext?: boolean;
    }): Promise<ValidateFrameActionResponse>;
    /**
     * Nonce to sign a message
     *
     * @summary Fetch nonce
     *
     *
     * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object.
     *
     * @example
     *
     * client.fetchNonce().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)
     *
     */
    fetchNonce(): Promise<NonceResponse>;
    /**
     * Fetches metrics casts matching a query
     *
     * @summary Metrics for casts
     *
     * @param {object} params
     * @param {string} params.q  - Query string to search for casts
     * @param {FetchCastMetricsIntervalEnum} params.interval [optional]  - Interval of time for which to fetch metrics. Choices are `1d`, `7d`, `30d`
     * @param {number} params.authorFid [optional]  - Fid of the user whose casts you want to search
     * @param {string} params.channelId [optional]  - Channel ID of the casts you want to search
     *
     * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const q =
     * const interval =
     * const authorFid =
     * const channelId =
     *
     * client.fetchCastMetrics({ q, interval, authorFid, channelId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)
     *
     */
    fetchCastMetrics(params: {
        q: string;
        interval?: FetchCastMetricsIntervalEnum;
        authorFid?: number;
        channelId?: string;
    }): Promise<CastsMetricsResponse>;
    /**
     * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.
     *
     * @summary Unmute FID
     *
     * @param {object} params
     * @param {number} params.fid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {number} params.mutedFid  - The unique identifier of a farcaster user (unsigned integer)
     *
     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const mutedFid =
     *
     * client.deleteMute({fid, mutedFid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)
     *
     */
    deleteMute(params: {
        fid: number;
        mutedFid: number;
    }): Promise<MuteResponse>;
    /**
     * Fetches all FIDs that a user has muted.
     *
     * @summary Muted FIDs of user
     *
     * @param {object} params
     * @param {number} params.fid  - The user's FID (identifier)
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const limit =
     *
     * client.fetchMuteList({ fid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)
     *
     */
    fetchMuteList(params: {
        fid: number;
        limit?: number;
        cursor?: string;
    }): Promise<MuteListResponse>;
    /**
     * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.
     *
     * @summary Mute FID
     *
     * @param {object} params
     * @param {number} params.fid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {number} params.mutedFid  - The unique identifier of a farcaster user (unsigned integer)
     *
     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const mutedFid =
     *
     * client.publishMute({fid, mutedFid}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)
     *
     */
    publishMute(params: {
        fid: number;
        mutedFid: number;
    }): Promise<MuteResponse>;
    /**
     * Returns a list of notifications for a specific FID.
     *
     * @summary For user
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.
     * @param {Array<NotificationType>} params.type [optional]  - Notification type to fetch. Comma separated values of follows, recasts, likes, mentions, replies.
     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the viewer follows (if viewer_fid is provided).
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const type =
     * const priorityMode =
     * const limit =
     *
     * client.fetchAllNotifications({ fid, type, priorityMode, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)
     *
     */
    fetchAllNotifications(params: {
        fid: number;
        type?: Array<NotificationType>;
        priorityMode?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<NotificationsResponse>;
    /**
     * Returns a list of notifications for a user in specific channels
     *
     * @summary For user by channel
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.
     * @param {string[]} params.channelIds  - Comma separated channel_ids (find list of all channels here - https://docs.neynar.com/reference/list-all-channels)
     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the viewer follows (if viewer_fid is provided).
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const channelIds =
     * const priorityMode =
     * const limit =
     *
     * client.fetchChannelNotificationsForUser({ fid, channelIds, priorityMode, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)
     *
     */
    fetchChannelNotificationsForUser(params: {
        fid: number;
        channelIds: string[];
        priorityMode?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<NotificationsResponse>;
    /**
     * Returns a list of notifications for a user in specific parent_urls
     *
     * @summary For user by parent_urls
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.
     * @param {string[]} params.parentUrls  - Comma separated parent_urls
     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the viewer follows (if viewer_fid is provided).
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const parentUrls =
     * const priorityMode =
     * const limit =
     *
     * client.fetchNotificationsByParentUrlForUser({ fid, parentUrls, priorityMode, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)
     *
     */
    fetchNotificationsByParentUrlForUser(params: {
        fid: number;
        parentUrls: string[];
        priorityMode?: boolean;
        limit?: number;
        cursor?: string;
    }): Promise<NotificationsResponse>;
    /**
     * Mark notifications as seen
     *
     * @summary Mark as seen
     *
     * @param {object} params
     * @param {string} params.signerUuid  - The UUID of the signer. Signer should have atleast one write permission
     * @param {NotificationType} params.type [optional]
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const type =
     *
     * client.markNotificationsAsSeen({signerUuid, type}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)
     *
     */
    markNotificationsAsSeen(params: {
        signerUuid: string;
        type?: NotificationType;
    }): Promise<OperationResponse>;
    /**
     * Creates a new token. This is an allowlisted API, reach out if you want access.
     *
     * @summary Deploy fungible
     *
     * @param {object} params
     * @param {string} params.owner  - Ethereum address of the one who is creating the token
     * @param {string} params.symbol  - Symbol/Ticker for the token
     * @param {string} params.name  - Name of the token
     * @param {DeployFungibleReqBodyMetadataMedia} params.metadataMedia [optional]
     * @param {string} params.metadataDescription [optional]  - Description of the token
     * @param {DeployFungibleMetadataNsfwEnum} params.metadataNsfw [optional]  - Indicates if the token is NSFW (Not Safe For Work).
     * @param {string} params.metadataWebsiteLink [optional]  - Website link related to the token
     * @param {string} params.metadataTwitter [optional]  - Twitter profile link
     * @param {string} params.metadataDiscord [optional]  - Discord server link
     * @param {string} params.metadataTelegram [optional]  - Telegram link
     * @param {DeployFungibleNetworkEnum} params.network [optional]  - Network/Chain name
     * @param {DeployFungibleFactoryEnum} params.factory [optional]  - Factory name - wow -> [wow.xyz](https://wow.xyz) - clanker -> [clanker.world](https://www.clanker.world)
     *
     * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const owner =
     * const symbol =
     * const name =
     * const metadataMedia =
     * const metadataDescription =
     * const metadataNsfw =
     * const metadataWebsiteLink =
     * const metadataTwitter =
     * const metadataDiscord =
     * const metadataTelegram =
     * const network =
     * const factory =
     *
     * client.deployFungible({ owner, symbol, name, metadataMedia, metadataDescription, metadataNsfw, metadataWebsiteLink, metadataTwitter, metadataDiscord, metadataTelegram, network, factory }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)
     *
     */
    deployFungible(params: {
        owner: string;
        symbol: string;
        name: string;
        metadataMedia?: DeployFungibleReqBodyMetadataMedia;
        metadataDescription?: string;
        metadataNsfw?: DeployFungibleMetadataNsfwEnum;
        metadataWebsiteLink?: string;
        metadataTwitter?: string;
        metadataDiscord?: string;
        metadataTelegram?: string;
        network?: DeployFungibleNetworkEnum;
        factory?: DeployFungibleFactoryEnum;
    }): Promise<DeployFungibleResponse>;
    /**
     * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \"X, Y, Z and N others you know own this asset\".
     *
     * @summary Relevant owners
     *
     * @param {object} params
     * @param {string} params.contractAddress  - Contract address of the fungible asset
     * @param {Array<Networks>} params.networks  - Comma separated list of networks to fetch balances for. Currently, only "base" is supported.
     * @param {number} params.viewerFid [optional]  - If you provide a viewer_fid, the response will include token holders from the user's network, respecting their mutes and blocks and including viewer_context; if not provided, the response will show top token holders across the networkboth sets can be combined to generate a longer list if desired.
     *
     * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const contractAddress =
     * const networks =
     * const viewerFid =
     *
     * client.fetchRelevantFungibleOwners({ contractAddress, networks, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)
     *
     */
    fetchRelevantFungibleOwners(params: {
        contractAddress: string;
        networks: Array<Networks>;
        viewerFid?: number;
    }): Promise<RelevantFungibleOwnersResponse>;
    /**
     * Fetches the token balances of a user given their FID
     *
     * @summary Token balance
     *
     * @param {object} params
     * @param {number} params.fid  - FID of the user to fetch
     * @param {Array<Networks>} params.networks  - Comma separated list of networks to fetch balances for. Currently, only "base" is supported.
     *
     * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const networks =
     *
     * client.fetchUserBalance({ fid, networks }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)
     *
     */
    fetchUserBalance(params: {
        fid: number;
        networks: Array<Networks>;
    }): Promise<BalanceResponse>;
    /**
     * Delete a reaction (like or recast) to a cast \\ (In order to delete a reaction `signer_uuid` must be approved)
     *
     * @summary Delete reaction
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {ReactionType} params.reactionType
     * @param {string} params.target
     * @param {number} params.targetAuthorFid [optional]  - The unique identifier of a farcaster user (unsigned integer)
     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const reactionType =
     * const target =
     * const targetAuthorFid =
     * const idem =
     *
     * client.deleteReaction({signerUuid, reactionType, target, targetAuthorFid, idem}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)
     *
     */
    deleteReaction(params: {
        signerUuid: string;
        reactionType: ReactionType;
        target: string;
        targetAuthorFid?: number;
        idem?: string;
    }): Promise<OperationResponse>;
    /**
     * Fetches reactions for a given cast
     *
     * @summary Reactions for cast
     *
     * @param {object} params
     * @param {string} params.hash
     * @param {Array<ReactionsType>} params.types  - Customize which reaction types the request should search for. This is a comma-separated string that can include the following values: 'likes' and 'recasts'. By default api returns both. To select multiple types, use a comma-separated list of these values.
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of reactions that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const hash =
     * const types =
     * const viewerFid =
     * const limit =
     *
     * client.fetchCastReactions({ hash, types, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)
     *
     */
    fetchCastReactions(params: {
        hash: string;
        types: Array<ReactionsType>;
        viewerFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<ReactionsCastResponse>;
    /**
     * Fetches reactions for a given user
     *
     * @summary Reactions for user
     *
     * @param {object} params
     * @param {number} params.fid
     * @param {ReactionsType} params.type  - Type of reaction to fetch (likes or recasts or all)
     * @param {number} params.viewerFid [optional]  - Providing this will return a list of reactions that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const type =
     * const viewerFid =
     * const limit =
     *
     * client.fetchUserReactions({ fid, type, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)
     *
     */
    fetchUserReactions(params: {
        fid: number;
        type: ReactionsType;
        viewerFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<ReactionsResponse>;
    /**
     * Post a reaction (like or recast) to a given cast \\ (In order to post a reaction `signer_uuid` must be approved)
     *
     * @summary Post a reaction
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {ReactionType} params.reactionType
     * @param {string} params.target
     * @param {number} params.targetAuthorFid [optional]  - The unique identifier of a farcaster user (unsigned integer)
     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const reactionType =
     * const target =
     * const targetAuthorFid =
     * const idem =
     *
     * client.publishReaction({signerUuid, reactionType, target, targetAuthorFid, idem}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)
     *
     */
    publishReaction(params: {
        signerUuid: string;
        reactionType: ReactionType;
        target: string;
        targetAuthorFid?: number;
        idem?: string;
    }): Promise<OperationResponse>;
    /**
     * Creates a signer and returns the signer status. \\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.
     *
     * @summary Create signer
     *
     *
     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.
     *
     * @example
     *
     * client.createSigner().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)
     *
     */
    createSigner(): Promise<Signer>;
    /**
     * Fetch authorization url (Fetched authorized url useful for SIWN login operation)
     *
     * @summary Fetch authorization url
     *
     * @param {object} params
     * @param {string} params.clientId
     * @param {AuthorizationUrlResponseType} params.responseType
     *
     * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const clientId =
     * const responseType =
     *
     * client.fetchAuthorizationUrl({ clientId, responseType }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)
     *
     */
    fetchAuthorizationUrl(params: {
        clientId: string;
        responseType: AuthorizationUrlResponseType;
    }): Promise<AuthorizationUrlResponse>;
    /**
     * Fetches a list of signers for a custody address
     *
     * @summary List signers
     *
     * @param {object} params
     * @param {string} params.message  - A Sign-In with Ethereum (SIWE) message that the user's Ethereum wallet signs. This message includes details such as the domain, address, statement, URI, nonce, and other relevant information following the EIP-4361 standard. It should be structured and URL-encoded.  example:  example.com wants you to sign in with your Ethereum account:n0x23A...F232nnSign in to continue.nnURI: example.comnVersion: 1nChain ID: 1nNonce: xyz123nIssued At: 2021-09-01T14:52:07Z  Note: This is just an example message (So, message is invalid, since we don't want any signers related to NEYNAR_API_DOCS to be exposed).   [Checkout fetch-signers API documentation for more details.](https://docs.neynar.com/docs/fetch-signers-1)
     * @param {string} params.signature  - The digital signature produced by signing the provided SIWE message with the user's Ethereum private key. This signature is used to verify the authenticity of the message and the identity of the signer.
     *
     * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const message =
     * const signature =
     *
     * client.fetchSigners({ message, signature }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)
     *
     */
    fetchSigners(params: {
        message: string;
        signature: string;
    }): Promise<SignerListResponse>;
    /**
     * Fetches the status of a developer managed signer by public key
     *
     * @summary Status by public key
     *
     * @param {object} params
     * @param {string} params.publicKey
     *
     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const publicKey =
     *
     * client.lookupDeveloperManagedSigner({ publicKey }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)
     *
     */
    lookupDeveloperManagedSigner(params: {
        publicKey: string;
    }): Promise<DeveloperManagedSigner>;
    /**
     * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)
     *
     * @summary Status
     *
     * @param {object} params
     * @param {string} params.signerUuid
     *
     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     *
     * client.lookupSigner({ signerUuid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)
     *
     */
    lookupSigner(params: {
        signerUuid: string;
    }): Promise<Signer>;
    /**
     * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.
     *
     * @summary Publish message
     *
     * @param {object} params
     * @param {object} params.body
     *
     * @returns {Promise<object>} A promise that resolves to a `object` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const body =
     *
     * client.publishMessageToFarcaster({ body }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)
     *
     */
    publishMessageToFarcaster(params: {
        body: object;
    }): Promise<object>;
    /**
     * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.
     *
     * @summary Register Signed Key
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.signature  - Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signers public key
     * @param {number} params.appFid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {number} params.deadline  - unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended)
     * @param {string} params.redirectUrl [optional]  - Url to redirect to after the signer is approved.  **Note** : This should only be used when requesting a signer from a native mobile application.
     * @param {SignedKeyRequestSponsor} params.sponsor [optional]
     *
     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const signature =
     * const appFid =
     * const deadline =
     * const redirectUrl =
     * const sponsor =
     *
     * client.registerSignedKey({signerUuid, signature, appFid, deadline, redirectUrl, sponsor}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)
     *
     */
    registerSignedKey(params: {
        signerUuid: string;
        signature: string;
        appFid: number;
        deadline: number;
        redirectUrl?: string;
        sponsor?: SignedKeyRequestSponsor;
    }): Promise<Signer>;
    /**
     * Registers an signed key and returns the developer managed signer status with an approval url.
     *
     * @summary Register Signed Key
     *
     * @param {object} params
     * @param {string} params.publicKey  - Ed25519 public key
     * @param {string} params.signature  - Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signers public key
     * @param {number} params.appFid  - The unique identifier of a farcaster user (unsigned integer)
     * @param {number} params.deadline  - unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended)
     * @param {string} params.redirectUrl [optional]  - Url to redirect to after the signer is approved.  **Note** : This should only be used when requesting a signer from a native mobile application.
     * @param {SignedKeyRequestSponsor} params.sponsor [optional]
     *
     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const publicKey =
     * const signature =
     * const appFid =
     * const deadline =
     * const redirectUrl =
     * const sponsor =
     *
     * client.registerSignedKeyForDeveloperManagedSigner({publicKey, signature, appFid, deadline, redirectUrl, sponsor}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)
     *
     */
    registerSignedKeyForDeveloperManagedSigner(params: {
        publicKey: string;
        signature: string;
        appFid: number;
        deadline: number;
        redirectUrl?: string;
        sponsor?: SignedKeyRequestSponsor;
    }): Promise<DeveloperManagedSigner>;
    /**
     * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.
     *
     * @summary Buy storage
     *
     * @param {object} params
     * @param {number} params.fid
     * @param {number} params.units [optional]  - Number of storage units to buy. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.
     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.
     *
     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const units =
     * const idem =
     *
     * client.buyStorage({fid, units, idem}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)
     *
     */
    buyStorage(params: {
        fid: number;
        units?: number;
        idem?: string;
    }): Promise<StorageAllocationsResponse>;
    /**
     * Fetches storage allocations for a given user
     *
     * @summary Allocation of user
     *
     * @param {object} params
     * @param {number} params.fid
     *
     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     *
     * client.lookupUserStorageAllocations({ fid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)
     *
     */
    lookupUserStorageAllocations(params: {
        fid: number;
    }): Promise<StorageAllocationsResponse>;
    /**
     * Fetches storage usage for a given user
     *
     * @summary Usage of user
     *
     * @param {object} params
     * @param {number} params.fid
     *
     * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     *
     * client.lookupUserStorageUsage({ fid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)
     *
     */
    lookupUserStorageUsage(params: {
        fid: number;
    }): Promise<StorageUsageResponse>;
    /**
     * Fetch what FIDs and contracts a FID is subscribed to.
     *
     * @summary Subscribed to
     *
     * @param {object} params
     * @param {number} params.fid
     * @param {SubscriptionProvider} params.subscriptionProvider
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const subscriptionProvider =
     * const viewerFid =
     *
     * client.fetchSubscribedToForFid({ fid, subscriptionProvider, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)
     *
     */
    fetchSubscribedToForFid(params: {
        fid: number;
        subscriptionProvider: SubscriptionProvider;
        viewerFid?: number;
    }): Promise<SubscribedToResponse>;
    /**
     * Fetch subscribers for a given FID\'s contracts. Doesn\'t return addresses that don\'t have an FID.
     *
     * @summary Subscribers of a user
     *
     * @param {object} params
     * @param {number} params.fid
     * @param {SubscriptionProviders} params.subscriptionProvider
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const subscriptionProvider =
     * const viewerFid =
     *
     * client.fetchSubscribersForFid({ fid, subscriptionProvider, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)
     *
     */
    fetchSubscribersForFid(params: {
        fid: number;
        subscriptionProvider: SubscriptionProviders;
        viewerFid?: number;
    }): Promise<SubscribersResponse>;
    /**
     * Check if a wallet address is subscribed to a given STP (Hypersub) contract.
     *
     * @summary Hypersub subscription check
     *
     * @param {object} params
     * @param {string[]} params.addresses  - Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {string} params.contractAddress  - Ethereum address of the STP contract
     * @param {string} params.chainId  - Chain ID of the STP contract
     *
     * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const addresses =
     * const contractAddress =
     * const chainId =
     *
     * client.fetchSubscriptionCheck({ addresses, contractAddress, chainId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)
     *
     */
    fetchSubscriptionCheck(params: {
        addresses: string[];
        contractAddress: string;
        chainId: string;
    }): Promise<SubscriptionCheckResponse>;
    /**
     * Fetch created subscriptions for a given FID\'s.
     *
     * @summary Subscriptions created by FID
     *
     * @param {object} params
     * @param {number} params.fid
     * @param {SubscriptionProvider} params.subscriptionProvider
     *
     * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const subscriptionProvider =
     *
     * client.fetchSubscriptionsForFid({ fid, subscriptionProvider }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)
     *
     */
    fetchSubscriptionsForFid(params: {
        fid: number;
        subscriptionProvider: SubscriptionProvider;
    }): Promise<SubscriptionsResponse>;
    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved)
     *
     * @summary Delete verification
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.address  - Ethereum address
     * @param {string} params.blockHash
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const address =
     * const blockHash =
     *
     * client.deleteVerification({signerUuid, address, blockHash}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)
     *
     */
    deleteVerification(params: {
        signerUuid: string;
        address: string;
        blockHash: string;
    }): Promise<OperationResponse>;
    /**
     * Fetches information about multiple users based on FIDs
     *
     * @summary By FIDs
     *
     * @param {object} params
     * @param {number[]} params.fids  - Comma separated list of FIDs, up to 100 at a time
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fids =
     * const viewerFid =
     *
     * client.fetchBulkUsers({ fids, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)
     *
     */
    fetchBulkUsers(params: {
        fids: number[];
        viewerFid?: number;
    }): Promise<BulkUsersResponse>;
    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     *
     * @summary By Eth or Sol addresses
     *
     * @param {object} params
     * @param {string[]} params.addresses  - Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {Array<BulkUserAddressType>} params.addressTypes [optional]  - Customize which address types the request should search for. This is a comma-separated string that can include the following values: 'custody_address' and 'verified_address'. By default api returns both. To select multiple types, use a comma-separated list of these values.
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const addresses =
     * const addressTypes =
     * const viewerFid =
     *
     * client.fetchBulkUsersByEthOrSolAddress({ addresses, addressTypes, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)
     *
     */
    fetchBulkUsersByEthOrSolAddress(params: {
        addresses: string[];
        addressTypes?: Array<BulkUserAddressType>;
        viewerFid?: number;
    }): Promise<BulkUsersByAddressResponse>;
    /**
     * Fetches power users based on Warpcast power badges. Information is updated once a day.
     *
     * @summary Power users
     *
     * @param {object} params
     * @param {number} params.viewerFid [optional]
     * @param {number} params.limit [optional]  - Number of power users to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const viewerFid =
     * const limit =
     *
     * client.fetchPowerUsers({ viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)
     *
     */
    fetchPowerUsers(params: {
        viewerFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<UsersResponse>;
    /**
     * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
     *
     * @summary Power user FIDs
     *
     * @param {object} params
     *
     * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     *
     * client.fetchPowerUsersLite().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)
     *
     */
    fetchPowerUsersLite(): Promise<UserPowerLiteResponse>;
    /**
     * Fetches a list of users given a location
     *
     * @summary By location
     *
     * @param {object} params
     * @param {number} params.latitude  - Latitude of the location
     * @param {number} params.longitude  - Longitude of the location
     * @param {number} params.viewerFid [optional]  - FID of the user viewing the feed. Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)
     * @param {string} params.cursor [optional]  - Pagination cursor
     *
     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const latitude =
     * const longitude =
     * const viewerFid =
     * const limit =
     *
     * client.fetchUsersByLocation({ latitude, longitude, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)
     *
     */
    fetchUsersByLocation(params: {
        latitude: number;
        longitude: number;
        viewerFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<UsersResponse>;
    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved)
     *
     * @summary Follow user
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {Array<number>} params.targetFids
     *
     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const targetFids =
     *
     * client.followUser({signerUuid, targetFids}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)
     *
     */
    followUser(params: {
        signerUuid: string;
        targetFids: Array<number>;
    }): Promise<BulkFollowResponse>;
    /**
     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)
     *
     * @summary Fetch fresh FID
     *
     * @param {object} params
     *
     * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     *
     * client.getFreshAccountFID().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)
     *
     */
    getFreshAccountFID(): Promise<UserFIDResponse>;
    /**
     * Lookup a user by custody-address
     *
     * @summary By custody-address
     *
     * @param {object} params
     * @param {string} params.custodyAddress  - Custody Address associated with mnemonic
     *
     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const custodyAddress =
     *
     * client.lookupUserByCustodyAddress({ custodyAddress }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)
     *
     */
    lookupUserByCustodyAddress(params: {
        custodyAddress: string;
    }): Promise<UserResponse>;
    /**
     * Fetches a single hydrated user object given a username
     *
     * @summary By username
     *
     * @param {object} params
     * @param {string} params.username  - Username of the user to fetch
     * @param {number} params.viewerFid [optional]
     *
     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const username =
     * const viewerFid =
     *
     * client.lookupUserByUsername({ username, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)
     *
     */
    lookupUserByUsername(params: {
        username: string;
        viewerFid?: number;
    }): Promise<UserResponse>;
    /**
     * Fetches the users who have verified the specified X (Twitter) username
     *
     * @summary By X username
     *
     * @param {object} params
     * @param {string} params.xUsername  - X (Twitter) username to search for, without the @ symbol
     * @param {number} params.viewerFid [optional]  - FID of the viewer for contextual information like follows and blocks
     *
     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const xUsername =
     * const viewerFid =
     *
     * client.lookupUsersByXUsername({ xUsername, viewerFid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)
     *
     */
    lookupUsersByXUsername(params: {
        xUsername: string;
        viewerFid?: number;
    }): Promise<BulkUsersResponse>;
    /**
     * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved)
     *
     * @summary Add verification
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.address  - Ethereum address
     * @param {string} params.blockHash
     * @param {string} params.ethSignature
     * @param {VerificationType} params.verificationType [optional]
     * @param {VerificationChainId} params.chainId [optional]
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const address =
     * const blockHash =
     * const ethSignature =
     * const verificationType =
     * const chainId =
     *
     * client.publishVerification({signerUuid, address, blockHash, ethSignature, verificationType, chainId}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)
     *
     */
    publishVerification(params: {
        signerUuid: string;
        address: string;
        blockHash: string;
        ethSignature: string;
        verificationType?: VerificationType;
        chainId?: VerificationChainId;
    }): Promise<OperationResponse>;
    /**
     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.
     *
     * @summary Register new account
     *
     * @param {object} params
     * @param {string} params.signature
     * @param {number} params.fid
     * @param {string} params.requestedUserCustodyAddress
     * @param {number} params.deadline
     * @param {string} params.fname [optional]
     * @param {RegisterUserReqBodyMetadata} params.metadata [optional]
     *
     * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signature =
     * const fid =
     * const requestedUserCustodyAddress =
     * const deadline =
     * const fname =
     * const metadata =
     *
     * client.registerAccount({signature, fid, requestedUserCustodyAddress, deadline, fname, metadata}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)
     *
     */
    registerAccount(params: {
        signature: string;
        fid: number;
        requestedUserCustodyAddress: string;
        deadline: number;
        fname?: string;
        metadata?: RegisterUserReqBodyMetadata;
    }): Promise<RegisterUserResponse>;
    /**
     * Search for Usernames
     *
     * @summary Search for Usernames
     *
     * @param {object} params
     * @param {string} params.q
     * @param {number} params.viewerFid [optional]  - Providing this will return search results that respects this user's mutes and blocks and includes `viewer_context`.
     * @param {number} params.limit [optional]  - Number of users to fetch (Default: 5, Maximum: 10)
     * @param {string} params.cursor [optional]  - Pagination cursor.
     *
     * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const q =
     * const viewerFid =
     * const limit =
     *
     * client.searchUser({ q, viewerFid, limit }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)
     *
     */
    searchUser(params: {
        q: string;
        viewerFid?: number;
        limit?: number;
        cursor?: string;
    }): Promise<UserSearchResponse>;
    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved)
     *
     * @summary Unfollow user
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {Array<number>} params.targetFids
     *
     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const targetFids =
     *
     * client.unfollowUser({signerUuid, targetFids}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)
     *
     */
    unfollowUser(params: {
        signerUuid: string;
        targetFids: Array<number>;
    }): Promise<BulkFollowResponse>;
    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved)
     *
     * @summary Update user profile
     *
     * @param {object} params
     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.
     * @param {string} params.bio [optional]
     * @param {string} params.pfpUrl [optional]
     * @param {string} params.url [optional]
     * @param {string} params.username [optional]
     * @param {string} params.displayName [optional]
     * @param {UpdateUserReqBodyLocation} params.location [optional]
     * @param {UpdateUserReqBodyVerifiedAccounts} params.verifiedAccounts [optional]
     *
     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const signerUuid =
     * const bio =
     * const pfpUrl =
     * const url =
     * const username =
     * const displayName =
     * const location =
     * const verifiedAccounts =
     *
     * client.updateUser({signerUuid, bio, pfpUrl, url, username, displayName, location, verifiedAccounts}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)
     *
     */
    updateUser(params: {
        signerUuid: string;
        bio?: string;
        pfpUrl?: string;
        url?: string;
        username?: string;
        displayName?: string;
        location?: UpdateUserReqBodyLocation;
        verifiedAccounts?: UpdateUserReqBodyVerifiedAccounts;
    }): Promise<OperationResponse>;
    /**
     * Delete a webhook
     *
     * @summary Delete a webhook
     *
     * @param {object} params
     * @param {string} params.webhookId
     *
     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const webhookId =
     *
     * client.deleteWebhook({webhookId}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)
     *
     */
    deleteWebhook(params: {
        webhookId: string;
    }): Promise<WebhookResponse>;
    /**
     * Fetch a list of webhooks associated to a user
     *
     * @summary Associated webhooks of user
     *
     *
     * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object.
     *
     * @example
     *
     * client.fetchWebhooks().then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)
     *
     */
    fetchWebhooks(): Promise<WebhookListResponse>;
    /**
     * Fetch a webhook
     *
     * @summary Fetch a webhook
     *
     * @param {object} params
     * @param {string} params.webhookId
     *
     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const webhookId =
     *
     * client.lookupWebhook({ webhookId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)
     *
     */
    lookupWebhook(params: {
        webhookId: string;
    }): Promise<WebhookResponse>;
    /**
     * Create a webhook
     *
     * @summary Create a webhook
     *
     * @param {object} params
     * @param {string} params.name
     * @param {string} params.url
     * @param {WebhookSubscriptionFilters} params.subscription [optional]
     *
     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const name =
     * const url =
     * const subscription =
     *
     * client.publishWebhook({name, url, subscription}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)
     *
     */
    publishWebhook(params: {
        name: string;
        url: string;
        subscription?: WebhookSubscriptionFilters;
    }): Promise<WebhookResponse>;
    /**
     * Update a webhook
     *
     * @summary Update a webhook
     *
     * @param {object} params
     * @param {string} params.name
     * @param {string} params.url
     * @param {WebhookSubscriptionFilters} params.subscription [optional]
     * @param {string} params.webhookId
     *
     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const name =
     * const url =
     * const subscription =
     * const webhookId =
     *
     * client.updateWebhook({name, url, subscription, webhookId}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)
     *
     */
    updateWebhook(params: {
        name: string;
        url: string;
        subscription?: WebhookSubscriptionFilters;
        webhookId: string;
    }): Promise<WebhookResponse>;
    /**
     * Update webhook active status
     *
     * @summary Update webhook status
     *
     * @param {object} params
     * @param {string} params.webhookId
     * @param {WebhookPatchReqBodyActiveEnum} params.active
     *
     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const webhookId =
     * const active =
     *
     * client.updateWebhookActiveStatus({webhookId, active}).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)
     *
     */
    updateWebhookActiveStatus(params: {
        webhookId: string;
        active: WebhookPatchReqBodyActiveEnum;
    }): Promise<WebhookResponse>;
    /**
       * Creates a signer and registers a signed key for the signer.
       * It returns a Signer which includes `signer_approval_url` that can be used to create a QR Code for the user to scan and approve the signer.
       *
       * @param {Object} [options] - Optional parameters for the request.
       * @param {string} [options.farcasterDeveloperMnemonic] - mnemonic of the farcaster developer account
       * @param {number} [options.deadline] - (Optional) Unix timestamp in seconds that controls how long the signed key
       *   request is valid for. A 24-hour duration from now is recommended.
       *
       * @returns {Promise<Signer>} A promise that resolves to a `Signer` object,
       *   that includes signer_approval_url.
       *
       * @example
       *
       * // Fill in the appropriate values
       *
       * const farcasterDeveloperMnemonic =
       * const deadline =
       *
       * client.createSignerAndRegisterSignedKey({ farcasterDeveloperMnemonic, deadline: 1693927665 }).then(response => {
       *   console.log('Signer', response);
       * });
       */
    createSignerAndRegisterSignedKey(params: {
        farcasterDeveloperMnemonic: string;
        deadline?: number;
    }): Promise<Signer | undefined>;
}
