"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const __1 = require("..");
const util_1 = require("./util");
async function testFindAccountsByMints() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const accounts = await (0, __1.findAccountsByMints)(client.connection, new web3_js_1.PublicKey('So11111111111111111111111111111111111111112'), new web3_js_1.PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'), __1.OPENBOOK_PROGRAM_ID);
    console.log(accounts.map((a) => a.publicKey.toBase58()));
}
async function testFindAllMarkets() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const markets = await (0, __1.findAllMarkets)(client.connection, __1.OPENBOOK_PROGRAM_ID, client.provider);
    console.log('markets', markets);
}
async function testDecodeMarket() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const marketPk = new web3_js_1.PublicKey('BU3EaRVo9WN44muCBy3mwkCQ4uYQWiuqay1whEmeSXK3');
    const market = await __1.Market.load(client, marketPk);
    await market.loadOrderBook();
    await market.loadEventHeap();
    console.log(market.toPrettyString());
}
async function benchDecodeMarket() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const marketPk = new web3_js_1.PublicKey('CFSMrBssNG8Ud1edW59jNLnq2cwrQ9uY5cM3wXmqRJj3');
    const market = await __1.Market.load(client, marketPk);
    await market.loadOrderBook();
    await market.loadEventHeap();
    const bookSideAccount = await client.connection.getAccountInfo(market.bids.pubkey);
    const start = new Date();
    for (let i = 0; i < 10000; ++i) {
        const side = __1.BookSide.decodeAccountfromBuffer(bookSideAccount.data);
        market.bids.account = side;
        market.bids.getL2(16);
    }
    const end = new Date();
    console.log({ start, end, duration: end.valueOf() - start.valueOf() });
    console.log();
}
async function testDecodeMultiple() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const markets = [
        new web3_js_1.PublicKey('BU3EaRVo9WN44muCBy3mwkCQ4uYQWiuqay1whEmeSXK3'),
        new web3_js_1.PublicKey('D8BPZXCYvVBkXR5NAoDnuzjFGuF2kFKWyfEUtZbmjRg7'),
    ];
    for (const marketPk of markets) {
        const market = await __1.Market.load(client, marketPk);
        await market.loadOrderBook();
        const mktTag = marketPk.toString().substring(0, 6);
        console.log(mktTag, market.bids?.getL2(300));
        console.log(mktTag, market.asks?.getL2(300));
    }
}
async function testWatchMarket() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const marketPk = new web3_js_1.PublicKey('CFSMrBssNG8Ud1edW59jNLnq2cwrQ9uY5cM3wXmqRJj3');
    const market = await __1.Market.load(client, marketPk);
    await market.loadOrderBook();
    console.log('bids before sub', market.bids?.getL2(2));
    const w = new __1.Watcher(client.connection);
    w.addMarket(market);
    await (0, __1.sleep)(5_000);
    console.log('bids after sub', market.bids?.getL2(2));
}
async function testMarketLots() {
    const client = (0, util_1.initReadOnlyOpenbookClient)();
    const marketPk1 = new web3_js_1.PublicKey('Hojg6SoyQAjXRBU4HtR48RB5YVfNzu2vwcLMK6xXPSJS');
    const market1 = await __1.Market.load(client, marketPk1);
    const tick1 = market1.tickSize.toNumber();
    if ('1' !== market1.priceUiToLots(tick1).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('0' !== market1.priceUiToLots(0.9 * tick1).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('1' !== market1.priceUiToLots(1.9 * tick1).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('10000000000' !== market1.priceUiToLots(1).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    const marketPk2 = new web3_js_1.PublicKey('DBSZ24hqXS5o8djunrTzBsJUb1P8ZvBs1nng5rmZKsJt');
    const market2 = await __1.Market.load(client, marketPk2);
    const tick2 = market2.tickSize.toNumber();
    if ('1' !== market2.priceUiToLots(tick2).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('0' !== market2.priceUiToLots(0.9 * tick2).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('1' !== market2.priceUiToLots(1.9 * tick2).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
    if ('10000000000000' !== market2.priceUiToLots(1).toString()) {
        throw new Error('price lot calculation rounds wrongly');
    }
}
// void testFindAccountsByMints();
// void testFindAllMarkets();
// void testDecodeMarket();
// void testWatchMarket();
// void testMarketLots();
void benchDecodeMarket();
// void testDecodeMultiple();
