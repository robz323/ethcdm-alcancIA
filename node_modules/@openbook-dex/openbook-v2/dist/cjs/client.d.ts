/// <reference types="bn.js" />
/// <reference types="node" />
import { type AnchorProvider, BN, Program, type IdlTypes, type IdlAccounts } from '@coral-xyz/anchor';
import { type AccountInfo, type Commitment, type Connection, Keypair, PublicKey, type Signer, type TransactionInstruction, type TransactionSignature } from '@solana/web3.js';
import { type OpenbookV2 } from './openbook_v2';
export type IdsSource = 'api' | 'static' | 'get-program-accounts';
export type PlaceOrderArgs = IdlTypes<OpenbookV2>['PlaceOrderArgs'];
export type PlaceOrderType = IdlTypes<OpenbookV2>['PlaceOrderType'];
export type Side = IdlTypes<OpenbookV2>['Side'];
export type SelfTradeBehavior = IdlTypes<OpenbookV2>['SelfTradeBehavior'];
export type PlaceOrderPeggedArgs = IdlTypes<OpenbookV2>['PlaceOrderPeggedArgs'];
export type PlaceMultipleOrdersArgs = IdlTypes<OpenbookV2>['PlaceMultipleOrdersArgs'];
export type OracleConfigParams = IdlTypes<OpenbookV2>['OracleConfigParams'];
export type OracleConfig = IdlTypes<OpenbookV2>['OracleConfig'];
export type MarketAccount = IdlAccounts<OpenbookV2>['market'];
export type OpenOrdersAccount = IdlAccounts<OpenbookV2>['openOrdersAccount'];
export type OpenOrdersIndexerAccount = IdlAccounts<OpenbookV2>['openOrdersIndexer'];
export type EventHeapAccount = IdlAccounts<OpenbookV2>['eventHeap'];
export type AnyEvent = IdlTypes<OpenbookV2>['AnyEvent'];
export type FillEvent = IdlTypes<OpenbookV2>['FillEvent'];
export type OutEvent = IdlTypes<OpenbookV2>['OutEvent'];
export type BookSideAccount = IdlAccounts<OpenbookV2>['bookSide'];
export type AnyNode = IdlTypes<OpenbookV2>['AnyNode'];
export type InnerNode = IdlTypes<OpenbookV2>['InnerNode'];
export type LeafNode = IdlTypes<OpenbookV2>['LeafNode'];
export type OpenOrder = IdlTypes<OpenbookV2>['OpenOrder'];
export interface OpenBookClientOptions {
    idsSource?: IdsSource;
    postSendTxCallback?: ({ txid }: {
        txid: string;
    }) => void;
    prioritizationFee?: number;
    txConfirmationCommitment?: Commitment;
    referrerWallet?: PublicKey;
}
export declare function nameToString(name: number[]): string;
export declare const OPENBOOK_PROGRAM_ID: PublicKey;
export declare class OpenBookV2Client {
    provider: AnchorProvider;
    programId: PublicKey;
    opts: OpenBookClientOptions;
    program: Program<OpenbookV2>;
    referrerWallet: PublicKey | undefined;
    private readonly idsSource;
    private readonly postSendTxCallback?;
    private readonly prioritizationFee;
    private readonly txConfirmationCommitment;
    constructor(provider: AnchorProvider, programId?: PublicKey, opts?: OpenBookClientOptions);
    get connection(): Connection;
    get walletPk(): PublicKey;
    setProvider(provider: AnchorProvider): void;
    sendAndConfirmTransaction(ixs: TransactionInstruction[], opts?: any): Promise<string>;
    createProgramAccount(authority: Keypair, size: number): Promise<PublicKey>;
    createProgramAccountIx(authority: PublicKey, size: number): Promise<[TransactionInstruction, Signer]>;
    deserializeOpenOrderAccount(publicKey: PublicKey): Promise<OpenOrdersAccount | null>;
    deserializeOpenOrdersIndexerAccount(publicKey: PublicKey): Promise<OpenOrdersIndexerAccount | null>;
    deserializeEventHeapAccount(publicKey: PublicKey): Promise<EventHeapAccount | null>;
    createMarketIx(payer: PublicKey, name: string, quoteMint: PublicKey, baseMint: PublicKey, quoteLotSize: BN, baseLotSize: BN, makerFee: BN, takerFee: BN, timeExpiry: BN, oracleA: PublicKey | null, oracleB: PublicKey | null, openOrdersAdmin: PublicKey | null, consumeEventsAdmin: PublicKey | null, closeMarketAdmin: PublicKey | null, oracleConfigParams?: OracleConfigParams, market?: Keypair, collectFeeAdmin?: PublicKey): Promise<[TransactionInstruction[], Signer[]]>;
    closeMarketIx(marketPublicKey: PublicKey, market: MarketAccount, solDestination: PublicKey, closeMarketAdmin?: Keypair | null): Promise<[TransactionInstruction, Signer[]]>;
    findOpenOrdersIndexer(owner?: PublicKey): PublicKey;
    createOpenOrdersIndexer(openOrdersIndexer: PublicKey): Promise<TransactionSignature>;
    createOpenOrdersIndexerIx(openOrdersIndexer: PublicKey, owner?: PublicKey): Promise<TransactionInstruction>;
    findAllOpenOrders(owner?: PublicKey): Promise<PublicKey[]>;
    findOpenOrderAtIndex(owner: PublicKey | undefined, accountIndex: BN): PublicKey;
    findOpenOrdersForMarket(owner: PublicKey | undefined, market: PublicKey): Promise<PublicKey[]>;
    createOpenOrdersIx(market: PublicKey, name: string, owner: PublicKey | undefined, delegateAccount: PublicKey | null, openOrdersIndexer?: PublicKey | null): Promise<[TransactionInstruction[], PublicKey]>;
    createOpenOrders(payer: Keypair, market: PublicKey, name: string, owner?: Keypair, delegateAccount?: PublicKey | null): Promise<PublicKey>;
    depositIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, baseAmount: BN, quoteAmount: BN): Promise<TransactionInstruction>;
    depositNativeIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, baseAmount: BN, quoteAmount: BN): Promise<[TransactionInstruction[], Signer[]]>;
    decodeMarket(data: Buffer): any;
    placeOrderIx(openOrdersPublicKey: PublicKey, marketPublicKey: PublicKey, market: MarketAccount, userTokenAccount: PublicKey, args: PlaceOrderArgs, remainingAccounts: PublicKey[], openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    placeOrderPeggedIx(openOrdersPublicKey: PublicKey, marketPublicKey: PublicKey, market: MarketAccount, userTokenAccount: PublicKey, openOrdersAdmin: PublicKey | null, args: PlaceOrderPeggedArgs, remainingAccounts: PublicKey[], openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    placeTakeOrderIx(marketPublicKey: PublicKey, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, openOrdersAdmin: PublicKey | null, args: PlaceOrderArgs, remainingAccounts: PublicKey[], openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    cancelAllAndPlaceOrdersIx(openOrdersPublicKey: PublicKey, marketPublicKey: PublicKey, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, openOrdersAdmin: PublicKey | null, orderType: PlaceOrderType, bids: PlaceMultipleOrdersArgs[], asks: PlaceMultipleOrdersArgs[], limit?: number, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    placeOrdersIx(openOrdersPublicKey: PublicKey, marketPublicKey: PublicKey, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, openOrdersAdmin: PublicKey | null, orderType: PlaceOrderType, bids: PlaceMultipleOrdersArgs[], asks: PlaceMultipleOrdersArgs[], limit?: number, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    cancelOrderByIdIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, market: MarketAccount, orderId: BN, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    cancelOrderByClientIdIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, market: MarketAccount, clientOrderId: BN, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    cancelAllOrdersIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, market: MarketAccount, limit: number, side: Side | null, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    closeOpenOrdersIndexerIx(owner: Keypair, market: MarketAccount, openOrdersIndexer?: PublicKey): Promise<[TransactionInstruction, Signer[]]>;
    settleFundsIx(openOrdersPublicKey: PublicKey, openOrdersAccount: OpenOrdersAccount, marketPublicKey: PublicKey, market: MarketAccount, userBaseAccount: PublicKey, userQuoteAccount: PublicKey, referrerAccount: PublicKey | null, penaltyPayer: PublicKey, openOrdersDelegate?: Keypair): Promise<[TransactionInstruction, Signer[]]>;
    closeOpenOrdersAccountIx(owner: Keypair, openOrdersPublicKey: PublicKey, solDestination?: PublicKey, openOrdersIndexer?: PublicKey): Promise<[TransactionInstruction, Signer[]]>;
    consumeEventsIx(marketPublicKey: PublicKey, market: MarketAccount, limit: BN, remainingAccounts: PublicKey[]): Promise<TransactionInstruction>;
    consumeEventsForAccountIx(marketPublicKey: PublicKey, market: MarketAccount, openOrdersAccount: PublicKey): Promise<TransactionInstruction>;
    consumeGivenEventsIx(marketPublicKey: PublicKey, market: MarketAccount, slots: BN[], remainingAccounts: PublicKey[]): Promise<TransactionInstruction>;
    pruneOrdersIx(marketPublicKey: PublicKey, market: MarketAccount, openOrdersPublicKey: PublicKey, limit: number, closeMarketAdmin?: Keypair | null): Promise<[TransactionInstruction, Signer[]]>;
    getAccountsToConsume(market: MarketAccount): Promise<PublicKey[]>;
    getSlotsToConsume(key: PublicKey, market: MarketAccount): Promise<BN[]>;
}
export declare function getFilteredProgramAccounts(connection: Connection, programId: PublicKey, filters: any): Promise<Array<{
    publicKey: PublicKey;
    accountInfo: AccountInfo<Buffer>;
}>>;
