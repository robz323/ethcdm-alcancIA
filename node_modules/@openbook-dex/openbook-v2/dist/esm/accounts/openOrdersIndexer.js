import { OpenOrders, Market, BookSide, SideUtils, } from '..';
export class OpenOrdersIndexer {
    client;
    pubkey;
    account;
    constructor(client, pubkey, account) {
        this.client = client;
        this.pubkey = pubkey;
        this.account = account;
    }
    static async load(client, owner) {
        const pubkey = client.findOpenOrdersIndexer(owner);
        const account = await client.program.account.openOrdersIndexer.fetch(pubkey);
        return new OpenOrdersIndexer(client, pubkey, account);
    }
    static async loadNullable(client, owner) {
        const pubkey = client.findOpenOrdersIndexer(owner);
        const account = await client.program.account.openOrdersIndexer.fetchNullable(pubkey);
        return account && new OpenOrdersIndexer(client, pubkey, account);
    }
    async loadAllOpenOrders() {
        const ooPks = this.account.addresses;
        const oos = await this.client.program.account.openOrdersAccount.fetchMultiple(ooPks);
        const marketPks = oos.map((oo) => oo.market);
        const markets = await this.client.program.account.market.fetchMultiple(marketPks);
        const bookSidePks = markets.flatMap((m) => [m.bids, m.asks]);
        const bookSideAis = await this.client.connection.getMultipleAccountsInfo(bookSidePks);
        return oos.map((oo, i) => {
            const mkt = new Market(this.client, marketPks[i], markets[i]);
            mkt.bids = new BookSide(mkt, bookSidePks[2 * i], BookSide.decodeAccountfromBuffer(bookSideAis[2 * i].data), SideUtils.Bid);
            mkt.asks = new BookSide(mkt, bookSidePks[2 * i + 1], BookSide.decodeAccountfromBuffer(bookSideAis[2 * i + 1].data), SideUtils.Ask);
            return new OpenOrders(ooPks[i], oo, mkt);
        });
    }
}
