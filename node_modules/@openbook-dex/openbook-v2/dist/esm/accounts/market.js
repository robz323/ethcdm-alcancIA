import Big from 'big.js';
import { BN } from '@coral-xyz/anchor';
import { PublicKey } from '@solana/web3.js';
import { toNative, BookSide, SideUtils, nameToString, EventHeap, EventType, } from '..';
const FEES_SCALE_FACTOR = new BN(1_000_000);
export class Market {
    client;
    pubkey;
    account;
    minOrderSize;
    tickSize;
    quoteLotFactor;
    baseNativeFactor;
    quoteNativeFactor;
    /**
     * use async loadBids() or loadOrderBook() to populate bids
     */
    bids;
    /**
     * use async loadAsks() or loadOrderBook() to populate asks
     */
    asks;
    eventHeap;
    constructor(client, pubkey, account) {
        this.client = client;
        this.pubkey = pubkey;
        this.account = account;
        this.baseNativeFactor = new Big(10).pow(-account.baseDecimals);
        this.quoteNativeFactor = new Big(10).pow(-account.quoteDecimals);
        this.minOrderSize = new Big(account.baseLotSize.toString()).mul(this.baseNativeFactor);
        this.quoteLotFactor = new Big(account.quoteLotSize.toString()).mul(this.quoteNativeFactor);
        this.tickSize = new Big(10)
            .pow(account.baseDecimals - account.quoteDecimals)
            .mul(new Big(account.quoteLotSize.toString()))
            .div(new Big(account.baseLotSize.toString()));
    }
    static async load(client, pubkey) {
        const account = await client.program.account.market.fetch(pubkey);
        return new Market(client, pubkey, account);
    }
    baseLotsToUi(lots) {
        return new Big(lots.toString()).mul(this.minOrderSize).toNumber();
    }
    baseNativeToUi(native) {
        return new Big(native.toString()).mul(this.baseNativeFactor).toNumber();
    }
    quoteLotsToUi(lots) {
        return new Big(lots.toString()).mul(this.quoteLotFactor).toNumber();
    }
    quoteNativeToUi(native) {
        return new Big(native.toString()).mul(this.quoteNativeFactor).toNumber();
    }
    priceLotsToUi(lots) {
        return new Big(lots.toString()).mul(this.tickSize).toNumber();
    }
    baseUiToLots(uiAmount) {
        return toNative(uiAmount, this.account.baseDecimals).div(this.account.baseLotSize);
    }
    quoteUiToLots(uiAmount) {
        return toNative(uiAmount, this.account.quoteDecimals).div(this.account.quoteLotSize);
    }
    priceUiToLots(uiAmount) {
        return toNative(uiAmount * Number(this.account.baseLotSize.toString()), this.account.quoteDecimals).div(new BN(Math.pow(10, this.account.baseDecimals)).imul(this.account.quoteLotSize));
    }
    makerFeeFloor(quoteNative) {
        return quoteNative.mul(this.account.makerFee).div(FEES_SCALE_FACTOR);
    }
    async loadBids() {
        const bidsAi = await this.client.connection.getAccountInfo(this.account.bids);
        this.bids = new BookSide(this, this.account.bids, BookSide.decodeAccountfromBuffer(bidsAi.data), SideUtils.Bid);
        return this.bids;
    }
    async loadAsks() {
        const asksAi = await this.client.connection.getAccountInfo(this.account.asks);
        this.asks = new BookSide(this, this.account.asks, BookSide.decodeAccountfromBuffer(asksAi.data), SideUtils.Ask);
        return this.asks;
    }
    async loadEventHeap() {
        const eventHeap = (await this.client.program.account.eventHeap.fetch(this.account.eventHeap));
        this.eventHeap = new EventHeap(this.account.eventHeap, eventHeap, this);
        return this.eventHeap;
    }
    async loadOrderBook() {
        await Promise.all([this.loadBids(), this.loadAsks()]);
        return this;
    }
    toPrettyString() {
        const mkt = this.account;
        let debug = `Market: ${nameToString(mkt.name)}\n`;
        debug += ` authority: ${mkt.marketAuthority.toBase58()}\n`;
        debug += ` collectFeeAdmin: ${mkt.collectFeeAdmin.toBase58()}\n`;
        if (!mkt.openOrdersAdmin.key.equals(PublicKey.default))
            debug += ` openOrdersAdmin: ${mkt.openOrdersAdmin.key.toBase58()}\n`;
        if (!mkt.consumeEventsAdmin.key.equals(PublicKey.default))
            debug += ` consumeEventsAdmin: ${mkt.consumeEventsAdmin.key.toBase58()}\n`;
        if (!mkt.closeMarketAdmin.key.equals(PublicKey.default))
            debug += ` closeMarketAdmin: ${mkt.closeMarketAdmin.key.toBase58()}\n`;
        debug += ` baseMint: ${mkt.baseMint.toBase58()}\n`;
        debug += ` quoteMint: ${mkt.quoteMint.toBase58()}\n`;
        debug += ` marketBaseVault: ${mkt.marketBaseVault.toBase58()}\n`;
        debug += ` marketQuoteVault: ${mkt.marketQuoteVault.toBase58()}\n`;
        if (!mkt.oracleA.key.equals(PublicKey.default)) {
            debug += ` oracleConfig: { confFilter: ${mkt.oracleConfig.confFilter}, maxStalenessSlots: ${mkt.oracleConfig.maxStalenessSlots.toString()} }\n`;
            debug += ` oracleA: ${mkt.oracleA.key.toBase58()}\n`;
        }
        if (!mkt.oracleB.key.equals(PublicKey.default))
            debug += ` oracleB: ${mkt.oracleB.key.toBase58()}\n`;
        debug += ` bids: ${mkt.bids.toBase58()}\n`;
        const bb = this.bids?.best();
        if (bb) {
            debug += `  best: ${bb.price} ${bb.size} ${bb.leafNode.owner.toBase58()}\n`;
        }
        debug += ` asks: ${mkt.asks.toBase58()}\n`;
        const ba = this.asks?.best();
        if (ba) {
            debug += `  best: ${ba.price} ${ba.size} ${ba.leafNode.owner.toBase58()}\n`;
        }
        debug += ` eventHeap: ${mkt.eventHeap.toBase58()}\n`;
        if (this.eventHeap) {
            let fillEvents = 0;
            let outEvents = 0;
            for (const event of this.eventHeap.parsedEvents()) {
                switch (event.eventType) {
                    case EventType.Fill: {
                        fillEvents += 1;
                        continue;
                    }
                    case EventType.Out: {
                        outEvents += 1;
                        continue;
                    }
                }
            }
            debug += `  fillEvents: ${fillEvents}\n`;
            debug += `  outEvents: ${outEvents}\n`;
        }
        else {
            debug += `  loaded: false\n`;
        }
        debug += ` minOrderSize: ${this.minOrderSize}\n`;
        debug += ` tickSize: ${this.tickSize}\n`;
        return debug;
    }
}
