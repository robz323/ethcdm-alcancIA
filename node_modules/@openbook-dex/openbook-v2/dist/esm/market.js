import { PublicKey, } from '@solana/web3.js';
import { OPENBOOK_PROGRAM_ID, getFilteredProgramAccounts, } from './client';
import { utils, Program, getProvider, BN, } from '@coral-xyz/anchor';
import { toNative, toUiDecimals } from './utils/utils';
import Big from 'big.js';
import { IDL } from './openbook_v2';
const BATCH_TX_SIZE = 50;
export async function findAccountsByMints(connection, baseMintAddress, quoteMintAddress, programId) {
    const filters = [
        {
            memcmp: {
                offset: 792,
                bytes: baseMintAddress.toBase58(),
            },
        },
        {
            memcmp: {
                offset: 824,
                bytes: quoteMintAddress.toBase58(),
            },
        },
    ];
    return await getFilteredProgramAccounts(connection, programId, filters);
}
export async function findAllMarkets(connection, programId = OPENBOOK_PROGRAM_ID, provider) {
    if (provider == null) {
        provider = getProvider();
    }
    const program = new Program(IDL, programId, provider);
    const [eventAuthority] = PublicKey.findProgramAddressSync([Buffer.from('__event_authority')], programId);
    const marketsAll = [];
    const signatures = (await connection.getSignaturesForAddress(eventAuthority)).map((x) => x.signature);
    const batchSignatures = [[]];
    for (let i = 0; i < signatures.length; i += BATCH_TX_SIZE) {
        batchSignatures.push(signatures.slice(0, BATCH_TX_SIZE));
    }
    for (const batch of batchSignatures) {
        const allTxs = await connection.getTransactions(batch, {
            commitment: 'confirmed',
            maxSupportedTransactionVersion: 0,
        });
        for (const tx of allTxs) {
            if (tx?.meta?.innerInstructions !== null &&
                tx?.meta?.innerInstructions !== undefined) {
                for (const innerIns of tx.meta.innerInstructions) {
                    const innerIx = innerIns.instructions?.[11];
                    if (innerIx?.accounts?.[0] !== undefined) {
                        // validate key and program key
                        const eventAuthorityKey = innerIx.accounts[0];
                        const programKey = innerIx.programIdIndex;
                        if (tx.transaction.message.staticAccountKeys[eventAuthorityKey].toString() !== eventAuthority.toString() ||
                            tx.transaction.message.staticAccountKeys[programKey].toString() !== programId.toString()) {
                            continue;
                        }
                        else {
                            const ixData = utils.bytes.bs58.decode(innerIx.data);
                            const eventData = utils.bytes.base64.encode(ixData.slice(8));
                            const event = program.coder.events.decode(eventData);
                            if (event != null) {
                                const market = {
                                    market: event.data.market.toString(),
                                    baseMint: event.data.baseMint.toString(),
                                    quoteMint: event.data.quoteMint.toString(),
                                    name: event.data.name,
                                    timestamp: tx.blockTime,
                                };
                                marketsAll.push(market);
                            }
                        }
                    }
                }
            }
        }
    }
    return marketsAll;
}
function priceLotsToUiConverter(market) {
    return new Big(10)
        .pow(market.baseDecimals - market.quoteDecimals)
        .mul(new Big(market.quoteLotSize.toString()))
        .div(new Big(market.baseLotSize.toString()))
        .toNumber();
}
function baseLotsToUiConverter(market) {
    return new Big(market.baseLotSize.toString())
        .div(new Big(10).pow(market.baseDecimals))
        .toNumber();
}
function quoteLotsToUiConverter(market) {
    return new Big(market.quoteLotSize.toString())
        .div(new Big(10).pow(market.quoteDecimals))
        .toNumber();
}
export function uiPriceToLots(market, price) {
    return toNative(price, market.quoteDecimals)
        .mul(market.baseLotSize)
        .div(market.quoteLotSize.mul(new BN(Math.pow(10, market.baseDecimals))));
}
export function uiBaseToLots(market, quantity) {
    return toNative(quantity, market.baseDecimals).div(market.baseLotSize);
}
export function uiQuoteToLots(market, uiQuote) {
    return toNative(uiQuote, market.quoteDecimals).div(market.quoteLotSize);
}
export function priceLotsToNative(market, price) {
    return price.mul(market.quoteLotSize).div(market.baseLotSize);
}
export function priceLotsToUi(market, price) {
    return parseFloat(price.toString()) * priceLotsToUiConverter(market);
}
export function priceNativeToUi(market, price) {
    return toUiDecimals(price, market.quoteDecimals - market.baseDecimals);
}
export function baseLotsToUi(market, quantity) {
    return parseFloat(quantity.toString()) * baseLotsToUiConverter(market);
}
export function quoteLotsToUi(market, quantity) {
    return parseFloat(quantity.toString()) * quoteLotsToUiConverter(market);
}
export function quantityToUiBase(market, quantity, decimals) {
    return toUiDecimals(quantity.mul(market.baseLotSize).toNumber(), decimals);
}
