const locks = new Map();
export async function withLock(scope, key, acquireLockSignalOrCallback, callback) {
    let acquireLockSignal = undefined;
    if (acquireLockSignalOrCallback instanceof AbortSignal)
        acquireLockSignal = acquireLockSignalOrCallback;
    else if (acquireLockSignalOrCallback != null)
        callback = acquireLockSignalOrCallback;
    if (callback == null)
        throw new Error("callback is required");
    while (locks.get(scope)?.has(key)) {
        if (acquireLockSignal?.aborted)
            throw acquireLockSignal.reason;
        try {
            if (acquireLockSignal != null) {
                const acquireLockPromise = createAbortSignalAbortPromise(acquireLockSignal);
                await Promise.race([
                    acquireLockPromise.promise,
                    locks.get(scope)?.get(key)
                ]);
                acquireLockPromise.dispose();
            }
            else
                await locks.get(scope)?.get(key);
        }
        catch (err) {
            // we only need to wait here for the promise to resolve, we don't care about the result
        }
        if (acquireLockSignal?.aborted)
            throw acquireLockSignal.reason;
    }
    const promise = callback.call(scope);
    if (!locks.has(scope))
        locks.set(scope, new Map());
    locks.get(scope).set(key, promise);
    try {
        return await promise;
    }
    finally {
        locks.get(scope)?.delete(key);
        if (locks.get(scope)?.size === 0)
            locks.delete(scope);
    }
}
/**
 * Check if a lock is currently active for a given `scope` and `key`.
 */
export function isLockActive(scope, key) {
    return locks.get(scope)?.has(key) ?? false;
}
/**
 * Acquire a lock for a given `scope` and `key`.
 */
export async function acquireLock(scope, key, acquireLockSignal) {
    let releaseLock;
    await new Promise((accept, reject) => {
        void withLock(scope, key, acquireLockSignal, async () => {
            accept(null);
            await new Promise((accept) => {
                releaseLock = accept;
            });
        })
            .catch(reject);
    });
    return {
        scope,
        key,
        dispose() {
            releaseLock(null);
        },
        [Symbol.dispose]() {
            releaseLock(null);
        }
    };
}
/**
 * Wait for a lock to be released for a given `scope` and `key`.
 */
export async function waitForLockRelease(scope, key, signal) {
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (signal?.aborted)
            throw signal.reason;
        try {
            if (signal != null) {
                const signalPromise = createAbortSignalAbortPromise(signal);
                await Promise.race([
                    signalPromise.promise,
                    locks.get(scope)?.get(key)
                ]);
                signalPromise.dispose();
            }
            else
                await locks.get(scope)?.get(key);
        }
        catch (err) {
            // we only need to wait here for the promise to resolve, we don't care about the result
        }
        if (signal?.aborted)
            throw signal.reason;
        if (locks.get(scope)?.has(key))
            continue;
        await Promise.resolve(); // wait for a microtask to run, so other pending locks can be registered
        if (signal?.aborted)
            throw signal.reason;
        if (locks.get(scope)?.has(key))
            continue;
        return;
    }
}
function createControlledPromise() {
    let resolve;
    let reject;
    const promise = new Promise((accept, fail) => {
        resolve = accept;
        reject = fail;
    });
    return {
        promise,
        resolve: resolve,
        reject: reject
    };
}
function createAbortSignalAbortPromise(signal) {
    const acquireLockPromise = createControlledPromise();
    const onAbort = () => {
        acquireLockPromise.resolve();
        signal.removeEventListener("abort", onAbort);
    };
    signal.addEventListener("abort", onAbort);
    return {
        promise: acquireLockPromise.promise,
        dispose() {
            signal.removeEventListener("abort", onAbort);
        }
    };
}
//# sourceMappingURL=withLock.js.map