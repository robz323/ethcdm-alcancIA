import { Connection, Keypair, PublicKey } from "@solana/web3.js";
import { BN } from "@coral-xyz/anchor";
import Decimal from "decimal.js";
import { CreateCollectionOptions, CreateSingleOptions } from "@3land/listings-sdk/dist/types/implementation/implementationTypes";
import { mintCollectionNFT, closePerpTradeShort, closePerpTradeLong, openPerpTradeShort, openPerpTradeLong, FEE_TIERS, PriorityFee, TargetTokenStruct, InputAssetStruct } from "../tools";
import { Config, TokenCheck, CollectionDeployment, CollectionOptions, GibworkCreateTaskReponse, JupiterTokenData, MintCollectionNFTResponse, PumpfunLaunchResponse, PumpFunTokenOptions, OrderParams, FlashTradeParams, FlashCloseTradeParams, HeliusWebhookIdResponse, HeliusWebhookResponse, deBridgeOrderInput, deBridgeSupportedChainsResponse, deBridgeOrderResponse, deBridgeOrderStatusResponse, deBridgeTokensInfoResponse, SplAuthorityInput, CctpTransferInput, TokenTransferInput, CreateWrappedTokenInput } from "../types";
import { DasApiAsset, DasApiAssetList, GetAssetsByAuthorityRpcInput, GetAssetsByCreatorRpcInput } from "@metaplex-foundation/digital-asset-standard-api";
import { AlloraInference, AlloraTopic } from "@alloralabs/allora-sdk";
/**
 * Main class for interacting with Solana blockchain
 * Provides a unified interface for token operations, NFT management, trading and more
 *
 * @class SolanaAgentKit
 * @property {Connection} connection - Solana RPC connection
 * @property {Keypair} wallet - Wallet keypair for signing transactions
 * @property {PublicKey} wallet_address - Public key of the wallet
 * @property {Config} config - Configuration object
 */
export declare class SolanaAgentKit {
    connection: Connection;
    wallet: Keypair;
    wallet_address: PublicKey;
    config: Config;
    /**
     * @deprecated Using openai_api_key directly in constructor is deprecated.
     * Please use the new constructor with Config object instead:
     * @example
     * const agent = new SolanaAgentKit(privateKey, rpcUrl, {
     *   OPENAI_API_KEY: 'your-key'
     * });
     */
    constructor(private_key: string, rpc_url: string, openai_api_key: string | null);
    constructor(private_key: string, rpc_url: string, config: Config);
    requestFaucetFunds(): Promise<string>;
    deployToken(name: string, uri: string, symbol: string, decimals: number | undefined, authority: SplAuthorityInput, initialSupply?: number): Promise<{
        mint: PublicKey;
    }>;
    deployCollection(options: CollectionOptions): Promise<CollectionDeployment>;
    getBalance(token_address?: PublicKey): Promise<number>;
    getTokenBalances(wallet_address?: PublicKey): Promise<{
        sol: number;
        tokens: Array<{
            tokenAddress: string;
            name: string;
            symbol: string;
            balance: number;
            decimals: number;
        }>;
    }>;
    getBalanceOther(walletAddress: PublicKey, tokenAddress?: PublicKey): Promise<number>;
    mintNFT(collectionMint: PublicKey, metadata: Parameters<typeof mintCollectionNFT>[2], recipient?: PublicKey): Promise<MintCollectionNFTResponse>;
    transfer(to: PublicKey, amount: number, mint?: PublicKey): Promise<string>;
    registerDomain(name: string, spaceKB?: number): Promise<string>;
    resolveSolDomain(domain: string): Promise<PublicKey>;
    getPrimaryDomain(account: PublicKey): Promise<string>;
    trade(outputMint: PublicKey, inputAmount: number, inputMint?: PublicKey, slippageBps?: number): Promise<string>;
    limitOrder(marketId: PublicKey, quantity: number, side: string, price: number): Promise<string>;
    batchOrder(marketId: PublicKey, orders: OrderParams[]): Promise<string>;
    cancelAllOrders(marketId: PublicKey): Promise<string>;
    withdrawAll(marketId: PublicKey): Promise<string>;
    openPerpTradeLong(args: Omit<Parameters<typeof openPerpTradeLong>[0], "agent">): Promise<string>;
    openPerpTradeShort(args: Omit<Parameters<typeof openPerpTradeShort>[0], "agent">): Promise<string>;
    closePerpTradeShort(args: Omit<Parameters<typeof closePerpTradeShort>[0], "agent">): Promise<string>;
    closePerpTradeLong(args: Omit<Parameters<typeof closePerpTradeLong>[0], "agent">): Promise<string>;
    lendAssets(amount: number): Promise<string>;
    luloLend(mintAddress: string, amount: number): Promise<string>;
    luloWithdraw(mintAddress: string, amount: number): Promise<string>;
    getTPS(): Promise<number>;
    getTokenDataByAddress(mint: string): Promise<JupiterTokenData | undefined>;
    getTokenDataByTicker(ticker: string): Promise<JupiterTokenData | undefined>;
    fetchTokenPrice(mint: string): Promise<string>;
    launchPumpFunToken(tokenName: string, tokenTicker: string, description: string, imageUrl: string, options?: PumpFunTokenOptions): Promise<PumpfunLaunchResponse>;
    stake(amount: number): Promise<string>;
    restake(amount: number): Promise<string>;
    sendCompressedAirdrop(mintAddress: string, amount: number, decimals: number, recipients: string[], priorityFeeInLamports: number, shouldLog: boolean): Promise<string[]>;
    meteoraCreateDynamicPool(tokenAMint: PublicKey, tokenBMint: PublicKey, tokenAAmount: BN, tokenBAmount: BN, tradeFeeNumerator: number, activationPoint: BN | null, hasAlphaVault: boolean, activationType: number): Promise<string>;
    meteoraCreateDlmmPool(tokenAMint: PublicKey, tokenBMint: PublicKey, binStep: number, initialPrice: number, priceRoundingUp: boolean, feeBps: number, activationType: number, hasAlphaVault: boolean, activationPoint: BN | undefined): Promise<string>;
    orcaClosePosition(positionMintAddress: PublicKey): Promise<string>;
    orcaCreateCLMM(mintDeploy: PublicKey, mintPair: PublicKey, initialPrice: Decimal, feeTier: keyof typeof FEE_TIERS): Promise<string>;
    orcaCreateSingleSidedLiquidityPool(depositTokenAmount: number, depositTokenMint: PublicKey, otherTokenMint: PublicKey, initialPrice: Decimal, maxPrice: Decimal, feeTier: keyof typeof FEE_TIERS): Promise<string>;
    orcaFetchPositions(): Promise<string>;
    orcaOpenCenteredPositionWithLiquidity(whirlpoolAddress: PublicKey, priceOffsetBps: number, inputTokenMint: PublicKey, inputAmount: Decimal): Promise<string>;
    orcaOpenSingleSidedPosition(whirlpoolAddress: PublicKey, distanceFromCurrentPriceBps: number, widthBps: number, inputTokenMint: PublicKey, inputAmount: Decimal): Promise<string>;
    resolveAllDomains(domain: string): Promise<PublicKey | undefined>;
    getOwnedAllDomains(owner: PublicKey): Promise<string[]>;
    getOwnedDomainsForTLD(tld: string): Promise<string[]>;
    getAllDomainsTLDs(): Promise<string[]>;
    getAllRegisteredAllDomains(): Promise<string[]>;
    getMainAllDomainsDomain(owner: PublicKey): Promise<string | null>;
    raydiumCreateAmmV4(marketId: PublicKey, baseAmount: BN, quoteAmount: BN, startTime: BN): Promise<string>;
    raydiumCreateClmm(mint1: PublicKey, mint2: PublicKey, configId: PublicKey, initialPrice: Decimal, startTime: BN): Promise<string>;
    raydiumCreateCpmm(mint1: PublicKey, mint2: PublicKey, configId: PublicKey, mintAAmount: BN, mintBAmount: BN, startTime: BN): Promise<string>;
    openbookCreateMarket(baseMint: PublicKey, quoteMint: PublicKey, lotSize?: number, tickSize?: number): Promise<string[]>;
    manifestCreateMarket(baseMint: PublicKey, quoteMint: PublicKey): Promise<string[]>;
    getPythPriceFeedID(tokenSymbol: string): Promise<string>;
    getPythPrice(priceFeedID: string): Promise<string>;
    createGibworkTask(title: string, content: string, requirements: string, tags: string[], tokenMintAddress: string, tokenAmount: number, payer?: string): Promise<GibworkCreateTaskReponse>;
    rockPaperScissors(amount: number, choice: "rock" | "paper" | "scissors"): Promise<string>;
    createTiplink(amount: number, splmintAddress?: PublicKey): Promise<{
        url: string;
        signature: string;
    }>;
    tensorListNFT(nftMint: PublicKey, price: number): Promise<string>;
    tensorCancelListing(nftMint: PublicKey): Promise<string>;
    closeEmptyTokenAccounts(): Promise<{
        signature: string;
        size: number;
    }>;
    fetchTokenReportSummary(mint: string): Promise<TokenCheck>;
    fetchTokenDetailedReport(mint: string): Promise<TokenCheck>;
    /**
     * Opens a new trading position on Flash.Trade
     * @param params Flash trade parameters including market, side, collateral, leverage, and pool name
     * @returns Transaction signature
     */
    flashOpenTrade(params: FlashTradeParams): Promise<string>;
    /**
     * Closes an existing trading position on Flash.Trade
     * @param params Flash trade close parameters
     * @returns Transaction signature
     */
    flashCloseTrade(params: FlashCloseTradeParams): Promise<string>;
    heliusParseTransactions(transactionId: string): Promise<any>;
    getAllAssetsbyOwner(owner: PublicKey, limit: number): Promise<any>;
    create3LandCollection(collectionOpts: CreateCollectionOptions, isDevnet?: boolean, priorityFeeParam?: number): Promise<string>;
    create3LandNft(collectionAccount: string, createItemOptions: CreateSingleOptions, isDevnet?: boolean, withPool?: boolean, priorityFeeParam?: number): Promise<string>;
    sendTranctionWithPriority(priorityLevel: string, amount: number, to: PublicKey, splmintAddress?: PublicKey): Promise<{
        transactionId: string;
        fee: number;
    }>;
    createSquadsMultisig(creator: PublicKey): Promise<string>;
    depositToMultisig(amount: number, vaultIndex?: number, mint?: PublicKey): Promise<string>;
    transferFromMultisig(amount: number, to: PublicKey, vaultIndex?: number, mint?: PublicKey): Promise<string>;
    createMultisigProposal(transactionIndex?: number | bigint): Promise<string>;
    approveMultisigProposal(transactionIndex?: number | bigint): Promise<string>;
    rejectMultisigProposal(transactionIndex?: number | bigint): Promise<string>;
    executeMultisigTransaction(transactionIndex?: number | bigint): Promise<string>;
    CreateWebhook(accountAddresses: string[], webhookURL: string): Promise<HeliusWebhookResponse>;
    getWebhook(id: string): Promise<HeliusWebhookIdResponse>;
    deleteWebhook(webhookID: string): Promise<any>;
    createDriftUserAccount(depositAmount: number, depositSymbol: string): Promise<{
        txSignature: string;
        account: PublicKey;
        message?: never;
    } | {
        message: string;
        account: PublicKey;
        txSignature?: never;
    }>;
    createDriftVault(params: {
        name: string;
        marketName: `${string}-${string}`;
        redeemPeriod: number;
        maxTokens: number;
        minDepositAmount: number;
        managementFee: number;
        profitShare: number;
        hurdleRate?: number;
        permissioned?: boolean;
    }): Promise<string>;
    depositIntoDriftVault(amount: number, vault: string): Promise<string>;
    depositToDriftUserAccount(amount: number, symbol: string, isRepayment?: boolean): Promise<import("@drift-labs/sdk").TxSigAndSlot>;
    deriveDriftVaultAddress(name: string): Promise<PublicKey>;
    doesUserHaveDriftAccount(): Promise<{
        hasAccount: boolean;
        account: PublicKey;
    }>;
    driftUserAccountInfo(): Promise<{
        name: number[];
        accountAddress: string;
        authority: PublicKey;
        overallBalance: number;
        settledPerpPnl: string;
        lastActiveSlot: number;
        perpPositions: {
            market: string;
            baseAssetAmount: number;
            quoteAssetAmount: number;
            quoteEntryAmount: number;
            quoteBreakEvenAmount: number;
            settledPnl: number;
            openAsks: number;
            openBids: number;
            openOrders: number;
            positionType: string;
        }[];
        spotPositions: ({
            availableBalance: number;
            symbol: string;
            openAsks: number;
            openBids: number;
            openOrders: number;
            type: string;
        } | undefined)[];
    }>;
    requestWithdrawalFromDriftVault(amount: number, vault: string): Promise<string>;
    tradeUsingDelegatedDriftVault(vault: string, amount: number, symbol: string, action: "long" | "short", type: "market" | "limit", price?: number): Promise<import("@drift-labs/sdk").TxSigAndSlot>;
    tradeUsingDriftPerpAccount(amount: number, symbol: string, action: "long" | "short", type: "market" | "limit", price?: number): Promise<string>;
    updateDriftVault(vaultAddress: string, params: {
        name: string;
        marketName: `${string}-${string}`;
        redeemPeriod: number;
        maxTokens: number;
        minDepositAmount: number;
        managementFee: number;
        profitShare: number;
        hurdleRate?: number;
        permissioned?: boolean;
    }): Promise<string>;
    getDriftVaultInfo(vaultName: string): Promise<{
        name: string;
        delegate: string;
        address: string;
        marketName: string;
        balance: string;
        redeemPeriod: number;
        maxTokens: number;
        minDepositAmount: number;
        managementFee: number;
        profitShare: number;
        hurdleRate: number;
        permissioned: boolean;
    }>;
    withdrawFromDriftAccount(amount: number, symbol: string, isBorrow?: boolean): Promise<import("@drift-labs/sdk").TxSigAndSlot>;
    withdrawFromDriftVault(vault: string): Promise<string>;
    updateDriftVaultDelegate(vaultAddress: string, delegate: string): Promise<string>;
    getAvailableDriftMarkets(type?: "spot" | "perp"): import("@drift-labs/sdk").SpotMarketConfig[] | import("@drift-labs/sdk").PerpMarketConfig[] | {
        spot: import("@drift-labs/sdk").SpotMarketConfig[];
        perp: import("@drift-labs/sdk").PerpMarketConfig[];
    };
    stakeToDriftInsuranceFund(amount: number, symbol: string): Promise<string>;
    requestUnstakeFromDriftInsuranceFund(amount: number, symbol: string): Promise<string>;
    unstakeFromDriftInsuranceFund(symbol: string): Promise<string>;
    driftSpotTokenSwap(params: {
        fromSymbol: string;
        toSymbol: string;
        slippage?: number;
    } & ({
        toAmount: number;
    } | {
        fromAmount: number;
    })): Promise<string>;
    getPerpMarketFundingRate(symbol: `${string}-PERP`, period?: "year" | "hour"): Promise<{
        longRate: number;
        shortRate: number;
        friendlyString: string;
    }>;
    getEntryQuoteOfPerpTrade(amount: number, symbol: `${string}-PERP`, action: "short" | "long"): Promise<{
        entryPrice: number;
        priceImpact: number;
        bestPrice: number;
        worstPrice: number;
    }>;
    getLendAndBorrowAPY(symbol: string): Promise<{
        lendingAPY: number;
        borrowAPY: number;
    }>;
    voltrDepositStrategy(depositAmount: BN, vault: PublicKey, strategy: PublicKey): Promise<string>;
    voltrWithdrawStrategy(withdrawAmount: BN, vault: PublicKey, strategy: PublicKey): Promise<string>;
    voltrGetPositionValues(vault: PublicKey): Promise<string>;
    getAsset(assetId: string): Promise<DasApiAsset>;
    getAssetsByAuthority(params: GetAssetsByAuthorityRpcInput): Promise<DasApiAssetList>;
    getAssetsByCreator(params: GetAssetsByCreatorRpcInput): Promise<DasApiAssetList>;
    swap(amount: string, fromChain: string, fromToken: string, toChain: string, toToken: string, dstAddr: string, slippageBps?: number): Promise<string>;
    getPriceInference(tokenSymbol: string, timeframe: string): Promise<string>;
    getAllTopics(): Promise<AlloraTopic[]>;
    getInferenceByTopicId(topicId: number): Promise<AlloraInference>;
    closeAccounts(mints: string[]): Promise<string[]>;
    burnTokens(mints: string[]): Promise<string[]>;
    mergeTokens(inputAssets: InputAssetStruct[], outputMint: string, priorityFee: PriorityFee): Promise<string[]>;
    spreadToken(inputAsset: InputAssetStruct, targetTokens: TargetTokenStruct[], priorityFee: PriorityFee): Promise<string[]>;
    simulateSwitchboardFeed(feed: string, crossbarUrl: string): Promise<string>;
    pingElfaAiApi(): Promise<any>;
    getElfaAiApiKeyStatus(): Promise<any>;
    getSmartMentions(limit?: number, offset?: number): Promise<any>;
    getTopMentionsByTicker(ticker: string, timeWindow?: string, page?: number, pageSize?: number, includeAccountDetails?: boolean): Promise<any>;
    searchMentionsByKeywords(keywords: string, from: number, to: number, limit?: number): Promise<any>;
    getTrendingTokens(): Promise<any>;
    getTrendingTokensUsingElfaAi(): Promise<any>;
    getSmartTwitterAccountStats(username: string): Promise<any>;
    getDebridgeSupportedChains(): Promise<deBridgeSupportedChainsResponse>;
    getDebridgeTokensInfo(chainId: string, search?: string): Promise<deBridgeTokensInfoResponse>;
    createDebridgeOrder(orderInput: deBridgeOrderInput): Promise<deBridgeOrderResponse>;
    executeDebridgeOrder(transactionData: string): Promise<string>;
    checkDebridgeTransactionStatus(txHashOrOrderId: string): Promise<deBridgeOrderStatusResponse[]>;
    fluxbeamCreatePool(token_a: PublicKey, token_a_amount: number, token_b: PublicKey, token_b_amount: number): Promise<string>;
    getCoingeckoLatestPools(): Promise<any>;
    getTokenInfoUsingCoingecko(tokenAddress: string): Promise<any>;
    getTokenPriceDataUsingCoingecko(...tokenAddresses: string[]): Promise<any>;
    getTopGainersOnCoingecko(duration?: "1h" | "24h" | "7d" | "14d" | "30d" | "60d" | "1y", noOfCoins?: 300 | 500 | 1000 | "all"): Promise<any>;
    getCoingeckoTrendingPools(duration?: "5m" | "1h" | "24h" | "6h"): Promise<any>;
    getTrendingTokensOnCoingecko(): Promise<any>;
    getWormholeSupportedChains(): Promise<string>;
    cctpTransfer(input: CctpTransferInput): Promise<{
        success: boolean;
        status: string;
        sourceChain: string;
        destinationChain: "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Snaxchain" | "Unichain" | "Worldchain" | "Ink" | "HyperEVM" | "Monad" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Noble" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia";
        amount: string;
        sourceTransaction: string[];
        attestation: any[];
        destinationTransaction: string[];
        automatic: boolean;
        error?: never;
    } | {
        success: boolean;
        error: string;
        status?: never;
        sourceChain?: never;
        destinationChain?: never;
        amount?: never;
        sourceTransaction?: never;
        attestation?: never;
        destinationTransaction?: never;
        automatic?: never;
    }>;
    tokenTransfer(input: TokenTransferInput): Promise<any>;
    createWrappedToken(input: CreateWrappedTokenInput): Promise<import("../tools").CreateWrappedTokenResponse>;
    /**
     * Get quote for token swap on OKX DEX
     * @param fromTokenAddress Source token address
     * @param toTokenAddress Target token address
     * @param amount Amount to swap in base units
     * @param slippage Slippage tolerance as a decimal (default: 0.5%)
     * @returns Quote information
     */
    getOkxQuote(fromTokenAddress: string, toTokenAddress: string, amount: string, slippage?: string): Promise<any>;
    /**
     * Execute token swap on OKX DEX
     * @param fromTokenAddress Source token address
     * @param toTokenAddress Target token address
     * @param amount Amount to swap in base units
     * @param slippage Slippage tolerance as a decimal (default: 0.5%)
     * @param autoSlippage Use auto slippage (default: false)
     * @param maxAutoSlippageBps Maximum auto slippage in basis points (default: 100 = 1%)
     * @param userWalletAddress Optional wallet address to use (defaults to agent's wallet)
     * @returns Swap result with transaction ID
     */
    executeOkxSwap(fromTokenAddress: string, toTokenAddress: string, amount: string, slippage?: string, autoSlippage?: boolean, maxAutoSlippageBps?: string, userWalletAddress?: string): Promise<any>;
    /**
     * Get list of tokens supported by OKX DEX
     * @returns List of supported tokens
     */
    getOkxTokens(): Promise<any>;
    /**
     * Get liquidity information from OKX DEX
     * @param chainId Chain ID to query liquidity for
     * @returns Liquidity data
     */
    getOkxLiquidity(chainId: string): Promise<any>;
    /**
     * Get chain data from OKX DEX
     * @returns Chain data
     */
    getOkxChainData(): Promise<any>;
}
//# sourceMappingURL=index.d.ts.map