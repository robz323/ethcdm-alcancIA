"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSigner = getSigner;
exports.getTokenDecimals = getTokenDecimals;
const sdk_1 = require("@wormhole-foundation/sdk");
const evm_1 = __importDefault(require("@wormhole-foundation/sdk/evm"));
const solana_1 = __importDefault(require("@wormhole-foundation/sdk/solana"));
const sui_1 = __importDefault(require("@wormhole-foundation/sdk/sui"));
const aptos_1 = __importDefault(require("@wormhole-foundation/sdk/aptos"));
const dotenv_1 = require("dotenv");
(0, dotenv_1.config)();
/**
 * Retrieves an environment variable
 *
 * @param {string} key - The name of the environment variable
 * @returns {string} The value of the environment variable
 * @throws {Error} If the environment variable is not set
 */
function getEnv(key) {
    const val = process.env[key];
    if (!val) {
        throw new Error(`Missing environment variable: ${key}`);
    }
    return val;
}
/**
 * Creates a signer for a specific blockchain
 *
 * This function handles the creation of signers for different blockchain platforms
 * (Solana, EVM, Sui, Aptos) using private keys from environment variables.
 *
 * @template N - Network type (Mainnet, Testnet, Devnet)
 * @template C - Chain type (Solana, Ethereum, etc.)
 *
 * @param {ChainContext<N, C>} chain - The chain context
 * @param {bigint} [gasLimit] - Optional gas limit for EVM chains
 *
 * @returns {Promise<SignerStuff<N, C>>} The signer, chain context, and address
 * @throws {Error} If the platform is not supported or if required environment variables are missing
 */
async function getSigner(chain, gasLimit) {
    let signer;
    const platform = chain.platform.utils()._platform;
    switch (platform) {
        case "Solana":
            signer = await (await (0, solana_1.default)()).getSigner(await chain.getRpc(), getEnv("SOLANA_PRIVATE_KEY"));
            break;
        case "Evm": {
            const evmSignerOptions = gasLimit ? { gasLimit } : {};
            signer = await (await (0, evm_1.default)()).getSigner(await chain.getRpc(), getEnv("ETH_PRIVATE_KEY"), evmSignerOptions);
            break;
        }
        case "Sui":
            signer = await (await (0, sui_1.default)()).getSigner(await chain.getRpc(), getEnv("SUI_MNEMONIC"));
            break;
        case "Aptos":
            signer = await (await (0, aptos_1.default)()).getSigner(await chain.getRpc(), getEnv("APTOS_PRIVATE_KEY"));
            break;
        default:
            throw new Error("Unsupported platform: " + platform);
    }
    return {
        chain,
        signer: signer,
        address: sdk_1.Wormhole.chainAddress(chain.chain, signer.address()),
    };
}
async function getTokenDecimals(wh, token, sendChain) {
    return (0, sdk_1.isTokenId)(token)
        ? Number(await wh.getDecimals(token.chain, token.address))
        : sendChain.config.nativeTokenDecimals;
}
//# sourceMappingURL=helper.js.map