import { Wormhole } from "@wormhole-foundation/sdk";
import { Chain, Network, TokenAddress, UniversalAddress } from "@wormhole-foundation/sdk";
import { CreateWrappedTokenInput } from "../../types";
/**
 * Interface for the input parameters to create a wrapped token
 *
 * @property {Chain} destinationChain - The target blockchain where the wrapped token will be created
 * @property {string} tokenAddress - The address of the token on Solana to be wrapped
 * @property {Network} network - The network to use ("Mainnet", "Testnet", or "Devnet")
 */
/**
 * Interface for the response from creating a wrapped token
 *
 * @property {boolean} success - Whether the operation was successful
 * @property {Object} [wrappedToken] - Information about the wrapped token (if successful)
 * @property {Chain} wrappedToken.chain - The chain where the wrapped token was created
 * @property {string|TokenAddress<Chain>|UniversalAddress} wrappedToken.address - The address of the wrapped token
 * @property {string} [attestationTxid] - The transaction ID of the attestation transaction
 * @property {string} [error] - Error message if the operation failed
 */
export interface CreateWrappedTokenResponse {
    success: boolean;
    wrappedToken?: {
        chain: Chain;
        address: string | TokenAddress<Chain> | UniversalAddress;
    };
    attestationTxid?: string;
    error?: string;
}
/**
 * Checks if a token is already wrapped on the destination chain
 *
 * This function queries the destination chain to see if a wrapped version of the
 * source token already exists, which helps avoid creating duplicate wrapped tokens.
 *
 * @param {Wormhole<Network>} wh - Wormhole SDK instance
 * @param {Chain} srcChain - Source chain identifier
 * @param {Chain} destChain - Destination chain identifier
 * @param {string} tokenAddress - Token address on the source chain
 * @returns {Promise<TokenAddress<Chain>|UniversalAddress|null>} The wrapped token address if it exists, null otherwise
 */
export declare const isTokenWrapped: (wh: Wormhole<Network>, srcChain: Chain, destChain: Chain, tokenAddress: string) => Promise<TokenAddress<Chain> | UniversalAddress | null>;
/**
 * Creates a wrapped token on the destination chain
 *
 * This function performs the following steps:
 * 1. Checks if the token is already wrapped on the destination chain
 * 2. If not wrapped, creates an attestation on the source chain (Solana)
 * 3. Waits for the attestation to be processed by Wormhole guardians
 * 4. Submits the attestation to the destination chain to create the wrapped token
 * 5. Polls for the wrapped token to be available on the destination chain
 *
 * @param {CreateWrappedTokenInput} input - Parameters for creating the wrapped token
 * @param {Chain} input.destinationChain - The target blockchain where the wrapped token will be created
 * @param {string} input.tokenAddress - The address of the token on Solana to be wrapped
 * @param {Network} input.network - The network to use ("Mainnet", "Testnet", or "Devnet")
 *
 * @returns {Promise<CreateWrappedTokenResponse>} Response with the wrapped token information
 *
 * @throws Will throw an error if the wrapped token creation fails at any step
 */
export declare const createWrappedToken: (input: CreateWrappedTokenInput) => Promise<CreateWrappedTokenResponse>;
//# sourceMappingURL=createWrappedToken.d.ts.map