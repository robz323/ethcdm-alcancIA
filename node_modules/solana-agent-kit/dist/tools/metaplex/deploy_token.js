"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy_token = deploy_token;
const web3_js_1 = require("@solana/web3.js");
const umi_bundle_defaults_1 = require("@metaplex-foundation/umi-bundle-defaults");
const umi_1 = require("@metaplex-foundation/umi");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_web3js_adapters_1 = require("@metaplex-foundation/umi-web3js-adapters");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
/**
 * Deploy a new SPL token
 * @param agent SolanaAgentKit instance
 * @param name Name of the token
 * @param uri URI for the token metadata
 * @param symbol Symbol of the token
 * @param decimals Number of decimals for the token (default: 9)
 * @param authority Authority for the token mint (optional). It contains mintAuthority, freezeAuthority, updateAuthority and isMutale. Default is the agent wallet address for every authority and true for isMutable.
 * @param initialSupply Initial supply to mint (optional)
 * @returns Object containing token mint address and initial account (if supply was minted)
 */
async function deploy_token(agent, name, uri, symbol, decimals = 9, authority, initialSupply) {
    try {
        // Create UMI instance from agent
        const umi = (0, umi_bundle_defaults_1.createUmi)(agent.connection.rpcEndpoint).use((0, mpl_toolbox_1.mplToolbox)());
        umi.use((0, umi_1.keypairIdentity)((0, umi_web3js_adapters_1.fromWeb3JsKeypair)(agent.wallet)));
        // Create new token mint
        const mint = (0, umi_1.generateSigner)(umi);
        let builder = (0, mpl_token_metadata_1.createFungible)(umi, {
            name,
            uri,
            symbol,
            sellerFeeBasisPoints: {
                basisPoints: 0n,
                identifier: "%",
                decimals: 2,
            },
            decimals,
            mint,
        });
        if (initialSupply) {
            builder = builder.add((0, mpl_token_metadata_1.mintV1)(umi, {
                mint: mint.publicKey,
                tokenStandard: mpl_token_metadata_1.TokenStandard.Fungible,
                tokenOwner: (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(agent.wallet_address),
                amount: initialSupply * Math.pow(10, decimals),
            }));
        }
        // Set default token authority
        const defaultAuthority = {
            mintAuthority: agent.wallet_address,
            freezeAuthority: agent.wallet_address,
            updateAuthority: agent.wallet_address,
            isMutable: true,
        };
        if (authority.mintAuthority === null) {
            defaultAuthority.mintAuthority = null;
        }
        else if (authority.mintAuthority !== undefined) {
            defaultAuthority.mintAuthority = new web3_js_1.PublicKey(authority.mintAuthority);
        }
        if (authority.freezeAuthority === null) {
            defaultAuthority.freezeAuthority = null;
        }
        else if (authority.freezeAuthority !== undefined) {
            defaultAuthority.freezeAuthority = new web3_js_1.PublicKey(authority.freezeAuthority);
        }
        if (authority.updateAuthority !== undefined) {
            defaultAuthority.updateAuthority = new web3_js_1.PublicKey(authority.updateAuthority);
        }
        if (authority.isMutable !== undefined) {
            defaultAuthority.isMutable = authority.isMutable;
        }
        if (defaultAuthority.mintAuthority !== agent.wallet_address) {
            builder = builder.add((0, mpl_toolbox_1.setAuthority)(umi, {
                owned: mint.publicKey,
                owner: (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(agent.wallet_address),
                authorityType: mpl_toolbox_1.AuthorityType.MintTokens,
                newAuthority: defaultAuthority.mintAuthority
                    ? (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(defaultAuthority.mintAuthority)
                    : (0, umi_1.none)(),
            }));
        }
        if (defaultAuthority.freezeAuthority !== agent.wallet.publicKey) {
            builder = builder.add((0, mpl_toolbox_1.setAuthority)(umi, {
                owned: mint.publicKey,
                owner: (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(agent.wallet_address),
                authorityType: mpl_toolbox_1.AuthorityType.FreezeAccount,
                newAuthority: defaultAuthority.freezeAuthority
                    ? (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(defaultAuthority.freezeAuthority)
                    : (0, umi_1.none)(),
            }));
        }
        if (defaultAuthority.updateAuthority !== agent.wallet.publicKey) {
            builder = builder.add((0, mpl_token_metadata_1.updateV1)(umi, {
                isMutable: authority.isMutable === false ? false : true,
                mint: mint.publicKey,
                authority: (0, umi_1.createSignerFromKeypair)(umi, (0, umi_web3js_adapters_1.fromWeb3JsKeypair)(agent.wallet)),
                newUpdateAuthority: defaultAuthority.updateAuthority
                    ? (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(defaultAuthority.updateAuthority)
                    : (0, umi_web3js_adapters_1.fromWeb3JsPublicKey)(agent.wallet_address),
            }));
        }
        else {
            builder = builder.add((0, mpl_token_metadata_1.updateV1)(umi, {
                isMutable: authority.isMutable === false ? false : true,
                mint: mint.publicKey,
                authority: (0, umi_1.createSignerFromKeypair)(umi, (0, umi_web3js_adapters_1.fromWeb3JsKeypair)(agent.wallet)),
            }));
        }
        await builder.sendAndConfirm(umi, { confirm: { commitment: "processed" } });
        return {
            mint: (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(mint.publicKey),
        };
    }
    catch (error) {
        throw new Error(`Token deployment failed: ${error.message}`);
    }
}
//# sourceMappingURL=deploy_token.js.map