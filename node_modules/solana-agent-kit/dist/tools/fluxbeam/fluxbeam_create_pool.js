"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fluxBeamCreatePool = fluxBeamCreatePool;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("../../constants");
const FluxbeamUtils_1 = require("../../utils/FluxbeamUtils");
/**
 * Create a new pool using FluxBeam
 * @param agent SolanaAgentKit instance
 * @param token_a token mint address of the first token
 * @param token_a_amount Amount to swap (in token decimals)
 * @param token_b  Source token mint address (defaults to USDC)
 * @param token_b_amount Source token mint address (defaults to USDC)
 * @param slippageBps Slippage tolerance in basis points (default: 300 = 3%)
 * @returns Transaction signature
 */
async function fluxBeamCreatePool(agent, token_a, token_a_amount, token_b, token_b_amount) {
    try {
        const isTokenA_NativeSol = token_a.equals(constants_1.TOKENS.SOL);
        const tokenA_Decimals = isTokenA_NativeSol
            ? 9
            : await (0, FluxbeamUtils_1.getTokenDecimals)(agent, token_a);
        const scaledAmountTokenA = token_a_amount * Math.pow(10, tokenA_Decimals);
        const isTokenB_NativeSol = token_b.equals(constants_1.TOKENS.SOL);
        const tokenB_Decimals = isTokenB_NativeSol
            ? 9
            : await (0, FluxbeamUtils_1.getTokenDecimals)(agent, token_b);
        const scaledAmountTokenB = token_b_amount * Math.pow(10, tokenB_Decimals);
        const response = await (await fetch(`${constants_1.FLUXBEAM_BASE_URI}/token_pools`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                payer: agent.wallet_address,
                token_a: token_a,
                token_b: token_b,
                token_a_amount: scaledAmountTokenA,
                token_b_amount: scaledAmountTokenB,
            }),
        })).json();
        if (response.error) {
            throw new Error(response.error);
        }
        // Deserialize transaction
        const TransactionBuf = Buffer.from(response.transaction, "base64");
        const transaction = web3_js_1.VersionedTransaction.deserialize(TransactionBuf);
        // Sign and send transaction
        transaction.sign([agent.wallet]);
        const signature = await agent.connection.sendRawTransaction(transaction.serialize(), {
            maxRetries: 3,
            skipPreflight: true,
        });
        return signature;
    }
    catch (error) {
        throw new Error(`Failed to create fluxbeam pool: ${error.message}`);
    }
}
//# sourceMappingURL=fluxbeam_create_pool.js.map