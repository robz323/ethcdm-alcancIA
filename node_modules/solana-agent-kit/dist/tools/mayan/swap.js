"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.swap = swap;
const swap_sdk_1 = require("@mayanfinance/swap-sdk");
const ethers_1 = require("ethers");
const ERC20Permit_json_1 = require("@openzeppelin/contracts/build/contracts/ERC20Permit.json");
const MayanForwarderArtifact_1 = __importDefault(require("./MayanForwarderArtifact"));
async function findTokenContract(symbol, chain) {
    const tokens = await (0, swap_sdk_1.fetchTokenList)(chain, true);
    const token = tokens.find((t) => t.symbol.toLowerCase() === symbol.toLowerCase());
    if (!token) {
        throw new Error(`Couldn't find token with ${symbol} symbol`);
    }
    return token.contract;
}
async function swap(agent, amount, fromChain, fromToken, toChain, toToken, dstAddr, slippageBps = "auto") {
    if (fromToken.length < 32) {
        fromToken = await findTokenContract(fromToken, fromChain);
    }
    if (toToken.length < 32) {
        toToken = await findTokenContract(toToken, toChain);
    }
    const quotes = await (0, swap_sdk_1.fetchQuote)({
        amount: +amount,
        fromChain: fromChain,
        toChain: toChain,
        fromToken,
        toToken,
        slippageBps,
    });
    if (quotes.length === 0) {
        throw new Error("There is no quote available for the tokens you requested.");
    }
    let txHash;
    if (fromChain === "solana") {
        txHash = await swapSolana(quotes[0], agent, dstAddr);
    }
    else {
        txHash = await swapEVM(quotes[0], agent, dstAddr);
    }
    return `https://explorer.mayan.finance/swap/${txHash}`;
}
async function swapSolana(quote, agent, dstAddr) {
    const jitoConfig = await getJitoConfig();
    const jitoTipLamports = await getJitoTipLamports();
    const jitoTip = jitoConfig?.enable
        ? Math.min(jitoTipLamports || jitoConfig?.defaultTipLamports, jitoConfig?.maxTipLamports)
        : 0;
    const jitoOptions = {
        tipLamports: jitoTip,
        jitoAccount: jitoConfig.jitoAccount,
        jitoSendUrl: jitoConfig.sendBundleUrl,
        signAllTransactions: async (trxs) => {
            for (let i = 0; i < trxs.length; i++) {
                if ("version" in trxs[i]) {
                    trxs[i].sign([agent.wallet]);
                }
                else {
                    trxs[i].partialSign(agent.wallet);
                }
            }
            return trxs;
        },
    };
    const signer = async (trx) => {
        if ("version" in trx) {
            trx.sign([agent.wallet]);
        }
        else {
            trx.partialSign(agent.wallet);
        }
        return trx;
    };
    const swapRes = await (0, swap_sdk_1.swapFromSolana)(quote, agent.wallet.publicKey.toString(), dstAddr, null, signer, agent.connection, [], { skipPreflight: true }, jitoOptions);
    if (!swapRes.signature) {
        throw new Error("Error on swap from solana. Try again.");
    }
    try {
        const { blockhash, lastValidBlockHeight } = await agent.connection.getLatestBlockhash();
        const result = await agent.connection.confirmTransaction({
            signature: swapRes.signature,
            blockhash: blockhash,
            lastValidBlockHeight: lastValidBlockHeight,
        }, "confirmed");
        if (result?.value.err) {
            throw new Error(`Transaction ${swapRes.serializedTrx} reverted!`);
        }
        return swapRes.signature;
    }
    catch (error) {
        // Wait for 3 sec and check mayan explorer
        await new Promise((resolve) => setTimeout(resolve, 3000));
        const res = await fetch(`https://explorer-api.mayan.finance/v3/swap/trx/${swapRes.signature}`);
        if (res.status !== 200) {
            throw error;
        }
        return swapRes.signature;
    }
}
let evmWallet;
async function swapEVM(quote, agent, dstAddr) {
    if (!evmWallet) {
        if (agent.config.ETHEREUM_PRIVATE_KEY) {
            evmWallet = new ethers_1.Wallet(agent.config.ETHEREUM_PRIVATE_KEY);
        }
        else {
            throw new Error("You haven't provided EVM wallet private key.");
        }
    }
    const signer = evmWallet.connect((0, ethers_1.getDefaultProvider)(quote.fromToken.chainId));
    const amountIn = getAmountOfFractionalAmount(quote.effectiveAmountIn, quote.fromToken.decimals);
    const tokenContract = new ethers_1.Contract(quote.fromToken.contract, ERC20Permit_json_1.abi, signer);
    const allowance = await tokenContract.allowance(evmWallet.address, swap_sdk_1.addresses.MAYAN_FORWARDER_CONTRACT);
    if (allowance < amountIn) {
        // Approve the spender to spend the tokens
        const approveTx = await tokenContract.approve(swap_sdk_1.addresses.MAYAN_FORWARDER_CONTRACT, amountIn);
        await approveTx.wait();
    }
    let permit;
    if (quote.fromToken.supportsPermit) {
        permit = await getERC20Permit(quote, tokenContract, amountIn, signer);
    }
    const swapRes = await (0, swap_sdk_1.swapFromEvm)(quote, evmWallet.address, dstAddr, null, signer, permit, null, null);
    if (typeof swapRes === "string") {
        return swapRes;
    }
    return swapRes.hash;
}
async function getJitoConfig() {
    const res = await fetch(`https://sia.mayan.finance/v4/init`);
    const data = await res.json();
    return data.solanaJitoConfig;
}
async function getJitoTipLamports() {
    const res = await fetch(`https://price-api.mayan.finance/jito-tips/suggest`);
    const data = await res.json();
    const tip = typeof data?.default === "number" && Number.isFinite(data.default)
        ? data?.default?.toFixed(9)
        : null;
    return tip ? Math.floor(Number(tip) * 10 ** 9) : null;
}
function getAmountOfFractionalAmount(amount, decimals) {
    const cutFactor = Math.min(8, Number(decimals));
    const numStr = Number(amount).toFixed(cutFactor + 1);
    const reg = new RegExp(`^-?\\d+(?:\\.\\d{0,${cutFactor}})?`);
    const matchResult = numStr.match(reg);
    if (!matchResult) {
        throw new Error("getAmountOfFractionalAmount: fixedAmount is null");
    }
    const fixedAmount = matchResult[0];
    return (0, ethers_1.parseUnits)(fixedAmount, Number(decimals));
}
async function getERC20Permit(quote, tokenContract, amountIn, signer) {
    const walletSrcAddr = await signer.getAddress();
    const nonce = await tokenContract.nonces(walletSrcAddr);
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour from now
    const domain = {
        name: await tokenContract.name(),
        version: "1",
        chainId: quote.fromToken.chainId,
        verifyingContract: await tokenContract.getAddress(),
    };
    const domainSeparator = await tokenContract.DOMAIN_SEPARATOR();
    for (let i = 1; i < 11; i++) {
        domain.version = String(i);
        const hash = ethers_1.TypedDataEncoder.hashDomain(domain);
        if (hash.toLowerCase() === domainSeparator.toLowerCase()) {
            break;
        }
    }
    let spender = swap_sdk_1.addresses.MAYAN_FORWARDER_CONTRACT;
    if (quote.type === "SWIFT" && quote.gasless) {
        const forwarderContract = new ethers_1.Contract(swap_sdk_1.addresses.MAYAN_FORWARDER_CONTRACT, MayanForwarderArtifact_1.default.abi, signer.provider);
        const isValidSwiftContract = await forwarderContract.mayanProtocols(quote.swiftMayanContract);
        if (!isValidSwiftContract) {
            throw new Error("Invalid Swift contract for gasless swap");
        }
        if (!quote.swiftMayanContract) {
            throw new Error("Swift contract not found");
        }
        spender = quote.swiftMayanContract;
    }
    const types = {
        Permit: [
            { name: "owner", type: "address" },
            { name: "spender", type: "address" },
            { name: "value", type: "uint256" },
            { name: "nonce", type: "uint256" },
            { name: "deadline", type: "uint256" },
        ],
    };
    const value = {
        owner: walletSrcAddr,
        spender,
        value: amountIn,
        nonce: nonce,
        deadline: deadline,
    };
    const signature = await signer.signTypedData(domain, types, value);
    const { v, r, s } = ethers_1.Signature.from(signature);
    const permitTx = await tokenContract.permit(walletSrcAddr, spender, amountIn, deadline, v, r, s);
    await permitTx.wait();
    return {
        value: amountIn,
        deadline,
        v,
        r,
        s,
    };
}
//# sourceMappingURL=swap.js.map