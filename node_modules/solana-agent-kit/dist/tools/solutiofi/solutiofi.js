"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeAccounts = closeAccounts;
exports.burnTokens = burnTokens;
exports.mergeTokens = mergeTokens;
exports.spreadToken = spreadToken;
const sdk_1 = __importDefault(require("@solutiofi/sdk"));
let solutiofiClient = null;
/**
 * Initialize the SolutioFi client
 * @param agent The SolanaAgentKit instance
 */
async function initClient(agent) {
    if (!agent.config.SOLUTIOFI_API_KEY) {
        throw new Error("SolutioFi API key not found in config");
    }
    if (!solutiofiClient) {
        solutiofiClient = new sdk_1.default({
            apiKey: agent.config.SOLUTIOFI_API_KEY,
        });
        await solutiofiClient.authenticate();
    }
    return solutiofiClient;
}
/**
 * Close token accounts
 * @param agent SolanaAgentKit instance
 * @param mints Array of mint addresses to close
 */
async function closeAccounts(agent, mints) {
    try {
        const client = await initClient(agent);
        const signatures = [];
        const versionedTxns = await client.close(agent.wallet.publicKey.toString(), mints);
        for (const transaction of versionedTxns) {
            try {
                transaction.sign([agent.wallet]);
                const signature = await agent.connection.sendRawTransaction(transaction.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: "processed",
                });
                signatures.push(signature);
            }
            catch (error) {
                continue;
            }
        }
        return signatures;
    }
    catch (e) {
        throw new Error(`Failed to close accounts: ${e}`);
    }
}
/**
 * Burns tokens using SolutioFi
 * @param agent SolanaAgentKit instance
 * @param mints Array of mint addresses for the tokens to burn
 * @returns Array of versioned transactions
 */
async function burnTokens(agent, mints) {
    try {
        const client = await initClient(agent);
        const signatures = [];
        const versionedTxns = await client.burn(agent.wallet.publicKey.toString(), mints);
        for (const transaction of versionedTxns) {
            try {
                transaction.sign([agent.wallet]);
                const signature = await agent.connection.sendRawTransaction(transaction.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: "processed",
                });
                signatures.push(signature);
            }
            catch (error) {
                continue;
            }
        }
        return signatures;
    }
    catch (e) {
        throw new Error(`Failed to burn tokens: ${e}`);
    }
}
/**
 * Merge multiple tokens into one
 * @param agent SolanaAgentKit instance
 * @param inputAssets Array of input assets to merge
 * @param outputMint Output token mint address
 * @param priorityFee Transaction priority level
 */
async function mergeTokens(agent, inputAssets, outputMint, priorityFee) {
    try {
        const client = await initClient(agent);
        const signatures = [];
        const swapData = await client.merge(agent.wallet.publicKey.toString(), inputAssets, outputMint, priorityFee);
        for (const txn of swapData.transactions) {
            try {
                const transaction = txn.transaction;
                transaction.sign([agent.wallet]);
                const signature = await agent.connection.sendRawTransaction(transaction.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: "processed",
                });
                signatures.push(signature);
            }
            catch (error) {
                continue;
            }
        }
        return signatures;
    }
    catch (e) {
        throw new Error(`Failed to merge tokens: ${e}`);
    }
}
/**
 * Split a token into multiple tokens
 * @param agent SolanaAgentKit instance
 * @param inputAsset Input asset to spread
 * @param targetTokens Array of target tokens and their allocations
 * @param priorityFee Transaction priority level
 */
async function spreadToken(agent, inputAsset, targetTokens, priorityFee) {
    try {
        const client = await initClient(agent);
        const signatures = [];
        const swapData = await client.spread(agent.wallet.publicKey.toString(), inputAsset, targetTokens, priorityFee);
        for (const txn of swapData.transactions) {
            try {
                const transaction = txn.transaction;
                transaction.sign([agent.wallet]);
                const signature = await agent.connection.sendRawTransaction(transaction.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: "processed",
                });
                signatures.push(signature);
            }
            catch (error) {
                continue;
            }
        }
        return signatures;
    }
    catch (e) {
        throw new Error(`Failed to spread token: ${e}`);
    }
}
//# sourceMappingURL=solutiofi.js.map