import { Metadata } from '@metaplex-foundation/mpl-token-metadata';
import { PublicKey } from '@solana/web3.js';
import { findMetadataPda } from './pdas';
export const findMetadataFromMint = (mint) => {
    return findMetadataPda(new PublicKey(mint))[0];
};
export const fetchMetadataByMint = async (conn, mint) => {
    const address = findMetadataFromMint(mint);
    return {
        address,
        metadata: await fetchMetadata(conn, address),
    };
};
export var MetadataErrType;
(function (MetadataErrType) {
    MetadataErrType["Malformed"] = "Malformed";
    MetadataErrType["Unknown"] = "Unknown";
})(MetadataErrType || (MetadataErrType = {}));
export const getMetadataErrType = (err) => {
    if ((err.code === 'ERR_ASSERTION' && err.message?.startsWith('Expected')) ||
        (err instanceof RangeError &&
            err.message?.includes('access memory outside buffer'))) {
        return MetadataErrType.Malformed;
    }
    return MetadataErrType.Unknown;
};
/** Handles burned but non-empty metadata accounts */
export const deserializeMeta = (data) => {
    // NFT + metadata has been burned. The account may not be empty yet b/c 0.01 fee has not been collected yet.
    if (data[0] === 0)
        return null;
    return Metadata.deserialize(Buffer.from(data))[0];
};
/** Fetches Metadata account and handles zero'ed out accounts w/ Metaplex fee remaining */
export const fetchMetadata = async (conn, address) => {
    try {
        const acct = await conn.getAccountInfo(address);
        if (!acct) {
            return null;
        }
        return deserializeMeta(acct.data);
    }
    catch (err) {
        const errType = getMetadataErrType(err);
        switch (errType) {
            case MetadataErrType.Malformed:
                console.warn(`metadata acct ${address} malformed, skipping: ${err}`);
                return null;
        }
        throw err;
    }
};
//# sourceMappingURL=token_metadata.js.map