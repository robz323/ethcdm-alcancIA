import { createTransferInstruction, } from '@metaplex-foundation/mpl-token-metadata';
import { ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { SystemProgram, SYSVAR_INSTRUCTIONS_PUBKEY, } from '@solana/web3.js';
import { AUTH_PROGRAM_ID, findEditionPda, findTokenRecordPda } from './pdas';
import { fetchMetadataByMint } from './token_metadata';
export const prepPnftRuleset = async ({ connection, meta, nftMint, }) => {
    if (!meta) {
        const { address, metadata } = await fetchMetadataByMint(connection, nftMint);
        if (!metadata)
            throw new Error(`metadata account not found for mint ${nftMint}`);
        meta = {
            address,
            metadata,
        };
    }
    const ruleSet = meta.metadata.programmableConfig?.ruleSet ?? undefined;
    return {
        meta,
        ruleSet,
    };
};
export const prepPnftAccounts = async ({ connection, meta, nftMint, sourceAta, destAta, authData = null, }) => {
    if (!meta) {
        const { address, metadata } = await fetchMetadataByMint(connection, nftMint);
        if (!metadata)
            throw new Error(`metadata account not found for mint ${nftMint}`);
        meta = {
            address,
            metadata,
        };
    }
    const creators = meta.metadata.data.creators ?? [];
    const ruleSet = meta.metadata.programmableConfig?.ruleSet ?? undefined;
    const [ownerTokenRecordPda, ownerTokenRecordBump] = findTokenRecordPda(nftMint, sourceAta);
    const [destTokenRecordPda, destTokenRecordBump] = findTokenRecordPda(nftMint, destAta);
    //retrieve edition PDA
    const [nftEditionPda] = findEditionPda(nftMint);
    //have to re-serialize due to anchor limitations
    const authDataSerialized = authData
        ? {
            payload: Object.entries(authData.payload.map).map(([k, v]) => {
                return { name: k, payload: v };
            }),
        }
        : null;
    return {
        meta,
        creators,
        ruleSet,
        ownerTokenRecordBump,
        ownerTokenRecordPda,
        destTokenRecordBump,
        destTokenRecordPda,
        nftEditionPda,
        authDataSerialized,
    };
};
export const makePnftTransferIx = async ({ mint, tokenOwner, destinationOwner, authority = null, args = null, connection, fromAddr, toAddr, tokenProgram, }) => {
    const { meta, ruleSet, nftEditionPda, ownerTokenRecordPda, destTokenRecordPda, } = await prepPnftAccounts({
        connection,
        nftMint: mint,
        sourceAta: fromAddr,
        destAta: toAddr,
    });
    const transferAcccounts = {
        authority: authority ?? tokenOwner,
        tokenOwner,
        token: fromAddr,
        mint,
        metadata: meta.address,
        edition: nftEditionPda,
        destinationOwner,
        destination: toAddr,
        payer: tokenOwner,
        splTokenProgram: tokenProgram,
        splAtaProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
        sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,
        authorizationRules: ruleSet,
        authorizationRulesProgram: AUTH_PROGRAM_ID,
        ownerTokenRecord: ownerTokenRecordPda,
        destinationTokenRecord: destTokenRecordPda,
    };
    if (!args) {
        args = {
            __kind: 'V1',
            amount: 1,
            authorizationData: null,
        };
    }
    // not sure needed (keeping around in case changes, to quickly remember command)
    // const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
    //   units: 400_000,
    // });
    const transferArgs = {
        transferArgs: args,
    };
    const transferIx = createTransferInstruction(transferAcccounts, transferArgs);
    return transferIx;
};
//# sourceMappingURL=token_rules.js.map