import { BorshCoder, } from '@coral-xyz/anchor';
import { PublicKey, } from '@solana/web3.js';
import bs58 from 'bs58';
import { sha256 } from 'js-sha256';
import { isNullLike } from '../utils';
// =============== Decode accounts ===============
/** `capName` in the format of "InscriptionV3" */
export const getAcctDiscHexFromName = (capName) => sha256(`account:${capName}`).slice(0, 16);
export const genAcctDiscHexMap = (idl) => {
    const coder = new BorshCoder(idl);
    return Object.fromEntries(idl.accounts?.map((acc) => {
        const name = acc.name;
        const capName = name.at(0).toUpperCase() + name.slice(1);
        return [
            getAcctDiscHexFromName(capName),
            {
                decoder: (buffer) => coder.accounts.decode(name, buffer),
                name,
            },
        ];
    }) ?? []);
};
export const getAcctDiscHex = (data) => data.toString('hex').slice(0, 16);
export const decodeAnchorAcct = (acct, discMap) => {
    const disc = getAcctDiscHex(acct.data);
    const meta = discMap[disc];
    if (!meta)
        return null;
    return {
        name: meta.name,
        account: meta.decoder(acct.data),
    };
};
// =============== END Decode accounts ===============
/** `snakeCaseName` in the format of "sell_nft_token_pool" */
export const getIxDiscHexFromName = (snakeCaseName) => sha256(`global:${snakeCaseName}`).slice(0, 16);
export const genIxDiscHexMap = (idl) => {
    return Object.fromEntries(idl.instructions.map((ix) => {
        const name = ix.name;
        const snakeCaseName = name.replaceAll(/([A-Z])/g, '_$1').toLowerCase();
        return [name, getIxDiscHexFromName(snakeCaseName)];
    }));
};
export const getIxDiscHex = (bs58Data) => Buffer.from(bs58.decode(bs58Data)).toString('hex').slice(0, 16);
// =============== Parse ixs/events ===============
const invokeRegex = /^Program ([A-Za-z0-9]{32,44}) invoke \[\d+\]$/;
const ixNameRegex = /^Program log: Instruction: ([A-Za-z0-9]+)$/;
const eventRegex = /^Program data: /;
const userLogRegex = /^Program log: /;
/// Adapted from https://github.com/saber-hq/saber-common/blob/4b533d77af8ad5c26f033fd5e69bace96b0e1840/packages/anchor-contrib/src/utils/coder.ts#L171-L185
export const parseAnchorEvents = (eventParser, programId, logs) => {
    // Prevents certain log messages from breaking the event parser.
    logs = logs?.filter((l) => !l.match(userLogRegex) || l.match(ixNameRegex));
    // Saves us from parsing if no events are present.
    if (!logs?.some((l) => l.match(eventRegex))) {
        return [];
    }
    const parsedLogsIter = eventParser.parseLogs(logs);
    let parsedEvent = parsedLogsIter.next();
    let latestIxName = null;
    let ixSeq = -1;
    let matchedIxCount = 0;
    // Count the number of expected matched logs
    for (let idx = 0; idx < logs.length; idx++) {
        const invokeMatch = logs[idx].match(invokeRegex);
        if (invokeMatch?.at(1) === programId.toBase58()) {
            matchedIxCount++;
        }
    }
    const events = [];
    for (let idx = 0; idx < logs.length; idx++) {
        const invokeMatch = logs[idx].match(invokeRegex);
        if (invokeMatch?.at(1) === programId.toBase58()) {
            idx++;
            const instrMatch = logs.at(idx)?.match(ixNameRegex);
            if (instrMatch?.at(1)) {
                // Lower case this so it matches what ix decoder gives back.
                latestIxName =
                    instrMatch[1].at(0).toLowerCase() + instrMatch[1].slice(1);
                ixSeq++;
                idx++;
            }
        }
        if (idx >= logs.length)
            continue;
        if (!logs[idx].match(eventRegex))
            continue;
        if (!parsedEvent.done) {
            events.push({
                ixName: latestIxName,
                ixSeq,
                event: parsedEvent.value,
            });
            if (events.length === matchedIxCount) {
                break;
            }
            parsedEvent = parsedLogsIter.next();
        }
    }
    return events;
};
export const parseAnchorIxs = ({ coder, tx, programId, noopIxDiscHex, eventParser, formatIxPreprocess, }) => {
    const message = tx.transaction.message;
    const logs = tx.meta?.logMessages;
    const allEvents = eventParser
        ? parseAnchorEvents(eventParser, programId, logs)
        : [];
    let eventsIdx = 0;
    const ixs = [];
    extractAllIxs({ tx, programId, noopIxDiscHex }).forEach(({ rawIx, ixIdx, subIxIdx, innerIxs, noopIxs }) => {
        // Skip noopIxs.
        if (noopIxDiscHex && getIxDiscHex(rawIx.data) === noopIxDiscHex)
            return;
        // Instruction data.
        const ix = coder.instruction.decode(rawIx.data, 'base58');
        if (!ix)
            return;
        const accountMetas = rawIx.accounts.map((acctIdx) => {
            const pubkey = message.accountKeys[acctIdx];
            return {
                pubkey,
                isSigner: message.isAccountSigner(acctIdx),
                isWritable: message.isAccountWritable(acctIdx),
            };
        });
        // Match events (if any).
        const events = [];
        if (allEvents.at(eventsIdx)?.ixName === ix.name) {
            let ixSeq = allEvents[eventsIdx].ixSeq;
            while (allEvents.at(eventsIdx)?.ixSeq === ixSeq) {
                events.push(allEvents[eventsIdx].event);
                eventsIdx++;
            }
        }
        const formatted = coder.instruction.format(formatIxPreprocess ? formatIxPreprocess(ix) : ix, accountMetas);
        ixs.push({
            ixIdx,
            subIxIdx,
            ix,
            innerIxs,
            noopIxs,
            events,
            formatted,
            accountKeys: message.accountKeys,
        });
    });
    return ixs;
};
export const getAnchorAcctByName = (ix, suffix) => {
    return ix.formatted?.accounts.find((acc) => acc.name?.endsWith(suffix));
};
// =============== END Parse ixs/events ===============
export const extractAllIxs = ({ tx, programId, noopIxDiscHex, }) => {
    const outIxs = [];
    const msg = tx.transaction.message;
    const programIdIndex = programId
        ? msg.accountKeys.findIndex((k) => new PublicKey(k).equals(programId))
        : null;
    const maybeAttachNoopIx = (ix) => {
        if (isNullLike(programIdIndex || programIdIndex !== ix.programIdIndex))
            return;
        if (getIxDiscHex(ix.data) !== noopIxDiscHex)
            return;
        const prev = outIxs.at(-1);
        if (isNullLike(prev))
            return;
        prev.noopIxs ??= [];
        prev.noopIxs.push(ix);
    };
    const addIx = (ix, ixIdx, subIxIdx, innerIxs) => {
        if (!isNullLike(programIdIndex) && programIdIndex !== ix.programIdIndex)
            return;
        maybeAttachNoopIx(ix);
        outIxs.push({
            rawIx: ix,
            ixIdx,
            subIxIdx,
            innerIxs,
        });
    };
    tx.transaction.message.instructions.forEach((ix, ixIdx) => {
        const innerIxs = tx.meta?.innerInstructions?.find((inner) => inner.index === ixIdx)
            ?.instructions ?? [];
        addIx(ix, ixIdx, undefined, innerIxs);
        innerIxs.forEach((innerIx, subIxIdx) => {
            addIx(innerIx, ixIdx, subIxIdx, undefined);
        });
    });
    return outIxs;
};
//# sourceMappingURL=anchor.js.map