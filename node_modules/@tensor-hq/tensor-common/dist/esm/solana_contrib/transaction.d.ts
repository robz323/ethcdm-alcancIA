/// <reference types="node" />
import { AccountInfo, AddressLookupTableAccount, Blockhash, BlockhashWithExpiryBlockHeight, Commitment, CompiledInstruction, ConfirmOptions, Connection, Finality, Message, MessageHeader, PublicKey, RpcResponseAndContext, SignatureStatus, Signer, Transaction, TransactionError, TransactionInstruction, TransactionResponse, TransactionSignature, VersionedTransaction, VersionedTransactionResponse } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { Maybe, Overwrite } from '../utils';
import { TxV0WithHeight, TxWithHeight } from './types';
declare const DEFAULT_CONFIRM_OPTS: ConfirmOptions;
export type ConfirmedTx = {
    txSig: TransactionSignature;
    slot: number;
    err: TransactionError | null;
};
type Logger = {
    info: (msg: string) => void;
    warn: (msg: string) => void;
    error: (msg: string) => void;
    debug: (msg: string) => void;
};
type ConfirmOpts = {
    disableWs?: boolean;
};
export type TransactionMessageJSON = {
    header: MessageHeader;
    accountKeys: string[];
    recentBlockhash: Blockhash;
    instructions: CompiledInstruction[];
};
export type TransactionJSON = Overwrite<TransactionResponse['transaction'], {
    message: TransactionMessageJSON;
}>;
export type TransactionResponseJSON = Overwrite<TransactionResponse, {
    transaction: TransactionJSON;
}>;
export type TransactionResponseLoadedAddresses = {
    v0LoadedAddresses?: {
        numWritableAccounts: number;
        numReadonlyAccounts: number;
    };
};
export type TransactionResponseAugmented = TransactionResponse & TransactionResponseLoadedAddresses;
export type TransactionResponseAugmentedJSON = Overwrite<TransactionResponseAugmented, {
    transaction: TransactionJSON;
}>;
export declare const castTxResponseJSON: <T extends TransactionResponse>(tx: T) => Overwrite<T, {
    transaction: TransactionJSON;
}>;
export declare const castTxResponse: <T extends TransactionResponseJSON>(tx: T) => Overwrite<T, {
    transaction: TransactionResponse['transaction'];
}>;
export declare const castMessageJSON: (msg: Message) => TransactionMessageJSON;
export declare class RetryTxSender {
    private done;
    private resolveReference;
    private cancelReference;
    private start?;
    private txSig?;
    private confirmedTx?;
    readonly connection: Connection;
    readonly additionalConnections: Connection[];
    readonly logger?: Logger;
    readonly opts: ConfirmOptions;
    readonly timeout: number;
    readonly retrySleep: number;
    constructor({ connection, additionalConnections, logger, txSig, opts, timeout, retrySleep, }: {
        connection: Connection;
        additionalConnections?: Connection[];
        /** pass an optional logger object (can be console, can be winston) if you want verbose logs */
        logger?: Logger;
        /** pass an optional txSig if you want to confirm at signature without resending it. */
        txSig?: string;
        opts?: typeof DEFAULT_CONFIRM_OPTS;
        timeout?: number;
        retrySleep?: number;
    });
    send(tx: Transaction | VersionedTransaction): Promise<TransactionSignature>;
    tryConfirm(lastValidBlockHeight?: number, opts?: ConfirmOpts): Promise<ConfirmedTx>;
    cancelConfirm(): void;
    private _confirmTransaction;
    private _getTimestamp;
    private _stopWaiting;
    private _sleep;
    private _outdatedBlockHeightPromise;
    private _racePromises;
    private _sendToAdditionalConnections;
    addAdditionalConnection(newConnection: Connection): void;
}
type MaybeBlockhash = {
    type: 'blockhash';
    blockhash: string;
} | {
    type: 'blockhashArgs';
    args: GetRpcMultipleConnsArgs;
};
type BuildTxArgs = {
    feePayer: PublicKey;
    instructions: TransactionInstruction[];
    additionalSigners?: Array<Signer>;
    maybeBlockhash: MaybeBlockhash;
};
export declare const buildTx: ({ feePayer, instructions, additionalSigners, maybeBlockhash, }: BuildTxArgs) => Promise<TxWithHeight>;
export declare const buildTxV0: ({ feePayer, instructions, additionalSigners, addressLookupTableAccs, maybeBlockhash, }: {
    addressLookupTableAccs: AddressLookupTableAccount[];
} & BuildTxArgs) => Promise<TxV0WithHeight>;
export declare const buildTxsLegacyV0: ({ feePayer, instructions, additionalSigners, addressLookupTableAccs, maybeBlockhash, }: {
    addressLookupTableAccs: AddressLookupTableAccount[];
} & BuildTxArgs) => Promise<{
    tx: Transaction;
    txV0: VersionedTransaction;
    blockhash: any;
    lastValidBlockHeight: any;
}>;
type GetRpcMultipleConnsArgs = {
    connections: Array<Connection>;
    commitment?: Commitment;
    maxRetries?: number;
    startTimeoutMs?: number;
    maxTimeoutMs?: number;
};
export declare const getLatestBlockhashMultConns: ({ connections, commitment, maxRetries, startTimeoutMs, maxTimeoutMs, }: GetRpcMultipleConnsArgs) => Promise<BlockhashWithExpiryBlockHeight>;
/**
 * Races multiple connections to confirm a tx.
 *
 * This will throw TransactionExpiredBlockheightExceededError
 * if we cannot confirm by the tx's lastValidBlockHeight.
 */
export declare const confirmTransactionMultConns: ({ conns, sig, timeoutMs, maxDelayMs, startingDelayMs, numOfAttempts, }: {
    conns: Connection[];
    sig: string;
    timeoutMs?: number | undefined;
    maxDelayMs?: number | undefined;
    startingDelayMs?: number | undefined;
    numOfAttempts?: number | undefined;
}) => Promise<RpcResponseAndContext<SignatureStatus>>;
export declare const getLatestBlockHeight: ({ connections, commitment, maxRetries, startTimeoutMs, maxTimeoutMs, }: GetRpcMultipleConnsArgs) => Promise<number>;
export declare const serializeAnyVersionTx: (tx: Transaction | VersionedTransaction, verifySignatures?: boolean) => number[];
export declare const legacyToV0Tx: (legacy: Buffer | Uint8Array | Array<number>) => VersionedTransaction;
type AccountWithSlot = {
    slot: number;
    account: AccountInfo<Buffer> | null;
    pubkey: PublicKey;
};
/** Use this vs getAccountInfo w/ minContextSlot since minContextSlot just spam retries.
 * See getMultiAccountsWaitSlot if you have a batch of accounts.  */
export declare const getAccountWaitSlot: ({ conn, slot, pubkey, beforeHook, retries, }: {
    conn: Connection;
    slot: number;
    pubkey: PublicKey;
    /** Hook right before RPC call */
    beforeHook?: (() => Promise<void>) | undefined;
    /** Retries for connection request. */
    retries?: number | undefined;
}) => Promise<AccountWithSlot>;
export declare const getMultipleAccountsWaitSlot: ({ conn, slot, pubkeys, beforeHook, retries, }: {
    conn: Connection;
    slot: number;
    pubkeys: PublicKey[];
    /** Hook right before RPC call */
    beforeHook?: (() => Promise<void>) | undefined;
    /** Retries for connection request. */
    retries?: number | undefined;
}) => Promise<AccountWithSlot[]>;
export declare const getAccountKeys: (tx: VersionedTransactionResponse) => PublicKey[];
/** converts the new v0 tx type to legacy so that our downstream parser works as expected */
export declare const convertTxToLegacy: (tx: VersionedTransactionResponse & TransactionResponseLoadedAddresses) => TransactionResponseAugmented;
/** gets new v0 and legacy transactions with the old TransactionResponse format */
export declare const getTransactionConvertedToLegacy: (conn: Connection, sig: string, commitment?: Finality) => Promise<TransactionResponse | null>;
export declare const MAX_COMPUTE_UNITS = 1400000;
/** Adds (1) increase compute + (2) priority fees */
export declare const prependComputeIxs: (ixs: TransactionInstruction[], compute?: Maybe<number>, priorityMicroLamports?: Maybe<number>) => TransactionInstruction[];
export {};
//# sourceMappingURL=transaction.d.ts.map