/// <reference types="node" />
import { BorshCoder, Event, EventParser, Idl, Instruction } from '@coral-xyz/anchor';
import type { InstructionDisplay } from '@coral-xyz/anchor/dist/cjs/coder/borsh/instruction';
import type { AllAccountsMap } from '@coral-xyz/anchor/dist/cjs/program/namespace/types';
import { AccountInfo, CompiledInstruction, PublicKey, TransactionResponse } from '@solana/web3.js';
import { TransactionResponseJSON } from './transaction';
type Decoder = (buffer: Buffer) => any;
export type AcctDiscHexMap<IDL extends Idl> = Record<string, {
    decoder: Decoder;
    name: keyof AllAccountsMap<IDL>;
}>;
export type ExtractedIx = {
    rawIx: CompiledInstruction;
    /** Index of top-level instruction. */
    ixIdx: number;
    /** If this is an inner instruction, the index within its parent top-level instruction. */
    subIxIdx?: number;
    /** Presence of field = it's a top-level ix; absence = inner ix itself. */
    innerIxs?: CompiledInstruction[];
    noopIxs?: CompiledInstruction[];
};
export type AnchorIxName<IDL extends Idl> = IDL['instructions'][number]['name'];
export type AnchorIx<IDL extends Idl> = Omit<Instruction, 'name'> & {
    name: AnchorIxName<IDL>;
};
export type ParsedAnchorEvent<IDL extends Idl> = {
    ixName: string | null;
    /** Increments every time a new invocation of a program ix happens. */
    ixSeq: number;
    event: AnchorEvent<IDL>;
};
export type AnchorEvent<IDL extends Idl, Events = IDL['events']> = Events extends any[] ? Event<Events[number]> : undefined;
export type ParsedAnchorIx<IDL extends Idl> = {
    ix: AnchorIx<IDL>;
    events: AnchorEvent<IDL>[];
    formatted: InstructionDisplay | null;
    accountKeys: PublicKey[];
} & Pick<ExtractedIx, 'ixIdx' | 'subIxIdx' | 'innerIxs' | 'noopIxs'>;
export type ParsedAnchorAccount = InstructionDisplay['accounts'][number];
/** `capName` in the format of "InscriptionV3" */
export declare const getAcctDiscHexFromName: (capName: string) => string;
export declare const genAcctDiscHexMap: <IDL extends Idl>(idl: IDL) => AcctDiscHexMap<IDL>;
export declare const getAcctDiscHex: (data: Buffer) => string;
export declare const decodeAnchorAcct: <IDL extends Idl>(acct: AccountInfo<Buffer>, discMap: AcctDiscHexMap<IDL>) => {
    name: import("@coral-xyz/anchor/dist/cjs/program/namespace/types").AllAccounts<IDL>["name"];
    account: any;
} | null;
/** `snakeCaseName` in the format of "sell_nft_token_pool" */
export declare const getIxDiscHexFromName: (snakeCaseName: string) => string;
export declare const genIxDiscHexMap: <IDL extends Idl>(idl: IDL) => Record<AnchorIxName<IDL>, string>;
export declare const getIxDiscHex: (bs58Data: string) => string;
export declare const parseAnchorEvents: <IDL extends Idl>(eventParser: EventParser, programId: PublicKey, logs: string[] | undefined | null) => ParsedAnchorEvent<IDL>[];
export declare const parseAnchorIxs: <IDL extends Idl>({ coder, tx, programId, noopIxDiscHex, eventParser, formatIxPreprocess, }: {
    coder: BorshCoder;
    tx: TransactionResponse;
    programId: PublicKey;
    /** If passed, will match noopIxs to its parent ix and omits it in the top-level output */
    noopIxDiscHex?: string | undefined;
    /** If provided, will try to parse events. Do not initialize if there are no events defined! */
    eventParser?: EventParser | undefined;
    /** Useful if ix parser can't handle a complex defined arg type: removing the arg before formatter is called helps */
    formatIxPreprocess?: ((ix: Instruction) => Instruction) | undefined;
}) => ParsedAnchorIx<IDL>[];
export declare const getAnchorAcctByName: <AccountSuffix extends string, IDL extends Idl>(ix: ParsedAnchorIx<IDL>, suffix: AccountSuffix) => {
    name?: string | undefined;
    pubkey: PublicKey;
    isSigner: boolean;
    isWritable: boolean;
} | undefined;
export declare const extractAllIxs: ({ tx, programId, noopIxDiscHex, }: {
    tx: TransactionResponse | TransactionResponseJSON;
    /** If passed, will filter for ixs w/ this program ID. */
    programId?: PublicKey | undefined;
    /** If passed WITH programId, will attach self-CPI noop ixs to corresponding programId ixs. NB: noopIxs are included in the final array too. */
    noopIxDiscHex?: string | undefined;
}) => ExtractedIx[];
export {};
//# sourceMappingURL=anchor.d.ts.map