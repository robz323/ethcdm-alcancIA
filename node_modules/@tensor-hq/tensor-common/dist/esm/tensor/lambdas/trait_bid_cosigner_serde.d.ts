/// <reference types="node" />
import BN from 'bn.js';
import { PublicKey, TransactionInstruction } from '@solana/web3.js';
import { Creator, UseMethod } from '@metaplex-foundation/mpl-token-metadata';
import type { MetadataArgs } from '@metaplex-foundation/mpl-bubblegum';
import { Attribute, PnftArgs } from '..';
import { Maybe } from '../..';
declare enum Field {
    Name = "Name"
}
declare enum Target {
    AssetId = "AssetId",
    Whitelist = "Whitelist"
}
type SerializedInstruction = {
    programId: string;
    keys: Array<{
        pubkey: string;
        isSigner: boolean;
        isWritable: boolean;
    }>;
    data: number[];
};
export type CreatorSerialized = {
    address: string;
    verified: boolean;
    share: number;
};
export type CollectionSerialized = {
    key: string;
    verified: boolean;
};
export type UsesSerialized = {
    useMethod: UseMethod;
    remaining: string;
    total: string;
};
export type MetadataArgsSerialized = Omit<MetadataArgs, 'collection' | 'creators' | 'uses'> & {
    collection: CollectionSerialized | null;
    creators: CreatorSerialized[];
    uses: UsesSerialized | null;
};
export type TakeCompressedArgs = {
    targetData: {
        target: 'assetIdOrFvcWithoutField';
        data: {
            metaHash: Buffer;
            creators: Creator[];
            sellerFeeBasisPoints: number;
        };
    } | {
        target: 'rest';
        data: {
            metadata: MetadataArgs;
        };
    };
    bidId: PublicKey;
    merkleTree: PublicKey;
    proof: Buffer[];
    root: number[];
    /** in most cases nonce == index and doesn't need to passed in separately */
    nonce?: BN;
    index: number;
    minAmount: BN;
    currency?: PublicKey | null;
    makerBroker: PublicKey | null;
    optionalRoyaltyPct?: number | null;
    owner: PublicKey;
    seller: PublicKey;
    delegate?: PublicKey;
    margin?: PublicKey | null;
    takerBroker?: PublicKey | null;
    rentDest: PublicKey;
    compute?: number | null;
    priorityMicroLamports?: number | null;
    canopyDepth?: number;
    whitelist?: PublicKey | null;
    delegateSigner?: boolean;
    cosigner?: PublicKey | null;
    feePayer?: PublicKey | null;
    blockhash?: string;
    /** in case fetch times out (eg IPFS no longer hosted), fallback to this */
    extMeta: {
        name?: Maybe<string>;
        attributes?: Maybe<Attribute[]>;
    } | null;
};
export type TakeCompressedArgsSerialized = {
    targetData: {
        target: 'assetIdOrFvcWithoutField';
        data: {
            metaHash: number[];
            creators: CreatorSerialized[];
            sellerFeeBasisPoints: number;
        };
    } | {
        target: 'rest';
        data: {
            metadata: MetadataArgsSerialized;
        };
    };
    bidId: string;
    merkleTree: string;
    proof: number[][];
    root: number[];
    nonce?: string;
    index: number;
    minAmount: string;
    currency?: string | null;
    makerBroker: string | null;
    optionalRoyaltyPct?: number | null;
    owner: string;
    seller: string;
    delegate?: string;
    margin?: string | null;
    takerBroker?: string | null;
    rentDest: string;
    compute?: number | null;
    priorityMicroLamports?: number | null;
    canopyDepth?: number;
    whitelist?: string | null;
    delegateSigner?: boolean;
    cosigner?: string | null;
    feePayer?: string | null;
    blockhash?: string;
    /** in case fetch times out (eg IPFS no longer hosted), fallback to this */
    extMeta: {
        name?: Maybe<string>;
        attributes?: Maybe<Attribute[]>;
    } | null;
};
export declare function serializeTakeCompressedArgs(args: TakeCompressedArgs): TakeCompressedArgsSerialized;
export declare function deserializeTakeCompressedArgs(args: TakeCompressedArgsSerialized): TakeCompressedArgs;
export type TakeNonCompressedArgs = {
    bidId: PublicKey;
    nftMint: PublicKey;
    nftSellerAcc: PublicKey;
    owner: PublicKey;
    seller: PublicKey;
    minAmount: BN;
    currency?: PublicKey | null;
    makerBroker: PublicKey | null;
    optionalRoyaltyPct?: number | null;
    margin?: PublicKey | null;
    takerBroker?: PublicKey | null;
    rentDest: PublicKey;
    whitelist?: PublicKey | null;
    cosigner?: PublicKey | null;
    feePayer?: PublicKey | null;
    blockhash?: string;
    /** in case fetch times out (eg IPFS no longer hosted), fallback to this */
    extMeta: {
        name?: Maybe<string>;
        attributes?: Maybe<Attribute[]>;
    } | null;
} & PnftArgs;
export type PnftArgsSerialized = {
    authData?: any | null;
    /** passing in null or undefined means these ixs are NOT included */
    compute?: number | null;
    /** If a ruleSet is present, we add this many additional */
    ruleSetAddnCompute?: number | null;
    priorityMicroLamports?: number | null;
};
export type TakeNonCompressedArgsSerialized = {
    bidId: string;
    nftMint: string;
    nftSellerAcc: string;
    owner: string;
    seller: string;
    minAmount: string;
    currency?: string | null;
    makerBroker: string | null;
    optionalRoyaltyPct?: number | null;
    margin?: string | null;
    takerBroker?: string | null;
    rentDest: string;
    whitelist?: string | null;
    cosigner?: string | null;
    feePayer?: string | null;
    blockhash?: string;
    extMeta: {
        name?: Maybe<string>;
        attributes?: Maybe<Attribute[]>;
    } | null;
} & PnftArgsSerialized;
export declare function serializeTakeNonCompressedArgs(args: TakeNonCompressedArgs): TakeNonCompressedArgsSerialized;
export declare function deserializeTakeNonCompressedArgs(args: TakeNonCompressedArgsSerialized): TakeNonCompressedArgs;
export type PlaceBidArgs = {
    traits: Attribute[];
    otherIxs: TransactionInstruction[];
    target: Target;
    targetId: PublicKey;
    bidId: PublicKey;
    field?: Field | null;
    fieldId?: PublicKey | null;
    quantity?: number;
    owner: PublicKey;
    amount: BN;
    expireInSec?: BN | null;
    currency?: PublicKey | null;
    makerBroker?: PublicKey | null;
    privateTaker?: PublicKey | null;
    compute?: number | null;
    priorityMicroLamports?: number | null;
    margin?: PublicKey | null;
    cosigner?: PublicKey | null;
    blockhash?: string;
};
export type PlaceBidArgsSerialized = {
    traits: Attribute[];
    otherIxs: SerializedInstruction[];
    target: Target;
    targetId: string;
    bidId: string;
    field?: Field | null;
    fieldId?: string | null;
    quantity?: number;
    owner: string;
    amount: string;
    expireInSec?: string | null;
    currency?: string | null;
    makerBroker?: string | null;
    privateTaker?: string | null;
    compute?: number | null;
    priorityMicroLamports?: number | null;
    margin?: string | null;
    cosigner?: string | null;
    blockhash?: string;
};
export declare function serializePlaceBidArgs(args: PlaceBidArgs): PlaceBidArgsSerialized;
export declare function deserializePlaceBidArgs(serialized: PlaceBidArgsSerialized): PlaceBidArgs;
export declare enum TraitBidRequestType {
    TakeCompressed = "TAKE_COMPRESSED",
    TakeLegacy = "TAKE_LEGACY",
    TakeT22 = "TAKE_T22",
    TakeWns = "TAKE_WNS",
    PlaceBid = "PLACE_BID",
    EditBid = "EDIT_BID"
}
export type TraitBidsRequest = {
    type: TraitBidRequestType.TakeCompressed;
    args: TakeCompressedArgsSerialized;
} | {
    type: TraitBidRequestType.TakeLegacy | TraitBidRequestType.TakeT22 | TraitBidRequestType.TakeWns;
    args: TakeNonCompressedArgsSerialized;
} | {
    type: TraitBidRequestType.PlaceBid | TraitBidRequestType.EditBid;
    args: PlaceBidArgsSerialized;
};
export {};
//# sourceMappingURL=trait_bid_cosigner_serde.d.ts.map