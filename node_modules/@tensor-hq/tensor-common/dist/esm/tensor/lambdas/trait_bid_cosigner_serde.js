import BN from 'bn.js';
import { PublicKey } from '@solana/web3.js';
// TODO: imported from tcomp-ts, since we dont have it in tensor-common
var Field;
(function (Field) {
    Field["Name"] = "Name";
})(Field || (Field = {}));
var Target;
(function (Target) {
    Target["AssetId"] = "AssetId";
    Target["Whitelist"] = "Whitelist";
})(Target || (Target = {}));
function serializeInstruction(instruction) {
    return {
        programId: instruction.programId.toString(),
        keys: instruction.keys.map((keyObj) => ({
            pubkey: keyObj.pubkey.toString(),
            isSigner: keyObj.isSigner,
            isWritable: keyObj.isWritable,
        })),
        data: Array.from(instruction.data),
    };
}
function deserializeInstruction(serialized) {
    return {
        programId: new PublicKey(serialized.programId),
        keys: serialized.keys.map((keyObj) => ({
            pubkey: new PublicKey(keyObj.pubkey),
            isSigner: keyObj.isSigner,
            isWritable: keyObj.isWritable,
        })),
        data: Buffer.from(serialized.data),
    };
}
function serializeMetadataArgs(args) {
    return {
        name: args.name,
        symbol: args.symbol,
        uri: args.uri,
        sellerFeeBasisPoints: args.sellerFeeBasisPoints,
        primarySaleHappened: args.primarySaleHappened,
        isMutable: args.isMutable,
        editionNonce: args.editionNonce,
        tokenStandard: args.tokenStandard,
        tokenProgramVersion: args.tokenProgramVersion,
        collection: args.collection
            ? {
                key: args.collection.key.toString(),
                verified: args.collection.verified,
            }
            : null,
        creators: args.creators.map((creator) => ({
            address: creator.address.toString(),
            verified: creator.verified,
            share: creator.share,
        })),
        uses: args.uses
            ? {
                useMethod: args.uses.useMethod,
                remaining: args.uses.remaining.toString(),
                total: args.uses.total.toString(),
            }
            : null,
    };
}
function deserializeMetadataArgs(serialized) {
    return {
        name: serialized.name,
        symbol: serialized.symbol,
        uri: serialized.uri,
        sellerFeeBasisPoints: serialized.sellerFeeBasisPoints,
        primarySaleHappened: serialized.primarySaleHappened,
        isMutable: serialized.isMutable,
        editionNonce: serialized.editionNonce,
        tokenStandard: serialized.tokenStandard,
        tokenProgramVersion: serialized.tokenProgramVersion,
        collection: serialized.collection
            ? {
                key: new PublicKey(serialized.collection.key),
                verified: serialized.collection.verified,
            }
            : null,
        creators: serialized.creators.map((creator) => ({
            address: new PublicKey(creator.address),
            verified: creator.verified,
            share: creator.share,
        })),
        uses: serialized.uses
            ? {
                useMethod: serialized.uses.useMethod,
                remaining: new BN(serialized.uses.remaining),
                total: new BN(serialized.uses.total),
            }
            : null,
    };
}
export function serializeTakeCompressedArgs(args) {
    return {
        targetData: args.targetData.target === 'assetIdOrFvcWithoutField'
            ? {
                target: args.targetData.target,
                data: {
                    metaHash: [...args.targetData.data.metaHash],
                    creators: args.targetData.data.creators.map((creator) => ({
                        address: creator.address.toString(),
                        verified: creator.verified,
                        share: creator.share,
                    })),
                    sellerFeeBasisPoints: args.targetData.data.sellerFeeBasisPoints,
                },
            }
            : {
                target: args.targetData.target,
                data: {
                    metadata: serializeMetadataArgs(args.targetData.data.metadata),
                },
            },
        bidId: args.bidId.toString(),
        merkleTree: args.merkleTree.toString(),
        proof: args.proof.map((p) => [...p]),
        root: args.root,
        nonce: args.nonce ? args.nonce.toString() : undefined,
        index: args.index,
        minAmount: args.minAmount.toString(),
        currency: args.currency ? args.currency.toString() : null,
        makerBroker: args.makerBroker ? args.makerBroker.toString() : null,
        optionalRoyaltyPct: args.optionalRoyaltyPct,
        owner: args.owner.toString(),
        seller: args.seller.toString(),
        delegate: args.delegate ? args.delegate.toString() : undefined,
        margin: args.margin ? args.margin.toString() : null,
        takerBroker: args.takerBroker ? args.takerBroker.toString() : null,
        rentDest: args.rentDest.toString(),
        compute: args.compute,
        priorityMicroLamports: args.priorityMicroLamports,
        canopyDepth: args.canopyDepth,
        whitelist: args.whitelist ? args.whitelist.toString() : null,
        delegateSigner: args.delegateSigner,
        cosigner: args.cosigner ? args.cosigner.toString() : null,
        feePayer: args.feePayer ? args.feePayer.toString() : null,
        blockhash: args.blockhash,
        extMeta: args.extMeta,
    };
}
export function deserializeTakeCompressedArgs(args) {
    return {
        targetData: args.targetData.target === 'assetIdOrFvcWithoutField'
            ? {
                target: args.targetData.target,
                data: {
                    metaHash: Buffer.from(args.targetData.data.metaHash),
                    creators: args.targetData.data.creators.map((creator) => ({
                        address: new PublicKey(creator.address),
                        verified: creator.verified,
                        share: creator.share,
                    })),
                    sellerFeeBasisPoints: args.targetData.data.sellerFeeBasisPoints,
                },
            }
            : {
                target: args.targetData.target,
                data: {
                    metadata: deserializeMetadataArgs(args.targetData.data.metadata),
                },
            },
        bidId: new PublicKey(args.bidId),
        merkleTree: new PublicKey(args.merkleTree),
        proof: args.proof.map((p) => Buffer.from(p)),
        root: args.root,
        nonce: args.nonce ? new BN(args.nonce) : undefined,
        index: args.index,
        minAmount: new BN(args.minAmount),
        currency: args.currency ? new PublicKey(args.currency) : null,
        makerBroker: args.makerBroker ? new PublicKey(args.makerBroker) : null,
        optionalRoyaltyPct: args.optionalRoyaltyPct,
        owner: new PublicKey(args.owner),
        seller: new PublicKey(args.seller),
        delegate: args.delegate ? new PublicKey(args.delegate) : undefined,
        margin: args.margin ? new PublicKey(args.margin) : null,
        takerBroker: args.takerBroker ? new PublicKey(args.takerBroker) : null,
        rentDest: new PublicKey(args.rentDest),
        compute: args.compute,
        priorityMicroLamports: args.priorityMicroLamports,
        canopyDepth: args.canopyDepth,
        whitelist: args.whitelist ? new PublicKey(args.whitelist) : null,
        delegateSigner: args.delegateSigner,
        cosigner: args.cosigner ? new PublicKey(args.cosigner) : null,
        feePayer: args.feePayer ? new PublicKey(args.feePayer) : null,
        blockhash: args.blockhash,
        extMeta: args.extMeta,
    };
}
export function serializeTakeNonCompressedArgs(args) {
    return {
        bidId: args.bidId.toString(),
        nftMint: args.nftMint.toString(),
        nftSellerAcc: args.nftSellerAcc.toString(),
        owner: args.owner.toString(),
        seller: args.seller.toString(),
        minAmount: args.minAmount.toString(),
        currency: args.currency ? args.currency.toString() : null,
        makerBroker: args.makerBroker ? args.makerBroker.toString() : null,
        optionalRoyaltyPct: args.optionalRoyaltyPct,
        margin: args.margin ? args.margin.toString() : null,
        takerBroker: args.takerBroker ? args.takerBroker.toString() : null,
        rentDest: args.rentDest.toString(),
        whitelist: args.whitelist ? args.whitelist.toString() : null,
        cosigner: args.cosigner ? args.cosigner.toString() : null,
        feePayer: args.feePayer ? args.feePayer.toString() : null,
        authData: args.authData,
        compute: args.compute,
        ruleSetAddnCompute: args.ruleSetAddnCompute,
        priorityMicroLamports: args.priorityMicroLamports,
        blockhash: args.blockhash,
        extMeta: args.extMeta,
    };
}
export function deserializeTakeNonCompressedArgs(args) {
    return {
        bidId: new PublicKey(args.bidId),
        nftMint: new PublicKey(args.nftMint),
        nftSellerAcc: new PublicKey(args.nftSellerAcc),
        owner: new PublicKey(args.owner),
        seller: new PublicKey(args.seller),
        minAmount: new BN(args.minAmount),
        currency: args.currency ? new PublicKey(args.currency) : null,
        makerBroker: args.makerBroker ? new PublicKey(args.makerBroker) : null,
        optionalRoyaltyPct: args.optionalRoyaltyPct,
        margin: args.margin ? new PublicKey(args.margin) : null,
        takerBroker: args.takerBroker ? new PublicKey(args.takerBroker) : null,
        rentDest: new PublicKey(args.rentDest),
        whitelist: args.whitelist ? new PublicKey(args.whitelist) : null,
        cosigner: args.cosigner ? new PublicKey(args.cosigner) : null,
        feePayer: args.feePayer ? new PublicKey(args.feePayer) : null,
        // PnftArgs fields:
        authData: args.authData,
        compute: args.compute,
        ruleSetAddnCompute: args.ruleSetAddnCompute,
        priorityMicroLamports: args.priorityMicroLamports,
        blockhash: args.blockhash,
        extMeta: args.extMeta,
    };
}
export function serializePlaceBidArgs(args) {
    return {
        traits: args.traits,
        otherIxs: args.otherIxs.map(serializeInstruction),
        target: args.target,
        targetId: args.targetId.toString(),
        bidId: args.bidId.toString(),
        field: args.field,
        fieldId: args.fieldId ? args.fieldId.toString() : null,
        quantity: args.quantity,
        owner: args.owner.toString(),
        amount: args.amount.toString(),
        expireInSec: args.expireInSec ? args.expireInSec.toString() : null,
        currency: args.currency ? args.currency.toString() : null,
        makerBroker: args.makerBroker ? args.makerBroker.toString() : null,
        privateTaker: args.privateTaker ? args.privateTaker.toString() : null,
        compute: args.compute,
        priorityMicroLamports: args.priorityMicroLamports,
        margin: args.margin ? args.margin.toString() : null,
        cosigner: args.cosigner ? args.cosigner.toString() : null,
        blockhash: args.blockhash,
    };
}
export function deserializePlaceBidArgs(serialized) {
    return {
        traits: serialized.traits,
        otherIxs: serialized.otherIxs.map(deserializeInstruction),
        target: serialized.target,
        targetId: new PublicKey(serialized.targetId),
        bidId: new PublicKey(serialized.bidId),
        field: serialized.field,
        fieldId: serialized.fieldId ? new PublicKey(serialized.fieldId) : null,
        quantity: serialized.quantity,
        owner: new PublicKey(serialized.owner),
        amount: new BN(serialized.amount),
        expireInSec: serialized.expireInSec ? new BN(serialized.expireInSec) : null,
        currency: serialized.currency ? new PublicKey(serialized.currency) : null,
        makerBroker: serialized.makerBroker
            ? new PublicKey(serialized.makerBroker)
            : null,
        privateTaker: serialized.privateTaker
            ? new PublicKey(serialized.privateTaker)
            : null,
        compute: serialized.compute,
        priorityMicroLamports: serialized.priorityMicroLamports,
        margin: serialized.margin ? new PublicKey(serialized.margin) : null,
        cosigner: serialized.cosigner ? new PublicKey(serialized.cosigner) : null,
        blockhash: serialized.blockhash,
    };
}
export var TraitBidRequestType;
(function (TraitBidRequestType) {
    TraitBidRequestType["TakeCompressed"] = "TAKE_COMPRESSED";
    TraitBidRequestType["TakeLegacy"] = "TAKE_LEGACY";
    TraitBidRequestType["TakeT22"] = "TAKE_T22";
    TraitBidRequestType["TakeWns"] = "TAKE_WNS";
    TraitBidRequestType["PlaceBid"] = "PLACE_BID";
    TraitBidRequestType["EditBid"] = "EDIT_BID";
})(TraitBidRequestType || (TraitBidRequestType = {}));
//# sourceMappingURL=trait_bid_cosigner_serde.js.map