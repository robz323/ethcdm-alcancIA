/*
buy
https://explorer.solana.com/tx/5na6GnUhy1hMX4Q9mRREJkkmwbpQRiApgnpMwnQQ6ku2hP4KCzWyG3qeJiXrodu9xLrkLyF9N4dVt8APur5cGDcd
deposit + buy + transfer + withdraw from fee + transfer + transfer + exec sale
 */
import { AuctionHouse, createBuyInstruction, createDepositInstruction, createExecuteSaleInstruction, PROGRAM_ID, } from '@metaplex-foundation/mpl-auction-house';
import { Metadata } from '@metaplex-foundation/mpl-token-metadata';
import { createAssociatedTokenAccountInstruction, getAccount, getAssociatedTokenAddress, } from '@solana/spl-token';
import { PublicKey, SystemProgram, } from '@solana/web3.js';
import BN from 'bn.js';
import { getQuantityWithMantissa } from './shared';
import { buildTx } from '../../solana_contrib';
import { findAuctionHouseBuyerEscrowPda, findAuctionHouseProgramAsSignerPda, findAuctionHouseTradeStatePda, findMetadataPda, } from '../../metaplex';
export const makeAHBuyTx = async (connections, tokenMint, auctionHouse, buyer, priceLamports, tokenSize = 1, ahProgramId = PROGRAM_ID) => {
    const connection = connections[0];
    const instructions = [];
    const additionalSigners = [];
    const auctionHouseKey = new PublicKey(auctionHouse);
    const mintKey = new PublicKey(tokenMint);
    const buyerKey = new PublicKey(buyer);
    const auctionHouseObj = await AuctionHouse.fromAccountAddress(connection, auctionHouseKey);
    const tokenSizeAdjusted = await getQuantityWithMantissa(connection, tokenSize, mintKey);
    const buyerTokenAccountKey = await getAssociatedTokenAddress(mintKey, buyerKey);
    //this is supposed to be the account holding the NFT
    const largestTokenHolders = await connection.getTokenLargestAccounts(mintKey);
    const sellerTokenAccountKey = largestTokenHolders.value[0].address;
    const sellerTokenAcc = await getAccount(connection, sellerTokenAccountKey);
    const sellerKey = new PublicKey(sellerTokenAcc.owner);
    const [programAsSigner, programAsSignerBump] = findAuctionHouseProgramAsSignerPda(ahProgramId);
    const [sellerTradeState] = findAuctionHouseTradeStatePda(auctionHouseKey, sellerKey, auctionHouseObj.treasuryMint, mintKey, priceLamports, tokenSizeAdjusted, sellerTokenAccountKey);
    const [buyerTradeState, buyerTradeBump] = findAuctionHouseTradeStatePda(auctionHouseKey, buyerKey, auctionHouseObj.treasuryMint, mintKey, priceLamports, tokenSizeAdjusted, sellerTokenAccountKey);
    const [freeTradeState, freeTradeBump] = findAuctionHouseTradeStatePda(auctionHouseKey, sellerKey, auctionHouseObj.treasuryMint, mintKey, new BN(0), tokenSizeAdjusted, sellerTokenAccountKey, ahProgramId);
    const [escrowPaymentAccount, escrowPaymentBump] = findAuctionHouseBuyerEscrowPda(auctionHouseKey, buyerKey, ahProgramId);
    const [metadata] = findMetadataPda(mintKey);
    const depositIx = createDepositInstruction({
        auctionHouse: auctionHouseKey,
        auctionHouseFeeAccount: auctionHouseObj.auctionHouseFeeAccount,
        authority: auctionHouseObj.authority,
        escrowPaymentAccount,
        paymentAccount: buyerKey,
        transferAuthority: auctionHouseObj.authority,
        treasuryMint: auctionHouseObj.treasuryMint,
        wallet: buyerKey,
    }, {
        amount: priceLamports,
        escrowPaymentBump,
    });
    const buyIx = createBuyInstruction({
        auctionHouse: auctionHouseKey,
        auctionHouseFeeAccount: auctionHouseObj.auctionHouseFeeAccount,
        authority: auctionHouseObj.authority,
        buyerTradeState,
        escrowPaymentAccount,
        metadata,
        paymentAccount: buyerKey,
        tokenAccount: sellerTokenAccountKey,
        transferAuthority: SystemProgram.programId,
        treasuryMint: auctionHouseObj.treasuryMint,
        wallet: buyerKey,
    }, {
        buyerPrice: priceLamports,
        escrowPaymentBump,
        tokenSize: tokenSizeAdjusted,
        tradeStateBump: buyerTradeBump,
    });
    const createAtaIx = createAssociatedTokenAccountInstruction(buyerKey, buyerTokenAccountKey, buyerKey, mintKey);
    const execSaleIx = createExecuteSaleInstruction({
        auctionHouse: auctionHouseKey,
        auctionHouseFeeAccount: auctionHouseObj.auctionHouseFeeAccount,
        auctionHouseTreasury: auctionHouseObj.auctionHouseTreasury,
        authority: auctionHouseObj.authority,
        buyer: buyerKey,
        buyerReceiptTokenAccount: buyerTokenAccountKey,
        buyerTradeState,
        escrowPaymentAccount,
        freeTradeState,
        metadata,
        programAsSigner,
        seller: sellerKey,
        sellerPaymentReceiptAccount: sellerKey,
        sellerTradeState,
        tokenAccount: sellerTokenAccountKey,
        tokenMint: mintKey,
        treasuryMint: auctionHouseObj.treasuryMint,
    }, {
        buyerPrice: priceLamports,
        escrowPaymentBump,
        freeTradeStateBump: freeTradeBump,
        programAsSignerBump,
        tokenSize: tokenSizeAdjusted,
    });
    //add creators for royalty payments
    const metadataDecoded = await Metadata.fromAccountAddress(connection, metadata);
    for (let i = 0; i < metadataDecoded.data.creators.length; i++) {
        execSaleIx.keys.push({
            pubkey: new PublicKey(metadataDecoded.data.creators[i].address),
            isWritable: true,
            isSigner: false,
        });
    }
    instructions.push(depositIx, buyIx);
    if (auctionHouseObj.requiresSignOff) {
        execSaleIx.keys[9].isSigner = true;
    }
    //optionally create ata for buyer
    const buyerAtaInfo = await connection.getAccountInfo(buyerTokenAccountKey);
    if (!buyerAtaInfo?.lamports || !buyerAtaInfo.data?.length) {
        instructions.push(createAtaIx);
    }
    instructions.push(execSaleIx);
    return {
        ...(await buildTx({
            maybeBlockhash: {
                type: 'blockhashArgs',
                args: {
                    connections,
                },
            },
            instructions,
            additionalSigners,
            feePayer: buyerKey,
        })),
        auctionHouseObj,
        sellerTradeState,
    };
};
//# sourceMappingURL=buy.js.map