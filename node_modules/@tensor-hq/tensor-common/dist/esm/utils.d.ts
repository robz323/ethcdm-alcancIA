/// <reference types="node" />
import semaphore from 'semaphore';
export declare class TimeoutError extends Error {
}
export type Overwrite<T, NewT> = Omit<T, keyof NewT> & NewT;
export declare const rejectAfterDelay: (ms: number) => Promise<unknown>;
export declare const settleAllWithTimeout: <T>(promises: Promise<T>[], timeoutMs: number) => Promise<T[]>;
export type Maybe<T> = T | null | undefined;
export declare const isNullLike: <T>(v: Maybe<T>) => v is null | undefined;
export declare const filterNullLike: <T>(arr: Maybe<T>[]) => T[];
/**
 * Unflattens an object with keys:
 * {abc: 1, 'foo.abc': 2, 'bar.abc': 2}
 * into:
 * {abc: 1, foo: {abc: 2}, bar: {abc: 2}}
 */
export declare const unflattenFields: (record: Record<string, any>) => Record<string, any>;
export declare const toHexString: (byteArray: number[]) => string;
export declare const hexCode: (decCode: number) => string;
export declare const makeBatches: <T>(items: T[], batchSize: number) => T[][];
export declare function partitionByKey<T>(arr: Array<T>, getKey: (item: T) => string): Record<string, T[]>;
export declare function partitionByKey<T>(arr: Array<T>, getKey: (item: T) => Maybe<string>): Partial<Record<string, T[]>>;
export declare function partitionByKeySingle<T>(arr: Array<T>, getKey: (item: T) => string): Record<string, T>;
export declare function partitionByKeySingle<T>(arr: Array<T>, getKey: (item: T) => Maybe<string>): Partial<Record<string, T>>;
/** Earlier items take precedence IF `getKey` is specified. */
export declare const dedupeList: <T, K>(arr: T[], getKey?: ((item: T) => K) | undefined) => T[];
export declare const parseDate: (date: string | Date) => Date;
export declare const runWithSem: <T>(sem: semaphore.Semaphore, fn: () => Promise<T>) => Promise<T>;
/** Differs from lodash's capitalize since it doesn't lower case everything else. */
export declare const capitalize: (str: string) => string;
export declare const eqSet: <T>(xs: Set<T>, ys: Set<T>) => boolean;
export declare const nameToBuffer: (name: string, bytes?: number) => number[];
export declare const bufferToName: (buf: Buffer) => string;
export declare function getRandomInt(min: number, max: number): number;
export declare const equalWithNull: <T>(a: Maybe<T>, b: Maybe<T>, eqFn?: ((a: T, b: T) => boolean) | undefined) => boolean;
/** Amortized O(n) complexity */
export declare const removeNullBytes: (str: string) => string;
/** Removes keys that have undefined values */
export declare const removeUndefinedKeys: (obj: object) => any;
//# sourceMappingURL=utils.d.ts.map