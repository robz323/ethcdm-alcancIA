import BN from 'bn.js';
import { Big } from 'big.js';
import { isNullLike } from './utils';
export const sum = (arr) => {
    return arr.reduce((a, b) => a + b, 0);
};
// ===== dates =====
export const minDate = (a, b) => (a < b ? a : b);
export const maxDate = (a, b) => (a > b ? a : b);
// ===== bigints =====
export const minBigInt = (a, b) => (a < b ? a : b);
export const maxBigInt = (a, b) => (a > b ? a : b);
export const sqBigInt = (a) => a * a;
export const minBigInts = (arr) => {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = minBigInt(min, v);
    });
    return min;
};
export const maxBigInts = (arr) => {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = maxBigInt(min, v);
    });
    return min;
};
// ===== Bigs =====
export const validBigStr = (s) => {
    try {
        new Big(s);
        return true;
    }
    catch (err) {
        return false;
    }
};
export const sumBig = (arr) => {
    return arr.reduce((a, b) => a.add(b), new Big(0));
};
export const sumBN = (arr) => {
    return arr.reduce((a, b) => a.add(b), new BN(0));
};
export function minBigBN(a, b) {
    return a.lt(b) ? a : b;
}
export function maxBigBN(a, b) {
    return a.gt(b) ? a : b;
}
export function minBigsBNs(arr) {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = minBigBN(min, v);
    });
    return min;
}
export function maxBigsBNs(arr) {
    if (!arr.length)
        return null;
    let max = arr[0];
    arr.slice(1).forEach((v) => {
        max = maxBigBN(max, v);
    });
    return max;
}
export const sortNumberOrBig = (a, b, 
/** If true, means nulls sort before all other non-null values.
 * NB: sorting before other values means it will:
 *  - come first if you're sorting in ASC order
 *  - come last if you're sorting in DESC order
 */
nullsFirst = true) => {
    if (isNullLike(a) && isNullLike(b))
        return 0;
    if (isNullLike(a))
        return nullsFirst ? -1 : 1;
    if (isNullLike(b))
        return nullsFirst ? 1 : -1;
    if (typeof a !== 'number')
        a = a.toNumber();
    if (typeof b !== 'number')
        b = b.toNumber();
    return a - b;
};
export const sortBigInt = (a, b, 
/** If true, means nulls sort before all other non-null values.
 * NB: sorting before other values means it will:
 *  - come first if you're sorting in ASC order
 *  - come last if you're sorting in DESC order
 */
nullsFirst = true) => {
    if (isNullLike(a) && isNullLike(b))
        return 0;
    if (isNullLike(a))
        return nullsFirst ? -1 : 1;
    if (isNullLike(b))
        return nullsFirst ? 1 : -1;
    return Number(a - b);
};
// Round in case there are decimals.
export const bigToBN = (big) => new BN(big.round().toString());
export const BNToBig = (bn) => new Big(bn.toString());
//# sourceMappingURL=math.js.map