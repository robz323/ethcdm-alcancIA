"use strict";
/*
accept bid
https://solscan.io/tx/3uie9LC6j9cVt2TABcwEqKoKLp2ue3RRKAtm4twFvV74D4BhqNeYiZwooAL6sLbSxsu2ptRp8YDfCY93taEpShpB
sell + transfer + withdraw from fee + transfer + transfer + ata create + execute sale
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAHAcceptBidTx = void 0;
const mpl_auction_house_1 = require("@metaplex-foundation/mpl-auction-house");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const metaplex_1 = require("../../metaplex");
const solana_contrib_1 = require("../../solana_contrib");
const shared_1 = require("./shared");
const makeAHAcceptBidTx = async (connections, tokenMint, seller, auctionHouse, buyer, newPriceLamports, //bid to be accepted
tokenSize = 1) => {
    const connection = connections[0];
    const instructions = [];
    const additionalSigners = [];
    const auctionHouseKey = new web3_js_1.PublicKey(auctionHouse);
    const mintKey = new web3_js_1.PublicKey(tokenMint);
    const sellerKey = new web3_js_1.PublicKey(seller);
    const buyerKey = new web3_js_1.PublicKey(buyer);
    const auctionHouseObj = await mpl_auction_house_1.AuctionHouse.fromAccountAddress(connection, auctionHouseKey);
    const tokenSizeAdjusted = new bn_js_1.default(await (0, shared_1.getQuantityWithMantissa)(connection, tokenSize, mintKey));
    const sellerTokenAccountKey = await (0, spl_token_1.getAssociatedTokenAddress)(mintKey, sellerKey);
    const buyerTokenAccountKey = await (0, spl_token_1.getAssociatedTokenAddress)(mintKey, buyerKey);
    const [programAsSigner, programAsSignerBump] = (0, metaplex_1.findAuctionHouseProgramAsSignerPda)();
    const [sellerTradeState, sellerTradeStateBump] = (0, metaplex_1.findAuctionHouseTradeStatePda)(auctionHouseKey, sellerKey, auctionHouseObj.treasuryMint, mintKey, newPriceLamports, tokenSizeAdjusted, sellerTokenAccountKey);
    const [buyerTradeState, buyerTradeStateBump] = (0, metaplex_1.findAuctionHouseTradeStatePda)(auctionHouseKey, buyerKey, auctionHouseObj.treasuryMint, mintKey, newPriceLamports, tokenSizeAdjusted, sellerTokenAccountKey);
    const [freeTradeState, freeTradeStateBump] = (0, metaplex_1.findAuctionHouseTradeStatePda)(auctionHouseKey, sellerKey, auctionHouseObj.treasuryMint, mintKey, new bn_js_1.default(0), tokenSizeAdjusted, sellerTokenAccountKey);
    const [escrowPaymentAccount, escrowPaymentAccountBump] = (0, metaplex_1.findAuctionHouseBuyerEscrowPda)(auctionHouseKey, buyerKey);
    const [metadata] = (0, metaplex_1.findMetadataPda)(mintKey);
    const sellIx = (0, mpl_auction_house_1.createSellInstruction)({
        wallet: sellerKey,
        authority: auctionHouseObj.authority,
        auctionHouse: auctionHouseKey,
        auctionHouseFeeAccount: auctionHouseObj.auctionHouseFeeAccount,
        freeSellerTradeState: freeTradeState,
        metadata,
        programAsSigner,
        sellerTradeState,
        tokenAccount: sellerTokenAccountKey,
    }, {
        buyerPrice: newPriceLamports,
        freeTradeStateBump: freeTradeStateBump,
        programAsSignerBump: programAsSignerBump,
        tokenSize: tokenSizeAdjusted,
        tradeStateBump: sellerTradeStateBump,
    });
    const createAtaIx = (0, spl_token_1.createAssociatedTokenAccountInstruction)(sellerKey, buyerTokenAccountKey, buyerKey, mintKey);
    const execSaleIx = (0, mpl_auction_house_1.createExecuteSaleInstruction)({
        auctionHouse: auctionHouseKey,
        auctionHouseFeeAccount: auctionHouseObj.auctionHouseFeeAccount,
        auctionHouseTreasury: auctionHouseObj.auctionHouseTreasury,
        authority: auctionHouseObj.authority,
        buyer: buyerKey,
        buyerReceiptTokenAccount: buyerTokenAccountKey,
        buyerTradeState,
        escrowPaymentAccount,
        freeTradeState,
        metadata,
        programAsSigner,
        seller: sellerKey,
        sellerPaymentReceiptAccount: sellerKey,
        sellerTradeState,
        tokenAccount: sellerTokenAccountKey,
        tokenMint: mintKey,
        treasuryMint: auctionHouseObj.treasuryMint,
    }, {
        buyerPrice: newPriceLamports,
        escrowPaymentBump: escrowPaymentAccountBump,
        freeTradeStateBump: freeTradeStateBump,
        programAsSignerBump: programAsSignerBump,
        tokenSize: tokenSizeAdjusted,
    });
    //add creators for royalty payments
    const metadataDecoded = await mpl_token_metadata_1.Metadata.fromAccountAddress(connection, metadata);
    for (let i = 0; i < metadataDecoded.data.creators.length; i++) {
        execSaleIx.keys.push({
            pubkey: new web3_js_1.PublicKey(metadataDecoded.data.creators[i].address),
            isWritable: true,
            isSigner: false,
        });
    }
    instructions.push(sellIx);
    //optionally create ata for buyer
    const buyerAtaInfo = await connection.getAccountInfo(buyerTokenAccountKey);
    if (!buyerAtaInfo?.lamports || !buyerAtaInfo.data?.length) {
        instructions.push(createAtaIx);
    }
    instructions.push(execSaleIx);
    return (0, solana_contrib_1.buildTx)({
        maybeBlockhash: {
            type: 'blockhashArgs',
            args: {
                connections,
            },
        },
        instructions,
        additionalSigners,
        feePayer: sellerKey,
    });
};
exports.makeAHAcceptBidTx = makeAHAcceptBidTx;
//# sourceMappingURL=accept_bid.js.map