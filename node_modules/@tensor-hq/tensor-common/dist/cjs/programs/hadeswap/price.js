"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeHswapTakerPrice = exports.calculateNextSpotPrice = void 0;
const big_js_1 = __importDefault(require("big.js"));
const constants_1 = require("./constants");
// NB: copied from https://github.com/hadeswap-solana/hadeswap-sdk-public/blob/66ab430a7a11bd014804d48a7f5d2e7fd906f9ac/src/hadeswap-core/helpers.ts#L86
const calculateNextSpotPrice = ({ orderType, spotPrice, delta, bondingCurveType, counter, }) => {
    if (bondingCurveType === constants_1.HadeswapBondingCurveType.Linear) {
        let current_price = spotPrice; // 1
        const targetCounter = counter + (orderType === constants_1.HadeswapOrderType.Buy ? 1 : -1);
        if (targetCounter >= 0) {
            // 0
            for (let i = 0; i < Math.abs(targetCounter); i++) {
                current_price += delta;
            }
        }
        else {
            for (let i = 0; i < Math.abs(targetCounter); i++) {
                current_price -= delta;
            }
        }
        return current_price;
    }
    else if (bondingCurveType === constants_1.HadeswapBondingCurveType.Exponential) {
        const newCounter = orderType === constants_1.HadeswapOrderType.Buy ? counter + 1 : counter - 1;
        let newDelta = newCounter > 0 ? (delta + 1e4) / 1e4 : 1 / ((delta + 1e4) / 1e4);
        return spotPrice * Math.pow(newDelta, Math.abs(newCounter));
    }
    else if (bondingCurveType === constants_1.HadeswapBondingCurveType.XYK) {
        // const deltaCorrected = delta - counter;
        const nftTokensBalance = delta * spotPrice;
        const counterUpdated = orderType === constants_1.HadeswapOrderType.Buy ? counter : counter - 1;
        const currentDelta = delta + 1 - counterUpdated;
        const diffAmount = (counterUpdated * nftTokensBalance) / currentDelta;
        const newNftTokensBalance = nftTokensBalance + diffAmount;
        return orderType === constants_1.HadeswapOrderType.Buy
            ? newNftTokensBalance / (currentDelta - 1)
            : newNftTokensBalance / (currentDelta + 1);
    }
    return 0;
};
exports.calculateNextSpotPrice = calculateNextSpotPrice;
const computeHswapTakerPrice = ({ takerSide, config, extraNFTsSelected, }) => {
    const price = (0, exports.calculateNextSpotPrice)({
        orderType: takerSide === 'Buy' ? constants_1.HadeswapOrderType.Buy : constants_1.HadeswapOrderType.Sell,
        spotPrice: config.baseSpotPrice,
        delta: config.delta,
        bondingCurveType: config.curveType === 'linear'
            ? constants_1.HadeswapBondingCurveType.Linear
            : config.curveType === 'exponential'
                ? constants_1.HadeswapBondingCurveType.Exponential
                : constants_1.HadeswapBondingCurveType.XYK,
        counter: config.mathCounter +
            // Gotta add 1 to counter for sells lol.
            (takerSide === 'Buy' ? 0 : 1) +
            (takerSide === 'Buy' ? 1 : -1) * extraNFTsSelected,
    });
    // This can happen with XYK pools (when we go past the allowable amount).
    if (isNaN(price) || !isFinite(price))
        return null;
    return new big_js_1.default(price)
        .mul(1 + ((takerSide === 'Buy' ? 1 : -1) * config.feeBps) / 10000)
        .round();
};
exports.computeHswapTakerPrice = computeHswapTakerPrice;
//# sourceMappingURL=price.js.map