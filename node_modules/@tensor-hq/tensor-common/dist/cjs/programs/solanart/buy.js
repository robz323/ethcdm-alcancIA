"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSolanartBuyTx = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const metaplex_1 = require("../../metaplex");
const solana_contrib_1 = require("../../solana_contrib");
const shared_1 = require("./shared");
const makeSolanartBuyTx = async ({ connections, buyer, seller, tokenMint, priceLamports, blockhash, }) => {
    const connection = connections[0];
    const instructions = [];
    const buyerAcc = new web3_js_1.PublicKey(buyer);
    const sellerAcc = new web3_js_1.PublicKey(seller);
    const mintAcc = new web3_js_1.PublicKey(tokenMint);
    const { tokenAccount: targetTokenAccount, instructions: tokenInstr } = await (0, solana_contrib_1.getOrCreateAtaForMint)({
        connection,
        owner: buyerAcc,
        mint: mintAcc,
    });
    const currTempTokenAcc = (await connection.getTokenLargestAccounts(mintAcc)).value.find((r) => r.uiAmount === 1);
    if (!currTempTokenAcc) {
        throw new Error(`cannot find current token account for ${tokenMint}`);
    }
    const { address, metadata } = await (0, metaplex_1.fetchMetadataByMint)(connection, mintAcc);
    if (!metadata)
        throw new Error(`cannot find metadata for ${tokenMint}`);
    const [escrowDataAcc] = (0, shared_1.findDataEscrowPda)(mintAcc);
    const [royaltiesAcc] = (0, shared_1.findRoyaltiesPda)(mintAcc, sellerAcc);
    const [badgerAcc] = (0, shared_1.findBadgerPda)(sellerAcc);
    const data = Buffer.from([0x5, ...priceLamports.toBuffer('le', 8)]);
    const instructionAccounts = [
        /// 0. [signer] The account of the buyer
        {
            pubkey: buyerAcc,
            isSigner: true,
            isWritable: true,
        },
        /// 1.  [] buyer token account to receive the NFT
        {
            pubkey: targetTokenAccount,
            isSigner: false,
            isWritable: true,
        },
        /// 2. [writable] current temporary token account of the NFT
        {
            pubkey: currTempTokenAcc.address,
            isSigner: false,
            isWritable: true,
        },
        /// 3. [writable] seller address
        {
            pubkey: sellerAcc,
            isSigner: false,
            isWritable: true,
        },
        /// 4. [writable] Escrow data account for the sale
        {
            pubkey: escrowDataAcc,
            isSigner: false,
            isWritable: true,
        },
        /// 5. [writable] Royalties data account for the sale
        {
            pubkey: royaltiesAcc,
            isSigner: false,
            isWritable: true,
        },
        /// 6. [] token program
        {
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isSigner: false,
            isWritable: false,
        },
        /// 7. [] solanart fee address
        {
            pubkey: shared_1.SOLANART_FEE_ACCT,
            isSigner: false,
            isWritable: true,
        },
        /// 8. [] PDA, owner of temp token account
        {
            pubkey: shared_1.SOLANART_ESCROW_OWNER_ACCT,
            isSigner: false,
            isWritable: false,
        },
        /// 9. [] metadata account
        {
            pubkey: address,
            isSigner: false,
            isWritable: true,
        },
        /// 10. [writable] mint pubkey
        {
            pubkey: mintAcc,
            isSigner: false,
            isWritable: true,
        },
        /// 11. [] Badgers Stake Account
        { pubkey: badgerAcc, isSigner: false, isWritable: true },
        /// 12. [] Badgers Stake program ID
        {
            pubkey: shared_1.BADGER_PROGRAM_ID,
            isSigner: false,
            isWritable: false,
        },
        /// 13. [] system Program
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        /// INSERT CREATORS ADDRESSES HERE
        /// 14. OPTIONAL [] NFT edition
        /// 15. OPTIONAL [] associated token program
        /// 16. OPTIONAL [] metadata program id
        /// 17. OPTIONAL [] sysvar instruction
        /// 18. OPTIONAL [] owner token record
        /// 19. OPTIONAL [] dest token record
        /// 20. OPTIONAL [] AUTH prog id
        /// 21. OPTIONAL [] ruleset
    ];
    ///
    ///  + `[writable]` Creator wallets (up to 5) - all creators
    ///
    metadata.data.creators?.forEach((creator) => {
        instructionAccounts.push({
            pubkey: creator.address,
            isSigner: false,
            isWritable: true,
        });
    });
    if (metadata.tokenStandard === mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible) {
        const { ruleSet, nftEditionPda, ownerTokenRecordPda, destTokenRecordPda } = await (0, metaplex_1.prepPnftAccounts)({
            connection,
            nftMint: new web3_js_1.PublicKey(tokenMint),
            sourceAta: currTempTokenAcc.address,
            destAta: targetTokenAccount,
        });
        instructionAccounts.push(...[
            {
                pubkey: nftEditionPda,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: metaplex_1.TMETA_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: ownerTokenRecordPda,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: destTokenRecordPda,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: metaplex_1.AUTH_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
        ]);
        if (ruleSet) {
            instructionAccounts.push({
                pubkey: ruleSet,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    const transactionInstruction = new web3_js_1.TransactionInstruction({
        programId: shared_1.SOLANART_PROGRAM_ID,
        keys: instructionAccounts,
        data,
    });
    if (tokenInstr.length) {
        instructions.push(...tokenInstr);
    }
    instructions.push(transactionInstruction);
    return (0, solana_contrib_1.buildTx)({
        maybeBlockhash: blockhash
            ? {
                type: 'blockhash',
                blockhash,
            }
            : {
                type: 'blockhashArgs',
                args: {
                    connections,
                },
            },
        instructions,
        feePayer: buyerAcc,
    });
};
exports.makeSolanartBuyTx = makeSolanartBuyTx;
//# sourceMappingURL=buy.js.map