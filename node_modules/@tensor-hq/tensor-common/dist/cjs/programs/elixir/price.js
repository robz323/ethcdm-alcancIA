"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeElixirSaleCapRaydium = exports.computeElixirTakerPriceRaydium = exports.computeElixirTakerPrice = void 0;
const big_js_1 = __importDefault(require("big.js"));
const constants_1 = require("./constants");
const utils_1 = require("../../utils");
const ELIXIR_FEE_BPS = 250;
const RAYDIUM_FEE_BPS = 25;
//25bps margin of safety
const TOTAL_FEE = ELIXIR_FEE_BPS + RAYDIUM_FEE_BPS + 25;
const computeElixirTakerPrice = ({ takerSide, config, extraNFTsSelected, }) => {
    if (takerSide === 'Buy') {
        if ((0, utils_1.isNullLike)(config.buyPrices))
            return null;
        return config.buyPrices.at(extraNFTsSelected) ?? null;
    }
    else {
        if ((0, utils_1.isNullLike)(config.sellPrices))
            return null;
        return config.sellPrices.at(extraNFTsSelected) ?? null;
    }
};
exports.computeElixirTakerPrice = computeElixirTakerPrice;
const computeElixirTakerPriceRaydium = ({ takerSide, config: { baseLiquidity, quoteLiquidity }, extraNFTsSelected, }) => {
    //we always add 1 nft, so that if extraselected = 0, we get price for 1
    const buyNfts = takerSide === 'Buy' ? extraNFTsSelected + 1 : 0;
    const sellNfts = takerSide === 'Sell' ? extraNFTsSelected + 1 : 0;
    const k = baseLiquidity.mul(quoteLiquidity);
    const newPoolBaseTokens = baseLiquidity.add(new big_js_1.default(sellNfts - buyNfts).mul(constants_1.BASE_TOKENS_PER_NFT));
    if (newPoolBaseTokens.lte(0)) {
        // this should never happen given we have nftSaleCap, but to avoid FE breaking returning 0 rather than error
        return null;
    }
    const newPoolQuoteTokens = k.div(newPoolBaseTokens);
    const priceWithoutFee = newPoolQuoteTokens
        .sub(quoteLiquidity)
        .abs()
        .div(extraNFTsSelected + 1);
    return takerSide === 'Buy'
        ? priceWithoutFee.div(1 - TOTAL_FEE / 10000)
        : priceWithoutFee.mul(1 - TOTAL_FEE / 10000);
};
exports.computeElixirTakerPriceRaydium = computeElixirTakerPriceRaydium;
/// Max # of nfts you can buy from the elixir pool.
const computeElixirSaleCapRaydium = ({ baseLiquidity, }) => {
    // Subtract 1 to ensure we don't go to 0 (impossible)
    return baseLiquidity
        .minus(1)
        .div(constants_1.BASE_TOKENS_PER_NFT)
        .round(0, big_js_1.default.roundDown)
        .toNumber();
};
exports.computeElixirSaleCapRaydium = computeElixirSaleCapRaydium;
//# sourceMappingURL=price.js.map