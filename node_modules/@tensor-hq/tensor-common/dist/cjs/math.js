"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BNToBig = exports.bigToBN = exports.sortBigInt = exports.sortNumberOrBig = exports.maxBigsBNs = exports.minBigsBNs = exports.maxBigBN = exports.minBigBN = exports.sumBN = exports.sumBig = exports.validBigStr = exports.maxBigInts = exports.minBigInts = exports.sqBigInt = exports.maxBigInt = exports.minBigInt = exports.maxDate = exports.minDate = exports.sum = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const big_js_1 = require("big.js");
const utils_1 = require("./utils");
const sum = (arr) => {
    return arr.reduce((a, b) => a + b, 0);
};
exports.sum = sum;
// ===== dates =====
const minDate = (a, b) => (a < b ? a : b);
exports.minDate = minDate;
const maxDate = (a, b) => (a > b ? a : b);
exports.maxDate = maxDate;
// ===== bigints =====
const minBigInt = (a, b) => (a < b ? a : b);
exports.minBigInt = minBigInt;
const maxBigInt = (a, b) => (a > b ? a : b);
exports.maxBigInt = maxBigInt;
const sqBigInt = (a) => a * a;
exports.sqBigInt = sqBigInt;
const minBigInts = (arr) => {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = (0, exports.minBigInt)(min, v);
    });
    return min;
};
exports.minBigInts = minBigInts;
const maxBigInts = (arr) => {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = (0, exports.maxBigInt)(min, v);
    });
    return min;
};
exports.maxBigInts = maxBigInts;
// ===== Bigs =====
const validBigStr = (s) => {
    try {
        new big_js_1.Big(s);
        return true;
    }
    catch (err) {
        return false;
    }
};
exports.validBigStr = validBigStr;
const sumBig = (arr) => {
    return arr.reduce((a, b) => a.add(b), new big_js_1.Big(0));
};
exports.sumBig = sumBig;
const sumBN = (arr) => {
    return arr.reduce((a, b) => a.add(b), new bn_js_1.default(0));
};
exports.sumBN = sumBN;
function minBigBN(a, b) {
    return a.lt(b) ? a : b;
}
exports.minBigBN = minBigBN;
function maxBigBN(a, b) {
    return a.gt(b) ? a : b;
}
exports.maxBigBN = maxBigBN;
function minBigsBNs(arr) {
    if (!arr.length)
        return null;
    let min = arr[0];
    arr.slice(1).forEach((v) => {
        min = minBigBN(min, v);
    });
    return min;
}
exports.minBigsBNs = minBigsBNs;
function maxBigsBNs(arr) {
    if (!arr.length)
        return null;
    let max = arr[0];
    arr.slice(1).forEach((v) => {
        max = maxBigBN(max, v);
    });
    return max;
}
exports.maxBigsBNs = maxBigsBNs;
const sortNumberOrBig = (a, b, 
/** If true, means nulls sort before all other non-null values.
 * NB: sorting before other values means it will:
 *  - come first if you're sorting in ASC order
 *  - come last if you're sorting in DESC order
 */
nullsFirst = true) => {
    if ((0, utils_1.isNullLike)(a) && (0, utils_1.isNullLike)(b))
        return 0;
    if ((0, utils_1.isNullLike)(a))
        return nullsFirst ? -1 : 1;
    if ((0, utils_1.isNullLike)(b))
        return nullsFirst ? 1 : -1;
    if (typeof a !== 'number')
        a = a.toNumber();
    if (typeof b !== 'number')
        b = b.toNumber();
    return a - b;
};
exports.sortNumberOrBig = sortNumberOrBig;
const sortBigInt = (a, b, 
/** If true, means nulls sort before all other non-null values.
 * NB: sorting before other values means it will:
 *  - come first if you're sorting in ASC order
 *  - come last if you're sorting in DESC order
 */
nullsFirst = true) => {
    if ((0, utils_1.isNullLike)(a) && (0, utils_1.isNullLike)(b))
        return 0;
    if ((0, utils_1.isNullLike)(a))
        return nullsFirst ? -1 : 1;
    if ((0, utils_1.isNullLike)(b))
        return nullsFirst ? 1 : -1;
    return Number(a - b);
};
exports.sortBigInt = sortBigInt;
// Round in case there are decimals.
const bigToBN = (big) => new bn_js_1.default(big.round().toString());
exports.bigToBN = bigToBN;
const BNToBig = (bn) => new big_js_1.Big(bn.toString());
exports.BNToBig = BNToBig;
//# sourceMappingURL=math.js.map