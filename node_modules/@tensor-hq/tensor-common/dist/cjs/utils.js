"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeUndefinedKeys = exports.removeNullBytes = exports.equalWithNull = exports.getRandomInt = exports.bufferToName = exports.nameToBuffer = exports.eqSet = exports.capitalize = exports.runWithSem = exports.parseDate = exports.dedupeList = exports.partitionByKeySingle = exports.partitionByKey = exports.makeBatches = exports.hexCode = exports.toHexString = exports.unflattenFields = exports.filterNullLike = exports.isNullLike = exports.settleAllWithTimeout = exports.rejectAfterDelay = exports.TimeoutError = void 0;
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;
const rejectAfterDelay = (ms) => new Promise((_, reject) => {
    setTimeout(reject, ms, new TimeoutError(`timeout of ${ms}ms exceeded`));
});
exports.rejectAfterDelay = rejectAfterDelay;
const settleAllWithTimeout = async (promises, timeoutMs) => {
    const values = [];
    await Promise.allSettled(promises.map((promise) => Promise.race([promise, (0, exports.rejectAfterDelay)(timeoutMs)]))).then((result) => result.forEach((d) => {
        if (d.status === 'fulfilled') {
            values.push(d.value);
        }
    }));
    return values;
};
exports.settleAllWithTimeout = settleAllWithTimeout;
const isNullLike = (v) => v === null || v === undefined;
exports.isNullLike = isNullLike;
const filterNullLike = (arr) => arr.filter((v) => !(0, exports.isNullLike)(v));
exports.filterNullLike = filterNullLike;
/**
 * Unflattens an object with keys:
 * {abc: 1, 'foo.abc': 2, 'bar.abc': 2}
 * into:
 * {abc: 1, foo: {abc: 2}, bar: {abc: 2}}
 */
const unflattenFields = (record) => {
    const ret = {};
    Object.entries(record).forEach(([k, v]) => {
        const toks = k.split('.');
        let ref = ret;
        toks.forEach((tok, idx) => {
            // At leaf token: assign value.
            if (idx === toks.length - 1) {
                ref[tok] = v;
                return;
            }
            // Non-leaf token: create nested object.
            ref[tok] ??= {};
            ref = ref[tok];
        });
    });
    return ret;
};
exports.unflattenFields = unflattenFields;
//https://stackoverflow.com/questions/34309988/byte-array-to-hex-string-conversion-in-javascript
const toHexString = (byteArray) => {
    return Array.from(byteArray, function (byte) {
        return ('0' + (byte & 0xff).toString(16)).slice(-2);
    }).join('');
};
exports.toHexString = toHexString;
const hexCode = (decCode) => '0x' + decCode.toString(16);
exports.hexCode = hexCode;
const makeBatches = (items, batchSize) => {
    const out = [];
    for (let idx = 0; idx < items.length; idx += batchSize) {
        out.push(items.slice(idx, idx + batchSize));
    }
    return out;
};
exports.makeBatches = makeBatches;
function partitionByKey(arr, getKey) {
    const out = {};
    arr.forEach((item) => {
        const k = getKey(item);
        if ((0, exports.isNullLike)(k))
            return;
        out[k] ??= [];
        out[k].push(item);
    });
    return out;
}
exports.partitionByKey = partitionByKey;
function partitionByKeySingle(arr, getKey) {
    const out = {};
    arr.forEach((item) => {
        const k = getKey(item);
        if ((0, exports.isNullLike)(k))
            return;
        // first semantics: earlier items get priority
        out[k] ??= item;
    });
    return out;
}
exports.partitionByKeySingle = partitionByKeySingle;
/** Earlier items take precedence IF `getKey` is specified. */
const dedupeList = (arr, getKey) => {
    if (!getKey) {
        return [...new Set(arr)];
    }
    const seen = new Set();
    const out = [];
    for (const item of arr) {
        const k = getKey(item);
        if (seen.has(k))
            continue;
        seen.add(k);
        out.push(item);
    }
    return out;
};
exports.dedupeList = dedupeList;
const parseDate = (date) => {
    return new Date(date);
};
exports.parseDate = parseDate;
const runWithSem = (sem, fn) => {
    return new Promise((res, rej) => {
        sem.take(async () => {
            try {
                res(await fn());
            }
            catch (err) {
                rej(err);
            }
            finally {
                sem.leave();
            }
        });
    });
};
exports.runWithSem = runWithSem;
/** Differs from lodash's capitalize since it doesn't lower case everything else. */
const capitalize = (str) => {
    if (!str.length)
        return str;
    return str[0].toUpperCase() + str.slice(1);
};
exports.capitalize = capitalize;
const eqSet = (xs, ys) => xs.size === ys.size && [...xs].every((x) => ys.has(x));
exports.eqSet = eqSet;
const nameToBuffer = (name, bytes = 32) => {
    return Buffer.from(name.padEnd(bytes, '\0')).toJSON().data.slice(0, bytes);
};
exports.nameToBuffer = nameToBuffer;
const bufferToName = (buf) => {
    return buf.toString('utf8').trim().replaceAll(/\x00/g, '');
};
exports.bufferToName = bufferToName;
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
exports.getRandomInt = getRandomInt;
const equalWithNull = (a, b, eqFn) => (0, exports.isNullLike)(a)
    ? (0, exports.isNullLike)(b)
        ? true
        : false
    : (0, exports.isNullLike)(b)
        ? false
        : (0, exports.isNullLike)(eqFn)
            ? a === b
            : eqFn(a, b);
exports.equalWithNull = equalWithNull;
/** Amortized O(n) complexity */
const removeNullBytes = (str) => {
    let result = '';
    for (let i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) !== 0) {
            result += str[i]; // concatenations are optimized in modern browsers
        }
    }
    return result;
};
exports.removeNullBytes = removeNullBytes;
/** Removes keys that have undefined values */
const removeUndefinedKeys = (obj) => {
    const newObj = {};
    for (const [k, v] of Object.entries(obj)) {
        if (v !== undefined) {
            newObj[k] = v;
        }
    }
    return newObj;
};
exports.removeUndefinedKeys = removeUndefinedKeys;
//# sourceMappingURL=utils.js.map