"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUserRejectedSigningError = exports.numToU8Bytes = exports.numToU32Bytes = exports.numToU64Bytes = exports.numToi32Bytes = exports.getLamports = exports.TOKEN_ACC_RENT = exports.getRentSync = exports.getRent = exports.validPublicKey = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const validPublicKey = (input) => {
    try {
        new web3_js_1.PublicKey(input);
        return true;
    }
    catch (err) {
        return false;
    }
};
exports.validPublicKey = validPublicKey;
const getRent = (conn, acct) => {
    return conn.getMinimumBalanceForRentExemption(acct.size);
};
exports.getRent = getRent;
// based on https://docs.solana.com/developing/programming-model/accounts#:~:text=The%20current%20maximum%20size%20of,per%20account%20and%20per%20instruction.
const getRentSync = (dataSize) => Math.trunc(19.055441478439427 * (128 + dataSize) * 365.25);
exports.getRentSync = getRentSync;
exports.TOKEN_ACC_RENT = (0, exports.getRentSync)(spl_token_1.ACCOUNT_SIZE);
const getLamports = async (conn, acct) => {
    return (await conn.getAccountInfo(acct))?.lamports;
};
exports.getLamports = getLamports;
const numToi32Bytes = (num) => {
    // Ensure number is a 32-bit signed integer
    if (num > 2147483647 || num < -2147483648) {
        throw new Error('Number out of range for i32');
    }
    const bytes = new Uint8Array(4);
    for (let i = 0; i < 4; i++) {
        // Take the lowest 8 bits of the number and store them in the current byte
        bytes[i] = num & 0xff;
        // Right-shift the number by 8 bits to prepare for the next byte extraction
        num >>= 8;
    }
    return bytes;
};
exports.numToi32Bytes = numToi32Bytes;
const numToU64Bytes = (num) => {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setBigUint64(0, BigInt(num), true); // true for little endian
    return new Uint8Array(buffer);
};
exports.numToU64Bytes = numToU64Bytes;
const numToU32Bytes = (num) => {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, num, true); // true for little endian
    return new Uint8Array(buffer);
};
exports.numToU32Bytes = numToU32Bytes;
const numToU8Bytes = (num) => {
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    view.setUint8(0, num);
    return new Uint8Array(buffer);
};
exports.numToU8Bytes = numToU8Bytes;
const isUserRejectedSigningError = (err) => {
    return (
    // name vs types since some wallets may return generic error.
    err.name === 'WalletSignTransactionError' &&
        ['User rejected the request.', 'Transaction rejected'].includes(err.message));
};
exports.isUserRejectedSigningError = isUserRejectedSigningError;
//# sourceMappingURL=utils.js.map