"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upsertLUT = exports.createLUT = void 0;
const web3_js_1 = require("@solana/web3.js");
const transaction_1 = require("./transaction");
const time_1 = require("../time");
const utils_1 = require("../utils");
const createLUT = async ({ payer, conn, addresses, }) => {
    //use finalized, otherwise get "is not a recent slot err"
    const slot = await conn.getSlot('finalized');
    //create
    const [lookupTableInst, lookupTableAddress] = web3_js_1.AddressLookupTableProgram.createLookupTable({
        authority: payer.publicKey,
        payer: payer.publicKey,
        recentSlot: slot,
    });
    //see if already created
    let lookupTableAccount = (await conn.getAddressLookupTable(lookupTableAddress)).value;
    if (!!lookupTableAccount) {
        console.debug('LUT exists', lookupTableAddress.toBase58());
        return lookupTableAccount;
    }
    console.debug(`LUT missing, creating: ${lookupTableAddress.toBase58()}`);
    //add addresses
    const extendInstruction = web3_js_1.AddressLookupTableProgram.extendLookupTable({
        payer: payer.publicKey,
        authority: payer.publicKey,
        lookupTable: lookupTableAddress,
        addresses,
    });
    const tx = await (0, transaction_1.buildTxV0)({
        maybeBlockhash: {
            type: 'blockhashArgs',
            args: {
                connections: [conn],
            },
        },
        feePayer: payer.publicKey,
        instructions: [lookupTableInst, extendInstruction],
        additionalSigners: [payer],
        addressLookupTableAccs: [],
    });
    const sig = await conn.sendTransaction(tx.tx, { skipPreflight: true });
    await (0, transaction_1.confirmTransactionMultConns)({
        conns: [conn],
        sig,
        timeoutMs: 30 * 1000,
    });
    console.debug('new LUT created', lookupTableAddress.toBase58());
    //fetch
    lookupTableAccount = (await conn.getAddressLookupTable(lookupTableAddress))
        .value;
    return lookupTableAccount;
};
exports.createLUT = createLUT;
const upsertLUT = async ({ payer, conn, lookupTableAddress, addresses, keepRetryingBlockhash = false, }) => {
    let exist = (await conn.getAddressLookupTable(lookupTableAddress)).value;
    if ((0, utils_1.isNullLike)(exist)) {
        console.debug('LUT missing, creating: ', lookupTableAddress.toBase58());
        return (0, exports.createLUT)({ payer: payer, conn, addresses });
    }
    // Filter out only new adresses.
    addresses = addresses.filter((a) => !exist.state.addresses.some((a2) => a2.equals(a)));
    if (!addresses.length) {
        console.debug('no new addresses for', lookupTableAddress.toBase58());
        return exist;
    }
    const extendInstruction = web3_js_1.AddressLookupTableProgram.extendLookupTable({
        payer: payer.publicKey,
        authority: payer.publicKey,
        lookupTable: lookupTableAddress,
        addresses,
    });
    const tx = await (0, transaction_1.buildTxV0)({
        maybeBlockhash: {
            type: 'blockhashArgs',
            args: {
                connections: [conn],
            },
        },
        feePayer: payer.publicKey,
        instructions: [extendInstruction],
        additionalSigners: [payer],
        addressLookupTableAccs: [],
    });
    let done = false;
    while (!done) {
        try {
            const sig = await conn.sendTransaction(tx.tx, { skipPreflight: true });
            await (0, transaction_1.confirmTransactionMultConns)({
                conns: [conn],
                sig,
                timeoutMs: 30 * 1000,
            });
            done = true;
        }
        catch (e) {
            console.log('failed', e);
            if (!keepRetryingBlockhash) {
                throw e;
            }
            await (0, time_1.waitMS)(1000);
        }
    }
    console.debug('updated LUT', lookupTableAddress.toBase58());
    //fetch (this will actually show wrong the first time, need to rerun)
    const table = (await conn.getAddressLookupTable(lookupTableAddress)).value;
    return table;
};
exports.upsertLUT = upsertLUT;
//# sourceMappingURL=lut.js.map