"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAllIxs = exports.getAnchorAcctByName = exports.parseAnchorIxs = exports.parseAnchorEvents = exports.getIxDiscHex = exports.genIxDiscHexMap = exports.getIxDiscHexFromName = exports.decodeAnchorAcct = exports.getAcctDiscHex = exports.genAcctDiscHexMap = exports.getAcctDiscHexFromName = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const js_sha256_1 = require("js-sha256");
const utils_1 = require("../utils");
// =============== Decode accounts ===============
/** `capName` in the format of "InscriptionV3" */
const getAcctDiscHexFromName = (capName) => (0, js_sha256_1.sha256)(`account:${capName}`).slice(0, 16);
exports.getAcctDiscHexFromName = getAcctDiscHexFromName;
const genAcctDiscHexMap = (idl) => {
    const coder = new anchor_1.BorshCoder(idl);
    return Object.fromEntries(idl.accounts?.map((acc) => {
        const name = acc.name;
        const capName = name.at(0).toUpperCase() + name.slice(1);
        return [
            (0, exports.getAcctDiscHexFromName)(capName),
            {
                decoder: (buffer) => coder.accounts.decode(name, buffer),
                name,
            },
        ];
    }) ?? []);
};
exports.genAcctDiscHexMap = genAcctDiscHexMap;
const getAcctDiscHex = (data) => data.toString('hex').slice(0, 16);
exports.getAcctDiscHex = getAcctDiscHex;
const decodeAnchorAcct = (acct, discMap) => {
    const disc = (0, exports.getAcctDiscHex)(acct.data);
    const meta = discMap[disc];
    if (!meta)
        return null;
    return {
        name: meta.name,
        account: meta.decoder(acct.data),
    };
};
exports.decodeAnchorAcct = decodeAnchorAcct;
// =============== END Decode accounts ===============
/** `snakeCaseName` in the format of "sell_nft_token_pool" */
const getIxDiscHexFromName = (snakeCaseName) => (0, js_sha256_1.sha256)(`global:${snakeCaseName}`).slice(0, 16);
exports.getIxDiscHexFromName = getIxDiscHexFromName;
const genIxDiscHexMap = (idl) => {
    return Object.fromEntries(idl.instructions.map((ix) => {
        const name = ix.name;
        const snakeCaseName = name.replaceAll(/([A-Z])/g, '_$1').toLowerCase();
        return [name, (0, exports.getIxDiscHexFromName)(snakeCaseName)];
    }));
};
exports.genIxDiscHexMap = genIxDiscHexMap;
const getIxDiscHex = (bs58Data) => Buffer.from(bs58_1.default.decode(bs58Data)).toString('hex').slice(0, 16);
exports.getIxDiscHex = getIxDiscHex;
// =============== Parse ixs/events ===============
const invokeRegex = /^Program ([A-Za-z0-9]{32,44}) invoke \[\d+\]$/;
const ixNameRegex = /^Program log: Instruction: ([A-Za-z0-9]+)$/;
const eventRegex = /^Program data: /;
const userLogRegex = /^Program log: /;
/// Adapted from https://github.com/saber-hq/saber-common/blob/4b533d77af8ad5c26f033fd5e69bace96b0e1840/packages/anchor-contrib/src/utils/coder.ts#L171-L185
const parseAnchorEvents = (eventParser, programId, logs) => {
    // Prevents certain log messages from breaking the event parser.
    logs = logs?.filter((l) => !l.match(userLogRegex) || l.match(ixNameRegex));
    // Saves us from parsing if no events are present.
    if (!logs?.some((l) => l.match(eventRegex))) {
        return [];
    }
    const parsedLogsIter = eventParser.parseLogs(logs);
    let parsedEvent = parsedLogsIter.next();
    let latestIxName = null;
    let ixSeq = -1;
    let matchedIxCount = 0;
    // Count the number of expected matched logs
    for (let idx = 0; idx < logs.length; idx++) {
        const invokeMatch = logs[idx].match(invokeRegex);
        if (invokeMatch?.at(1) === programId.toBase58()) {
            matchedIxCount++;
        }
    }
    const events = [];
    for (let idx = 0; idx < logs.length; idx++) {
        const invokeMatch = logs[idx].match(invokeRegex);
        if (invokeMatch?.at(1) === programId.toBase58()) {
            idx++;
            const instrMatch = logs.at(idx)?.match(ixNameRegex);
            if (instrMatch?.at(1)) {
                // Lower case this so it matches what ix decoder gives back.
                latestIxName =
                    instrMatch[1].at(0).toLowerCase() + instrMatch[1].slice(1);
                ixSeq++;
                idx++;
            }
        }
        if (idx >= logs.length)
            continue;
        if (!logs[idx].match(eventRegex))
            continue;
        if (!parsedEvent.done) {
            events.push({
                ixName: latestIxName,
                ixSeq,
                event: parsedEvent.value,
            });
            if (events.length === matchedIxCount) {
                break;
            }
            parsedEvent = parsedLogsIter.next();
        }
    }
    return events;
};
exports.parseAnchorEvents = parseAnchorEvents;
const parseAnchorIxs = ({ coder, tx, programId, noopIxDiscHex, eventParser, formatIxPreprocess, }) => {
    const message = tx.transaction.message;
    const logs = tx.meta?.logMessages;
    const allEvents = eventParser
        ? (0, exports.parseAnchorEvents)(eventParser, programId, logs)
        : [];
    let eventsIdx = 0;
    const ixs = [];
    (0, exports.extractAllIxs)({ tx, programId, noopIxDiscHex }).forEach(({ rawIx, ixIdx, subIxIdx, innerIxs, noopIxs }) => {
        // Skip noopIxs.
        if (noopIxDiscHex && (0, exports.getIxDiscHex)(rawIx.data) === noopIxDiscHex)
            return;
        // Instruction data.
        const ix = coder.instruction.decode(rawIx.data, 'base58');
        if (!ix)
            return;
        const accountMetas = rawIx.accounts.map((acctIdx) => {
            const pubkey = message.accountKeys[acctIdx];
            return {
                pubkey,
                isSigner: message.isAccountSigner(acctIdx),
                isWritable: message.isAccountWritable(acctIdx),
            };
        });
        // Match events (if any).
        const events = [];
        if (allEvents.at(eventsIdx)?.ixName === ix.name) {
            let ixSeq = allEvents[eventsIdx].ixSeq;
            while (allEvents.at(eventsIdx)?.ixSeq === ixSeq) {
                events.push(allEvents[eventsIdx].event);
                eventsIdx++;
            }
        }
        const formatted = coder.instruction.format(formatIxPreprocess ? formatIxPreprocess(ix) : ix, accountMetas);
        ixs.push({
            ixIdx,
            subIxIdx,
            ix,
            innerIxs,
            noopIxs,
            events,
            formatted,
            accountKeys: message.accountKeys,
        });
    });
    return ixs;
};
exports.parseAnchorIxs = parseAnchorIxs;
const getAnchorAcctByName = (ix, suffix) => {
    return ix.formatted?.accounts.find((acc) => acc.name?.endsWith(suffix));
};
exports.getAnchorAcctByName = getAnchorAcctByName;
// =============== END Parse ixs/events ===============
const extractAllIxs = ({ tx, programId, noopIxDiscHex, }) => {
    const outIxs = [];
    const msg = tx.transaction.message;
    const programIdIndex = programId
        ? msg.accountKeys.findIndex((k) => new web3_js_1.PublicKey(k).equals(programId))
        : null;
    const maybeAttachNoopIx = (ix) => {
        if ((0, utils_1.isNullLike)(programIdIndex || programIdIndex !== ix.programIdIndex))
            return;
        if ((0, exports.getIxDiscHex)(ix.data) !== noopIxDiscHex)
            return;
        const prev = outIxs.at(-1);
        if ((0, utils_1.isNullLike)(prev))
            return;
        prev.noopIxs ??= [];
        prev.noopIxs.push(ix);
    };
    const addIx = (ix, ixIdx, subIxIdx, innerIxs) => {
        if (!(0, utils_1.isNullLike)(programIdIndex) && programIdIndex !== ix.programIdIndex)
            return;
        maybeAttachNoopIx(ix);
        outIxs.push({
            rawIx: ix,
            ixIdx,
            subIxIdx,
            innerIxs,
        });
    };
    tx.transaction.message.instructions.forEach((ix, ixIdx) => {
        const innerIxs = tx.meta?.innerInstructions?.find((inner) => inner.index === ixIdx)
            ?.instructions ?? [];
        addIx(ix, ixIdx, undefined, innerIxs);
        innerIxs.forEach((innerIx, subIxIdx) => {
            addIx(innerIx, ixIdx, subIxIdx, undefined);
        });
    });
    return outIxs;
};
exports.extractAllIxs = extractAllIxs;
//# sourceMappingURL=anchor.js.map