"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeFailoverConnection = exports.makeFailoverBlacklist = exports.ALCHEMY_BLACKLIST = exports.FAILOVER_ASYNC_METHODS = exports.Cluster = void 0;
const utils_1 = require("../utils");
var Cluster;
(function (Cluster) {
    // Add SVM chains as necessary
    Cluster["Mainnet"] = "mainnet";
    Cluster["Devnet"] = "devnet";
})(Cluster = exports.Cluster || (exports.Cluster = {}));
// Need to whitelist methods o/w we may return an async method for a non-async method.
exports.FAILOVER_ASYNC_METHODS = [
    'getBalanceAndContext',
    'getBalance',
    'getBlockTime',
    'getMinimumLedgerSlot',
    'getFirstAvailableBlock',
    'getSupply',
    'getTokenSupply',
    'getTokenAccountBalance',
    'getTokenAccountsByOwner',
    'getParsedTokenAccountsByOwner',
    'getLargestAccounts',
    'getTokenLargestAccounts',
    'getAccountInfoAndContext',
    'getParsedAccountInfo',
    'getAccountInfo',
    'getMultipleAccountsInfoAndContext',
    'getMultipleAccountsInfo',
    'getStakeActivation',
    'getProgramAccounts',
    'getParsedProgramAccounts',
    'confirmTransaction',
    'confirmTransaction',
    'getClusterNodes',
    'getVoteAccounts',
    'getSlot',
    'getSlotLeader',
    'getSlotLeaders',
    'getSignatureStatus',
    'getSignatureStatuses',
    'getTransactionCount',
    'getTotalSupply',
    'getInflationGovernor',
    'getInflationReward',
    'getEpochInfo',
    'getEpochSchedule',
    'getLeaderSchedule',
    'getMinimumBalanceForRentExemption',
    'getRecentBlockhashAndContext',
    'getRecentPerformanceSamples',
    'getFeeCalculatorForBlockhash',
    'getFeeForMessage',
    'getRecentBlockhash',
    'getLatestBlockhash',
    'getLatestBlockhashAndContext',
    'getVersion',
    'getGenesisHash',
    'getBlock',
    'getBlock',
    'getBlockHeight',
    'getBlockProduction',
    'getTransaction',
    'getTransaction',
    'getParsedTransaction',
    'getParsedTransactions',
    'getTransactions',
    'getTransactions',
    'getConfirmedBlock',
    'getBlocks',
    'getBlockSignatures',
    'getConfirmedBlockSignatures',
    'getConfirmedTransaction',
    'getParsedConfirmedTransaction',
    'getParsedConfirmedTransactions',
    'getConfirmedSignaturesForAddress',
    'getConfirmedSignaturesForAddress2',
    'getSignaturesForAddress',
    'getAddressLookupTable',
    'getNonceAndContext',
    'getNonce',
    'requestAirdrop',
    'getStakeMinimumDelegation',
    'simulateTransaction',
    'simulateTransaction',
    'sendTransaction',
    'sendTransaction',
    'sendRawTransaction',
    'sendEncodedTransaction',
];
// See https://docs.alchemy.com/reference/solana-api-quickstart
exports.ALCHEMY_BLACKLIST = ['getTokenLargestAccounts'];
const makeFailoverBlacklist = (conns) => {
    return Object.fromEntries(conns.reduce((memo, conn) => {
        if (!conn.rpcEndpoint.includes('alchemy'))
            return memo;
        return [...memo, [conn.rpcEndpoint, exports.ALCHEMY_BLACKLIST]];
    }, []));
};
exports.makeFailoverBlacklist = makeFailoverBlacklist;
/// This will failover from connection 0..N-1 if an ECONNREFUSED/503/timeout error is encountered.
const makeFailoverConnection = (conns, options) => {
    if (!conns.length)
        throw new Error('require at least 1 connection for failover');
    const timeoutMS = options?.timeoutMS;
    const methods = options?.failoverAsyncMethods ?? exports.FAILOVER_ASYNC_METHODS;
    const blacklist = options?.rpcBlacklistMethods;
    const handler = {
        get: (target, prop, receiver) => {
            const curMethod = prop.toString();
            if (!methods.includes(curMethod)) {
                return Reflect.get(target, prop, receiver);
            }
            // NB: can't be arrow function.
            return async function () {
                for (const [idx, conn] of conns.entries()) {
                    const badMethods = blacklist?.[conn.rpcEndpoint];
                    if (badMethods && badMethods.includes(curMethod)) {
                        console.warn(`conn ${idx} blacklisted ${curMethod}, skipping`);
                        continue;
                    }
                    try {
                        //@ts-ignore
                        const promise = conn[prop].apply(conn, arguments);
                        const res = await (timeoutMS
                            ? // Promise with timeout rejection.
                                Promise.race([promise, (0, utils_1.rejectAfterDelay)(timeoutMS)])
                            : promise);
                        return res;
                    }
                    catch (err) {
                        console.warn(`conn ${idx} error:`, err);
                        if (err instanceof utils_1.TimeoutError ||
                            err.message?.includes('503 Service Unavailable') ||
                            err.message?.includes('ECONNREFUSED')) {
                            continue;
                        }
                        throw err;
                    }
                }
                throw new Error(`503 Service Unavailable/ECONNREFUSED/timeout across ${conns.length} provider(s)`);
            };
        },
    };
    return new Proxy(conns[0], handler);
};
exports.makeFailoverConnection = makeFailoverConnection;
//# sourceMappingURL=connection.js.map