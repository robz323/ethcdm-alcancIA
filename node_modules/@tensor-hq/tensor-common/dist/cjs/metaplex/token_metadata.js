"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchMetadata = exports.deserializeMeta = exports.getMetadataErrType = exports.MetadataErrType = exports.fetchMetadataByMint = exports.findMetadataFromMint = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const web3_js_1 = require("@solana/web3.js");
const pdas_1 = require("./pdas");
const findMetadataFromMint = (mint) => {
    return (0, pdas_1.findMetadataPda)(new web3_js_1.PublicKey(mint))[0];
};
exports.findMetadataFromMint = findMetadataFromMint;
const fetchMetadataByMint = async (conn, mint) => {
    const address = (0, exports.findMetadataFromMint)(mint);
    return {
        address,
        metadata: await (0, exports.fetchMetadata)(conn, address),
    };
};
exports.fetchMetadataByMint = fetchMetadataByMint;
var MetadataErrType;
(function (MetadataErrType) {
    MetadataErrType["Malformed"] = "Malformed";
    MetadataErrType["Unknown"] = "Unknown";
})(MetadataErrType = exports.MetadataErrType || (exports.MetadataErrType = {}));
const getMetadataErrType = (err) => {
    if ((err.code === 'ERR_ASSERTION' && err.message?.startsWith('Expected')) ||
        (err instanceof RangeError &&
            err.message?.includes('access memory outside buffer'))) {
        return MetadataErrType.Malformed;
    }
    return MetadataErrType.Unknown;
};
exports.getMetadataErrType = getMetadataErrType;
/** Handles burned but non-empty metadata accounts */
const deserializeMeta = (data) => {
    // NFT + metadata has been burned. The account may not be empty yet b/c 0.01 fee has not been collected yet.
    if (data[0] === 0)
        return null;
    return mpl_token_metadata_1.Metadata.deserialize(Buffer.from(data))[0];
};
exports.deserializeMeta = deserializeMeta;
/** Fetches Metadata account and handles zero'ed out accounts w/ Metaplex fee remaining */
const fetchMetadata = async (conn, address) => {
    try {
        const acct = await conn.getAccountInfo(address);
        if (!acct) {
            return null;
        }
        return (0, exports.deserializeMeta)(acct.data);
    }
    catch (err) {
        const errType = (0, exports.getMetadataErrType)(err);
        switch (errType) {
            case MetadataErrType.Malformed:
                console.warn(`metadata acct ${address} malformed, skipping: ${err}`);
                return null;
        }
        throw err;
    }
};
exports.fetchMetadata = fetchMetadata;
//# sourceMappingURL=token_metadata.js.map