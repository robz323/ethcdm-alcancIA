"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePnftTransferIx = exports.prepPnftAccounts = exports.prepPnftRuleset = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const pdas_1 = require("./pdas");
const token_metadata_1 = require("./token_metadata");
const prepPnftRuleset = async ({ connection, meta, nftMint, }) => {
    if (!meta) {
        const { address, metadata } = await (0, token_metadata_1.fetchMetadataByMint)(connection, nftMint);
        if (!metadata)
            throw new Error(`metadata account not found for mint ${nftMint}`);
        meta = {
            address,
            metadata,
        };
    }
    const ruleSet = meta.metadata.programmableConfig?.ruleSet ?? undefined;
    return {
        meta,
        ruleSet,
    };
};
exports.prepPnftRuleset = prepPnftRuleset;
const prepPnftAccounts = async ({ connection, meta, nftMint, sourceAta, destAta, authData = null, }) => {
    if (!meta) {
        const { address, metadata } = await (0, token_metadata_1.fetchMetadataByMint)(connection, nftMint);
        if (!metadata)
            throw new Error(`metadata account not found for mint ${nftMint}`);
        meta = {
            address,
            metadata,
        };
    }
    const creators = meta.metadata.data.creators ?? [];
    const ruleSet = meta.metadata.programmableConfig?.ruleSet ?? undefined;
    const [ownerTokenRecordPda, ownerTokenRecordBump] = (0, pdas_1.findTokenRecordPda)(nftMint, sourceAta);
    const [destTokenRecordPda, destTokenRecordBump] = (0, pdas_1.findTokenRecordPda)(nftMint, destAta);
    //retrieve edition PDA
    const [nftEditionPda] = (0, pdas_1.findEditionPda)(nftMint);
    //have to re-serialize due to anchor limitations
    const authDataSerialized = authData
        ? {
            payload: Object.entries(authData.payload.map).map(([k, v]) => {
                return { name: k, payload: v };
            }),
        }
        : null;
    return {
        meta,
        creators,
        ruleSet,
        ownerTokenRecordBump,
        ownerTokenRecordPda,
        destTokenRecordBump,
        destTokenRecordPda,
        nftEditionPda,
        authDataSerialized,
    };
};
exports.prepPnftAccounts = prepPnftAccounts;
const makePnftTransferIx = async ({ mint, tokenOwner, destinationOwner, authority = null, args = null, connection, fromAddr, toAddr, tokenProgram, }) => {
    const { meta, ruleSet, nftEditionPda, ownerTokenRecordPda, destTokenRecordPda, } = await (0, exports.prepPnftAccounts)({
        connection,
        nftMint: mint,
        sourceAta: fromAddr,
        destAta: toAddr,
    });
    const transferAcccounts = {
        authority: authority ?? tokenOwner,
        tokenOwner,
        token: fromAddr,
        mint,
        metadata: meta.address,
        edition: nftEditionPda,
        destinationOwner,
        destination: toAddr,
        payer: tokenOwner,
        splTokenProgram: tokenProgram,
        splAtaProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
        systemProgram: web3_js_1.SystemProgram.programId,
        sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
        authorizationRules: ruleSet,
        authorizationRulesProgram: pdas_1.AUTH_PROGRAM_ID,
        ownerTokenRecord: ownerTokenRecordPda,
        destinationTokenRecord: destTokenRecordPda,
    };
    if (!args) {
        args = {
            __kind: 'V1',
            amount: 1,
            authorizationData: null,
        };
    }
    // not sure needed (keeping around in case changes, to quickly remember command)
    // const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
    //   units: 400_000,
    // });
    const transferArgs = {
        transferArgs: args,
    };
    const transferIx = (0, mpl_token_metadata_1.createTransferInstruction)(transferAcccounts, transferArgs);
    return transferIx;
};
exports.makePnftTransferIx = makePnftTransferIx;
//# sourceMappingURL=token_rules.js.map