"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeMintTwoAta = exports.createAndFundAta = exports.createNft = exports.createAta = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const metaplex_1 = require("../metaplex");
const utils_1 = require("../utils");
const tx_1 = require("./tx");
const createAta = async ({ conn, payer, mint, owner, }) => {
    const ata = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner.publicKey);
    const createAtaIx = (0, spl_token_1.createAssociatedTokenAccountInstruction)(owner.publicKey, ata, owner.publicKey, mint, spl_token_1.TOKEN_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
    await (0, tx_1.buildAndSendTx)({
        conn,
        payer,
        ixs: [createAtaIx],
        extraSigners: [owner],
    });
    return { mint, owner, ata };
};
exports.createAta = createAta;
const createNft = async ({ conn, payer, owner, mint, tokenStandard, royaltyBps, creators, collection, collectionVerified = true, ruleSet = null, }) => {
    // --------------------------------------- create
    const [metadata] = (0, metaplex_1.findMetadataPda)(mint.publicKey);
    const [masterEdition] = (0, metaplex_1.findMasterEditionPda)(mint.publicKey);
    const accounts = {
        metadata,
        masterEdition,
        mint: mint.publicKey,
        authority: owner.publicKey,
        payer: owner.publicKey,
        splTokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
        updateAuthority: owner.publicKey,
    };
    const args = {
        createArgs: {
            __kind: 'V1',
            assetData: {
                name: 'Whatever',
                symbol: 'TSR',
                uri: 'https://www.tensor.trade',
                sellerFeeBasisPoints: royaltyBps ?? 0,
                creators: creators?.map((c) => {
                    return {
                        address: c.address,
                        share: c.share,
                        verified: false,
                    };
                }) ?? null,
                primarySaleHappened: true,
                isMutable: true,
                tokenStandard,
                collection: collection
                    ? {
                        verified: false,
                        key: collection.publicKey,
                    }
                    : null,
                uses: null,
                collectionDetails: null,
                ruleSet,
            },
            decimals: 0,
            printSupply: { __kind: 'Zero' },
        },
    };
    const createIx = (0, mpl_token_metadata_1.createCreateInstruction)(accounts, args);
    // this test always initializes the mint, we we need to set the
    // account to be writable and a signer
    for (let i = 0; i < createIx.keys.length; i++) {
        if (createIx.keys[i].pubkey.toBase58() === mint.publicKey.toBase58()) {
            createIx.keys[i].isSigner = true;
            createIx.keys[i].isWritable = true;
        }
    }
    // --------------------------------------- mint
    // mint instrution will initialize a ATA account
    const ata = (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, owner.publicKey);
    const [tokenRecord] = (0, metaplex_1.findTokenRecordPda)(mint.publicKey, ata);
    const mintAcccounts = {
        token: ata,
        tokenOwner: owner.publicKey,
        metadata,
        masterEdition,
        tokenRecord,
        mint: mint.publicKey,
        payer: owner.publicKey,
        authority: owner.publicKey,
        sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
        splAtaProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
        splTokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        authorizationRules: ruleSet ?? undefined,
        authorizationRulesProgram: metaplex_1.AUTH_PROGRAM_ID,
    };
    const payload = {
        map: new Map(),
    };
    const mintArgs = {
        mintArgs: {
            __kind: 'V1',
            amount: 1,
            authorizationData: {
                payload,
            },
        },
    };
    const mintIx = (0, mpl_token_metadata_1.createMintInstruction)(mintAcccounts, mintArgs);
    // Have to do separately o/w for regular NFTs it'll complain about
    // collection verified can't be set.
    const verifyCollIxs = collection && collectionVerified
        ? [
            (0, mpl_token_metadata_1.createVerifyInstruction)({
                authority: owner.publicKey,
                metadata,
                collectionMint: collection.publicKey,
                collectionMetadata: (0, metaplex_1.findMetadataPda)(collection.publicKey)[0],
                collectionMasterEdition: (0, metaplex_1.findMasterEditionPda)(collection.publicKey)[0],
                sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            }, {
                verificationArgs: mpl_token_metadata_1.VerificationArgs.CollectionV1,
            }),
        ]
        : [];
    const verifyCreatorIxs = (0, utils_1.filterNullLike)(creators?.map((c) => {
        if (!c.authority)
            return;
        return (0, mpl_token_metadata_1.createVerifyInstruction)({
            metadata,
            authority: c.authority.publicKey,
            sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
        }, {
            verificationArgs: mpl_token_metadata_1.VerificationArgs.CreatorV1,
        });
    }) ?? []);
    // --------------------------------------- send
    await (0, tx_1.buildAndSendTx)({
        conn,
        payer,
        ixs: [createIx, mintIx, ...verifyCollIxs, ...verifyCreatorIxs],
        extraSigners: (0, utils_1.dedupeList)((0, utils_1.filterNullLike)([
            owner,
            mint,
            ...(creators?.map((c) => c.authority) ?? []),
        ]), (k) => k.publicKey.toBase58()),
    });
    return {
        ata,
        metadata,
        masterEdition,
    };
};
exports.createNft = createNft;
const createAndFundAta = async ({ conn, payer, owner, mint, royaltyBps, creators, collection, collectionVerified, createCollection = true, programmable = false, ruleSetAddr, }) => {
    const usedOwner = owner ?? (await (0, tx_1.createFundedWallet)({ conn, payer }));
    const usedMint = mint ?? web3_js_1.Keypair.generate();
    let collectionInfo;
    //create a verified collection
    if (createCollection && collection) {
        collectionInfo = await (0, exports.createNft)({
            conn,
            payer,
            owner: usedOwner,
            mint: collection,
            tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
            royaltyBps,
        });
    }
    const { metadata, ata, masterEdition } = await (0, exports.createNft)({
        conn,
        payer,
        mint: usedMint,
        owner: usedOwner,
        royaltyBps,
        creators,
        collection,
        collectionVerified,
        ruleSet: ruleSetAddr,
        tokenStandard: programmable
            ? mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible
            : mpl_token_metadata_1.TokenStandard.NonFungible,
    });
    return {
        mint: usedMint.publicKey,
        ata,
        owner: usedOwner,
        metadata,
        masterEdition,
        collectionInfo,
    };
};
exports.createAndFundAta = createAndFundAta;
/** Creates a mint + 2 ATAs. The `owner` will have the mint initially. */
const makeMintTwoAta = async ({ conn, payer, owner, other, royaltyBps, creators, collection, collectionVerified, createCollection, programmable, ruleSetAddr, }) => {
    const { mint, ata, metadata, masterEdition, collectionInfo } = await (0, exports.createAndFundAta)({
        conn,
        payer,
        owner,
        royaltyBps,
        creators,
        collection,
        collectionVerified,
        createCollection,
        programmable,
        ruleSetAddr,
    });
    const { ata: otherAta } = await (0, exports.createAta)({
        conn,
        payer,
        mint,
        owner: other,
    });
    return { mint, metadata, ata, otherAta, masterEdition, collectionInfo };
};
exports.makeMintTwoAta = makeMintTwoAta;
//# sourceMappingURL=nft.js.map