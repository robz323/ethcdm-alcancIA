"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeNTraders = exports.createFundedWallet = exports.buildAndSendTx = void 0;
const web3_js_1 = require("@solana/web3.js");
const exponential_backoff_1 = require("exponential-backoff");
const solana_contrib_1 = require("../solana_contrib");
const buildAndSendTx = async ({ conn, payer, ixs, extraSigners, 
/** For tests, skip preflight so we can expect tx errors */
opts, commitment = 'confirmed', debug, lookupTableAccounts, }) => {
    //build v0
    const { tx, blockhash, lastValidBlockHeight } = await (0, exponential_backoff_1.backOff)(() => (0, solana_contrib_1.buildTxV0)({
        maybeBlockhash: {
            type: 'blockhashArgs',
            args: {
                connections: [conn],
            },
        },
        instructions: ixs,
        //have to add TEST_KEYPAIR here instead of wallet.signTx() since partialSign not impl on v0 txs
        additionalSigners: [payer, ...(extraSigners ?? [])],
        feePayer: payer.publicKey,
        addressLookupTableAccs: lookupTableAccounts ?? [],
    }), {
        // Retry blockhash errors (happens during tests sometimes).
        retry: (e) => {
            return e.message.includes('blockhash');
        },
    });
    try {
        // Need to pass commitment here o/w it doesn't work...?
        if (debug)
            opts = { ...opts, commitment: 'confirmed' };
        const sig = await conn.sendTransaction(tx, {
            ...opts,
        });
        await conn.confirmTransaction({ signature: sig, blockhash, lastValidBlockHeight }, commitment);
        if (debug) {
            console.log(await conn.getTransaction(sig, {
                commitment,
                maxSupportedTransactionVersion: 0,
            }));
        }
        return sig;
    }
    catch (e) {
        //this is needed to see program error logs
        console.error('❌ FAILED TO SEND TX, FULL ERROR: ❌');
        console.error(e);
        throw e;
    }
};
exports.buildAndSendTx = buildAndSendTx;
const createFundedWallet = async ({ conn, payer, sol = 1000, }) => {
    const keypair = web3_js_1.Keypair.generate();
    //airdrops are funky, best to move from provider wallet
    const tx = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
        fromPubkey: payer.publicKey,
        toPubkey: keypair.publicKey,
        lamports: sol * web3_js_1.LAMPORTS_PER_SOL,
    }));
    await (0, exports.buildAndSendTx)({ conn, payer, ixs: tx.instructions });
    return keypair;
};
exports.createFundedWallet = createFundedWallet;
const makeNTraders = async ({ conn, payer, n, sol, }) => {
    return await Promise.all(Array(n)
        .fill(null)
        .map(async () => await (0, exports.createFundedWallet)({ conn, payer, sol })));
};
exports.makeNTraders = makeNTraders;
//# sourceMappingURL=tx.js.map