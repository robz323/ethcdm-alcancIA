"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeString = exports.isBase64 = exports.isHex = exports.isKeypairString = exports.isBytes = exports.isBase58 = exports.toUtf8 = exports.buf2String = void 0;
exports.parseMrEnclave = parseMrEnclave;
exports.parseCronSchedule = parseCronSchedule;
exports.parseRawMrEnclave = parseRawMrEnclave;
const bs58_1 = __importDefault(require("bs58"));
const cron_validator_1 = require("cron-validator");
const lodash_1 = __importDefault(require("lodash"));
const assertPositiveInteger = (int) => {
    if (int && (!lodash_1.default.isInteger(int) || int < 0)) {
        throw new Error("parameter expects a positive integer.");
    }
};
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
const buf2String = (buf) => Buffer.from(buf)
    .toString("utf8")
    .replace(/\u0000/g, "")
    .replace(/\0/g, "");
exports.buf2String = buf2String;
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
exports.toUtf8 = exports.buf2String;
/**
 * Determine whether a given string contains only base58 characters
 * @param value - the string to verify
 * @returns boolean indicating if a value is base58 encoded
 */
const isBase58 = (value) => /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
exports.isBase58 = isBase58;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
const isBytes = (value, length) => {
    assertPositiveInteger(length);
    const lengthPattern = length ? `{${length},}` : "*";
    const bytesRegexPattern = new RegExp(`^\\[\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((\\s*,\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))${lengthPattern})?\\s*\\]$`);
    return bytesRegexPattern.test(value);
};
exports.isBytes = isBytes;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
exports.isKeypairString = exports.isBytes;
/**
 * Determine whether a given string is hex encoded
 * @param value - the string to verify
 * @param length - the minimum number of characters following the 0x prefix
 * @returns boolean indicating if a value is a hex encoded string
 */
const isHex = (value, length) => {
    assertPositiveInteger(length);
    const hexRegexPattern = length
        ? new RegExp(`^(0x|0X)?[a-fA-F0-9]{${length ?? 64}}`)
        : new RegExp(`^(0x|0X)?[a-fA-F0-9]+$`);
    return hexRegexPattern.test(value);
};
exports.isHex = isHex;
/**
 * Determine whether a given string is base64 encoded
 * @param value - the string to verify
 * @returns boolean indicating if a value is a base64 encoded string
 */
const isBase64 = (value, length) => {
    assertPositiveInteger(length);
    const base64RegexPattern = length
        ? new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}){${length},}$`)
        : new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$`);
    return base64RegexPattern.test(value);
};
exports.isBase64 = isBase64;
/**
 * Attempt to parse a string into a valid a buffer format.
 *
 * Accepted formats:
 *  - byte array "[1, 2, 3, ...]"
 *  - hex string "0xabc123..."
 *  - base64 string "VGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg=="
 *  - base58 string "12DsSDs23..."
 *
 * @returns the parsed string in Buffer format or undefined if no regex matches found
 */
const decodeString = (data) => {
    const trimmed = data.trim();
    if ((0, exports.isBytes)(trimmed)) {
        return Buffer.from(new Uint8Array(JSON.parse(trimmed)));
    }
    else if ((0, exports.isHex)(trimmed)) {
        return Buffer.from(trimmed.toLowerCase().replace(/^0x/, ""), "hex");
    }
    else if ((0, exports.isBase58)(trimmed)) {
        return Buffer.from(bs58_1.default.decode(trimmed));
    }
    else if ((0, exports.isBase64)(trimmed)) {
        return Buffer.from(trimmed, "base64");
    }
    return undefined;
};
exports.decodeString = decodeString;
function parseMrEnclave(hexString) {
    if (!(0, exports.isHex)(hexString, 64)) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    const myUint8Array = new Uint8Array(Buffer.from(hexString.replaceAll(/0x|0X/g, ""), "hex"));
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
/**
 * Validate a cron schedule and return a valid 6 element cron string which includes seconds
 * @param cronSchedule - the cron string to validate
 * @returns - a valid cron schedule with seconds included
 * @throws {@link InvalidCronSchedule} if the cron schedule is not valid
 */
function parseCronSchedule(cronSchedule) {
    if (!(0, cron_validator_1.isValidCron)(cronSchedule, { seconds: true })) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    const fields = cronSchedule.split(" ");
    if (fields.length === 0) {
        throw new Error(`invalid cron schedule, expected format: '* * * * * *', received: ${cronSchedule}`);
    }
    if (fields.length === 6) {
        return cronSchedule;
    }
    fields.unshift(...Array(6 - fields.length).fill("0"));
    return fields.join(" ");
}
function parseRawMrEnclave(rawBuffer, addMissingBytes = false) {
    let myUint8Array;
    if (typeof rawBuffer === "string") {
        if ((0, exports.isBytes)(rawBuffer, 32)) {
            // check if its a string of bytes '[1,2,3]'
            myUint8Array = new Uint8Array(JSON.parse(rawBuffer));
        }
        else if ((0, exports.isHex)(rawBuffer, 64)) {
            // check if its a hex string '0x1A'
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer.replaceAll(/0x|0X/g, ""), "hex"));
        }
        else if ((0, exports.isBase64)(rawBuffer, 32)) {
            // check if its a base64 string
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "base64"));
        }
        else {
            // assume utf-8
            myUint8Array = new Uint8Array(Buffer.from(rawBuffer, "utf-8"));
        }
    }
    else if (rawBuffer instanceof Buffer) {
        myUint8Array = new Uint8Array(rawBuffer);
    }
    else if (rawBuffer instanceof Uint8Array) {
        myUint8Array = rawBuffer;
    }
    else {
        // Assume input is number[]
        myUint8Array = new Uint8Array(rawBuffer);
    }
    if (addMissingBytes) {
        // make sure its always 32 bytes
        return new Uint8Array(Array.from(myUint8Array).concat(Array(32).fill(0)).slice(0, 32));
    }
    if (myUint8Array.byteLength !== 32) {
        throw new Error(`Not a valid hex string representation of a MRENCLAVE measurement`);
    }
    return myUint8Array;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3N0cmluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUE4SEEsd0NBaUJDO0FBUUQsOENBb0JDO0FBRUQsOENBNkNDO0FBMU5ELGdEQUF3QjtBQUN4QixtREFBNkM7QUFDN0Msb0RBQXVCO0FBRXZCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxHQUFZLEVBQVEsRUFBRTtJQUNuRCxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsZ0JBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDSSxNQUFNLFVBQVUsR0FBRyxDQUN4QixHQUE0QyxFQUNwQyxFQUFFLENBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7S0FDYixRQUFRLENBQUMsTUFBTSxDQUFDO0tBQ2hCLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO0tBQ3RCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFOWCxRQUFBLFVBQVUsY0FNQztBQUV4Qjs7Ozs7O0dBTUc7QUFDVSxRQUFBLE1BQU0sR0FBRyxrQkFBVSxDQUFDO0FBRWpDOzs7O0dBSUc7QUFDSSxNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQWEsRUFBVyxFQUFFLENBQ2pELHlCQUF5QixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUQzQixRQUFBLFFBQVEsWUFDbUI7QUFFeEM7Ozs7O0dBS0c7QUFDSSxNQUFNLE9BQU8sR0FBRyxDQUFDLEtBQWEsRUFBRSxNQUFlLEVBQVcsRUFBRTtJQUNqRSxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU5QixNQUFNLGFBQWEsR0FB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Q3BCLGdDQUFnQztRQUNoQyxPQUFPLElBQUksVUFBVSxDQUNuQixLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FDaEUsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLFlBQVksQ0FBQyxVQUFVLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FDYixrRUFBa0UsQ0FDbkUsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcbmltcG9ydCB7IGlzVmFsaWRDcm9uIH0gZnJvbSBcImNyb24tdmFsaWRhdG9yXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5cbmNvbnN0IGFzc2VydFBvc2l0aXZlSW50ZWdlciA9IChpbnQ/OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKGludCAmJiAoIV8uaXNJbnRlZ2VyKGludCkgfHwgaW50IDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJhbWV0ZXIgZXhwZWN0cyBhIHBvc2l0aXZlIGludGVnZXIuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRvIHV0Zi04IGVuY29kaW5nIGFuZCByZW1vdmVzIG51bGwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnVmIC0gdGhlIGJ1ZmZlciwgYnl0ZSBhcnJheSwgb3Igc3RyaW5nIHRvIGNvbnZlcnQgdG8gdXRmLTggZW5jb2RpbmdcbiAqXG4gKiBAcmV0dXJucyB1dGYtOCBlbmNvZGVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgYnVmMlN0cmluZyA9IChcbiAgYnVmOiBVaW50OEFycmF5IHwgbnVtYmVyW10gfCBzdHJpbmcgfCBCdWZmZXJcbik6IHN0cmluZyA9PlxuICBCdWZmZXIuZnJvbShidWYpXG4gICAgLnRvU3RyaW5nKFwidXRmOFwiKVxuICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csIFwiXCIpXG4gICAgLnJlcGxhY2UoL1xcMC9nLCBcIlwiKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byB1dGYtOCBlbmNvZGluZyBhbmQgcmVtb3ZlcyBudWxsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ1ZiAtIHRoZSBidWZmZXIsIGJ5dGUgYXJyYXksIG9yIHN0cmluZyB0byBjb252ZXJ0IHRvIHV0Zi04IGVuY29kaW5nXG4gKlxuICogQHJldHVybnMgdXRmLTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvVXRmOCA9IGJ1ZjJTdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgY29udGFpbnMgb25seSBiYXNlNTggY2hhcmFjdGVyc1xuICogQHBhcmFtIHZhbHVlIC0gdGhlIHN0cmluZyB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGJhc2U1OCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jhc2U1OCA9ICh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiA9PlxuICAvXltBLUhKLU5QLVphLWttLXoxLTldKiQvLnRlc3QodmFsdWUpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgc2VjcmV0S2V5IFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIGVuY2xvc2VkIGluIHNxdWFyZSBicmFja2V0c1xuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgY29udGFpbnMgYSBzZWNyZXRLZXkgaW4gYnl0ZSBhcnJheSBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQnl0ZXMgPSAodmFsdWU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGFzc2VydFBvc2l0aXZlSW50ZWdlcihsZW5ndGgpO1xuXG4gIGNvbnN0IGxlbmd0aFBhdHRlcm4gPSBsZW5ndGggPyBgeyR7bGVuZ3RofSx9YCA6IFwiKlwiO1xuICBjb25zdCBieXRlc1JlZ2V4UGF0dGVybiA9IG5ldyBSZWdFeHAoXG4gICAgYF5cXFxcW1xcXFxzKigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKChcXFxccyosXFxcXHMqKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykpJHtsZW5ndGhQYXR0ZXJufSk/XFxcXHMqXFxcXF0kYFxuICApO1xuICByZXR1cm4gYnl0ZXNSZWdleFBhdHRlcm4udGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgc2VjcmV0S2V5IFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIGVuY2xvc2VkIGluIHNxdWFyZSBicmFja2V0c1xuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgdmFsdWUgY29udGFpbnMgYSBzZWNyZXRLZXkgaW4gYnl0ZSBhcnJheSBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzS2V5cGFpclN0cmluZyA9IGlzQnl0ZXM7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgaXMgaGV4IGVuY29kZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgZm9sbG93aW5nIHRoZSAweCBwcmVmaXhcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHZhbHVlIGlzIGEgaGV4IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBpc0hleCA9ICh2YWx1ZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGxlbmd0aCk7XG5cbiAgY29uc3QgaGV4UmVnZXhQYXR0ZXJuID0gbGVuZ3RoXG4gICAgPyBuZXcgUmVnRXhwKGBeKDB4fDBYKT9bYS1mQS1GMC05XXske2xlbmd0aCA/PyA2NH19YClcbiAgICA6IG5ldyBSZWdFeHAoYF4oMHh8MFgpP1thLWZBLUYwLTldKyRgKTtcbiAgcmV0dXJuIGhleFJlZ2V4UGF0dGVybi50ZXN0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgaXMgYmFzZTY0IGVuY29kZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgaXNCYXNlNjQgPSAodmFsdWU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGFzc2VydFBvc2l0aXZlSW50ZWdlcihsZW5ndGgpO1xuXG4gIGNvbnN0IGJhc2U2NFJlZ2V4UGF0dGVybiA9IGxlbmd0aFxuICAgID8gbmV3IFJlZ0V4cChcbiAgICAgICAgYF4oW0EtWmEtejAtOSsvXXs0fSkqKFtBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PXxbQS1aYS16MC05Ky9dezR9KXske2xlbmd0aH0sfSRgXG4gICAgICApXG4gICAgOiBuZXcgUmVnRXhwKFxuICAgICAgICBgXihbQS1aYS16MC05Ky9dezR9KSooW0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309fFtBLVphLXowLTkrL117NH0pJGBcbiAgICAgICk7XG4gIHJldHVybiBiYXNlNjRSZWdleFBhdHRlcm4udGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBzdHJpbmcgaW50byBhIHZhbGlkIGEgYnVmZmVyIGZvcm1hdC5cbiAqXG4gKiBBY2NlcHRlZCBmb3JtYXRzOlxuICogIC0gYnl0ZSBhcnJheSBcIlsxLCAyLCAzLCAuLi5dXCJcbiAqICAtIGhleCBzdHJpbmcgXCIweGFiYzEyMy4uLlwiXG4gKiAgLSBiYXNlNjQgc3RyaW5nIFwiVkdocGN5QnBjeUJoSUhSbGMzUWdjM1J5YVc1bkxnPT1cIlxuICogIC0gYmFzZTU4IHN0cmluZyBcIjEyRHNTRHMyMy4uLlwiXG4gKlxuICogQHJldHVybnMgdGhlIHBhcnNlZCBzdHJpbmcgaW4gQnVmZmVyIGZvcm1hdCBvciB1bmRlZmluZWQgaWYgbm8gcmVnZXggbWF0Y2hlcyBmb3VuZFxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlU3RyaW5nID0gKGRhdGE6IHN0cmluZyk6IEJ1ZmZlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IHRyaW1tZWQgPSBkYXRhLnRyaW0oKTtcbiAgaWYgKGlzQnl0ZXModHJpbW1lZCkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoSlNPTi5wYXJzZSh0cmltbWVkKSkpO1xuICB9IGVsc2UgaWYgKGlzSGV4KHRyaW1tZWQpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRyaW1tZWQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvLCBcIlwiKSwgXCJoZXhcIik7XG4gIH0gZWxzZSBpZiAoaXNCYXNlNTgodHJpbW1lZCkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnM1OC5kZWNvZGUodHJpbW1lZCkpO1xuICB9IGVsc2UgaWYgKGlzQmFzZTY0KHRyaW1tZWQpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRyaW1tZWQsIFwiYmFzZTY0XCIpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBSYXdCdWZmZXIgPSBzdHJpbmcgfCBCdWZmZXIgfCBVaW50OEFycmF5IHwgbnVtYmVyW107XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1yRW5jbGF2ZShoZXhTdHJpbmc6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBpZiAoIWlzSGV4KGhleFN0cmluZywgNjQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vdCBhIHZhbGlkIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBNUkVOQ0xBVkUgbWVhc3VyZW1lbnRgXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KFxuICAgIEJ1ZmZlci5mcm9tKGhleFN0cmluZy5yZXBsYWNlQWxsKC8weHwwWC9nLCBcIlwiKSwgXCJoZXhcIilcbiAgKTtcbiAgaWYgKG15VWludDhBcnJheS5ieXRlTGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBOb3QgYSB2YWxpZCBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgTVJFTkNMQVZFIG1lYXN1cmVtZW50YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbXlVaW50OEFycmF5O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgY3JvbiBzY2hlZHVsZSBhbmQgcmV0dXJuIGEgdmFsaWQgNiBlbGVtZW50IGNyb24gc3RyaW5nIHdoaWNoIGluY2x1ZGVzIHNlY29uZHNcbiAqIEBwYXJhbSBjcm9uU2NoZWR1bGUgLSB0aGUgY3JvbiBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIC0gYSB2YWxpZCBjcm9uIHNjaGVkdWxlIHdpdGggc2Vjb25kcyBpbmNsdWRlZFxuICogQHRocm93cyB7QGxpbmsgSW52YWxpZENyb25TY2hlZHVsZX0gaWYgdGhlIGNyb24gc2NoZWR1bGUgaXMgbm90IHZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNyb25TY2hlZHVsZShjcm9uU2NoZWR1bGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghaXNWYWxpZENyb24oY3JvblNjaGVkdWxlLCB7IHNlY29uZHM6IHRydWUgfSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgaW52YWxpZCBjcm9uIHNjaGVkdWxlLCBleHBlY3RlZCBmb3JtYXQ6ICcqICogKiAqICogKicsIHJlY2VpdmVkOiAke2Nyb25TY2hlZHVsZX1gXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGZpZWxkcyA9IGNyb25TY2hlZHVsZS5zcGxpdChcIiBcIik7XG4gIGlmIChmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGludmFsaWQgY3JvbiBzY2hlZHVsZSwgZXhwZWN0ZWQgZm9ybWF0OiAnKiAqICogKiAqIConLCByZWNlaXZlZDogJHtjcm9uU2NoZWR1bGV9YFxuICAgICk7XG4gIH1cblxuICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gNikge1xuICAgIHJldHVybiBjcm9uU2NoZWR1bGU7XG4gIH1cblxuICBmaWVsZHMudW5zaGlmdCguLi5BcnJheSg2IC0gZmllbGRzLmxlbmd0aCkuZmlsbChcIjBcIikpO1xuICByZXR1cm4gZmllbGRzLmpvaW4oXCIgXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYXdNckVuY2xhdmUoXG4gIHJhd0J1ZmZlcjogUmF3QnVmZmVyLFxuICBhZGRNaXNzaW5nQnl0ZXMgPSBmYWxzZVxuKTogVWludDhBcnJheSB7XG4gIGxldCBteVVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXk7XG5cbiAgaWYgKHR5cGVvZiByYXdCdWZmZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNCeXRlcyhyYXdCdWZmZXIsIDMyKSkge1xuICAgICAgLy8gY2hlY2sgaWYgaXRzIGEgc3RyaW5nIG9mIGJ5dGVzICdbMSwyLDNdJ1xuICAgICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoSlNPTi5wYXJzZShyYXdCdWZmZXIpKTtcbiAgICB9IGVsc2UgaWYgKGlzSGV4KHJhd0J1ZmZlciwgNjQpKSB7XG4gICAgICAvLyBjaGVjayBpZiBpdHMgYSBoZXggc3RyaW5nICcweDFBJ1xuICAgICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIEJ1ZmZlci5mcm9tKHJhd0J1ZmZlci5yZXBsYWNlQWxsKC8weHwwWC9nLCBcIlwiKSwgXCJoZXhcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0Jhc2U2NChyYXdCdWZmZXIsIDMyKSkge1xuICAgICAgLy8gY2hlY2sgaWYgaXRzIGEgYmFzZTY0IHN0cmluZ1xuICAgICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocmF3QnVmZmVyLCBcImJhc2U2NFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFzc3VtZSB1dGYtOFxuICAgICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocmF3QnVmZmVyLCBcInV0Zi04XCIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmF3QnVmZmVyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgbXlVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyKTtcbiAgfSBlbHNlIGlmIChyYXdCdWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgbXlVaW50OEFycmF5ID0gcmF3QnVmZmVyO1xuICB9IGVsc2Uge1xuICAgIC8vIEFzc3VtZSBpbnB1dCBpcyBudW1iZXJbXVxuICAgIG15VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlcik7XG4gIH1cblxuICBpZiAoYWRkTWlzc2luZ0J5dGVzKSB7XG4gICAgLy8gbWFrZSBzdXJlIGl0cyBhbHdheXMgMzIgYnl0ZXNcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBBcnJheS5mcm9tKG15VWludDhBcnJheSkuY29uY2F0KEFycmF5KDMyKS5maWxsKDApKS5zbGljZSgwLCAzMilcbiAgICApO1xuICB9XG5cbiAgaWYgKG15VWludDhBcnJheS5ieXRlTGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBOb3QgYSB2YWxpZCBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgTVJFTkNMQVZFIG1lYXN1cmVtZW50YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbXlVaW50OEFycmF5O1xufVxuIl19